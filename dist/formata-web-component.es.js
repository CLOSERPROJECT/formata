typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add("5");
const wx = 1, Sx = 2, ev = 4, xx = 8, Px = 16, Ox = 1, Cx = 2, kx = 4, $x = 8, Ax = 16, Ex = 1, Tx = 2, tv = "[", kl = "[!", nd = "]", lo = {}, xt = /* @__PURE__ */ Symbol(), Dx = "http://www.w3.org/1999/xhtml", Mx = "http://www.w3.org/2000/svg", rv = "@attach", cc = !1;
var $l = Array.isArray, Ix = Array.prototype.indexOf, uo = Array.prototype.includes, Al = Array.from, Ja = Object.keys, Za = Object.defineProperty, Sn = Object.getOwnPropertyDescriptor, nv = Object.getOwnPropertyDescriptors, sv = Object.prototype, Nx = Array.prototype, El = Object.getPrototypeOf, lg = Object.isExtensible;
function Wo(t) {
  return typeof t == "function";
}
const he = () => {
};
function Fx(t) {
  return t();
}
function dc(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function ov() {
  var t, e, r = new Promise((n, s) => {
    t = n, e = s;
  });
  return { promise: r, resolve: t, reject: e };
}
function Rx(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const r = [];
  for (const n of t)
    if (r.push(n), r.length === e) break;
  return r;
}
const Et = 2, Qa = 4, ki = 8, sd = 1 << 24, In = 16, Ur = 32, is = 64, od = 128, wr = 512, Ot = 1024, Tt = 2048, Fr = 4096, hr = 8192, xn = 16384, Tl = 32768, kn = 65536, ug = 1 << 17, iv = 1 << 18, Bs = 1 << 19, av = 1 << 20, bn = 1 << 25, Ds = 32768, fc = 1 << 21, id = 1 << 22, Wn = 1 << 23, en = /* @__PURE__ */ Symbol("$state"), ad = /* @__PURE__ */ Symbol("legacy props"), Vx = /* @__PURE__ */ Symbol(""), no = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), Lx = 1, $i = 3, zs = 8;
function ld(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function jx() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Bx(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function zx() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function qx(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Ux() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Kx() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function Wx(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function Hx() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Gx() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Yx() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Xx() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
function Dl(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function Jx() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function Zx() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ne = !1;
function zt(t) {
  Ne = t;
}
let ze;
function wt(t) {
  if (t === null)
    throw Dl(), lo;
  return ze = t;
}
function $n() {
  return wt(/* @__PURE__ */ ln(ze));
}
function de(t) {
  if (Ne) {
    if (/* @__PURE__ */ ln(ze) !== null)
      throw Dl(), lo;
    ze = t;
  }
}
function vt(t = 1) {
  if (Ne) {
    for (var e = t, r = ze; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ ln(r);
    ze = r;
  }
}
function el(t = !0) {
  for (var e = 0, r = ze; ; ) {
    if (r.nodeType === zs) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === nd) {
        if (e === 0) return r;
        e -= 1;
      } else (n === tv || n === kl) && (e += 1);
    }
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ln(r)
    );
    t && r.remove(), r = s;
  }
}
function lv(t) {
  if (!t || t.nodeType !== zs)
    throw Dl(), lo;
  return (
    /** @type {Comment} */
    t.data
  );
}
function uv(t) {
  return t === this.v;
}
function Qx(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function cv(t) {
  return !Qx(t, this.v);
}
let xo = !1, eP = !1;
function tP() {
  xo = !0;
}
const rP = [];
function Po(t, e = !1, r = !1) {
  return za(t, /* @__PURE__ */ new Map(), "", rP, null, r);
}
function za(t, e, r, n, s = null, o = !1) {
  if (typeof t == "object" && t !== null) {
    var i = e.get(t);
    if (i !== void 0) return i;
    if (t instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(t)
    );
    if (t instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(t)
    );
    if ($l(t)) {
      var a = (
        /** @type {Snapshot<any>} */
        Array(t.length)
      );
      e.set(t, a), s !== null && e.set(s, a);
      for (var l = 0; l < t.length; l += 1) {
        var u = t[l];
        l in t && (a[l] = za(u, e, r, n, null, o));
      }
      return a;
    }
    if (El(t) === sv) {
      a = {}, e.set(t, a), s !== null && e.set(s, a);
      for (var c in t)
        a[c] = za(
          // @ts-expect-error
          t[c],
          e,
          r,
          n,
          null,
          o
        );
      return a;
    }
    if (t instanceof Date)
      return (
        /** @type {Snapshot<T>} */
        structuredClone(t)
      );
    if (typeof /** @type {T & { toJSON?: any } } */
    t.toJSON == "function" && !o)
      return za(
        /** @type {T & { toJSON(): any } } */
        t.toJSON(),
        e,
        r,
        n,
        // Associate the instance with the toJSON clone
        t
      );
  }
  if (t instanceof EventTarget)
    return (
      /** @type {Snapshot<T>} */
      t
    );
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(t)
    );
  } catch {
    return (
      /** @type {Snapshot<T>} */
      t
    );
  }
}
let it = null;
function co(t) {
  it = t;
}
function Ms(t) {
  return (
    /** @type {T} */
    Ml().get(t)
  );
}
function Oo(t, e) {
  return Ml().set(t, e), e;
}
function nP(t) {
  return Ml().has(t);
}
function sP() {
  return Ml();
}
function W(t, e = !1, r) {
  it = {
    p: it,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: xo && !e ? { s: null, u: null, $: [] } : null
  };
}
function H(t) {
  var e = (
    /** @type {ComponentContext} */
    it
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      Mv(n);
  }
  return t !== void 0 && (e.x = t), e.i = !0, it = e.p, t ?? /** @type {T} */
  {};
}
function Co() {
  return !xo || it !== null && it.l === null;
}
function Ml(t) {
  return it === null && ld(), it.c ??= new Map(oP(it) || void 0);
}
function oP(t) {
  let e = t.p;
  for (; e !== null; ) {
    const r = e.c;
    if (r !== null)
      return r;
    e = e.p;
  }
  return null;
}
let Os = [];
function dv() {
  var t = Os;
  Os = [], dc(t);
}
function Ir(t) {
  if (Os.length === 0 && !ui) {
    var e = Os;
    queueMicrotask(() => {
      e === Os && dv();
    });
  }
  Os.push(t);
}
function iP() {
  for (; Os.length > 0; )
    dv();
}
function fv(t) {
  var e = Je;
  if (e === null)
    return Ge.f |= Wn, t;
  if ((e.f & Tl) === 0) {
    if ((e.f & od) === 0)
      throw t;
    e.b.error(t);
  } else
    fo(t, e);
}
function fo(t, e) {
  for (; e !== null; ) {
    if ((e.f & od) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const aP = -7169;
function dt(t, e) {
  t.f = t.f & aP | e;
}
function ud(t) {
  (t.f & wr) !== 0 || t.deps === null ? dt(t, Ot) : dt(t, Fr);
}
function hv(t) {
  if (t !== null)
    for (const e of t)
      (e.f & Et) === 0 || (e.f & Ds) === 0 || (e.f ^= Ds, hv(
        /** @type {Derived} */
        e.deps
      ));
}
function gv(t, e, r) {
  (t.f & Tt) !== 0 ? e.add(t) : (t.f & Fr) !== 0 && r.add(t), hv(t.deps), dt(t, Ot);
}
const Ui = /* @__PURE__ */ new Set();
let nt = null, hc = null, Er = null, ur = [], Il = null, gc = !1, ui = !1;
class Pn {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #s = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #i = /* @__PURE__ */ new Set();
  /**
   * A map of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`.
   * The value contains child effects that were dirty/maybe_dirty before being reset,
   * so they can be rescheduled if the branch survives.
   * @type {Map<Effect, { d: Effect[], m: Effect[] }>}
   */
  #a = /* @__PURE__ */ new Map();
  is_fork = !1;
  #u = !1;
  is_deferred() {
    return this.is_fork || this.#n > 0;
  }
  /**
   * Add an effect to the #skipped_branches map and reset its children
   * @param {Effect} effect
   */
  skip_effect(e) {
    this.#a.has(e) || this.#a.set(e, { d: [], m: [] });
  }
  /**
   * Remove an effect from the #skipped_branches map and reschedule
   * any tracked dirty/maybe_dirty child effects
   * @param {Effect} effect
   */
  unskip_effect(e) {
    var r = this.#a.get(e);
    if (r) {
      this.#a.delete(e);
      for (var n of r.d)
        dt(n, Tt), Dr(n);
      for (n of r.m)
        dt(n, Fr), Dr(n);
    }
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    ur = [], this.apply();
    var r = [], n = [];
    for (const s of e)
      this.#l(s, r, n);
    if (this.is_deferred()) {
      this.#c(n), this.#c(r);
      for (const [s, o] of this.#a)
        yv(s, o);
    } else {
      for (const s of this.#e) s();
      this.#e.clear(), this.#r === 0 && this.#d(), hc = this, nt = null, cg(n), cg(r), hc = null, this.#s?.resolve();
    }
    Er = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {Effect[]} effects
   * @param {Effect[]} render_effects
   */
  #l(e, r, n) {
    e.f ^= Ot;
    for (var s = e.first, o = null; s !== null; ) {
      var i = s.f, a = (i & (Ur | is)) !== 0, l = a && (i & Ot) !== 0, u = l || (i & hr) !== 0 || this.#a.has(s);
      if (!u && s.fn !== null) {
        a ? s.f ^= Ot : o !== null && (i & (Qa | ki | sd)) !== 0 ? o.b.defer_effect(s) : (i & Qa) !== 0 ? r.push(s) : Ti(s) && ((i & In) !== 0 && this.#i.add(s), fi(s));
        var c = s.first;
        if (c !== null) {
          s = c;
          continue;
        }
      }
      var f = s.parent;
      for (s = s.next; s === null && f !== null; )
        f === o && (o = null), s = f.next, f = f.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #c(e) {
    for (var r = 0; r < e.length; r += 1)
      gv(e[r], this.#o, this.#i);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    r !== xt && !this.previous.has(e) && this.previous.set(e, r), (e.f & Wn) === 0 && (this.current.set(e, e.v), Er?.set(e, e.v));
  }
  activate() {
    nt = this, this.apply();
  }
  deactivate() {
    nt === this && (nt = null, Er = null);
  }
  flush() {
    if (this.activate(), ur.length > 0) {
      if (pv(), nt !== null && nt !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #d() {
    if (Ui.size > 1) {
      this.previous.clear();
      var e = Er, r = !0;
      for (const s of Ui) {
        if (s === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (s.current.has(a))
            if (r && l !== s.current.get(a))
              s.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const i = [...s.current.keys()].filter((a) => !this.current.has(a));
        if (i.length > 0) {
          var n = ur;
          ur = [];
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            mv(u, i, a, l);
          if (ur.length > 0) {
            nt = s, s.apply();
            for (const u of ur)
              s.#l(u, [], []);
            s.deactivate();
          }
          ur = n;
        }
      }
      nt = null, Er = e;
    }
    this.committed = !0, Ui.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), !this.#u && (this.#u = !0, Ir(() => {
      this.#u = !1, this.is_deferred() ? ur.length > 0 && this.flush() : this.revive();
    }));
  }
  revive() {
    for (const e of this.#o)
      this.#i.delete(e), dt(e, Tt), Dr(e);
    for (const e of this.#i)
      dt(e, Fr), Dr(e);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#s ??= ov()).promise;
  }
  static ensure() {
    if (nt === null) {
      const e = nt = new Pn();
      Ui.add(nt), ui || Ir(() => {
        nt === e && e.flush();
      });
    }
    return nt;
  }
  apply() {
  }
}
function m(t) {
  var e = ui;
  ui = !0;
  try {
    for (var r; ; ) {
      if (iP(), ur.length === 0 && (nt?.flush(), ur.length === 0))
        return Il = null, /** @type {T} */
        r;
      pv();
    }
  } finally {
    ui = e;
  }
}
function pv() {
  gc = !0;
  var t = null;
  try {
    for (var e = 0; ur.length > 0; ) {
      var r = Pn.ensure();
      if (e++ > 1e3) {
        var n, s;
        lP();
      }
      r.process(ur), Hn.clear();
    }
  } finally {
    gc = !1, Il = null;
  }
}
function lP() {
  try {
    Ux();
  } catch (t) {
    fo(t, Il);
  }
}
let vn = null;
function cg(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (xn | hr)) === 0 && Ti(n) && (vn = /* @__PURE__ */ new Set(), fi(n), n.deps === null && n.first === null && n.nodes === null && (n.teardown === null && n.ac === null ? Vv(n) : n.fn = null), vn?.size > 0)) {
        Hn.clear();
        for (const s of vn) {
          if ((s.f & (xn | hr)) !== 0) continue;
          const o = [s];
          let i = s.parent;
          for (; i !== null; )
            vn.has(i) && (vn.delete(i), o.push(i)), i = i.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (xn | hr)) === 0 && fi(l);
          }
        }
        vn.clear();
      }
    }
    vn = null;
  }
}
function mv(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const s of t.reactions) {
      const o = s.f;
      (o & Et) !== 0 ? mv(
        /** @type {Derived} */
        s,
        e,
        r,
        n
      ) : (o & (id | In)) !== 0 && (o & Tt) === 0 && vv(s, e, n) && (dt(s, Tt), Dr(
        /** @type {Effect} */
        s
      ));
    }
}
function vv(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const s of t.deps) {
      if (uo.call(e, s))
        return !0;
      if ((s.f & Et) !== 0 && vv(
        /** @type {Derived} */
        s,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          s,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Dr(t) {
  for (var e = Il = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (gc && e === Je && (r & In) !== 0 && (r & iv) === 0)
      return;
    if ((r & (is | Ur)) !== 0) {
      if ((r & Ot) === 0) return;
      e.f ^= Ot;
    }
  }
  ur.push(e);
}
function yv(t, e) {
  if (!((t.f & Ur) !== 0 && (t.f & Ot) !== 0)) {
    (t.f & Tt) !== 0 ? e.d.push(t) : (t.f & Fr) !== 0 && e.m.push(t), dt(t, Ot);
    for (var r = t.first; r !== null; )
      yv(r, e), r = r.next;
  }
}
function cd(t) {
  let e = 0, r = Jn(0), n;
  return () => {
    gd() && (d(r), Ei(() => (e === 0 && (n = ot(() => t(() => Hr(r)))), e += 1, () => {
      Ir(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Hr(r));
      });
    })));
  };
}
var uP = kn | Bs | od;
function cP(t, e, r) {
  new dP(t, e, r);
}
class dP {
  /** @type {Boundary | null} */
  parent;
  is_pending = !1;
  /** @type {TemplateNode} */
  #e;
  /** @type {TemplateNode | null} */
  #t = Ne ? ze : null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #n;
  /** @type {Effect} */
  #s;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #a = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #l = null;
  #c = 0;
  #d = 0;
  #g = !1;
  #m = !1;
  /** @type {Set<Effect>} */
  #p = /* @__PURE__ */ new Set();
  /** @type {Set<Effect>} */
  #f = /* @__PURE__ */ new Set();
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #h = null;
  #b = cd(() => (this.#h = Jn(this.#c), () => {
    this.#h = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#e = e, this.#r = r, this.#n = n, this.parent = /** @type {Effect} */
    Je.b, this.is_pending = !!this.#r.pending, this.#s = qs(() => {
      if (Je.b = this, Ne) {
        const o = this.#t;
        $n(), /** @type {Comment} */
        o.nodeType === zs && /** @type {Comment} */
        o.data === kl ? this.#v() : (this.#y(), this.#d === 0 && (this.is_pending = !1));
      } else {
        var s = this.#S();
        try {
          this.#o = Xt(() => n(s));
        } catch (o) {
          this.error(o);
        }
        this.#d > 0 ? this.#x() : this.is_pending = !1;
      }
      return () => {
        this.#l?.remove();
      };
    }, uP), Ne && (this.#e = ze);
  }
  #y() {
    try {
      this.#o = Xt(() => this.#n(this.#e));
    } catch (e) {
      this.error(e);
    }
  }
  #v() {
    const e = this.#r.pending;
    e && (this.#i = Xt(() => e(this.#e)), Ir(() => {
      var r = this.#S();
      this.#o = this.#w(() => (Pn.ensure(), Xt(() => this.#n(r)))), this.#d > 0 ? this.#x() : (As(
        /** @type {Effect} */
        this.#i,
        () => {
          this.#i = null;
        }
      ), this.is_pending = !1);
    }));
  }
  #S() {
    var e = this.#e;
    return this.is_pending && (this.#l = qt(), this.#e.before(this.#l), e = this.#l), e;
  }
  /**
   * Defer an effect inside a pending boundary until the boundary resolves
   * @param {Effect} effect
   */
  defer_effect(e) {
    gv(e, this.#p, this.#f);
  }
  /**
   * Returns `false` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_rendered() {
    return !this.is_pending && (!this.parent || this.parent.is_rendered());
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #w(e) {
    var r = Je, n = Ge, s = it;
    nn(this.#s), Pr(this.#s), co(this.#s.ctx);
    try {
      return e();
    } catch (o) {
      return fv(o), null;
    } finally {
      nn(r), Pr(n), co(s);
    }
  }
  #x() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#o !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#l
    ), Bv(this.#o, this.#u)), this.#i === null && (this.#i = Xt(() => e(this.#e)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #_(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#_(e);
      return;
    }
    if (this.#d += e, this.#d === 0) {
      this.is_pending = !1;
      for (const r of this.#p)
        dt(r, Tt), Dr(r);
      for (const r of this.#f)
        dt(r, Fr), Dr(r);
      this.#p.clear(), this.#f.clear(), this.#i && As(this.#i, () => {
        this.#i = null;
      }), this.#u && (this.#e.before(this.#u), this.#u = null);
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#_(e), this.#c += e, !(!this.#h || this.#g) && (this.#g = !0, Ir(() => {
      this.#g = !1, this.#h && ho(this.#h, this.#c);
    }));
  }
  get_effect_pending() {
    return this.#b(), d(
      /** @type {Source<number>} */
      this.#h
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#r.onerror;
    let n = this.#r.failed;
    if (this.#m || !r && !n)
      throw e;
    this.#o && (Ct(this.#o), this.#o = null), this.#i && (Ct(this.#i), this.#i = null), this.#a && (Ct(this.#a), this.#a = null), Ne && (wt(
      /** @type {TemplateNode} */
      this.#t
    ), vt(), wt(el()));
    var s = !1, o = !1;
    const i = () => {
      if (s) {
        Zx();
        return;
      }
      s = !0, o && Xx(), Pn.ensure(), this.#c = 0, this.#a !== null && As(this.#a, () => {
        this.#a = null;
      }), this.is_pending = this.has_pending_snippet(), this.#o = this.#w(() => (this.#m = !1, Xt(() => this.#n(this.#e)))), this.#d > 0 ? this.#x() : this.is_pending = !1;
    };
    Ir(() => {
      try {
        o = !0, r?.(e, i), o = !1;
      } catch (a) {
        fo(a, this.#s && this.#s.parent);
      }
      n && (this.#a = this.#w(() => {
        Pn.ensure(), this.#m = !0;
        try {
          return Xt(() => {
            n(
              this.#e,
              () => e,
              () => i
            );
          });
        } catch (a) {
          return fo(
            a,
            /** @type {Effect} */
            this.#s.parent
          ), null;
        } finally {
          this.#m = !1;
        }
      }));
    });
  }
}
function bv(t, e, r, n) {
  const s = Co() ? Ai : dd;
  var o = t.filter((h) => !h.settled);
  if (r.length === 0 && o.length === 0) {
    n(e.map(s));
    return;
  }
  var i = nt, a = (
    /** @type {Effect} */
    Je
  ), l = fP(), u = o.length === 1 ? o[0].promise : o.length > 1 ? Promise.all(o.map((h) => h.promise)) : null;
  function c(h) {
    l();
    try {
      n(h);
    } catch (_) {
      (a.f & xn) === 0 && fo(_, a);
    }
    i?.deactivate(), pc();
  }
  if (r.length === 0) {
    u.then(() => c(e.map(s)));
    return;
  }
  function f() {
    l(), Promise.all(r.map((h) => /* @__PURE__ */ hP(h))).then((h) => c([...e.map(s), ...h])).catch((h) => fo(h, a));
  }
  u ? u.then(f) : f();
}
function fP() {
  var t = Je, e = Ge, r = it, n = nt;
  return function(o = !0) {
    nn(t), Pr(e), co(r), o && n?.activate();
  };
}
function pc() {
  nn(null), Pr(null), co(null);
}
// @__NO_SIDE_EFFECTS__
function Ai(t) {
  var e = Et | Tt, r = Ge !== null && (Ge.f & Et) !== 0 ? (
    /** @type {Derived} */
    Ge
  ) : null;
  return Je !== null && (Je.f |= Bs), {
    ctx: it,
    deps: null,
    effects: null,
    equals: uv,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      xt
    ),
    wv: 0,
    parent: r ?? Je,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function hP(t, e, r) {
  let n = (
    /** @type {Effect | null} */
    Je
  );
  n === null && jx();
  var s = (
    /** @type {Boundary} */
    n.b
  ), o = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), i = Jn(
    /** @type {V} */
    xt
  ), a = !Ge, l = /* @__PURE__ */ new Map();
  return wP(() => {
    var u = ov();
    o = u.promise;
    try {
      Promise.resolve(t()).then(u.resolve, u.reject).then(() => {
        c === nt && c.committed && c.deactivate(), pc();
      });
    } catch (_) {
      u.reject(_), pc();
    }
    var c = (
      /** @type {Batch} */
      nt
    );
    if (a) {
      var f = s.is_rendered();
      s.update_pending_count(1), c.increment(f), l.get(c)?.reject(no), l.delete(c), l.set(c, u);
    }
    const h = (_, b = void 0) => {
      if (c.activate(), b)
        b !== no && (i.f |= Wn, ho(i, b));
      else {
        (i.f & Wn) !== 0 && (i.f ^= Wn), ho(i, _);
        for (const [p, g] of l) {
          if (l.delete(p), p === c) break;
          g.reject(no);
        }
      }
      a && (s.update_pending_count(-1), c.decrement(f));
    };
    u.promise.then(h, (_) => h(null, _ || "unknown"));
  }), pd(() => {
    for (const u of l.values())
      u.reject(no);
  }), new Promise((u) => {
    function c(f) {
      function h() {
        f === o ? u(i) : c(o);
      }
      f.then(h, h);
    }
    c(o);
  });
}
// @__NO_SIDE_EFFECTS__
function O(t) {
  const e = /* @__PURE__ */ Ai(t);
  return zv(e), e;
}
// @__NO_SIDE_EFFECTS__
function dd(t) {
  const e = /* @__PURE__ */ Ai(t);
  return e.equals = cv, e;
}
function _v(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Ct(
        /** @type {Effect} */
        e[r]
      );
  }
}
function gP(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & Et) === 0)
      return (e.f & xn) === 0 ? (
        /** @type {Effect} */
        e
      ) : null;
    e = e.parent;
  }
  return null;
}
function fd(t) {
  var e, r = Je;
  nn(gP(t));
  try {
    t.f &= ~Ds, _v(t), e = Wv(t);
  } finally {
    nn(r);
  }
  return e;
}
function wv(t) {
  var e = fd(t);
  if (!t.equals(e) && (t.wv = Uv(), (!nt?.is_fork || t.deps === null) && (t.v = e, t.deps === null))) {
    dt(t, Ot);
    return;
  }
  Zn || (Er !== null ? (gd() || nt?.is_fork) && Er.set(t, e) : ud(t));
}
let mc = /* @__PURE__ */ new Set();
const Hn = /* @__PURE__ */ new Map();
let Sv = !1;
function Jn(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: uv,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function xe(t, e) {
  const r = Jn(t);
  return zv(r), r;
}
// @__NO_SIDE_EFFECTS__
function xv(t, e = !1, r = !0) {
  const n = Jn(t);
  return e || (n.equals = cv), xo && r && it !== null && it.l !== null && (it.l.s ??= []).push(n), n;
}
function q(t, e, r = !1) {
  Ge !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Mr || (Ge.f & ug) !== 0) && Co() && (Ge.f & (Et | In | id | ug)) !== 0 && (Sr === null || !uo.call(Sr, t)) && Yx();
  let n = r ? Pt(e) : e;
  return ho(t, n);
}
function ho(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Zn ? Hn.set(t, e) : Hn.set(t, r), t.v = e;
    var n = Pn.ensure();
    if (n.capture(t, r), (t.f & Et) !== 0) {
      const s = (
        /** @type {Derived} */
        t
      );
      (t.f & Tt) !== 0 && fd(s), ud(s);
    }
    t.wv = Uv(), Pv(t, Tt), Co() && Je !== null && (Je.f & Ot) !== 0 && (Je.f & (Ur | is)) === 0 && (br === null ? PP([t]) : br.push(t)), !n.is_fork && mc.size > 0 && !Sv && pP();
  }
  return e;
}
function pP() {
  Sv = !1;
  for (const t of mc)
    (t.f & Ot) !== 0 && dt(t, Fr), Ti(t) && fi(t);
  mc.clear();
}
function Hr(t) {
  q(t, t.v + 1);
}
function Pv(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = Co(), s = r.length, o = 0; o < s; o++) {
      var i = r[o], a = i.f;
      if (!(!n && i === Je)) {
        var l = (a & Tt) === 0;
        if (l && dt(i, e), (a & Et) !== 0) {
          var u = (
            /** @type {Derived} */
            i
          );
          Er?.delete(u), (a & Ds) === 0 && (a & wr && (i.f |= Ds), Pv(u, Fr));
        } else l && ((a & In) !== 0 && vn !== null && vn.add(
          /** @type {Effect} */
          i
        ), Dr(
          /** @type {Effect} */
          i
        ));
      }
    }
}
function Pt(t) {
  if (typeof t != "object" || t === null || en in t)
    return t;
  const e = El(t);
  if (e !== sv && e !== Nx)
    return t;
  var r = /* @__PURE__ */ new Map(), n = $l(t), s = /* @__PURE__ */ xe(0), o = On, i = (a) => {
    if (On === o)
      return a();
    var l = Ge, u = On;
    Pr(null), pg(o);
    var c = a();
    return Pr(l), pg(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ xe(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Hx();
        var c = r.get(l);
        return c === void 0 ? c = i(() => {
          var f = /* @__PURE__ */ xe(u.value);
          return r.set(l, f), f;
        }) : q(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = i(() => /* @__PURE__ */ xe(xt));
            r.set(l, c), Hr(s);
          }
        } else
          q(u, xt), Hr(s);
        return !0;
      },
      get(a, l, u) {
        if (l === en)
          return t;
        var c = r.get(l), f = l in a;
        if (c === void 0 && (!f || Sn(a, l)?.writable) && (c = i(() => {
          var _ = Pt(f ? a[l] : xt), b = /* @__PURE__ */ xe(_);
          return b;
        }), r.set(l, c)), c !== void 0) {
          var h = d(c);
          return h === xt ? void 0 : h;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = d(c));
        } else if (u === void 0) {
          var f = r.get(l), h = f?.v;
          if (f !== void 0 && h !== xt)
            return {
              enumerable: !0,
              configurable: !0,
              value: h,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === en)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== xt || Reflect.has(a, l);
        if (u !== void 0 || Je !== null && (!c || Sn(a, l)?.writable)) {
          u === void 0 && (u = i(() => {
            var h = c ? Pt(a[l]) : xt, _ = /* @__PURE__ */ xe(h);
            return _;
          }), r.set(l, u));
          var f = d(u);
          if (f === xt)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var f = r.get(l), h = l in a;
        if (n && l === "length")
          for (var _ = u; _ < /** @type {Source<number>} */
          f.v; _ += 1) {
            var b = r.get(_ + "");
            b !== void 0 ? q(b, xt) : _ in a && (b = i(() => /* @__PURE__ */ xe(xt)), r.set(_ + "", b));
          }
        if (f === void 0)
          (!h || Sn(a, l)?.writable) && (f = i(() => /* @__PURE__ */ xe(void 0)), q(f, Pt(u)), r.set(l, f));
        else {
          h = f.v !== xt;
          var p = i(() => Pt(u));
          q(f, p);
        }
        var g = Reflect.getOwnPropertyDescriptor(a, l);
        if (g?.set && g.set.call(c, u), !h) {
          if (n && typeof l == "string") {
            var y = (
              /** @type {Source<number>} */
              r.get("length")
            ), S = Number(l);
            Number.isInteger(S) && S >= y.v && q(y, S + 1);
          }
          Hr(s);
        }
        return !0;
      },
      ownKeys(a) {
        d(s);
        var l = Reflect.ownKeys(a).filter((f) => {
          var h = r.get(f);
          return h === void 0 || h.v !== xt;
        });
        for (var [u, c] of r)
          c.v !== xt && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        Gx();
      }
    }
  );
}
function dg(t) {
  try {
    if (t !== null && typeof t == "object" && en in t)
      return t[en];
  } catch {
  }
  return t;
}
function mP(t, e) {
  return Object.is(dg(t), dg(e));
}
var fg, Ov, Cv, kv;
function vc() {
  if (fg === void 0) {
    fg = window, Ov = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    Cv = Sn(e, "firstChild").get, kv = Sn(e, "nextSibling").get, lg(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), lg(r) && (r.__t = void 0);
  }
}
function qt(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Rr(t) {
  return (
    /** @type {TemplateNode | null} */
    Cv.call(t)
  );
}
// @__NO_SIDE_EFFECTS__
function ln(t) {
  return (
    /** @type {TemplateNode | null} */
    kv.call(t)
  );
}
function ge(t, e) {
  if (!Ne)
    return /* @__PURE__ */ Rr(t);
  var r = /* @__PURE__ */ Rr(ze);
  if (r === null)
    r = ze.appendChild(qt());
  else if (e && r.nodeType !== $i) {
    var n = qt();
    return r?.before(n), wt(n), n;
  }
  return e && Nl(
    /** @type {Text} */
    r
  ), wt(r), r;
}
function D(t, e = !1) {
  if (!Ne) {
    var r = /* @__PURE__ */ Rr(t);
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ ln(r) : r;
  }
  if (e) {
    if (ze?.nodeType !== $i) {
      var n = qt();
      return ze?.before(n), wt(n), n;
    }
    Nl(
      /** @type {Text} */
      ze
    );
  }
  return ze;
}
function be(t, e = 1, r = !1) {
  let n = Ne ? ze : t;
  for (var s; e--; )
    s = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ ln(n);
  if (!Ne)
    return n;
  if (r) {
    if (n?.nodeType !== $i) {
      var o = qt();
      return n === null ? s?.after(o) : n.before(o), wt(o), o;
    }
    Nl(
      /** @type {Text} */
      n
    );
  }
  return wt(n), n;
}
function hd(t) {
  t.textContent = "";
}
function $v() {
  return !1;
}
function vP(t = "") {
  return document.createComment(t);
}
function Nl(t) {
  if (
    /** @type {string} */
    t.nodeValue.length < 65536
  )
    return;
  let e = t.nextSibling;
  for (; e !== null && e.nodeType === $i; )
    e.remove(), t.nodeValue += /** @type {string} */
    e.nodeValue, e = t.nextSibling;
}
function yP(t, e) {
  if (e) {
    const r = document.body;
    t.autofocus = !0, Ir(() => {
      document.activeElement === r && t.focus();
    });
  }
}
function Av(t) {
  Ne && /* @__PURE__ */ Rr(t) !== null && hd(t);
}
let hg = !1;
function Ev() {
  hg || (hg = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
    { capture: !0 }
  ));
}
function Fl(t) {
  var e = Ge, r = Je;
  Pr(null), nn(null);
  try {
    return t();
  } finally {
    Pr(e), nn(r);
  }
}
function Tv(t, e, r, n = r) {
  t.addEventListener(e, () => Fl(r));
  const s = t.__on_r;
  s ? t.__on_r = () => {
    s(), n(!0);
  } : t.__on_r = () => n(!0), Ev();
}
function Dv(t) {
  Je === null && (Ge === null && qx(), zx()), Zn && Bx();
}
function bP(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function Or(t, e, r) {
  var n = Je;
  n !== null && (n.f & hr) !== 0 && (t |= hr);
  var s = {
    ctx: it,
    deps: null,
    nodes: null,
    f: t | Tt | wr,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: n,
    b: n && n.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      fi(s), s.f |= Tl;
    } catch (a) {
      throw Ct(s), a;
    }
  else e !== null && Dr(s);
  var o = s;
  if (r && o.deps === null && o.teardown === null && o.nodes === null && o.first === o.last && // either `null`, or a singular child
  (o.f & Bs) === 0 && (o = o.first, (t & In) !== 0 && (t & kn) !== 0 && o !== null && (o.f |= kn)), o !== null && (o.parent = n, n !== null && bP(o, n), Ge !== null && (Ge.f & Et) !== 0 && (t & is) === 0)) {
    var i = (
      /** @type {Derived} */
      Ge
    );
    (i.effects ??= []).push(o);
  }
  return s;
}
function gd() {
  return Ge !== null && !Mr;
}
function pd(t) {
  const e = Or(ki, null, !1);
  return dt(e, Ot), e.teardown = t, e;
}
function Xe(t) {
  Dv();
  var e = (
    /** @type {Effect} */
    Je.f
  ), r = !Ge && (e & Ur) !== 0 && (e & Tl) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      it
    );
    (n.e ??= []).push(t);
  } else
    return Mv(t);
}
function Mv(t) {
  return Or(Qa | av, t, !1);
}
function ko(t) {
  return Dv(), Or(ki | av, t, !0);
}
function Iv(t) {
  Pn.ensure();
  const e = Or(is | Bs, t, !0);
  return () => {
    Ct(e);
  };
}
function _P(t) {
  Pn.ensure();
  const e = Or(is | Bs, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? As(e, () => {
      Ct(e), n(void 0);
    }) : (Ct(e), n(void 0));
  });
}
function Rl(t) {
  return Or(Qa, t, !1);
}
function wP(t) {
  return Or(id | Bs, t, !0);
}
function Ei(t, e = 0) {
  return Or(ki | e, t, !0);
}
function ke(t, e = [], r = [], n = []) {
  bv(n, e, r, (s) => {
    Or(ki, () => t(...s.map(d)), !0);
  });
}
function qs(t, e = 0) {
  var r = Or(In | e, t, !0);
  return r;
}
function Nv(t, e = 0) {
  var r = Or(sd | e, t, !0);
  return r;
}
function Xt(t) {
  return Or(Ur | Bs, t, !0);
}
function Fv(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Zn, n = Ge;
    gg(!0), Pr(null);
    try {
      e.call(null);
    } finally {
      gg(r), Pr(n);
    }
  }
}
function Rv(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const s = r.ac;
    s !== null && Fl(() => {
      s.abort(no);
    });
    var n = r.next;
    (r.f & is) !== 0 ? r.parent = null : Ct(r, e), r = n;
  }
}
function SP(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & Ur) === 0 && Ct(e), e = r;
  }
}
function Ct(t, e = !0) {
  var r = !1;
  (e || (t.f & iv) !== 0) && t.nodes !== null && t.nodes.end !== null && (xP(
    t.nodes.start,
    /** @type {TemplateNode} */
    t.nodes.end
  ), r = !0), Rv(t, e && !r), tl(t, 0), dt(t, xn);
  var n = t.nodes && t.nodes.t;
  if (n !== null)
    for (const o of n)
      o.stop();
  Fv(t);
  var s = t.parent;
  s !== null && s.first !== null && Vv(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes = t.ac = null;
}
function xP(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : /* @__PURE__ */ ln(t);
    t.remove(), t = r;
  }
}
function Vv(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function As(t, e, r = !0) {
  var n = [];
  Lv(t, n, !0);
  var s = () => {
    r && Ct(t), e && e();
  }, o = n.length;
  if (o > 0) {
    var i = () => --o || s();
    for (var a of n)
      a.out(i);
  } else
    s();
}
function Lv(t, e, r) {
  if ((t.f & hr) === 0) {
    t.f ^= hr;
    var n = t.nodes && t.nodes.t;
    if (n !== null)
      for (const a of n)
        (a.is_global || r) && e.push(a);
    for (var s = t.first; s !== null; ) {
      var o = s.next, i = (s.f & kn) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (s.f & Ur) !== 0 && (t.f & In) !== 0;
      Lv(s, e, i ? r : !1), s = o;
    }
  }
}
function md(t) {
  jv(t, !0);
}
function jv(t, e) {
  if ((t.f & hr) !== 0) {
    t.f ^= hr, (t.f & Ot) === 0 && (dt(t, Tt), Dr(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, s = (r.f & kn) !== 0 || (r.f & Ur) !== 0;
      jv(r, s ? e : !1), r = n;
    }
    var o = t.nodes && t.nodes.t;
    if (o !== null)
      for (const i of o)
        (i.is_global || e) && i.in();
  }
}
function Bv(t, e) {
  if (t.nodes)
    for (var r = t.nodes.start, n = t.nodes.end; r !== null; ) {
      var s = r === n ? null : /* @__PURE__ */ ln(r);
      e.append(r), r = s;
    }
}
let qa = !1, Zn = !1;
function gg(t) {
  Zn = t;
}
let Ge = null, Mr = !1;
function Pr(t) {
  Ge = t;
}
let Je = null;
function nn(t) {
  Je = t;
}
let Sr = null;
function zv(t) {
  Ge !== null && (Sr === null ? Sr = [t] : Sr.push(t));
}
let Yt = null, lr = 0, br = null;
function PP(t) {
  br = t;
}
let qv = 1, Cs = 0, On = Cs;
function pg(t) {
  On = t;
}
function Uv() {
  return ++qv;
}
function Ti(t) {
  var e = t.f;
  if ((e & Tt) !== 0)
    return !0;
  if (e & Et && (t.f &= ~Ds), (e & Fr) !== 0) {
    for (var r = (
      /** @type {Value[]} */
      t.deps
    ), n = r.length, s = 0; s < n; s++) {
      var o = r[s];
      if (Ti(
        /** @type {Derived} */
        o
      ) && wv(
        /** @type {Derived} */
        o
      ), o.wv > t.wv)
        return !0;
    }
    (e & wr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Er === null && dt(t, Ot);
  }
  return !1;
}
function Kv(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !(Sr !== null && uo.call(Sr, t)))
    for (var s = 0; s < n.length; s++) {
      var o = n[s];
      (o.f & Et) !== 0 ? Kv(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? dt(o, Tt) : (o.f & Ot) !== 0 && dt(o, Fr), Dr(
        /** @type {Effect} */
        o
      ));
    }
}
function Wv(t) {
  var e = Yt, r = lr, n = br, s = Ge, o = Sr, i = it, a = Mr, l = On, u = t.f;
  Yt = /** @type {null | Value[]} */
  null, lr = 0, br = null, Ge = (u & (Ur | is)) === 0 ? t : null, Sr = null, co(t.ctx), Mr = !1, On = ++Cs, t.ac !== null && (Fl(() => {
    t.ac.abort(no);
  }), t.ac = null);
  try {
    t.f |= fc;
    var c = (
      /** @type {Function} */
      t.fn
    ), f = c(), h = t.deps, _ = nt?.is_fork;
    if (Yt !== null) {
      var b;
      if (_ || tl(t, lr), h !== null && lr > 0)
        for (h.length = lr + Yt.length, b = 0; b < Yt.length; b++)
          h[lr + b] = Yt[b];
      else
        t.deps = h = Yt;
      if (gd() && (t.f & wr) !== 0)
        for (b = lr; b < h.length; b++)
          (h[b].reactions ??= []).push(t);
    } else !_ && h !== null && lr < h.length && (tl(t, lr), h.length = lr);
    if (Co() && br !== null && !Mr && h !== null && (t.f & (Et | Fr | Tt)) === 0)
      for (b = 0; b < /** @type {Source[]} */
      br.length; b++)
        Kv(
          br[b],
          /** @type {Effect} */
          t
        );
    if (s !== null && s !== t) {
      if (Cs++, s.deps !== null)
        for (let p = 0; p < r; p += 1)
          s.deps[p].rv = Cs;
      if (e !== null)
        for (const p of e)
          p.rv = Cs;
      br !== null && (n === null ? n = br : n.push(.../** @type {Source[]} */
      br));
    }
    return (t.f & Wn) !== 0 && (t.f ^= Wn), f;
  } catch (p) {
    return fv(p);
  } finally {
    t.f ^= fc, Yt = e, lr = r, br = n, Ge = s, Sr = o, co(i), Mr = a, On = l;
  }
}
function OP(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = Ix.call(r, t);
    if (n !== -1) {
      var s = r.length - 1;
      s === 0 ? r = e.reactions = null : (r[n] = r[s], r.pop());
    }
  }
  if (r === null && (e.f & Et) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Yt === null || !uo.call(Yt, e))) {
    var o = (
      /** @type {Derived} */
      e
    );
    (o.f & wr) !== 0 && (o.f ^= wr, o.f &= ~Ds), ud(o), _v(o), tl(o, 0);
  }
}
function tl(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      OP(t, r[n]);
}
function fi(t) {
  var e = t.f;
  if ((e & xn) === 0) {
    dt(t, Ot);
    var r = Je, n = qa;
    Je = t, qa = !0;
    try {
      (e & (In | sd)) !== 0 ? SP(t) : Rv(t), Fv(t);
      var s = Wv(t);
      t.teardown = typeof s == "function" ? s : null, t.wv = qv;
      var o;
      cc && eP && (t.f & Tt) !== 0 && t.deps;
    } finally {
      qa = n, Je = r;
    }
  }
}
async function Vl() {
  await Promise.resolve(), m();
}
function d(t) {
  var e = t.f, r = (e & Et) !== 0;
  if (Ge !== null && !Mr) {
    var n = Je !== null && (Je.f & xn) !== 0;
    if (!n && (Sr === null || !uo.call(Sr, t))) {
      var s = Ge.deps;
      if ((Ge.f & fc) !== 0)
        t.rv < Cs && (t.rv = Cs, Yt === null && s !== null && s[lr] === t ? lr++ : Yt === null ? Yt = [t] : Yt.push(t));
      else {
        (Ge.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Ge] : uo.call(o, Ge) || o.push(Ge);
      }
    }
  }
  if (Zn && Hn.has(t))
    return Hn.get(t);
  if (r) {
    var i = (
      /** @type {Derived} */
      t
    );
    if (Zn) {
      var a = i.v;
      return ((i.f & Ot) === 0 && i.reactions !== null || Gv(i)) && (a = fd(i)), Hn.set(i, a), a;
    }
    var l = (i.f & wr) === 0 && !Mr && Ge !== null && (qa || (Ge.f & wr) !== 0), u = i.deps === null;
    Ti(i) && (l && (i.f |= wr), wv(i)), l && !u && Hv(i);
  }
  if (Er?.has(t))
    return Er.get(t);
  if ((t.f & Wn) !== 0)
    throw t.v;
  return t.v;
}
function Hv(t) {
  if (t.deps !== null) {
    t.f |= wr;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & Et) !== 0 && (e.f & wr) === 0 && Hv(
        /** @type {Derived} */
        e
      );
  }
}
function Gv(t) {
  if (t.v === xt) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Hn.has(e) || (e.f & Et) !== 0 && Gv(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function ot(t) {
  var e = Mr;
  try {
    return Mr = !0, t();
  } finally {
    Mr = e;
  }
}
function Nn(t, e) {
  var r = {};
  for (var n in t)
    e.includes(n) || (r[n] = t[n]);
  for (var s of Object.getOwnPropertySymbols(t))
    Object.propertyIsEnumerable.call(t, s) && !e.includes(s) && (r[s] = t[s]);
  return r;
}
function CP(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (en in t)
      yc(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && en in r && yc(r);
      }
  }
}
function yc(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        yc(t[n], e);
      } catch {
      }
    const r = El(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = nv(r);
      for (let s in n) {
        const o = n[s].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
const Yv = /* @__PURE__ */ new Set(), bc = /* @__PURE__ */ new Set();
function Xv(t, e, r, n = {}) {
  function s(o) {
    if (n.capture || si.call(e, o), !o.cancelBubble)
      return Fl(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? Ir(() => {
    e.addEventListener(t, s, n);
  }) : e.addEventListener(t, s, n), s;
}
function Ye(t, e, r, n = {}) {
  var s = Xv(e, t, r, n);
  return () => {
    t.removeEventListener(e, s, n);
  };
}
function kP(t) {
  for (var e = 0; e < t.length; e++)
    Yv.add(t[e]);
  for (var r of bc)
    r(t);
}
let mg = null;
function si(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, s = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    s[0] || t.target
  );
  mg = t;
  var i = 0, a = mg === t && t.__root;
  if (a) {
    var l = s.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = s.indexOf(e);
    if (u === -1)
      return;
    l <= u && (i = l);
  }
  if (o = /** @type {Element} */
  s[i] || t.target, o !== e) {
    Za(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Ge, f = Je;
    Pr(null), nn(null);
    try {
      for (var h, _ = []; o !== null; ) {
        var b = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var p = o["__" + n];
          p != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && p.call(o, t);
        } catch (g) {
          h ? _.push(g) : h = g;
        }
        if (t.cancelBubble || b === e || b === null)
          break;
        o = b;
      }
      if (h) {
        for (let g of _)
          queueMicrotask(() => {
            throw g;
          });
        throw h;
      }
    } finally {
      t.__root = e, delete t.currentTarget, Pr(c), nn(f);
    }
  }
}
function Jv(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Nr(t, e) {
  var r = (
    /** @type {Effect} */
    Je
  );
  r.nodes === null && (r.nodes = { start: t, end: e, a: null, t: null });
}
// @__NO_SIDE_EFFECTS__
function ne(t, e) {
  var r = (e & Ex) !== 0, n = (e & Tx) !== 0, s, o = !t.startsWith("<!>");
  return () => {
    if (Ne)
      return Nr(ze, null), ze;
    s === void 0 && (s = Jv(o ? t : "<!>" + t), r || (s = /** @type {TemplateNode} */
    /* @__PURE__ */ Rr(s)));
    var i = (
      /** @type {TemplateNode} */
      n || Ov ? document.importNode(s, !0) : s.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Rr(i)
      ), l = (
        /** @type {TemplateNode} */
        i.lastChild
      );
      Nr(a, l);
    } else
      Nr(i, i);
    return i;
  };
}
// @__NO_SIDE_EFFECTS__
function $P(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), s = `<${r}>${n ? t : "<!>" + t}</${r}>`, o;
  return () => {
    if (Ne)
      return Nr(ze, null), ze;
    if (!o) {
      var i = (
        /** @type {DocumentFragment} */
        Jv(s)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ Rr(i)
      );
      o = /** @type {Element} */
      /* @__PURE__ */ Rr(a);
    }
    var l = (
      /** @type {TemplateNode} */
      o.cloneNode(!0)
    );
    return Nr(l, l), l;
  };
}
// @__NO_SIDE_EFFECTS__
function AP(t, e) {
  return /* @__PURE__ */ $P(t, e, "svg");
}
function tt(t = "") {
  if (!Ne) {
    var e = qt(t + "");
    return Nr(e, e), e;
  }
  var r = ze;
  return r.nodeType !== $i ? (r.before(r = qt()), wt(r)) : Nl(
    /** @type {Text} */
    r
  ), Nr(r, r), r;
}
function M() {
  if (Ne)
    return Nr(ze, null), ze;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = qt();
  return t.append(e, r), Nr(e, r), t;
}
function A(t, e) {
  if (Ne) {
    var r = (
      /** @type {Effect & { nodes: EffectNodes }} */
      Je
    );
    ((r.f & Tl) === 0 || r.nodes.end === null) && (r.nodes.end = ze), $n();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
function De() {
  if (Ne && ze && ze.nodeType === zs && ze.textContent?.startsWith("$")) {
    const t = ze.textContent.substring(1);
    return $n(), t;
  }
  return (window.__svelte ??= {}).uid ??= 1, `c${window.__svelte.uid++}`;
}
function EP(t) {
  return t.endsWith("capture") && t !== "gotpointercapture" && t !== "lostpointercapture";
}
const TP = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function DP(t) {
  return TP.includes(t);
}
const MP = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function IP(t) {
  return t = t.toLowerCase(), MP[t] ?? t;
}
const NP = ["touchstart", "touchmove"];
function FP(t) {
  return NP.includes(t);
}
const RP = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function VP(t) {
  return RP.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    t
  );
}
function Ie(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function vd(t, e) {
  return Zv(t, e);
}
function LP(t, e) {
  vc(), e.intro = e.intro ?? !1;
  const r = e.target, n = Ne, s = ze;
  try {
    for (var o = /* @__PURE__ */ Rr(r); o && (o.nodeType !== zs || /** @type {Comment} */
    o.data !== tv); )
      o = /* @__PURE__ */ ln(o);
    if (!o)
      throw lo;
    zt(!0), wt(
      /** @type {Comment} */
      o
    );
    const i = Zv(t, { ...e, anchor: o });
    return zt(!1), /**  @type {Exports} */
    i;
  } catch (i) {
    if (i instanceof Error && i.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw i;
    return i !== lo && console.warn("Failed to hydrate: ", i), e.recover === !1 && Kx(), vc(), hd(r), zt(!1), vd(t, e);
  } finally {
    zt(n), wt(s);
  }
}
const Js = /* @__PURE__ */ new Map();
function Zv(t, { target: e, anchor: r, props: n = {}, events: s, context: o, intro: i = !0 }) {
  vc();
  var a = /* @__PURE__ */ new Set(), l = (f) => {
    for (var h = 0; h < f.length; h++) {
      var _ = f[h];
      if (!a.has(_)) {
        a.add(_);
        var b = FP(_);
        e.addEventListener(_, si, { passive: b });
        var p = Js.get(_);
        p === void 0 ? (document.addEventListener(_, si, { passive: b }), Js.set(_, 1)) : Js.set(_, p + 1);
      }
    }
  };
  l(Al(Yv)), bc.add(l);
  var u = void 0, c = _P(() => {
    var f = r ?? e.appendChild(qt());
    return cP(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (h) => {
        if (o) {
          W({});
          var _ = (
            /** @type {ComponentContext} */
            it
          );
          _.c = o;
        }
        if (s && (n.$$events = s), Ne && Nr(
          /** @type {TemplateNode} */
          h,
          null
        ), u = t(h, n) || {}, Ne && (Je.nodes.end = ze, ze === null || ze.nodeType !== zs || /** @type {Comment} */
        ze.data !== nd))
          throw Dl(), lo;
        o && H();
      }
    ), () => {
      for (var h of a) {
        e.removeEventListener(h, si);
        var _ = (
          /** @type {number} */
          Js.get(h)
        );
        --_ === 0 ? (document.removeEventListener(h, si), Js.delete(h)) : Js.set(h, _);
      }
      bc.delete(l), f !== r && f.parentNode?.removeChild(f);
    };
  });
  return _c.set(u, c), u;
}
let _c = /* @__PURE__ */ new WeakMap();
function Qv(t, e) {
  const r = _c.get(t);
  return r ? (_c.delete(t), r(e)) : Promise.resolve();
}
class Di {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /**
   * Map of keys to effects that are currently rendered in the DOM.
   * These effects are visible and actively part of the document tree.
   * Example:
   * ```
   * {#if condition}
   * 	foo
   * {:else}
   * 	bar
   * {/if}
   * ```
   * Can result in the entries `true->Effect` and `false->Effect`
   * @type {Map<Key, Effect>}
   */
  #t = /* @__PURE__ */ new Map();
  /**
   * Similar to #onscreen with respect to the keys, but contains branches that are not yet
   * in the DOM, because their insertion is deferred.
   * @type {Map<Key, Branch>}
   */
  #r = /* @__PURE__ */ new Map();
  /**
   * Keys of effects that are currently outroing
   * @type {Set<Key>}
   */
  #n = /* @__PURE__ */ new Set();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #s = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#s = r;
  }
  #o = () => {
    var e = (
      /** @type {Batch} */
      nt
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        md(n), this.#n.delete(r);
      else {
        var s = this.#r.get(r);
        s && (this.#t.set(r, s.effect), this.#r.delete(r), s.fragment.lastChild.remove(), this.anchor.before(s.fragment), n = s.effect);
      }
      for (const [o, i] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(i);
        a && (Ct(a.effect), this.#r.delete(i));
      }
      for (const [o, i] of this.#t) {
        if (o === r || this.#n.has(o)) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var u = document.createDocumentFragment();
            Bv(i, u), u.append(qt()), this.#r.set(o, { effect: i, fragment: u });
          } else
            Ct(i);
          this.#n.delete(o), this.#t.delete(o);
        };
        this.#s || !n ? (this.#n.add(o), As(i, a, !1)) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #i = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, s] of this.#r)
      r.includes(n) || (Ct(s.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      nt
    ), s = $v();
    if (r && !this.#t.has(e) && !this.#r.has(e))
      if (s) {
        var o = document.createDocumentFragment(), i = qt();
        o.append(i), this.#r.set(e, {
          effect: Xt(() => r(i)),
          fragment: o
        });
      } else
        this.#t.set(
          e,
          Xt(() => r(this.anchor))
        );
    if (this.#e.set(n, e), s) {
      for (const [a, l] of this.#t)
        a === e ? n.unskip_effect(l) : n.skip_effect(l);
      for (const [a, l] of this.#r)
        a === e ? n.unskip_effect(l.effect) : n.skip_effect(l.effect);
      n.oncommit(this.#o), n.ondiscard(this.#i);
    } else
      Ne && (this.anchor = ze), this.#o();
  }
}
function te(t, e, ...r) {
  var n = new Di(t);
  qs(() => {
    const s = e() ?? null;
    n.ensure(s, s && ((o) => s(o, ...r)));
  }, kn);
}
function $o(t) {
  it === null && ld(), xo && it.l !== null ? BP(it).m.push(t) : Xe(() => {
    const e = ot(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function jP(t) {
  it === null && ld(), $o(() => () => ot(t));
}
function BP(t) {
  var e = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
function ey() {
  return Symbol(rv);
}
function ue(t, e, r = !1) {
  Ne && $n();
  var n = new Di(t), s = r ? kn : 0;
  function o(i, a) {
    if (Ne) {
      const u = lv(t) === kl;
      if (i === u) {
        var l = el();
        wt(l), n.anchor = l, zt(!1), n.ensure(i, a), zt(!0);
        return;
      }
    }
    n.ensure(i, a);
  }
  qs(() => {
    var i = !1;
    e((a, l = !0) => {
      i = !0, o(l, a);
    }), i || o(!1, null);
  }, s);
}
function Ll(t, e, r) {
  Ne && $n();
  var n = new Di(t), s = !Co();
  qs(() => {
    var o = e();
    s && o !== null && typeof o == "object" && (o = /** @type {V} */
    {}), n.ensure(o, r);
  });
}
function jl(t, e) {
  return e;
}
function zP(t, e, r) {
  for (var n = [], s = e.length, o, i = e.length, a = 0; a < s; a++) {
    let f = e[a];
    As(
      f,
      () => {
        if (o) {
          if (o.pending.delete(f), o.done.add(f), o.pending.size === 0) {
            var h = (
              /** @type {Set<EachOutroGroup>} */
              t.outrogroups
            );
            wc(Al(o.done)), h.delete(o), h.size === 0 && (t.outrogroups = null);
          }
        } else
          i -= 1;
      },
      !1
    );
  }
  if (i === 0) {
    var l = n.length === 0 && r !== null;
    if (l) {
      var u = (
        /** @type {Element} */
        r
      ), c = (
        /** @type {Element} */
        u.parentNode
      );
      hd(c), c.append(u), t.items.clear();
    }
    wc(e, !l);
  } else
    o = {
      pending: new Set(e),
      done: /* @__PURE__ */ new Set()
    }, (t.outrogroups ??= /* @__PURE__ */ new Set()).add(o);
}
function wc(t, e = !0) {
  for (var r = 0; r < t.length; r++)
    Ct(t[r], e);
}
var vg;
function st(t, e, r, n, s, o = null) {
  var i = t, a = /* @__PURE__ */ new Map(), l = (e & ev) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    i = Ne ? wt(/* @__PURE__ */ Rr(u)) : u.appendChild(qt());
  }
  Ne && $n();
  var c = null, f = /* @__PURE__ */ dd(() => {
    var y = r();
    return $l(y) ? y : y == null ? [] : Al(y);
  }), h, _ = !0;
  function b() {
    g.fallback = c, qP(g, h, i, e, n), c !== null && (h.length === 0 ? (c.f & bn) === 0 ? md(c) : (c.f ^= bn, oi(c, null, i)) : As(c, () => {
      c = null;
    }));
  }
  var p = qs(() => {
    h = /** @type {V[]} */
    d(f);
    var y = h.length;
    let S = !1;
    if (Ne) {
      var x = lv(i) === kl;
      x !== (y === 0) && (i = el(), wt(i), zt(!1), S = !0);
    }
    for (var P = /* @__PURE__ */ new Set(), w = (
      /** @type {Batch} */
      nt
    ), C = $v(), k = 0; k < y; k += 1) {
      Ne && ze.nodeType === zs && /** @type {Comment} */
      ze.data === nd && (i = /** @type {Comment} */
      ze, S = !0, zt(!1));
      var $ = h[k], T = n($, k), E = _ ? null : a.get(T);
      E ? (E.v && ho(E.v, $), E.i && ho(E.i, k), C && w.unskip_effect(E.e)) : (E = UP(
        a,
        _ ? i : vg ??= qt(),
        $,
        T,
        k,
        s,
        e,
        r
      ), _ || (E.e.f |= bn), a.set(T, E)), P.add(T);
    }
    if (y === 0 && o && !c && (_ ? c = Xt(() => o(i)) : (c = Xt(() => o(vg ??= qt())), c.f |= bn)), Ne && y > 0 && wt(el()), !_)
      if (C) {
        for (const [I, F] of a)
          P.has(I) || w.skip_effect(F.e);
        w.oncommit(b), w.ondiscard(() => {
        });
      } else
        b();
    S && zt(!0), d(f);
  }), g = { effect: p, items: a, outrogroups: null, fallback: c };
  _ = !1, Ne && (i = ze);
}
function Ho(t) {
  for (; t !== null && (t.f & Ur) === 0; )
    t = t.next;
  return t;
}
function qP(t, e, r, n, s) {
  var o = (n & xx) !== 0, i = e.length, a = t.items, l = Ho(t.effect.first), u, c = null, f, h = [], _ = [], b, p, g, y;
  if (o)
    for (y = 0; y < i; y += 1)
      b = e[y], p = s(b, y), g = /** @type {EachItem} */
      a.get(p).e, (g.f & bn) === 0 && (g.nodes?.a?.measure(), (f ??= /* @__PURE__ */ new Set()).add(g));
  for (y = 0; y < i; y += 1) {
    if (b = e[y], p = s(b, y), g = /** @type {EachItem} */
    a.get(p).e, t.outrogroups !== null)
      for (const E of t.outrogroups)
        E.pending.delete(g), E.done.delete(g);
    if ((g.f & bn) !== 0)
      if (g.f ^= bn, g === l)
        oi(g, null, r);
      else {
        var S = c ? c.next : l;
        g === t.effect.last && (t.effect.last = g.prev), g.prev && (g.prev.next = g.next), g.next && (g.next.prev = g.prev), Rn(t, c, g), Rn(t, g, S), oi(g, S, r), c = g, h = [], _ = [], l = Ho(c.next);
        continue;
      }
    if ((g.f & hr) !== 0 && (md(g), o && (g.nodes?.a?.unfix(), (f ??= /* @__PURE__ */ new Set()).delete(g))), g !== l) {
      if (u !== void 0 && u.has(g)) {
        if (h.length < _.length) {
          var x = _[0], P;
          c = x.prev;
          var w = h[0], C = h[h.length - 1];
          for (P = 0; P < h.length; P += 1)
            oi(h[P], x, r);
          for (P = 0; P < _.length; P += 1)
            u.delete(_[P]);
          Rn(t, w.prev, C.next), Rn(t, c, w), Rn(t, C, x), l = x, c = C, y -= 1, h = [], _ = [];
        } else
          u.delete(g), oi(g, l, r), Rn(t, g.prev, g.next), Rn(t, g, c === null ? t.effect.first : c.next), Rn(t, c, g), c = g;
        continue;
      }
      for (h = [], _ = []; l !== null && l !== g; )
        (u ??= /* @__PURE__ */ new Set()).add(l), _.push(l), l = Ho(l.next);
      if (l === null)
        continue;
    }
    (g.f & bn) === 0 && h.push(g), c = g, l = Ho(g.next);
  }
  if (t.outrogroups !== null) {
    for (const E of t.outrogroups)
      E.pending.size === 0 && (wc(Al(E.done)), t.outrogroups?.delete(E));
    t.outrogroups.size === 0 && (t.outrogroups = null);
  }
  if (l !== null || u !== void 0) {
    var k = [];
    if (u !== void 0)
      for (g of u)
        (g.f & hr) === 0 && k.push(g);
    for (; l !== null; )
      (l.f & hr) === 0 && l !== t.fallback && k.push(l), l = Ho(l.next);
    var $ = k.length;
    if ($ > 0) {
      var T = (n & ev) !== 0 && i === 0 ? r : null;
      if (o) {
        for (y = 0; y < $; y += 1)
          k[y].nodes?.a?.measure();
        for (y = 0; y < $; y += 1)
          k[y].nodes?.a?.fix();
      }
      zP(t, k, T);
    }
  }
  o && Ir(() => {
    if (f !== void 0)
      for (g of f)
        g.nodes?.a?.apply();
  });
}
function UP(t, e, r, n, s, o, i, a) {
  var l = (i & wx) !== 0 ? (i & Px) === 0 ? /* @__PURE__ */ xv(r, !1, !1) : Jn(r) : null, u = (i & Sx) !== 0 ? Jn(s) : null;
  return {
    v: l,
    i: u,
    e: Xt(() => (o(e, l ?? r, u ?? s, a), () => {
      t.delete(n);
    }))
  };
}
function oi(t, e, r) {
  if (t.nodes)
    for (var n = t.nodes.start, s = t.nodes.end, o = e && (e.f & bn) === 0 ? (
      /** @type {EffectNodes} */
      e.nodes.start
    ) : r; n !== null; ) {
      var i = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ln(n)
      );
      if (o.before(n), n === s)
        return;
      n = i;
    }
}
function Rn(t, e, r) {
  e === null ? t.effect.first = r : e.next = r, r === null ? t.effect.last = e : r.prev = e;
}
function Q(t, e, r) {
  Ne && $n();
  var n = new Di(t);
  qs(() => {
    var s = e() ?? null;
    n.ensure(s, s && ((o) => r(o, s)));
  }, kn);
}
function KP(t, e, r, n, s, o) {
  let i = Ne;
  Ne && $n();
  var a = null;
  Ne && ze.nodeType === Lx && (a = /** @type {Element} */
  ze, $n());
  var l = (
    /** @type {TemplateNode} */
    Ne ? ze : t
  ), u = new Di(l, !1);
  qs(() => {
    const c = e() || null;
    var f = Mx;
    if (c === null) {
      u.ensure(null, null);
      return;
    }
    return u.ensure(c, (h) => {
      if (c) {
        if (a = Ne ? (
          /** @type {Element} */
          a
        ) : document.createElementNS(f, c), Nr(a, a), n) {
          Ne && VP(c) && a.append(document.createComment(""));
          var _ = Ne ? /* @__PURE__ */ Rr(a) : a.appendChild(qt());
          Ne && (_ === null ? zt(!1) : wt(_)), n(a, _);
        }
        Je.nodes.end = a, h.before(a);
      }
      Ne && wt(h);
    }), () => {
    };
  }, kn), pd(() => {
  }), i && (zt(!0), wt(l));
}
function WP(t, e) {
  Rl(() => {
    var r = t.getRootNode(), n = (
      /** @type {ShadowRoot} */
      r.host ? (
        /** @type {ShadowRoot} */
        r
      ) : (
        /** @type {Document} */
        r.head ?? /** @type {Document} */
        r.ownerDocument.head
      )
    );
    if (!n.querySelector("#" + e.hash)) {
      const s = document.createElement("style");
      s.id = e.hash, s.textContent = e.code, n.appendChild(s);
    }
  });
}
function HP(t, e) {
  var r = void 0, n;
  Nv(() => {
    r !== (r = e()) && (n && (Ct(n), n = null), r && (n = Xt(() => {
      Rl(() => (
        /** @type {(node: Element) => void} */
        r(t)
      ));
    })));
  });
}
function ty(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (r = ty(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function io() {
  for (var t, e, r = 0, n = "", s = arguments.length; r < s; r++) (t = arguments[r]) && (e = ty(t)) && (n && (n += " "), n += e);
  return n;
}
function as(t) {
  return typeof t == "object" ? io(t) : t ?? "";
}
const yg = [...` 	
\r\fÂ \v\uFEFF`];
function GP(t, e, r) {
  var n = t == null ? "" : "" + t;
  if (r) {
    for (var s in r)
      if (r[s])
        n = n ? n + " " + s : s;
      else if (n.length)
        for (var o = s.length, i = 0; (i = n.indexOf(s, i)) >= 0; ) {
          var a = i + o;
          (i === 0 || yg.includes(n[i - 1])) && (a === n.length || yg.includes(n[a])) ? n = (i === 0 ? "" : n.substring(0, i)) + n.substring(a + 1) : i = a;
        }
  }
  return n === "" ? null : n;
}
function bg(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var s in t) {
    var o = t[s];
    o != null && o !== "" && (n += " " + s + ": " + o + r);
  }
  return n;
}
function Pu(t) {
  return t[0] !== "-" || t[1] !== "-" ? t.toLowerCase() : t;
}
function YP(t, e) {
  if (e) {
    var r = "", n, s;
    if (Array.isArray(e) ? (n = e[0], s = e[1]) : n = e, t) {
      t = String(t).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var o = !1, i = 0, a = !1, l = [];
      n && l.push(...Object.keys(n).map(Pu)), s && l.push(...Object.keys(s).map(Pu));
      var u = 0, c = -1;
      const p = t.length;
      for (var f = 0; f < p; f++) {
        var h = t[f];
        if (a ? h === "/" && t[f - 1] === "*" && (a = !1) : o ? o === h && (o = !1) : h === "/" && t[f + 1] === "*" ? a = !0 : h === '"' || h === "'" ? o = h : h === "(" ? i++ : h === ")" && i--, !a && o === !1 && i === 0) {
          if (h === ":" && c === -1)
            c = f;
          else if (h === ";" || f === p - 1) {
            if (c !== -1) {
              var _ = Pu(t.substring(u, c).trim());
              if (!l.includes(_)) {
                h !== ";" && f++;
                var b = t.substring(u, f).trim();
                r += " " + b + ";";
              }
            }
            u = f + 1, c = -1;
          }
        }
      }
    }
    return n && (r += bg(n)), s && (r += bg(s, !0)), r = r.trim(), r === "" ? null : r;
  }
  return t == null ? null : String(t);
}
function ls(t, e, r, n, s, o) {
  var i = t.__className;
  if (Ne || i !== r || i === void 0) {
    var a = GP(r, n, o);
    (!Ne || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : e ? t.className = a : t.setAttribute("class", a)), t.__className = r;
  } else if (o && s !== o)
    for (var l in o) {
      var u = !!o[l];
      (s == null || u !== !!s[l]) && t.classList.toggle(l, u);
    }
  return o;
}
function Ou(t, e = {}, r, n) {
  for (var s in r) {
    var o = r[s];
    e[s] !== o && (r[s] == null ? t.style.removeProperty(s) : t.style.setProperty(s, o, n));
  }
}
function XP(t, e, r, n) {
  var s = t.__style;
  if (Ne || s !== e) {
    var o = YP(e, n);
    (!Ne || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (Ou(t, r?.[0], n[0]), Ou(t, r?.[1], n[1], "important")) : Ou(t, r, n));
  return n;
}
function Sc(t, e, r = !1) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!$l(e))
      return Jx();
    for (var n of t.options)
      n.selected = e.includes(_g(n));
    return;
  }
  for (n of t.options) {
    var s = _g(n);
    if (mP(s, e)) {
      n.selected = !0;
      return;
    }
  }
  (!r || e !== void 0) && (t.selectedIndex = -1);
}
function JP(t) {
  var e = new MutationObserver(() => {
    Sc(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), pd(() => {
    e.disconnect();
  });
}
function _g(t) {
  return "__value" in t ? t.__value : t.value;
}
const Go = /* @__PURE__ */ Symbol("class"), Yo = /* @__PURE__ */ Symbol("style"), ry = /* @__PURE__ */ Symbol("is custom element"), ny = /* @__PURE__ */ Symbol("is html");
function sy(t) {
  if (Ne) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          An(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var s = t.checked;
          An(t, "checked", null), t.checked = s;
        }
      }
    };
    t.__on_r = r, Ir(r), Ev();
  }
}
function ZP(t, e) {
  var r = yd(t);
  r.value === (r.value = // treat null and undefined the same for the initial value
  e ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  t.value === e && (e !== 0 || t.nodeName !== "PROGRESS") || (t.value = e ?? "");
}
function Us(t, e) {
  e ? t.hasAttribute("selected") || t.setAttribute("selected", "") : t.removeAttribute("selected");
}
function An(t, e, r, n) {
  var s = yd(t);
  Ne && (s[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || s[e] !== (s[e] = r) && (e === "loading" && (t[Vx] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && oy(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function QP(t, e, r, n, s = !1, o = !1) {
  if (Ne && s && t.tagName === "INPUT") {
    var i = (
      /** @type {HTMLInputElement} */
      t
    ), a = i.type === "checkbox" ? "defaultChecked" : "defaultValue";
    a in r || sy(i);
  }
  var l = yd(t), u = l[ry], c = !l[ny];
  let f = Ne && u;
  f && zt(!1);
  var h = e || {}, _ = t.tagName === "OPTION";
  for (var b in e)
    b in r || (r[b] = null);
  r.class ? r.class = as(r.class) : r[Go] && (r.class = null), r[Yo] && (r.style ??= null);
  var p = oy(t);
  for (const C in r) {
    let k = r[C];
    if (_ && C === "value" && k == null) {
      t.value = t.__value = "", h[C] = k;
      continue;
    }
    if (C === "class") {
      var g = t.namespaceURI === "http://www.w3.org/1999/xhtml";
      ls(t, g, k, n, e?.[Go], r[Go]), h[C] = k, h[Go] = r[Go];
      continue;
    }
    if (C === "style") {
      XP(t, k, e?.[Yo], r[Yo]), h[C] = k, h[Yo] = r[Yo];
      continue;
    }
    var y = h[C];
    if (!(k === y && !(k === void 0 && t.hasAttribute(C)))) {
      h[C] = k;
      var S = C[0] + C[1];
      if (S !== "$$")
        if (S === "on") {
          const $ = {}, T = "$$" + C;
          let E = C.slice(2);
          var x = DP(E);
          if (EP(E) && (E = E.slice(0, -7), $.capture = !0), !x && y) {
            if (k != null) continue;
            t.removeEventListener(E, h[T], $), h[T] = null;
          }
          if (k != null)
            if (x)
              t[`__${E}`] = k, kP([E]);
            else {
              let I = function(F) {
                h[C].call(this, F);
              };
              h[T] = Xv(E, t, I, $);
            }
          else x && (t[`__${E}`] = void 0);
        } else if (C === "style")
          An(t, C, k);
        else if (C === "autofocus")
          yP(
            /** @type {HTMLElement} */
            t,
            !!k
          );
        else if (!u && (C === "__value" || C === "value" && k != null))
          t.value = t.__value = k;
        else if (C === "selected" && _)
          Us(
            /** @type {HTMLOptionElement} */
            t,
            k
          );
        else {
          var P = C;
          c || (P = IP(P));
          var w = P === "defaultValue" || P === "defaultChecked";
          if (k == null && !u && !w)
            if (l[C] = null, P === "value" || P === "checked") {
              let $ = (
                /** @type {HTMLInputElement} */
                t
              );
              const T = e === void 0;
              if (P === "value") {
                let E = $.defaultValue;
                $.removeAttribute(P), $.defaultValue = E, $.value = $.__value = T ? E : null;
              } else {
                let E = $.defaultChecked;
                $.removeAttribute(P), $.defaultChecked = E, $.checked = T ? E : !1;
              }
            } else
              t.removeAttribute(C);
          else w || p.includes(P) && (u || typeof k != "string") ? (t[P] = k, P in l && (l[P] = xt)) : typeof k != "function" && An(t, P, k);
        }
    }
  }
  return f && zt(!0), h;
}
function ve(t, e, r = [], n = [], s = [], o, i = !1, a = !1) {
  bv(s, r, n, (l) => {
    var u = void 0, c = {}, f = t.nodeName === "SELECT", h = !1;
    if (Nv(() => {
      var b = e(...l.map(d)), p = QP(
        t,
        u,
        b,
        o,
        i,
        a
      );
      h && f && "value" in b && Sc(
        /** @type {HTMLSelectElement} */
        t,
        b.value
      );
      for (let y of Object.getOwnPropertySymbols(c))
        b[y] || Ct(c[y]);
      for (let y of Object.getOwnPropertySymbols(b)) {
        var g = b[y];
        y.description === rv && (!u || g !== u[y]) && (c[y] && Ct(c[y]), c[y] = Xt(() => HP(t, () => g))), p[y] = g;
      }
      u = p;
    }), f) {
      var _ = (
        /** @type {HTMLSelectElement} */
        t
      );
      Rl(() => {
        Sc(
          _,
          /** @type {Record<string | symbol, any>} */
          u.value,
          !0
        ), JP(_);
      });
    }
    h = !0;
  });
}
function yd(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [ry]: t.nodeName.includes("-"),
      [ny]: t.namespaceURI === Dx
    }
  );
}
var wg = /* @__PURE__ */ new Map();
function oy(t) {
  var e = t.getAttribute("is") || t.nodeName, r = wg.get(e);
  if (r) return r;
  wg.set(e, r = []);
  for (var n, s = t, o = Element.prototype; o !== s; ) {
    n = nv(s);
    for (var i in n)
      n[i].set && r.push(i);
    s = El(s);
  }
  return r;
}
let Cu = null;
function eO() {
  if (Cu === null) {
    var t = document.createElement("select");
    t.innerHTML = "<option><span>t</span></option>", Cu = /** @type {Element} */
    t.firstChild?.firstChild?.nodeType === 1;
  }
  return Cu;
}
function iy(t, e) {
  var r = Ne;
  eO() || (zt(!1), t.textContent = "", t.append(vP("")));
  try {
    e();
  } finally {
    r && (Ne ? de(t) : (zt(!0), wt(t)));
  }
}
function go(t, e, r = e) {
  var n = /* @__PURE__ */ new WeakSet();
  Tv(t, "input", async (s) => {
    var o = s ? t.defaultValue : t.value;
    if (o = ku(t) ? $u(o) : o, r(o), nt !== null && n.add(nt), await Vl(), o !== (o = e())) {
      var i = t.selectionStart, a = t.selectionEnd, l = t.value.length;
      if (t.value = o ?? "", a !== null) {
        var u = t.value.length;
        i === a && a === l && u > l ? (t.selectionStart = u, t.selectionEnd = u) : (t.selectionStart = i, t.selectionEnd = Math.min(a, u));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (Ne && t.defaultValue !== t.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  ot(e) == null && t.value) && (r(ku(t) ? $u(t.value) : t.value), nt !== null && n.add(nt)), Ei(() => {
    var s = e();
    if (t === document.activeElement) {
      var o = (
        /** @type {Batch} */
        hc ?? nt
      );
      if (n.has(o))
        return;
    }
    ku(t) && s === $u(t.value) || t.type === "date" && !s && !t.value || s !== t.value && (t.value = s ?? "");
  });
}
function ku(t) {
  var e = t.type;
  return e === "number" || e === "range";
}
function $u(t) {
  return t === "" ? null : +t;
}
function ay(t, e, r = e) {
  Tv(t, "change", () => {
    r(t.files);
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  Ne && t.files && r(t.files), Ei(() => {
    t.files = e();
  });
}
function Sg(t, e) {
  return t === e || t?.[en] === e;
}
function et(t = {}, e, r, n) {
  return Rl(() => {
    var s, o;
    return Ei(() => {
      s = o, o = [], ot(() => {
        t !== r(...o) && (e(t, ...o), s && Sg(r(...s), t) && e(null, ...s));
      });
    }), () => {
      Ir(() => {
        o && Sg(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
function bd(t = !1) {
  const e = (
    /** @type {ComponentContextLegacy} */
    it
  ), r = e.l.u;
  if (!r) return;
  let n = () => CP(e.s);
  if (t) {
    let s = 0, o = (
      /** @type {Record<string, any>} */
      {}
    );
    const i = /* @__PURE__ */ Ai(() => {
      let a = !1;
      const l = e.s;
      for (const u in l)
        l[u] !== o[u] && (o[u] = l[u], a = !0);
      return a && s++, s;
    });
    n = () => d(i);
  }
  r.b.length && ko(() => {
    xg(e, n), dc(r.b);
  }), Xe(() => {
    const s = ot(() => r.m.map(Fx));
    return () => {
      for (const o of s)
        typeof o == "function" && o();
    };
  }), r.a.length && Xe(() => {
    xg(e, n), dc(r.a);
  });
}
function xg(t, e) {
  if (t.l.s)
    for (const r of t.l.s) d(r);
  e();
}
let Ki = !1;
function tO(t) {
  var e = Ki;
  try {
    return Ki = !1, [t(), Ki];
  } finally {
    Ki = e;
  }
}
const rO = {
  get(t, e) {
    if (!t.exclude.includes(e))
      return t.props[e];
  },
  set(t, e) {
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    if (!t.exclude.includes(e) && e in t.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: t.props[e]
      };
  },
  has(t, e) {
    return t.exclude.includes(e) ? !1 : e in t.props;
  },
  ownKeys(t) {
    return Reflect.ownKeys(t.props).filter((e) => !t.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function ie(t, e, r) {
  return new Proxy(
    { props: t, exclude: e },
    rO
  );
}
const nO = {
  get(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Wo(n) && (n = n()), typeof n == "object" && n !== null && e in n) return n[e];
    }
  },
  set(t, e, r) {
    let n = t.props.length;
    for (; n--; ) {
      let s = t.props[n];
      Wo(s) && (s = s());
      const o = Sn(s, e);
      if (o && o.set)
        return o.set(r), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Wo(n) && (n = n()), typeof n == "object" && n !== null && e in n) {
        const s = Sn(n, e);
        return s && !s.configurable && (s.configurable = !0), s;
      }
    }
  },
  has(t, e) {
    if (e === en || e === ad) return !1;
    for (let r of t.props)
      if (Wo(r) && (r = r()), r != null && e in r) return !0;
    return !1;
  },
  ownKeys(t) {
    const e = [];
    for (let r of t.props)
      if (Wo(r) && (r = r()), !!r) {
        for (const n in r)
          e.includes(n) || e.push(n);
        for (const n of Object.getOwnPropertySymbols(r))
          e.includes(n) || e.push(n);
      }
    return e;
  }
};
function ce(...t) {
  return new Proxy({ props: t }, nO);
}
function v(t, e, r, n) {
  var s = !xo || (r & Cx) !== 0, o = (r & $x) !== 0, i = (r & Ax) !== 0, a = (
    /** @type {V} */
    n
  ), l = !0, u = () => (l && (l = !1, a = i ? ot(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), a), c;
  if (o) {
    var f = en in t || ad in t;
    c = Sn(t, e)?.set ?? (f && e in t ? (x) => t[e] = x : void 0);
  }
  var h, _ = !1;
  o ? [h, _] = tO(() => (
    /** @type {V} */
    t[e]
  )) : h = /** @type {V} */
  t[e], h === void 0 && n !== void 0 && (h = u(), c && (s && Wx(), c(h)));
  var b;
  if (s ? b = () => {
    var x = (
      /** @type {V} */
      t[e]
    );
    return x === void 0 ? u() : (l = !0, x);
  } : b = () => {
    var x = (
      /** @type {V} */
      t[e]
    );
    return x !== void 0 && (a = /** @type {V} */
    void 0), x === void 0 ? a : x;
  }, s && (r & kx) === 0)
    return b;
  if (c) {
    var p = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(x, P) {
        return arguments.length > 0 ? ((!s || !P || p || _) && c(P ? b() : x), x) : b();
      })
    );
  }
  var g = !1, y = ((r & Ox) !== 0 ? Ai : dd)(() => (g = !1, b()));
  o && d(y);
  var S = (
    /** @type {Effect} */
    Je
  );
  return (
    /** @type {() => V} */
    (function(x, P) {
      if (arguments.length > 0) {
        const w = P ? d(y) : s && o ? Pt(x) : x;
        return q(y, w), g = !0, a !== void 0 && (a = w), x;
      }
      return Zn && g || (S.f & xn) !== 0 ? y.v : d(y);
    })
  );
}
function sO(t) {
  return new oO(t);
}
class oO {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, i) => {
      var a = /* @__PURE__ */ xv(i, !1, !1);
      return r.set(o, a), a;
    };
    const s = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, i) {
          return d(r.get(i) ?? n(i, Reflect.get(o, i)));
        },
        has(o, i) {
          return i === ad ? !0 : (d(r.get(i) ?? n(i, Reflect.get(o, i))), Reflect.has(o, i));
        },
        set(o, i, a) {
          return q(r.get(i) ?? n(i, a), a), Reflect.set(o, i, a);
        }
      }
    );
    this.#t = (e.hydrate ? LP : vd)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: s,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && m(), this.#e = s.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || Za(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(i) {
          this.#t[o] = i;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(s, o);
    }, this.#t.$destroy = () => {
      Qv(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...s) => r.call(this, ...s);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (s) => s !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
let ly;
typeof HTMLElement == "function" && (ly = class extends HTMLElement {
  /** The Svelte component constructor */
  $$ctor;
  /** Slots */
  $$s;
  /** @type {any} The Svelte component instance */
  $$c;
  /** Whether or not the custom element is connected */
  $$cn = !1;
  /** @type {Record<string, any>} Component props data */
  $$d = {};
  /** `true` if currently in the process of reflecting component props back to attributes */
  $$r = !1;
  /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
  $$p_d = {};
  /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
  $$l = {};
  /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
  $$l_u = /* @__PURE__ */ new Map();
  /** @type {any} The managed render effect for reflecting attributes */
  $$me;
  /** @type {ShadowRoot | null} The ShadowRoot of the custom element */
  $$shadowRoot = null;
  /**
   * @param {*} $$componentCtor
   * @param {*} $$slots
   * @param {ShadowRootInit | undefined} shadow_root_init
   */
  constructor(t, e, r) {
    super(), this.$$ctor = t, this.$$s = e, r && (this.$$shadowRoot = this.attachShadow(r));
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  addEventListener(t, e, r) {
    if (this.$$l[t] = this.$$l[t] || [], this.$$l[t].push(e), this.$$c) {
      const n = this.$$c.$on(t, e);
      this.$$l_u.set(e, n);
    }
    super.addEventListener(t, e, r);
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  removeEventListener(t, e, r) {
    if (super.removeEventListener(t, e, r), this.$$c) {
      const n = this.$$l_u.get(e);
      n && (n(), this.$$l_u.delete(e));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let t = function(n) {
        return (s) => {
          const o = document.createElement("slot");
          n !== "default" && (o.name = n), A(s, o);
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const e = {}, r = iO(this);
      for (const n of this.$$s)
        n in r && (n === "default" && !this.$$d.children ? (this.$$d.children = t(n), e.default = !0) : e[n] = t(n));
      for (const n of this.attributes) {
        const s = this.$$g_p(n.name);
        s in this.$$d || (this.$$d[s] = Ua(s, n.value, this.$$p_d, "toProp"));
      }
      for (const n in this.$$p_d)
        !(n in this.$$d) && this[n] !== void 0 && (this.$$d[n] = this[n], delete this[n]);
      this.$$c = sO({
        component: this.$$ctor,
        target: this.$$shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: e,
          $$host: this
        }
      }), this.$$me = Iv(() => {
        Ei(() => {
          this.$$r = !0;
          for (const n of Ja(this.$$c)) {
            if (!this.$$p_d[n]?.reflect) continue;
            this.$$d[n] = this.$$c[n];
            const s = Ua(
              n,
              this.$$d[n],
              this.$$p_d,
              "toAttribute"
            );
            s == null ? this.removeAttribute(this.$$p_d[n].attribute || n) : this.setAttribute(this.$$p_d[n].attribute || n, s);
          }
          this.$$r = !1;
        });
      });
      for (const n in this.$$l)
        for (const s of this.$$l[n]) {
          const o = this.$$c.$on(n, s);
          this.$$l_u.set(s, o);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  /**
   * @param {string} attr
   * @param {string} _oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(t, e, r) {
    this.$$r || (t = this.$$g_p(t), this.$$d[t] = Ua(t, r, this.$$p_d, "toProp"), this.$$c?.$set({ [t]: this.$$d[t] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
    });
  }
  /**
   * @param {string} attribute_name
   */
  $$g_p(t) {
    return Ja(this.$$p_d).find(
      (e) => this.$$p_d[e].attribute === t || !this.$$p_d[e].attribute && e.toLowerCase() === t
    ) || t;
  }
});
function Ua(t, e, r, n) {
  const s = r[t]?.type;
  if (e = s === "Boolean" && typeof e != "boolean" ? e != null : e, !n || !r[t])
    return e;
  if (n === "toAttribute")
    switch (s) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (s) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      // conversion already handled above
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function iO(t) {
  const e = {};
  return t.childNodes.forEach((r) => {
    e[
      /** @type {Element} node */
      r.slot || "default"
    ] = !0;
  }), e;
}
function K(t, e, r, n, s, o) {
  let i = class extends ly {
    constructor() {
      super(t, r, s), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Ja(e).map(
        (a) => (e[a].attribute || a).toLowerCase()
      );
    }
  };
  return Ja(e).forEach((a) => {
    Za(i.prototype, a, {
      get() {
        return this.$$c && a in this.$$c ? this.$$c[a] : this.$$d[a];
      },
      set(l) {
        l = Ua(a, l, e), this.$$d[a] = l;
        var u = this.$$c;
        if (u) {
          var c = Sn(u, a)?.get;
          c ? u[a] = l : u.$set({ [a]: l });
        }
      }
    });
  }), n.forEach((a) => {
    Za(i.prototype, a, {
      get() {
        return this.$$c?.[a];
      }
    });
  }), t.element = /** @type {any} */
  i, i;
}
const Vr = "$ref", Pg = "$id", Og = "properties", aO = "items", uy = "dependencies", cy = "if", dy = "allOf", so = "anyOf", oo = "oneOf", lO = "__sjsf_rootSchema", Bl = "__additional_property", fy = "data-url";
function uO(t) {
  return t.properties !== void 0;
}
function cO(t) {
  return typeof t == "object" && !Array.isArray(t);
}
function dO(t, e) {
  return Array.from(new Array(t), (r, n) => e(n));
}
function Cg(t) {
  return Array.from(new Set(t));
}
function Au(t, e) {
  const r = t.length;
  if (r === 0)
    return e;
  let n = e.length;
  if (n === 0)
    return t;
  if (r < n) {
    const o = t;
    t = e, e = o, n = r;
  }
  const s = new Set(t);
  for (let o = 0; o < n; o++)
    s.add(e[o]);
  return Array.from(s);
}
function fO(t, e) {
  const r = [];
  if (t.length === 0 || e.length === 0)
    return r;
  if (t.length > e.length) {
    const s = t;
    t = e, e = s;
  }
  const n = new Set(e);
  for (let s = 0; s < t.length && n.size > 0; s++) {
    const o = t[s];
    n.delete(o) && r.push(o);
  }
  return r;
}
function Is(t) {
  return t !== null && typeof t == "object";
}
const hO = Object.prototype;
function hi(t) {
  const e = Object.getPrototypeOf(t);
  return e === hO || e === null;
}
function xc(t) {
  return Is(t) && hi(t);
}
function tn(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return !1;
  return !0;
}
const gO = [
  "array",
  "boolean",
  "integer",
  "null",
  "number",
  "object",
  "string"
], pO = new Set(gO);
function mO(t) {
  return pO.has(t);
}
const _d = [
  "$defs",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies"
];
new Set(_d);
const wd = [
  "items",
  "allOf",
  "oneOf",
  "anyOf"
];
new Set(wd);
const Sd = [
  "items",
  "additionalItems",
  "additionalProperties",
  "propertyNames",
  "contains",
  "if",
  "then",
  "else",
  "not"
];
new Set(Sd);
[
  ..._d,
  ...wd,
  ...Sd
];
function er(t) {
  return typeof t == "object";
}
function zn(t) {
  return er(t) ? tn(t) : t === !0;
}
function Ka(t, e, r = { type: "root", path: [] }) {
  if (!er(t))
    return e(t, r);
  const n = {
    ...t
  };
  for (const i of wd) {
    const a = t[i];
    if (a === void 0 || !Array.isArray(a))
      continue;
    const l = {
      type: "array",
      parent: t,
      key: i,
      index: 0,
      path: r.path.concat(i, 0)
    };
    n[i] = a.map((u, c) => (l.index = c, l.path[l.path.length - 1] = c, Ka(u, e, l)));
  }
  const s = /* @__PURE__ */ new Map();
  for (const i of _d) {
    const a = t[i];
    if (a === void 0)
      continue;
    const l = {
      type: "record",
      parent: t,
      key: i,
      property: "",
      path: r.path.concat(i, "")
    }, u = Object.keys(a), c = u.length;
    for (let f = 0; f < c; f++) {
      const h = u[f], _ = a[h];
      if (Array.isArray(_)) {
        s.set(h, _);
        continue;
      }
      l.property = h, l.path[l.path.length - 1] = h, s.set(h, Ka(_, e, l));
    }
    n[i] = Object.fromEntries(s), s.clear();
  }
  const o = {
    type: "sub",
    parent: t,
    key: "items",
    path: r.path.concat("")
  };
  for (const i of Sd) {
    const a = t[i];
    a === void 0 || Array.isArray(a) || (o.key = i, o.path[o.path.length - 1] = i, n[i] = Ka(a, e, o));
  }
  return e(n, r);
}
function hy(t, e) {
  return (r) => {
    if (t.has(r))
      return t.get(r);
    const n = e(r);
    return t.set(r, n), n;
  };
}
const zl = hy;
function gy() {
}
function rl(t) {
  return t;
}
const py = (t, e) => t ? py(e % t, t) : e, vO = (t, e) => Math.abs(t * e) / py(t, e);
function yO(t, e) {
  return t === e ? t : `^(?=.*(?:${t}))(?=.*(?:${e})).*$`;
}
function* Eu(t, e, r) {
  const n = t.length, s = e.length;
  if (n > 0 && s > 0)
    for (let o = 0; o < n; o++) {
      const i = t[o];
      for (let a = 0; a < s; a++)
        yield r(i, e[a]);
    }
}
function Tu(t, e) {
  return t || e;
}
function kg(t) {
  return (e, r) => {
    const n = { ...e }, s = Object.keys(r), o = s.length;
    for (let i = 0; i < o; i++) {
      const a = s[i];
      n[a] = e[a] === void 0 ? r[a] : t(e[a], r[a]);
    }
    return n;
  };
}
function bO(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t)
    for (const n of r[0])
      e.set(n, r[1]);
  return e;
}
function ms(t, e, r) {
  r === void 0 || zn(r) ? delete t[e] : t[e] = r;
}
const _O = [
  "properties",
  "patternProperties",
  "additionalProperties"
];
function $g(t) {
  const e = Object.keys(t), r = e.length, n = [];
  for (let s = 0; s < r; s++) {
    const o = e[s];
    n.push({
      regExp: new RegExp(o),
      schema: t[o]
    });
  }
  return [n, e];
}
const Ag = [[], []];
function Eg(t, e, r) {
  const n = r.length;
  for (let s = 0; s < n; s++) {
    const o = r[s];
    if (!o.regExp.test(e))
      continue;
    const i = o.schema;
    if (i === !1)
      return !0;
    t.push(i);
  }
  return !1;
}
const wO = [
  "items",
  "additionalItems"
], SO = [
  "if",
  "then",
  "else"
];
function Tg(t, e) {
  return e.if !== void 0 && (t.if = e.if), e.then !== void 0 && (t.then = e.then), e.else !== void 0 && (t.else = e.else), t;
}
function Du(t, e) {
  if (t === e)
    return t;
  switch (t) {
    case "number":
      if (e === "integer")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    case "integer":
      if (e === "number")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    default:
      return;
  }
}
function vs(t, e, r) {
  return [t, e, r];
}
function xO(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [r, n, s] of t) {
    const o = (i) => {
      if (!s(i))
        throw new Error(`Schema keys '${r}' and '${n}' are conflicting (${r}: ${JSON.stringify(i[r])}, ${n}: ${JSON.stringify(i[n])})`);
    };
    for (const i of [
      [r, n],
      [n, r]
    ]) {
      let a = e.get(i[0]);
      a === void 0 && (a = [], e.set(i[0], a)), a.push({ oppositeKey: i[1], check: o });
    }
  }
  return e;
}
const PO = [
  vs("minimum", "maximum", (t) => t.maximum >= t.minimum),
  vs("exclusiveMinimum", "maximum", (t) => t.maximum > t.exclusiveMinimum),
  vs("minimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.minimum),
  vs("exclusiveMinimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.exclusiveMinimum),
  vs("minLength", "maxLength", (t) => t.maxLength >= t.minLength),
  vs("minItems", "maxItems", (t) => t.maxItems >= t.minItems),
  vs("minProperties", "maxProperties", (t) => t.maxProperties >= t.minProperties)
];
function OO({ mergePatterns: t = yO, isSubRegExp: e = Object.is, intersectJson: r = fO, deduplicateJsonSchemaDef: n = rl, defaultMerger: s = rl, assigners: o = [], mergers: i, checks: a = PO } = {}) {
  function l(P) {
    const w = P.length;
    let C = P[0];
    for (let k = 1; k < w; k++) {
      const $ = y(C, P[k]);
      if ($ === !1)
        return !1;
      zn($) || (C = $);
    }
    return C;
  }
  function u(P, w, C, k, $, T, E) {
    if (P.length = 0, C === !1)
      return !1;
    if (P.push(C), $ !== void 0) {
      if ($ === !1)
        return !1;
      P.push($);
    }
    if (Eg(P, w, T))
      return !1;
    const F = P.length < 2;
    if (E === !1) {
      if (F)
        return;
      if (Eg(P, w, k))
        return !1;
    } else F && E !== void 0 && P.push(E);
    return P.length === 1 ? P[0] : l(P);
  }
  function c(P, w, C, k, $, T) {
    const E = C.length;
    if (E > 0 && $ !== !1)
      if (T)
        Object.assign(P, w);
      else
        for (let I = 0; I < E; I++) {
          const F = C[I];
          k.has(F) || (P[F] = y(w[F], $));
        }
    return P;
  }
  const f = (P, { properties: w = {}, patternProperties: C, additionalProperties: k = !0 }, { properties: $ = {}, patternProperties: T, additionalProperties: E = !0 }) => {
    const I = zn(k), F = zn(E);
    if (I && F)
      return ms(P, "properties", S(w, $)), ms(P, "patternProperties", C && T ? S(C, T) : C ?? T), delete P.additionalProperties, P;
    const U = y(k, E);
    ms(P, "additionalProperties", U);
    const B = {}, R = Object.keys(w), Z = R.length, [Y, X] = C ? $g(C) : Ag, [ae, J] = T ? $g(T) : Ag, j = [], ee = /* @__PURE__ */ new Set(), L = F ? void 0 : E;
    for (let we = 0; we < Z; we++) {
      const le = R[we];
      ee.add(le);
      const re = u(j, le, w[le], Y, $[le], ae, L);
      re !== void 0 && (B[le] = re);
    }
    const N = Object.keys($), V = N.length, G = I ? void 0 : k;
    for (let we = 0; we < V; we++) {
      const le = N[we];
      if (ee.has(le))
        continue;
      const re = u(j, le, $[le], ae, void 0, Y, G);
      re !== void 0 && (B[le] = re);
    }
    ms(P, "properties", B);
    let fe = {};
    const se = /* @__PURE__ */ new Set();
    if (X.length > 0 && J.length > 0) {
      const we = Eu(X, J, (le, re) => {
        e(le, re) && se.add(le), e(re, le) && se.add(re), fe[t(le, re)] = y(C[le], T[re]);
      });
      for (; !we.next().done; )
        ;
    }
    return fe = c(fe, C, X, se, E, F), fe = c(fe, T, J, se, k, I), ms(P, "patternProperties", fe), P;
  }, h = (P, { items: w = [], additionalItems: C }, { items: k = [], additionalItems: $ }) => {
    const T = Array.isArray(w), E = Array.isArray(k), I = [];
    if (P.items = I, T && E) {
      const [F, U, B] = w.length < k.length ? [w.length, C, k] : [k.length, $, w];
      let R = 0;
      for (; R < F; R++)
        I.push(y(w[R], k[R]));
      if (U === !1)
        P.additionalItems = !1;
      else {
        const Z = U === void 0 || zn(U);
        for (; R < B.length; R++)
          I.push(Z ? B[R] : y(B[R], U));
        ms(P, "additionalItems", C !== void 0 && $ !== void 0 ? y(C, $) : C ?? $);
      }
    } else if (T || E) {
      const [F, U, B] = T ? [w, k, C] : [k, w, $];
      ms(P, "additionalItems", B && y(B, U));
      for (let R = 0; R < F.length; R++)
        I.push(y(F[R], U));
    } else
      delete P.additionalItems, P.items = y(w, k);
    return P;
  }, _ = (P, w, C) => {
    Tg(P, w);
    const k = Tg({}, C);
    return P.allOf === void 0 ? P.allOf = [k] : P.allOf = P.allOf.concat(k), P;
  };
  function b(P, w) {
    return n(Array.from(Eu(P, w, y)));
  }
  const p = bO([
    [_O, f],
    [wO, h],
    [SO, _],
    ...o
  ]), g = xO(a);
  function y(P, w) {
    if (P === !1 || w === !1)
      return !1;
    if (zn(P))
      return zn(w) ? !0 : w;
    if (zn(w))
      return P;
    let C = { ...P };
    const k = /* @__PURE__ */ new Set(), $ = /* @__PURE__ */ new Set(), T = Object.keys(w), E = T.length;
    for (let I = 0; I < E; I++) {
      const F = T[I], U = w[F];
      if (U === void 0)
        continue;
      const B = g.get(F);
      if (B !== void 0) {
        const X = B.length;
        for (let ae = 0; ae < X; ae++) {
          const J = B[ae];
          P[J.oppositeKey] !== void 0 && $.add(J.check);
        }
      }
      const R = P[F];
      if (R === void 0) {
        C[F] = U;
        continue;
      }
      const Z = p.get(F);
      if (Z) {
        k.add(Z);
        continue;
      }
      const Y = x[F] ?? s;
      C[F] = Y(R, U);
    }
    for (const I of k)
      C = I(C, P, w);
    for (const I of $)
      I(C);
    return C;
  }
  const S = kg(y), x = {
    $id: s,
    $ref: s,
    $schema: s,
    $comment: s,
    $defs: S,
    definitions: S,
    type: (P, w) => {
      if (P === w)
        return P;
      const C = Array.isArray(P), k = Array.isArray(w);
      if (!C && !k) {
        const $ = Du(P, w);
        if ($ !== void 0)
          return $;
      } else if (C || k) {
        const $ = /* @__PURE__ */ new Set();
        if (C && k)
          for (const E of Eu(P, w, Du))
            E !== void 0 && $.add(E);
        else {
          const E = C ? P : w, I = C ? w : P, F = E.length;
          for (let U = 0; U < F; U++) {
            const B = Du(I, E[U]);
            B !== void 0 && $.add(B);
          }
        }
        const T = $.size;
        if (T === 1)
          return $.values().next().value;
        if (T > 1)
          return Array.from($);
      }
      throw new Error(`It is not possible to create an intersection of the following incompatible types: ${P.toString()}, ${w.toString()}`);
    },
    default: s,
    description: s,
    title: s,
    const: s,
    format: s,
    contentEncoding: s,
    contentMediaType: s,
    not: (P, w) => {
      const C = n([P, w]);
      return C.length === 1 ? C[0] : { anyOf: C };
    },
    pattern: t,
    readOnly: Tu,
    writeOnly: Tu,
    enum: (P, w) => {
      const C = r(P, w);
      if (C.length === 0)
        throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(P)}", "${JSON.stringify(w)}"`);
      return C;
    },
    anyOf: b,
    oneOf: b,
    allOf: (P, w) => n(P.concat(w)),
    propertyNames: y,
    contains: y,
    dependencies: kg((P, w) => Array.isArray(P) ? Array.isArray(w) ? Au(P, w) : y(w, { required: P }) : Array.isArray(w) ? y(P, { required: w }) : y(P, w)),
    examples: (P, w) => {
      if (!Array.isArray(P) || !Array.isArray(w))
        throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(P)}" and "${JSON.stringify(w)}"`);
      return Au(P, w);
    },
    multipleOf: (P, w) => {
      let C = 1;
      for (; !Number.isInteger(P) || !Number.isInteger(w); )
        C *= 10, P *= 10, w *= 10;
      return vO(P, w) / C;
    },
    exclusiveMaximum: Math.min,
    maximum: Math.min,
    maxItems: Math.min,
    maxLength: Math.min,
    maxProperties: Math.min,
    exclusiveMinimum: Math.max,
    minimum: Math.max,
    minItems: Math.max,
    minLength: Math.max,
    minProperties: Math.max,
    uniqueItems: Tu,
    required: Au,
    ...i
  };
  return {
    mergeSchemaDefinitions: y,
    mergeArrayOfSchemaDefinitions: l
  };
}
function CO(t) {
  const e = [], r = [t];
  for (; r.length > 0; ) {
    const n = r.pop();
    if (typeof n == "boolean" || n.allOf === void 0) {
      e.push(n);
      continue;
    }
    const { allOf: s, ...o } = n;
    e.push(o);
    for (let i = s.length - 1; i >= 0; i--)
      r.push(s[i]);
  }
  return e;
}
function kO(t) {
  return (e) => t(CO(e));
}
function gi(t) {
  if (t === null)
    return "null";
  if (Array.isArray(t))
    return "array";
  const e = typeof t;
  switch (e) {
    case "boolean":
    // TODO: Integer type inference ?
    // eslint-disable-next-line no-fallthrough
    case "number":
    case "object":
    case "string":
      return e;
    default:
      return "unknown";
  }
}
function ql(t) {
  if (t.type)
    return t.type;
  if (t.const !== void 0)
    return gi(t.const);
  if (t.properties || t.additionalProperties || t.propertyNames || t.patternProperties)
    return "object";
  if (Array.isArray(t.enum) && t.enum.length > 0)
    return Cg(t.enum.map(gi));
  const e = t.allOf ?? t.anyOf ?? t.oneOf;
  if (e) {
    let r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      er(s) && (r = r.concat(ql(s)));
    }
    return Cg(r);
  }
  return "unknown";
}
function $O(t) {
  return t === "null" || Array.isArray(t) && t.includes("null");
}
function my(t) {
  return $O(ql(t));
}
function AO(t) {
  if (t.length === 0)
    throw new Error("Unsupported schema types: empty type array");
  const e = t[0];
  return t.length === 1 ? e : e === "null" ? t[1] : e;
}
const po = (t) => {
  const e = ql(t);
  return Array.isArray(e) ? AO(e) : e;
};
function Dg(t) {
  return t === "boolean" || t === "integer" || t === "number" || t === "string" || t === "null";
}
function EO(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Xo = {}, Mg;
function TO() {
  if (Mg) return Xo;
  Mg = 1;
  var t = /~/, e = /~[01]/g;
  function r(u) {
    switch (u) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + u);
  }
  function n(u) {
    return t.test(u) ? u.replace(e, r) : u;
  }
  function s(u, c, f) {
    for (var h, _, b = 1, p = c.length; b < p; ) {
      if (c[b] === "constructor" || c[b] === "prototype" || c[b] === "__proto__") return u;
      if (h = n(c[b++]), _ = p > b, typeof u[h] > "u" && (Array.isArray(u) && h === "-" && (h = u.length), _ && (c[b] !== "" && c[b] < 1 / 0 || c[b] === "-" ? u[h] = [] : u[h] = {})), !_) break;
      u = u[h];
    }
    var g = u[h];
    return f === void 0 ? delete u[h] : u[h] = f, g;
  }
  function o(u) {
    if (typeof u == "string") {
      if (u = u.split("/"), u[0] === "") return u;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(u)) {
      for (const c of u)
        if (typeof c != "string" && typeof c != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return u;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function i(u, c) {
    if (typeof u != "object") throw new Error("Invalid input object.");
    c = o(c);
    var f = c.length;
    if (f === 1) return u;
    for (var h = 1; h < f; ) {
      if (u = u[n(c[h++])], f === h) return u;
      if (typeof u != "object" || u === null) return;
    }
  }
  function a(u, c, f) {
    if (typeof u != "object") throw new Error("Invalid input object.");
    if (c = o(c), c.length === 0) throw new Error("Invalid JSON pointer for set.");
    return s(u, c, f);
  }
  function l(u) {
    var c = o(u);
    return {
      get: function(f) {
        return i(f, c);
      },
      set: function(f, h) {
        return a(f, c, h);
      }
    };
  }
  return Xo.get = i, Xo.set = a, Xo.compile = l, Xo;
}
var DO = TO();
const MO = /* @__PURE__ */ EO(DO);
function vy(t, e) {
  if (!t.startsWith("#"))
    throw new Error(`Invalid reference: ${t}, must start with #`);
  const r = MO.get(e, decodeURIComponent(t.substring(1)));
  if (r === void 0)
    throw new Error(`Could not find a definition for ${t}.`);
  return r;
}
function xd(t, e, r, n = /* @__PURE__ */ new Set()) {
  const s = vy(e, r);
  if (!er(s))
    throw new Error(`Definition for ${e} should be a schema (object)`);
  const o = s[Vr];
  if (o) {
    if (n.has(o)) {
      if (n.size === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const u = Array.from(n), c = u[0];
      throw u.push(e, c), new Error(`Definition for ${c} contains a circular reference through ${u.join(" -> ")}`);
    }
    const i = xd(t, o, r, new Set(n).add(e));
    if (Object.keys(s).length < 2)
      return i;
    const { [Vr]: a, ...l } = s;
    return t.mergeSchemas(l, i);
  }
  return s;
}
function Be(t) {
  return xc(t);
}
function IO(t) {
  return Array.isArray(t);
}
function Pc(t) {
  if (typeof t == "string" || Array.isArray(t))
    return t.length === 0;
  if (!Is(t))
    return !0;
  if (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
    return t.byteLength === 0;
  const e = Object.getPrototypeOf(t);
  return e === Object.prototype || e === null ? tn(t) : Object.prototype.hasOwnProperty.call(e, "size") ? t.size === 0 : !0;
}
function Ig(t) {
  return typeof t == "string" ? t : JSON.stringify(t);
}
function Ns(t) {
  return t.discriminator?.propertyName;
}
function yy(t, e, r) {
  if (r && Be(t)) {
    const n = t[r];
    if (n === void 0)
      return;
    for (let s = 0; s < e.length; s++) {
      const i = e[s].properties?.[r] ?? {};
      if (i === !0)
        return s;
      if (!(i === !1 || i.type === "object" || i.type === "array") && (i.const === n || i.enum?.includes(n)))
        return s;
    }
  }
}
function NO({ required: t, ...e }) {
  return {
    allOf: [
      e,
      {
        anyOf: Object.keys(e.properties).map((r) => ({
          required: [r]
        }))
      }
    ]
  };
}
const FO = /* @__PURE__ */ new WeakMap(), RO = zl(FO, NO);
function by(t, e, r, n, s, o) {
  if (!uO(t))
    return e.isValid(t, n, r);
  const i = s !== void 0 ? t.properties[s] : void 0;
  return i !== void 0 ? e.isValid(i, n, o) : e.isValid(RO(t), n, r);
}
function VO(t, e, r, n, s) {
  if (e === void 0)
    return 0;
  const o = yy(e, r, s);
  if (o !== void 0)
    return o;
  const i = Be(e) && s !== void 0;
  for (let a = 0; a < r.length; a++)
    if (by(r[a], t, e, n, i ? s : void 0, i ? e[s] : void 0))
      return a;
  return 0;
}
function Oc(t, e, r, n, s) {
  let o = 0;
  if (n) {
    const i = n.properties;
    if (i && Be(s))
      for (const [a, l] of Object.entries(i)) {
        const u = s[a];
        if (typeof l == "boolean")
          continue;
        if (l[Vr] !== void 0) {
          const f = Lr(t, e, l, r, u);
          o += Oc(t, e, r, f, u);
          continue;
        }
        const c = l.oneOf || l.anyOf;
        if (c && u) {
          const f = Ns(l);
          o += pi(t, e, r, u, c.filter(er), -1, f);
          continue;
        }
        if (l.type === "object") {
          Be(u) && (o += 1), o += Oc(t, e, r, l, u);
          continue;
        }
        if (u !== void 0 && l.type === gi(u)) {
          o += 1;
          const f = l.default ?? l.const;
          f !== void 0 && (o += u === f ? 1 : -1);
          continue;
        }
      }
    else s !== void 0 && typeof n.type == "string" && n.type === gi(s) && (o += 1);
  }
  return o;
}
function pi(t, e, r, n, s, o = -1, i) {
  if (s.length === 0)
    return o;
  const a = s.map((_) => ks(e, _, r)), l = yy(n, s, i);
  if (typeof l == "number")
    return l;
  const u = [];
  if (n !== void 0) {
    const _ = Be(n) && i !== void 0;
    for (let b = 0; b < a.length; b++)
      by(a[b], t, n, r, _ ? i : void 0, _ ? n[i] : void 0) && u.push(b);
    if (u.length === 1)
      return u[0];
  }
  if (u.length === 0)
    for (let _ = 0; _ < a.length; _++)
      u.push(_);
  const c = /* @__PURE__ */ new Set();
  let f = 0, h = o;
  for (let _ = 0; _ < u.length; _++) {
    const b = u[_], p = a[b], g = Oc(t, e, r, p, n);
    c.add(g), g > f && (f = g, h = b);
  }
  return u.length > 1 && c.size === 1 && o >= 0 ? o : h;
}
function LO(t, e, r) {
  const n = Object.keys(t);
  let s;
  for (let o = n.length; o-- !== 0; )
    if (s = n[o], !r(t[s], e[s]))
      return !1;
  return Object.keys(e).length === n.length;
}
function jO(t, e, r) {
  const n = Object.keys(t), s = Object.keys(e);
  if (n.length !== s.length)
    return !1;
  let o;
  for (let i = n.length; i-- !== 0; )
    if (o = n[i], o !== s[i] || !r(t[o], e[o]))
      return !1;
  return !0;
}
function _y(t) {
  return function e(r, n) {
    if (r === n)
      return !0;
    if (Is(r) && Is(n)) {
      if (Array.isArray(r)) {
        if (!Array.isArray(n))
          return !1;
        const { length: s } = r;
        if (s !== n.length)
          return !1;
        for (let o = s; o-- !== 0; )
          if (!Ul(r[o], n[o]))
            return !1;
        return !0;
      }
      return Array.isArray(n) || !hi(r) || !hi(n) ? !1 : t(r, n, e);
    }
    return r !== r && n !== n;
  };
}
const Ul = _y(LO), BO = Ul, zO = _y(jO);
function Lr(t, e, r, n = {}, s, o = !1) {
  return Yr(t, e, r, n, s, void 0, void 0, o)[0];
}
function ks(t, e, r, n = /* @__PURE__ */ new Set(), s) {
  let o = e;
  const i = o[Vr];
  if (i) {
    if (n.has(i))
      return o;
    n.add(i);
    const { [Vr]: u, ...c } = o, f = xd(t, i, r);
    return ks(t, tn(c) ? f : t.mergeSchemas(f, c), r, n, s);
  }
  const a = o[Og];
  if (a) {
    const u = /* @__PURE__ */ new Map(), c = [];
    for (const [h, _] of Object.entries(a))
      if (typeof _ == "boolean")
        u.set(h, _);
      else {
        const b = new Set(n);
        u.set(h, ks(t, _, r, b, s)), c.push(b);
      }
    const f = n.size;
    for (const h of c)
      h.size !== f && h.forEach(n.add, n);
    o = {
      ...o,
      [Og]: Object.fromEntries(u)
    };
  }
  const l = o[aO];
  if (l && !Array.isArray(l) && typeof l != "boolean" && (o = {
    ...o,
    items: ks(t, l, r, n, s)
  }), s) {
    let u, c;
    so in e && Array.isArray(e[so]) ? (u = so, c = o[so]) : oo in e && Array.isArray(e[oo]) && (u = oo, c = o[oo]), u && c && (o = {
      ...o,
      [u]: c.map((f) => typeof f == "boolean" ? f : ks(t, f, r, n, s))
    });
  }
  return o;
}
function wy(t, e, r, n, s, o, i, a) {
  const l = ks(e, r, n, o, a);
  return BO(r, l) ? [r] : Yr(t, e, l, n, i, s, o, a);
}
function Yr(t, e, r, n, s, o = !1, i = /* @__PURE__ */ new Set(), a) {
  return KO(t, e, r, n, o, i, s, a).flatMap((u) => {
    let c = u;
    if (cy in c)
      return qO(t, e, c, n, o, i, s);
    const f = c.allOf;
    if (f) {
      if (o) {
        const { allOf: y, ...S } = c, x = [];
        for (let P = 0; P < f.length; P++) {
          const w = f[P];
          typeof w != "boolean" && x.push(w);
        }
        return x.push(S), x;
      }
      try {
        const y = [], S = [];
        c.allOf?.forEach((x) => {
          er(x) && x.contains ? y.push(x) : S.push(x);
        }), y.length && (c = { ...c, allOf: S }), c = e.mergeAllOf(c), y.length && (c.allOf = y);
      } catch (y) {
        console.warn(`could not merge subschemas in allOf:
`, y);
        const { allOf: S, ...x } = c;
        return x;
      }
    }
    const h = c.patternProperties, _ = h !== void 0, b = c.additionalProperties !== void 0 && c.additionalProperties !== !1;
    if (!_ && !b)
      return c;
    const p = { ...c.properties }, g = Be(s);
    if (_)
      for (const y of Object.keys(p)) {
        const S = Oy(h, y);
        S.length > 0 && (S.push(p[y]), p[y] = Lr(t, e, { allOf: S }, n, g ? s[y] : void 0));
      }
    return UO(t, e, {
      ...c,
      properties: p
    }, n, g ? s : void 0);
  });
}
function qO(t, e, r, n, s, o, i) {
  const { if: a, then: l, else: u, ...c } = r, f = a !== void 0 && t.isValid(a, n, i || {});
  let h = [c], _ = [];
  if (s)
    l && typeof l != "boolean" && (_ = _.concat(Yr(t, e, l, n, i, s, o))), u && typeof u != "boolean" && (_ = _.concat(Yr(t, e, u, n, i, s, o)));
  else {
    const b = f ? l : u;
    b && typeof b != "boolean" && (_ = _.concat(Yr(t, e, b, n, i, s, o)));
  }
  return _.length && (h = tn(c) ? _ : _.map((b) => e.mergeSchemas(c, b))), h.flatMap((b) => Yr(t, e, b, n, i, s, o));
}
function UO(t, e, r, n, s) {
  const { additionalProperties: o, patternProperties: i } = r, a = typeof o != "boolean" && o, l = o === !0 || a && Object.keys(o).length === 0;
  function u(c) {
    if (i !== void 0) {
      const f = Oy(i, c);
      if (f.length > 0)
        return {
          ...Lr(t, e, { allOf: f }, n, s?.[c])
        };
    }
    if (a) {
      if (Vr in o)
        return {
          ...Lr(t, e, { $ref: o[Vr] }, n, s)
        };
      if ("type" in o)
        return { ...o };
      if (so in o || oo in o)
        return {
          type: "object",
          ...o
        };
    }
    if (l) {
      const f = s?.[c];
      if (f !== void 0) {
        const h = gi(f);
        return mO(h) ? { type: h } : {};
      }
    }
    return { type: "null" };
  }
  if (s !== void 0)
    for (const c of Object.keys(s)) {
      if (c in r.properties)
        continue;
      const f = u(c);
      f[Bl] = !0, r.properties[c] = f;
    }
  return r;
}
function KO(t, e, r, n, s, o, i, a) {
  const l = wy(t, e, r, n, s, o, i, a);
  if (l.length > 1 || l[0] !== r)
    return l;
  if (uy in r)
    return Sy(t, e, r, n, s, o, i).flatMap((c) => Yr(t, e, c, n, i, s, o));
  if (dy in r && Array.isArray(r.allOf)) {
    const u = r.allOf.filter((f) => typeof f != "boolean").map((f) => Yr(t, e, f, n, i, s, o));
    return Py(u).map((f) => ({
      ...r,
      allOf: f
    }));
  }
  return [r];
}
function Sy(t, e, r, n, s, o, i) {
  const { dependencies: a, ...l } = r;
  return WO(t, e, l, n, s, i).flatMap((c) => xy(t, e, a, c, n, s, o, i));
}
function WO(t, e, r, n, s, o) {
  let i;
  const { oneOf: a, anyOf: l, ...u } = r;
  if (Array.isArray(a) ? i = a : Array.isArray(l) && (i = l), i) {
    const c = o === void 0 && s ? {} : o, f = Ns(r);
    i = i.map((b) => ks(e, b, n));
    const h = VO(t, c, i, n, f), _ = tn(u);
    if (s)
      return _ ? i : i.map((b) => e.mergeSchemas(u, b));
    r = _ ? i[h] : e.mergeSchemas(u, i[h]);
  }
  return [r];
}
function xy(t, e, r, n, s, o, i, a) {
  let l = [n];
  for (const u in r) {
    if (!o && (!Be(a) || a[u] === void 0) || n.properties && !(u in n.properties))
      continue;
    const { [u]: c, ...f } = r;
    return Array.isArray(c) ? l[0] = e.mergeSchemas(n, {
      required: c
    }) : typeof c != "boolean" && c && (l = HO(t, e, n, s, u, c, o, i, a)), l.flatMap((h) => xy(t, e, f, h, s, o, i, a));
  }
  return l;
}
function HO(t, e, r, n, s, o, i, a, l) {
  return Yr(t, e, o, n, l, i, a).flatMap((c) => {
    const { oneOf: f, ...h } = c, _ = tn(h) ? r : e.mergeSchemas(r, h);
    if (f === void 0)
      return _;
    const b = f.map((g) => typeof g == "boolean" || !(Vr in g) ? [g] : wy(t, e, g, n, i, a, l));
    return Py(b).flatMap((g) => GO(t, e, _, n, s, g, i, a, l));
  });
}
function GO(t, e, r, n, s, o, i, a, l) {
  const u = o.filter((c) => {
    if (typeof c == "boolean" || !c || !c.properties)
      return !1;
    const { [s]: f } = c.properties;
    if (f) {
      const h = {
        type: "object",
        properties: {
          [s]: f
        }
      };
      return t.isValid(h, n, l) || i;
    }
    return !1;
  });
  return !i && u.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [r]) : u.flatMap((c) => {
    const f = c, { [s]: h, ..._ } = f.properties, b = { ...f, properties: _ };
    return Yr(t, e, b, n, l, i, a).map((g) => e.mergeSchemas(r, g));
  });
}
function Py(t) {
  return t.reduce(
    (r, n) => n.length > 1 ? n.flatMap((s) => dO(r.length, (o) => [...r[o]].concat(s))) : (r.forEach((s) => s.push(n[0])), r),
    [[]]
    // Start with an empty list
  );
}
function Oy(t, e) {
  const r = [];
  for (const [n, s] of Object.entries(t))
    new RegExp(n).test(e) && r.push(s);
  return r;
}
function Pd(t) {
  return t.const !== void 0 || Array.isArray(t.enum) && t.enum.length === 1;
}
function Cy(t) {
  const e = t.enum;
  if (Array.isArray(e) && e.length === 1)
    return e[0];
  const r = t.const;
  if (r !== void 0)
    return r;
  throw new Error("schema cannot be inferred as a constant");
}
function Od(t, e, r, n) {
  const s = Lr(t, e, r, n);
  if (Array.isArray(s.enum))
    return !0;
  const o = s.oneOf || s.anyOf;
  return Array.isArray(o) ? o.every((i) => typeof i != "boolean" && Pd(i)) : !1;
}
function YO({ enum: t, oneOf: e, anyOf: r }) {
  if (t !== void 0)
    return t;
  const n = e ?? r;
  if (n !== void 0)
    return n.map((s, o) => {
      if (!er(s))
        throw new Error(`Invalid enum definition in altSchema.${o}`);
      return Cy(s);
    });
}
function ky(t, e, { items: r, uniqueItems: n }, s) {
  return n === !0 && Be(r) && Od(t, e, r, s);
}
function $y(t) {
  const { items: e } = t;
  return Array.isArray(e) && e.length > 0 && e.every(Be);
}
function Ng(t) {
  return t == null;
}
function mi(t, e, r = !1, n = !1, s = !1) {
  if (Array.isArray(e)) {
    const o = Array.isArray(t) ? t : [], i = s ? o : e, a = s ? e : o, l = i.map((u, c) => a[c] !== void 0 ? mi(o[c], e[c], r, n, s) : u);
    return (r || s) && l.length < a.length && l.push(...a.slice(l.length)), l;
  }
  if (Be(e)) {
    const o = Object.assign({}, t), i = Be(t) ? t : {};
    for (const [a, l] of Object.entries(e)) {
      const u = a in i, c = i[a];
      if (Be(c) && Be(l) && !Object.values(c).some(Be)) {
        o[a] = {
          ...c,
          ...l
        };
        continue;
      }
      o[a] = mi(
        i[a],
        l,
        r,
        n,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        // CHANGED: key is always in form data, maybe this condition should be value === undefined
        // overrideFormDataWithDefaults &&
        //   (keyExistsInDefaults || !keyExistsInFormData)
        s && u
      );
    }
    return o;
  }
  return n && (t !== void 0 && Ng(e) || typeof e == "number" && isNaN(e)) || s && !Ng(e) ? t : e;
}
function Ay(t, e, r = !1) {
  const n = Object.assign({}, t);
  for (const [s, o] of Object.entries(e)) {
    const i = t ? t[s] : {};
    Be(i) && Be(o) ? n[s] = Ay(i, o, r) : r && Array.isArray(i) && Array.isArray(o) ? n[s] = i.concat(r === "preventDuplicates" ? o.filter((a) => !i.includes(a)) : o) : n[s] = o;
  }
  return n;
}
function Ey(t) {
  switch (t) {
    case "array":
      return [];
    case "object":
      return {};
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "null":
      return null;
    default:
      return;
  }
}
function XO(t, e, r, n = void 0, s = {}, o = !1, i = {}, a = !1) {
  const l = Lr(t, e, r, s, n), u = Gn(t, e, l, {
    rootSchema: s,
    includeUndefinedValues: o,
    experimental_defaultFormStateBehavior: i,
    rawFormData: n,
    parentDefaults: void 0,
    // CHANGED: We use `required: true` at the root instead of `requiredAsRoot`
    required: !0,
    isSchemaRoot: !0,
    stack: /* @__PURE__ */ new Set(),
    shouldMergeDefaultsIntoFormData: !0,
    initialDefaultsGenerated: a
  });
  if (l.type !== "object" && Be(l.default) && // CHANGED: Added those conditions for typesafety, while original intentions is unknown
  (u === void 0 || typeof u == "object") && (n === void 0 || typeof n == "object"))
    return {
      ...u,
      ...n
    };
  if (Be(n) || Array.isArray(n)) {
    const { mergeDefaultsIntoFormData: c } = i || {};
    return mi(
      u,
      n,
      !0,
      c === "useDefaultIfFormDataUndefined",
      !0
      // set to true to override formData with defaults if they exist.
    );
  }
  return u;
}
function Gn(t, e, r, n) {
  const { parentDefaults: s, rawFormData: o, rootSchema: i, includeUndefinedValues: a, stack: l, experimental_defaultFormStateBehavior: u, required: c, isSchemaRoot: f, shouldMergeDefaultsIntoFormData: h, initialDefaultsGenerated: _ } = n, b = Be(o), p = b ? o : {}, g = Be(r) ? r : {};
  let y = s, S = null, x = p, P = u, w = l;
  const { default: C, $ref: k, oneOf: $, anyOf: T, allOf: E } = g;
  if (Pd(g) && u.constAsDefaults !== "never")
    y = g.const ?? g.enum?.[0];
  else if (Be(y) && Be(C) && !T && !$ && !k)
    y = Ay(y, C);
  else if (C !== void 0 && $ === void 0 && T === void 0 && k === void 0)
    y = C;
  else if (k !== void 0) {
    l.has(k) || (w = new Set(l).add(k), S = xd(e, k, i));
    const F = tn(p);
    S && y === void 0 && F && (y = C), h && S && !b && (x = o);
  } else if (uy in g) {
    const F = {
      ...Dy(t, e, g, {
        ...n,
        rawFormData: p
      }, y),
      ...p
    };
    S = Sy(t, e, g, i, !1, /* @__PURE__ */ new Set(), F)[0];
  } else if ($y(g))
    y = g.items.map((F, U) => Gn(t, e, F, {
      rootSchema: i,
      includeUndefinedValues: a,
      stack: l,
      experimental_defaultFormStateBehavior: u,
      parentDefaults: Array.isArray(s) ? s[U] : void 0,
      rawFormData: p,
      required: c,
      isSchemaRoot: !1,
      shouldMergeDefaultsIntoFormData: h,
      // CHANGED: this property is not provided in the original code
      initialDefaultsGenerated: _
    }));
  else if ($ !== void 0) {
    const { oneOf: F, ...U } = g;
    if ($.length === 0)
      return;
    const B = ql(g);
    (Array.isArray(B) ? B.every(Dg) : Dg(B)) && P?.constAsDefaults === "skipOneOf" && (P = {
      ...P,
      constAsDefaults: "never"
    });
    const R = $[pi(t, e, i, o ?? C, $.filter(er), 0, Ns(g))];
    if (typeof R == "boolean")
      return;
    S = tn(U) ? R : e.mergeSchemas(U, R);
  } else if (T !== void 0) {
    const { anyOf: F, ...U } = g;
    if (T.length === 0)
      return;
    const B = T[pi(t, e, i, o ?? C, T.filter(er), 0, Ns(g))];
    if (typeof B == "boolean")
      return;
    S = tn(U) ? B : e.mergeSchemas(U, B);
  }
  if (S)
    return Gn(t, e, S, {
      isSchemaRoot: f,
      rootSchema: i,
      includeUndefinedValues: a,
      stack: w,
      experimental_defaultFormStateBehavior: P,
      parentDefaults: y,
      rawFormData: o ?? x,
      required: c,
      shouldMergeDefaultsIntoFormData: h,
      initialDefaultsGenerated: _
    });
  y === void 0 && (y = g.default);
  let I = ZO(t, e, g, n, y) ?? y;
  if (h) {
    const { arrayMinItems: F = {} } = u || {}, { mergeExtraDefaults: U } = F, B = JO(t, e, g, i, o, u);
    (!Be(o) || E !== void 0) && (I = mi(I, B, U, !0));
  }
  return I;
}
function JO(t, e, r, n, s, o) {
  let i = s;
  return s !== void 0 && !Pd(r) && Od(t, e, r, n) && (i = YO(r)?.some((f) => Ul(f, s)) ? s : void 0), r.const !== void 0 && o?.constAsDefaults === "always" && (i = r.const), i;
}
function Ty(t, e) {
  const { default: r, type: n } = t;
  return Array.isArray(n) && n.includes("null") && Pc(e) && r === null ? null : e;
}
function Fg(t, e, r, n, s, o, i, a, l, u) {
  const { emptyObjectFields: c = "populateAllDefaults" } = u;
  if (n === !0 || s)
    t.set(e, r);
  else if (n === "excludeObjectChildren")
    (o && r !== void 0 || (Array.isArray(r) ? r.length > 0 : !Is(r) || !tn(r))) && t.set(e, r);
  else if (c !== "skipDefaults") {
    const f = i ? l.has(e) : a;
    Be(r) ? c === "skipEmptyDefaults" ? Pc(r) || t.set(e, r) : (!Pc(r) || l.has(e)) && (f || c !== "populateRequiredDefaults") && t.set(e, r) : (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field
      r !== void 0 && (c === "populateAllDefaults" || c === "skipEmptyDefaults" || f && l.has(e)) && t.set(e, r)
    );
  }
}
var mo;
(function(t) {
  t[t.Ignore = 0] = "Ignore", t[t.Invert = 1] = "Invert", t[t.Fallback = 2] = "Fallback";
})(mo || (mo = {}));
function Mu(t, e = mo.Ignore, r = -1) {
  if (r >= 0) {
    if (Array.isArray(t.items) && r < t.items.length) {
      const n = t.items[r];
      if (typeof n != "boolean")
        return n;
    }
  } else if (t.items && !Array.isArray(t.items) && typeof t.items != "boolean")
    return t.items;
  return e !== mo.Ignore && Be(t.additionalItems) ? t.additionalItems : {};
}
function ZO(t, e, r, n, s) {
  switch (po(r)) {
    // We need to recurse for object schema inner default values.
    case "object": {
      const { rawFormData: o } = n;
      return Dy(t, e, r, {
        ...n,
        rawFormData: Be(o) ? o : {}
      }, s);
    }
    case "array":
      return QO(t, e, r, n, Array.isArray(s) ? s : void 0);
    default:
      return;
  }
}
function Dy(t, e, r, { rootSchema: n, includeUndefinedValues: s, stack: o, experimental_defaultFormStateBehavior: i, required: a, isSchemaRoot: l, rawFormData: u, shouldMergeDefaultsIntoFormData: c, initialDefaultsGenerated: f }, h) {
  const b = i?.allOf === "populateDefaults" && dy in r || i?.emptyObjectFields !== "skipEmptyDefaults" && cy in r ? Lr(t, e, r, n, u) : r, p = new Set(b.required), g = Be(b.const) ? b.const : {}, y = /* @__PURE__ */ new Map(), S = b.properties, x = Be(h) ? h : void 0, P = Be(u) ? u : void 0;
  if (S !== void 0)
    for (const [C, k] of Object.entries(S)) {
      if (typeof k == "boolean")
        continue;
      const $ = Gn(t, e, k, {
        rootSchema: n,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        includeUndefinedValues: s === !0,
        parentDefaults: x?.[C],
        rawFormData: P?.[C],
        required: p.has(C),
        isSchemaRoot: !1,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      }), T = (k.const !== void 0 || g[C] !== void 0) && i.constAsDefaults !== "never";
      Fg(y, C, $, s, T, k.type === "null", l, a, new Set(b.required), i);
    }
  const w = b.additionalProperties;
  if (w !== void 0 && !f) {
    let C = new Set(Be(h) ? S === void 0 ? Object.keys(h) : Object.keys(h).filter((E) => !(E in S)) : void 0);
    const k = Object.keys(u), $ = new Set(S === void 0 ? k : k.filter((E) => !(E in S)));
    C = C.union($);
    const T = typeof w == "boolean" ? {} : w;
    C.forEach((E) => {
      const I = Gn(t, e, T, {
        rootSchema: n,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        includeUndefinedValues: s === !0,
        parentDefaults: x?.[E],
        rawFormData: P?.[E],
        required: p.has(E),
        isSchemaRoot: l,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      });
      Fg(y, E, I, s, !1, !1, l, a, $, {});
    });
  }
  return Ty(r, Object.fromEntries(y));
}
function QO(t, e, r, { rawFormData: n, rootSchema: s, stack: o, experimental_defaultFormStateBehavior: i, required: a, shouldMergeDefaultsIntoFormData: l, initialDefaultsGenerated: u }, c) {
  const { populate: f, mergeExtraDefaults: h, computeSkipPopulate: _ = () => !1 } = i?.arrayMinItems ?? {}, b = f === "never", p = f === "requiredOnly", g = f === "all" || !b && !p, S = i?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
  if (c !== void 0 && (c = c.map((w, C) => {
    const k = Mu(r, mo.Fallback, C), $ = Array.isArray(n) ? n[C] : void 0;
    return Gn(t, e, k, {
      rootSchema: s,
      stack: o,
      experimental_defaultFormStateBehavior: i,
      parentDefaults: w,
      required: a,
      includeUndefinedValues: !1,
      rawFormData: $,
      isSchemaRoot: !1,
      shouldMergeDefaultsIntoFormData: l,
      initialDefaultsGenerated: u
    });
  })), Array.isArray(n)) {
    const w = Mu(r);
    if (b)
      c = n;
    else {
      const C = n.map(($, T) => Gn(t, e, w, {
        rootSchema: s,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        rawFormData: $,
        parentDefaults: c?.[T],
        required: a,
        includeUndefinedValues: !1,
        isSchemaRoot: !1,
        shouldMergeDefaultsIntoFormData: l,
        initialDefaultsGenerated: u
      }));
      c = mi(c, C, (p && a || g) && h === !0);
    }
  }
  if (r.const === void 0 || i.constAsDefaults === "never") {
    if (b)
      return c ?? S;
    if (p && !a)
      return c;
  }
  let x;
  const P = c?.length ?? 0;
  if (!r.minItems || ky(t, e, r, s) || _(t, r, s) || r.minItems <= P)
    x = c || !a ? c : S;
  else {
    const w = Mu(r, mo.Invert), C = w.default, k = Array.from({ length: r.minItems - P }, () => Gn(t, e, w, {
      parentDefaults: C,
      rootSchema: s,
      stack: o,
      experimental_defaultFormStateBehavior: i,
      includeUndefinedValues: !1,
      rawFormData: void 0,
      isSchemaRoot: !1,
      required: a,
      shouldMergeDefaultsIntoFormData: l,
      initialDefaultsGenerated: u
    }));
    x = P ? c.concat(k) : k;
  }
  return Ty(r, x);
}
const eC = (t) => t.length > 1 ? `properties '${t.join("', '")}'` : `property '${t[0]}'`;
function tC(t, e) {
  const r = Object.keys(t);
  if (e === void 0)
    return r;
  const n = e.filter((a) => a === "*" || t[a]), s = new Set(n), o = r.filter((a) => !s.has(a)), i = n.indexOf("*");
  if (i === -1) {
    if (o.length)
      throw new Error(`uiSchema order list does not contain ${eC(o)}`);
    return n;
  }
  if (i !== n.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  return n.splice(i, 1, ...o), n;
}
function rC(t, e) {
  const r = t[e];
  return typeof r == "boolean" || !r ? !1 : Bl in r;
}
function My({ type: t, format: e }) {
  return t === "string" && e === fy;
}
function nC(t, e, r, n) {
  const { items: s } = r;
  if (cO(s)) {
    const o = Lr(t, e, s, n);
    return My(o);
  }
  return !1;
}
function sC(t, e) {
  return (Be(t.additionalProperties) || t.patternProperties !== void 0) && Be(e) && (t.maxProperties === void 0 || Object.keys(e).length < t.maxProperties);
}
const qn = /* @__PURE__ */ Symbol("no Value");
function Wi(t, e, r, n, s) {
  return r[Vr] !== void 0 ? Lr(t, e, r, n, s) : r;
}
function oC(t, e, r, n, s, o, i) {
  const a = e.type, l = r.type;
  if (!a || a === l) {
    const u = t.maxItems ?? -1;
    return l === "object" ? i.reduce((c, f) => {
      const h = Cd(n, s, o, r, e, f);
      return h !== void 0 && (u < 0 || c.length < u) && c.push(h), c;
    }, []) : u > 0 && i.length > u ? i.slice(0, u) : i;
  }
  return qn;
}
function Cd(t, e, r, n, s, o) {
  let i;
  const a = n.properties, l = Be(o);
  if (a !== void 0) {
    const u = {}, c = s.properties;
    c !== void 0 && l && Object.keys(c).forEach((_) => {
      _ in o && (u[_] = void 0);
    });
    const f = Object.keys(a), h = {};
    f.forEach((_) => {
      const b = l ? o[_] : void 0, p = c?.[_];
      let g = typeof p == "object" ? p : {};
      const y = a?.[_];
      let S = typeof y == "object" ? y : {};
      g = Wi(t, e, g, r, b), S = Wi(t, e, S, r, b);
      const x = g.type, P = S.type;
      if (!x || x === P)
        if (_ in u && delete u[_], P === "object" || P === "array" && Array.isArray(b)) {
          const w = Cd(t, e, r, S, g, b);
          (w !== void 0 || P === "array") && (h[_] = w);
        } else {
          const w = S.default ?? qn, C = g.default ?? qn;
          w !== qn && w !== b && (C === b ? u[_] = w : S.readOnly === !0 && (u[_] = void 0));
          const k = S.const ?? qn, $ = g.const ?? qn;
          k !== qn && k !== b && (u[_] = $ === b ? k : void 0);
        }
    }), i = {
      ...l ? o : void 0,
      ...u,
      ...h
    };
  } else if (s.type === "array" && n.type === "array" && Array.isArray(o)) {
    const u = s.items, c = n.items;
    if (Be(u) && Be(c)) {
      const f = oC(n, Wi(t, e, u, r, o), Wi(t, e, c, r, o), t, e, r, o);
      f !== qn && (i = f);
    } else typeof u == "boolean" && typeof c == "boolean" && u === c && (i = o);
  }
  return i;
}
function iC(t, e) {
  return Ka(t, (r) => {
    if (!er(r))
      return r;
    const n = r[Vr];
    return n !== void 0 && n.startsWith("#") && (r[Vr] = `${e}${n}`), r;
  });
}
function aC(t) {
  return t.split("/").slice(1).map((e) => e.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function lC(t, e) {
  const r = [];
  if (t === "")
    return r;
  const n = aC(t);
  let s = e;
  for (const o of n)
    if (Array.isArray(s) && /^\d+$/.test(o)) {
      const i = Number(o);
      r.push(i), s = s[i];
    } else
      r.push(o), s = s?.[o];
  return r;
}
function Rg(t, e, r, n, s, o) {
  function i(l, u, c, f) {
    const h = l.map((g) => typeof g == "boolean" ? g ? {} : { not: {} } : g), _ = pi(t, e, r, f, h, -1, Ns(u)), b = a(h[_], c, f);
    if (b !== void 0)
      return b;
    let p;
    for (const g of h) {
      if (!er(g))
        continue;
      const y = a(g, c, f);
      if (y !== void 0) {
        if (er(y))
          return y;
        p = y;
      }
    }
    return p;
  }
  function a(l, u, c) {
    for (let f = 0; f < u.length; f++) {
      if (l === void 0 || !er(l))
        return;
      if (l.$ref)
        return a(vy(l.$ref, r), u.slice(f), c);
      if (l.allOf) {
        const p = e.mergeAllOf(l);
        if (!p.allOf)
          return a(p, u.slice(f), c);
      }
      const h = l.anyOf ?? l.oneOf ?? l.allOf;
      if (h) {
        const p = i(h, l, u.slice(f), c);
        if (p !== void 0)
          return p;
      }
      const _ = u[f], b = typeof _;
      if (b === "number") {
        const { items: p, additionalItems: g } = l;
        l = (Array.isArray(p) ? p[_] : p) ?? g, c = IO(c) ? c[_] : void 0;
        continue;
      }
      if (b === "string") {
        const { properties: p, patternProperties: g, additionalProperties: y, dependencies: S, then: x, else: P } = l;
        l = (p && p[_]) ?? (g && Object.entries(g).find(([w]) => new RegExp(w).test(_))?.[1]) ?? y ?? (S && i(Object.values(S).filter(xc), l, u.slice(f), c)) ?? ((x || P) && i([x, P].filter(xc), l, u.slice(f), c)), c = Be(c) ? c[_] : void 0;
        continue;
      }
      return;
    }
    return l;
  }
  return a(n, s, o);
}
const uC = [!0, !1];
function Iu(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function cC(t) {
  return typeof t?.$ref == "string";
}
function nl(t, e) {
  return cC(e) ? t["ui:definitions"]?.[e.$ref] : e;
}
function dC(t, e, r, n) {
  const s = r["ui:options"], o = s && n in s ? s[n] : t["ui:globalOptions"]?.[n];
  return typeof o == "string" && o.startsWith("registry:") ? e[o.substring(9)] : o;
}
function kd(t, e, r) {
  let n = nl(t, e);
  for (let s = 0; s < r.length; s++) {
    if (n === void 0)
      return;
    const o = n.anyOf ?? n.oneOf;
    if (o) {
      let c;
      const f = r.slice(s);
      for (const h of o)
        if (c = kd(t, h, f), c !== void 0)
          return c;
    }
    const i = r[s], { items: a, additionalItems: l, additionalProperties: u } = n;
    n = nl(t, n[i] ?? (Array.isArray(a) ? a[i] : a) ?? u ?? l);
  }
  return n;
}
function fC(t, e) {
  return kd(t, t, e)?.["ui:options"]?.title;
}
class $d extends Map {
  /** @type {Map<K, Source<number>>} */
  #e = /* @__PURE__ */ new Map();
  #t = /* @__PURE__ */ xe(0);
  #r = /* @__PURE__ */ xe(0);
  #n = On || -1;
  /**
   * @param {Iterable<readonly [K, V]> | null | undefined} [value]
   */
  constructor(e) {
    if (super(), e) {
      for (var [r, n] of e)
        super.set(r, n);
      this.#r.v = super.size;
    }
  }
  /**
   * If the source is being created inside the same reaction as the SvelteMap instance,
   * we use `state` so that it will not be a dependency of the reaction. Otherwise we
   * use `source` so it will be.
   *
   * @template T
   * @param {T} value
   * @returns {Source<T>}
   */
  #s(e) {
    return On === this.#n ? /* @__PURE__ */ xe(e) : Jn(e);
  }
  /** @param {K} key */
  has(e) {
    var r = this.#e, n = r.get(e);
    if (n === void 0) {
      var s = super.get(e);
      if (s !== void 0)
        n = this.#s(0), r.set(e, n);
      else
        return d(this.#t), !1;
    }
    return d(n), !0;
  }
  /**
   * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn
   * @param {any} [this_arg]
   */
  forEach(e, r) {
    this.#o(), super.forEach(e, r);
  }
  /** @param {K} key */
  get(e) {
    var r = this.#e, n = r.get(e);
    if (n === void 0) {
      var s = super.get(e);
      if (s !== void 0)
        n = this.#s(0), r.set(e, n);
      else {
        d(this.#t);
        return;
      }
    }
    return d(n), super.get(e);
  }
  /**
   * @param {K} key
   * @param {V} value
   * */
  set(e, r) {
    var n = this.#e, s = n.get(e), o = super.get(e), i = super.set(e, r), a = this.#t;
    if (s === void 0)
      s = this.#s(0), n.set(e, s), q(this.#r, super.size), Hr(a);
    else if (o !== r) {
      Hr(s);
      var l = a.reactions === null ? null : new Set(a.reactions), u = l === null || !s.reactions?.every(
        (c) => (
          /** @type {NonNullable<typeof v_reactions>} */
          l.has(c)
        )
      );
      u && Hr(a);
    }
    return i;
  }
  /** @param {K} key */
  delete(e) {
    var r = this.#e, n = r.get(e), s = super.delete(e);
    return n !== void 0 && (r.delete(e), q(this.#r, super.size), q(n, -1), Hr(this.#t)), s;
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var e = this.#e;
      q(this.#r, 0);
      for (var r of e.values())
        q(r, -1);
      Hr(this.#t), e.clear();
    }
  }
  #o() {
    d(this.#t);
    var e = this.#e;
    if (this.#r.v !== e.size) {
      for (var r of super.keys())
        if (!e.has(r)) {
          var n = this.#s(0);
          e.set(r, n);
        }
    }
    for ([, n] of this.#e)
      d(n);
  }
  keys() {
    return d(this.#t), super.keys();
  }
  values() {
    return this.#o(), super.values();
  }
  entries() {
    return this.#o(), super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return d(this.#r), super.size;
  }
}
class Kl {
}
let us = 0;
const hC = 1 << us++, gC = 1 << us++, pC = 1 << us++, mC = 1 << us++, vC = 1 << us++, yC = 1 << us++, bC = 1 << us++, Ad = 1 << us++;
let Ao = 0;
const _C = 1 << Ao++, wC = 1 << Ao++, sl = 1 << Ao++, Vg = 1 << Ao++, Lg = 1 << Ao++;
(1 << Ao++) - 1;
function SC(t) {
  return "validateFieldValue" in t;
}
function xC(t) {
  return "validateFieldValueAsync" in t;
}
function PC(t) {
  return "validateAdditionalPropertyKey" in t;
}
function OC(t) {
  return "validateFileListAsync" in t;
}
const jg = "__sjsf_id_prefix", Iy = "root", Ed = "__sjsf_pseudo_element", Nu = Ed.length, Cc = "S", kc = "N";
function Td(t) {
  return `${Ed}${typeof t == "string" ? Cc : kc}${t}`;
}
function CC(t) {
  if (typeof t != "string" || !t.startsWith(Ed))
    return;
  const e = t.substring(Nu + 1);
  switch (t[Nu]) {
    case Cc:
      return e;
    case kc:
      return Number(e);
    default:
      throw new Error(`Unexpected pseudo element suffix "${t[Nu]}", expected "${Cc}" or "${kc}"`);
  }
}
function Ny(t) {
  return (e, r) => {
    const n = t(e, r);
    return n === void 0 ? `Label "${e}" is not translated` : typeof n == "string" ? n : n(r);
  };
}
function Fy(t, e, r, n = 0) {
  return t === void 0 && (t = {
    values: /* @__PURE__ */ new Map(),
    value: void 0
  }), e.length === n ? t.value = r : t.values.set(e[n], Fy(t.values.get(e[n]), e, r, n + 1)), t;
}
function Ry(t, e) {
  let r = 0;
  for (; t !== void 0 && r < e.length; )
    t = t.values.get(e[r++]);
  return t;
}
const Vy = /* @__PURE__ */ Symbol("form-context"), Kn = /* @__PURE__ */ Symbol("form-value"), Ly = /* @__PURE__ */ Symbol("form-id-prefix"), Ks = /* @__PURE__ */ Symbol("form-errors"), jy = /* @__PURE__ */ Symbol("form-id-from-path"), Wl = /* @__PURE__ */ Symbol("form-paths-trie-ref"), By = /* @__PURE__ */ Symbol("form-mark-schema-change"), $c = /* @__PURE__ */ Symbol("form-keyed-arrays"), Dd = /* @__PURE__ */ Symbol("form-fields-validation-mode"), Zt = /* @__PURE__ */ Symbol("form-schema"), Ac = /* @__PURE__ */ Symbol("form-retrieved-schema"), Hl = /* @__PURE__ */ Symbol("form-root-path"), Gl = /* @__PURE__ */ Symbol("form-ui-schema-root"), vo = /* @__PURE__ */ Symbol("form-ui-schema"), zy = /* @__PURE__ */ Symbol("form-ui-options-registry"), Eo = /* @__PURE__ */ Symbol("form-ui-extra-options"), jr = /* @__PURE__ */ Symbol("form-validator"), sn = /* @__PURE__ */ Symbol("form-merger"), qy = /* @__PURE__ */ Symbol("form-icons"), Uy = /* @__PURE__ */ Symbol("form-disabled"), Ky = /* @__PURE__ */ Symbol("form-data-url-to-blob"), Wy = /* @__PURE__ */ Symbol("form-translation"), Ec = /* @__PURE__ */ Symbol("form-translate"), Hy = /* @__PURE__ */ Symbol("form-resolver"), Tc = /* @__PURE__ */ Symbol("form-theme"), vi = /* @__PURE__ */ Symbol("form-fields-state-map");
function Yl(t, e) {
  const r = e, n = Ry(t.current, e);
  if (n === void 0)
    t.current = Fy(t.current, e, r);
  else {
    const s = n.value;
    if (s !== void 0)
      return s;
    n.value = r;
  }
  return r;
}
function kC(t, e, r) {
  return ((t.get(e) ?? 0) & r) > 0;
}
class $C {
  ref;
  #e = new $d();
  constructor(e) {
    this.ref = e;
  }
  assign(e) {
    this.#e.clear();
    for (const r of e) {
      let n = r[1];
      const s = new Set(n);
      n.length > s.size && (n = Array.from(s)), this.#e.set(r[0], {
        set: s,
        array: n
      });
    }
    return this;
  }
  updateErrors(e) {
    this.#e.clear();
    for (const { path: r, message: n } of e) {
      const s = Yl(this.ref, r), o = this.#e.get(s);
      if (o) {
        const i = o.set.size;
        o.set.add(n), i < o.set.size && o.array.push(n);
      } else {
        const i = [n];
        this.#e.set(s, {
          set: new Set(i),
          array: i
        });
      }
    }
    return this;
  }
  getFieldErrors(e) {
    return this.#e.get(e)?.array;
  }
  updateFieldErrors(e, r) {
    if (typeof r == "function") {
      const n = this.#e.get(e)?.array ?? [];
      r = r(n);
    }
    if (r.length > 0) {
      const n = new Set(r);
      this.#e.set(e, {
        set: n,
        array: r.length > n.size ? Array.from(n) : r
      });
    } else
      this.#e.delete(e);
    return r.length === 0;
  }
  hasErrors() {
    return this.#e.size > 0;
  }
  clear() {
    this.#e.clear();
  }
  *[Symbol.iterator]() {
    for (const e of this.#e)
      yield [e[0], e[1].array];
  }
}
function Ee() {
  return Ms(Vy);
}
function Gy(t) {
  Oo(Vy, t);
}
function mr(t, e) {
  return t[jy](e);
}
function Yy(t, e) {
  return Yl(t[Wl], e);
}
function* Xy(t) {
  t.value !== void 0 && (yield t.value);
  for (const e of t.values.values())
    yield* Xy(e);
}
function* Jy(t, e) {
  const r = t[Wl].current, n = Ry(r, e);
  n !== void 0 && (yield* Xy(n));
}
function Xl(t, e, r) {
  return Yy(t, e.concat(r));
}
function Mi(t, e, r) {
  return Xl(t, e, Td(r));
}
function Fs(t, e, r) {
  return mr(t, Mi(t, e, r));
}
function Bg(t, e) {
  return mr(t, Yy(t, e));
}
function AC(t, e) {
  return Od(t[jr], t[sn], e, t[Zt]);
}
function EC(t, e) {
  return ky(t[jr], t[sn], e, t[Zt]);
}
function TC(t, e) {
  return nC(t[jr], t[sn], e, t[Zt]);
}
function Tr(t, e, r, n) {
  return Lr(t[jr], t[sn], e, t[Zt], r, n);
}
function DC(t, e, r, n) {
  return Cd(t[jr], t[sn], t[Zt], e, r, n);
}
function MC(t, e, r, n, s) {
  return pi(t[jr], t[sn], t[Zt], e, r, n, s);
}
function Md(t, e) {
  return t[sn].mergeFormDataAndSchemaDefaults(e);
}
function IC(t) {
  t[By]();
}
function Zy(t, e) {
  return (r, n) => t(r, n) ?? e(r, n);
}
function Ii(t) {
  return (e) => t[e];
}
function zg(t, e) {
  return Zy(Ii(e), t);
}
function Qy(t, e) {
  return Zy(t, Ii(e));
}
function Yn(t, e) {
  return nl(t[Gl], e) ?? {};
}
function To(t, e, r) {
  return dC(t[Gl], t[zy], e, r);
}
function Xr(t, e) {
  return To(t, e, "title");
}
function Nt(t, e, r) {
  return t[Eo]?.(r, e) ?? To(t, e.uiSchema, r);
}
function NC(t, e, r, n) {
  const s = t[Eo]?.(r, e);
  if (s) {
    const i = n(s);
    if (i !== void 0)
      return i;
  }
  const o = To(t, e.uiSchema, r);
  if (o !== void 0)
    return n(o);
}
function St(t) {
  return (e, r, n) => Object.assign(e, To(n, r.uiSchema, t), n[Eo]?.(t, r));
}
function eb(t, e) {
  return (r, n, s) => {
    const o = To(s, n.uiSchema, t), i = s[Eo]?.(t, n);
    return Object.assign(r, o && e(o), i && e(i));
  };
}
function Rs(t, e) {
  let r = t[Wy];
  const n = To(t, e.uiSchema, "translations");
  r = n ? zg(r, n) : r;
  const s = t[Eo]?.("translations", e);
  return r = s ? zg(r, s) : r, Ny(r);
}
function vr(t, e, r) {
  const n = NC(t, e, "actions", (s) => s[r]);
  return n !== void 0 ? n : Nt(t, e, "action");
}
const FC = [];
function kt(t, e) {
  return t[Ks].getFieldErrors(e) ?? FC;
}
function tb(t, e) {
  const r = [];
  for (const n of e) {
    const s = t[Ks].getFieldErrors(n);
    if (s)
      for (let o = 0; o < s.length; o++)
        r.push(s[o]);
  }
  return r;
}
function RC(t, e) {
  ot(() => {
    t[Ks].updateErrors(e);
  });
}
function ci(t, e, r) {
  return ot(() => t[Ks].updateFieldErrors(e, r));
}
function rb(t) {
  return t[Dd];
}
function Cr(t, e, r) {
  t.fieldsValidation.run(e, r);
}
function VC(t, e, r, n) {
  return ot(() => {
    const s = t[jr];
    if (!PC(s))
      return !0;
    const o = s.validateAdditionalPropertyKey(r, e.schema);
    return ci(t, n.path, o);
  });
}
async function Jl(t, e, r, n) {
  const s = await ot(() => {
    const o = e[jr];
    return OC(o) ? o.validateFileListAsync(t, n, r) : !0;
  });
  return s === !0 || ci(e, r.path, s);
}
function $s(t, e, r) {
  const n = t[vi].get(e) ?? 0;
  t[vi].set(e, n | r);
}
const LC = [];
function un(t, e, r) {
  const n = /* @__PURE__ */ O(() => e().path);
  $o(() => {
    const c = d(n);
    return () => {
      t[vi].delete(c), t[Ks].updateFieldErrors(c, LC);
    };
  });
  const s = /* @__PURE__ */ O(() => t[Dd]), o = /* @__PURE__ */ O(() => t[vi].get(d(n)) ?? 0), i = (c) => {
    if (!(!(d(s) & c) || d(s) & Ad && !t.isSubmitted || d(s) & yC && !(d(o) & sl) || d(s) & bC && !(d(o) & Vg)))
      return r;
  }, a = /* @__PURE__ */ O(() => i(hC)), l = /* @__PURE__ */ O(() => i(gC)), u = /* @__PURE__ */ O(() => i(pC));
  return {
    onfocus() {
      $s(t, d(n), _C);
    },
    oninput() {
      $s(t, d(n), wC), d(a)?.();
    },
    onchange() {
      $s(t, d(n), sl), d(l)?.();
    },
    onblur() {
      $s(t, d(n), Vg), d(u)?.();
    }
  };
}
const jC = /* @__PURE__ */ new WeakMap(), cn = zl(jC, (t) => {
  const e = ey(), r = (n) => {
    const s = t.onfocus && Ye(n, "focus", t.onfocus), o = t.oninput && Ye(n, "input", t.oninput), i = t.onchange && Ye(n, "change", t.onchange), a = t.onblur && Ye(n, "blur", t.onblur);
    return () => {
      s?.(), o?.(), i?.(), a?.();
    };
  };
  return (n) => (n[e] = r, n);
});
function Ft(t, e, r, ...n) {
  for (let s = 0; s < n.length; s++)
    r = n[s](r, e, t);
  return r;
}
function BC(t) {
  return (e) => Object.assign(e, t);
}
function Do(t, e, r) {
  return t.disabled ||= r[Uy], t;
}
const nb = [
  "description",
  "help",
  "errors"
], zC = nb.concat("examples");
function Ws(t, e, r) {
  return t["aria-invalid"] = r[Ks].getFieldErrors(e.path) !== void 0, t;
}
function Id(t, e, r) {
  return t["aria-describedby"] = (Array.isArray(e.schema.examples) ? zC : nb).map((n) => Fs(r, e.path, n)).join(" "), t;
}
function qC(t, e, r) {
  return t["aria-readonly"] = e.schema.readOnly, t;
}
function UC(t, e, r) {
  return t["aria-required"] = e.required, t;
}
function KC(t) {
  switch (t) {
    case "date-time":
      return "datetime-local";
    case "uri":
      return "url";
    case "color":
    case "date":
    case "time":
    case "email":
      return t;
    default:
      return;
  }
}
function WC(t, e, r) {
  const { required: n, schema: s, path: o } = e, i = mr(r, o);
  t.id = i, t.name = i;
  const a = KC(s.format);
  return a !== void 0 && (t.type = a), t.required = n, t.minlength = s.minLength, t.maxlength = s.maxLength, t.pattern = s.pattern, t.min = s.minimum, t.max = s.maximum, t.step = s.multipleOf ?? (s.type === "number" ? "any" : void 0), t.list = Array.isArray(s.examples) ? Fs(r, e.path, "examples") : void 0, t.readonly = s.readOnly, t;
}
function HC(t, e, r) {
  const { path: n, required: s, schema: o } = e, i = mr(r, n);
  return t.id = i, t.name = i, t.required = s, t.minlength = o.minLength, t.maxlength = o.maxLength, t.readonly = o.readOnly, t;
}
function GC(t, e, r) {
  return t.for = mr(r, e.path), t;
}
function Zl(t) {
  return (e, r, n) => (e.id = Fs(n, r.path, t), e);
}
function YC(t) {
  return (e) => (e.tabindex = t, e);
}
function XC(t) {
  return (e) => (e["data-layout"] = t, e);
}
function JC(t) {
  return (e) => (e.type = t, e);
}
function sb(t, e, r, n) {
  return Ft(t, e, n, Zl("description"), St(r));
}
function ob(t, e, r, n) {
  return Ft(t, e, n, Zl("errors"), YC(-1), St(r));
}
function ib(t, e, r, n, s) {
  return Ft(t, e, s, St(r), BC(n));
}
function ab(t, e, r, n) {
  return Ft(t, e, n, Zl("help"), St(r));
}
function ZC(t, e, r, n) {
  return Ft(t, e, n, GC, St(r));
}
function Dc(t, e, r, n) {
  return Ft(t, e, n, Zl("title"), St(r));
}
function lb(t, e, r, n, s, o) {
  return Ft(
    t,
    e,
    o,
    XC(s),
    St(r),
    // @ts-expect-error Type `T` is resolved as `never` because this package
    // lacks suitable definitions for UI options,
    // but they are available in `theme` packages.
    eb(n, (i) => i[s])
  );
}
function QC(t, e, r, n, s) {
  return Ft(t, e, s, JC(n), St(r), Do);
}
function pr(t, e, r, n) {
  return Ft(t, e, n, St(r), Do, Ws, Id, qC, UC);
}
function Ni(t, e, r, n, s) {
  return Ft(t, e, s, WC, cn(n), St(r), Do, Ws, Id);
}
function ub(t, e, r, n, s) {
  return Ft(t, e, s, HC, cn(n), St(r), Do, Ws, Id);
}
async function cb(t, e, r, n) {
  const { name: s, blob: o } = await t[Ky](e, n);
  r.items.add(new File([o], s, { type: o.type }));
}
function ek(t, e, r, n) {
  const s = [];
  for (const o of n)
    s.push(cb(t, e, r, o));
  return Promise.all(s);
}
const tk = (t, e = he) => {
  var r = rk(), n = ge(r, !0);
  de(r), ke(() => Ie(n, e())), A(t, r);
};
function qg(t) {
  return (e) => Nd(e, { message: t });
}
var rk = /* @__PURE__ */ ne('<pre style="color: red;"> </pre>');
function Nd(t, e) {
  W(e, !0);
  const r = v(e, "message", 7);
  var n = {
    get message() {
      return r();
    },
    set message(s) {
      r(s), m();
    }
  };
  return tk(t, r), H(n);
}
K(Nd, { message: {} }, [], [], { mode: "open" });
function Me(t, e, r) {
  const n = r.uiSchema["ui:components"]?.[e];
  switch (typeof n) {
    case "undefined":
      return t[Tc](e, r) ?? // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      qg(t[Ec]("component-not-found", { type: e }));
    case "string":
      return t[Tc](n, r) ?? // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      qg(t[Ec]("component-not-found", {
        // @ts-expect-error ts cannot infer type properly by some reason
        type: n
      }));
    default:
      return n;
  }
}
function yo(t, e) {
  return Me(t, t[Hy](e), e);
}
function nk(t, e, r, n) {
  let s = Number.MIN_SAFE_INTEGER;
  return () => {
    let o;
    const i = e();
    return i ? (o = t[$c].get(i), o === void 0 && (o = n(i, () => s++), t[$c].set(i, o))) : o = r(), o;
  };
}
const yi = () => "abort", sk = ({ status: t }) => t !== "processing";
class ok {
  state;
  constructor(e) {
    this.state = e;
  }
}
class ik {
  state;
  constructor(e) {
    this.state = e;
  }
}
function bo(t) {
  const e = /* @__PURE__ */ O(() => t.delayedMs ?? 500), r = /* @__PURE__ */ O(() => t.timeoutMs ?? 8e3), n = /* @__PURE__ */ O(() => t.combinator ?? sk);
  let s = /* @__PURE__ */ xe({ status: "idle" }), o, i;
  function a() {
    clearTimeout(o), clearTimeout(i);
  }
  function l(b) {
    b.abortController.abort();
  }
  function u(b, p) {
    if (d(s).status === "failed")
      throw new ik(d(s));
    d(s).status === "processing" && d(s).promise === b && (a(), p());
  }
  function c(b) {
    if (d(s).status === "processing") {
      if (b !== "abort")
        return d(s).abortController;
      l(d(s));
    }
    return new AbortController();
  }
  async function f(b, p) {
    if (b === !1)
      throw new ok(d(s));
    const g = c(b), y = t.execute(g.signal, ...p);
    if (b === "untrack")
      return y;
    const S = y.then(
      (x) => (u(S, () => {
        q(s, { status: "success" }), t.onSuccess?.(x, ...p);
      }), x),
      (x) => (u(S, () => {
        q(s, { status: "failed", reason: "error", error: x }), t.onFailure?.(d(s), ...p);
      }), Promise.reject(x))
    );
    return q(s, {
      status: "processing",
      delayed: _.isDelayed,
      args: p,
      promise: S,
      abortController: g
    }), a(), o = setTimeout(
      () => {
        d(s).status !== "processing" || d(s).promise !== S || q(s, { ...d(s), delayed: !0 });
      },
      d(e)
    ), i = setTimeout(
      () => {
        d(s).status !== "processing" || d(s).promise !== S || (l(d(s)), q(s, { status: "failed", reason: "timeout" }), t.onFailure?.(d(s), ...p));
      },
      d(r)
    ), S;
  }
  function h(b) {
    return ot(() => f(d(n)(d(s)), b));
  }
  const _ = {
    get state() {
      return d(s);
    },
    get status() {
      return d(s).status;
    },
    get isSuccess() {
      return d(s).status === "success";
    },
    get isFailed() {
      return d(s).status === "failed";
    },
    get isProcessed() {
      return d(s).status === "processing";
    },
    get isDelayed() {
      return d(s).status === "processing" && d(s).delayed;
    },
    matches(b) {
      return d(s).status === b;
    },
    run(...b) {
      h(b).catch(gy);
    },
    runAsync(...b) {
      return h(b);
    },
    abort() {
      ot(() => {
        if (d(s).status !== "processing") return;
        const { args: b } = d(s);
        l(d(s)), a(), q(s, { status: "failed", reason: "aborted" }), t.onFailure?.(d(s), ...b);
      });
    }
  };
  return _;
}
function ak([t, e]) {
  return {
    get current() {
      return t();
    },
    set current(r) {
      e(r);
    }
  };
}
function db({
  initialOutput: t,
  getInput: e,
  setInput: r,
  toInput: n,
  toOutput: s,
  isEqual: o = Object.is
}) {
  let i;
  const a = bo({
    combinator: yi,
    execute: n,
    onSuccess(c) {
      i = c, r(c);
    }
  });
  let l = /* @__PURE__ */ xe(t);
  const u = bo({
    combinator: yi,
    execute: s,
    onSuccess(c) {
      q(l, c);
    }
  });
  return Xe(() => {
    const c = e();
    o(c, i) || (a.abort(), u.run(c));
  }), {
    get current() {
      return d(l);
    },
    set current(c) {
      u.abort(), q(l, c), a.run(c);
    },
    get inputProcessing() {
      return a.isProcessed;
    },
    get outputProcessing() {
      return u.isProcessed;
    }
  };
}
const Mc = "name=", Ug = "data:", Fd = ";base64,", lk = 8192;
function uk(t, e = "unknown") {
  if (!t.startsWith(Ug))
    throw new Error("File is invalid: URI must be a dataURI");
  const n = t.slice(Ug.length).split(Fd);
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [s, o] = n, i = s.split(";"), a = {
    mime: i[0],
    name: e,
    base64content: o
  };
  if (i.length > 1) {
    const l = i.slice(1).find((u) => u.startsWith(Mc));
    l !== void 0 && (a.name = decodeURIComponent(l.substring(Mc.length)));
  }
  return a;
}
function ck(t, e = lk) {
  return async (r, n) => {
    const { mime: s, base64content: o, name: i } = uk(n);
    try {
      const a = atob(o);
      await t({ signal: r });
      const l = new Uint8Array(a.length);
      for (let c = 0; c < a.length; c++)
        c % e === 0 && await t({ signal: r }), l[c] = a.charCodeAt(c);
      return { blob: new Blob([l], { type: s }), name: i };
    } catch (a) {
      throw a instanceof DOMException && a.name === "AbortError" ? a : new Error("File is invalid: " + a.message);
    }
  };
}
function dk(t) {
  return `;${Mc}${encodeURIComponent(t)}${Fd}`;
}
function fk(t, e) {
  const r = new FileReader(), n = () => {
    r.abort();
  };
  return t.addEventListener("abort", n), new Promise((s, o) => {
    r.onerror = o, r.onabort = o, r.onload = (i) => {
      let a = i.target?.result;
      if (typeof a != "string") {
        o(new Error("File is invalid: result must be a string"));
        return;
      }
      a = a.replace(Fd, dk(e.name)), s(a);
    }, r.readAsDataURL(e);
  }).finally(() => {
    t.removeEventListener("abort", n);
  });
}
const fb = fk, ro = /* @__PURE__ */ Symbol("unchanged");
function hk(t) {
  return function e(r, n) {
    if (r === n)
      return ro;
    if (typeof r == "object" && typeof n == "object") {
      const s = Array.isArray(r), o = Array.isArray(n);
      if (s && o) {
        const i = Math.min(r.length, n.length);
        let a = 0;
        for (; a < i; a++) {
          const l = e(r[a], n[a]);
          l !== ro && (r[a] = l);
        }
        if (r.length !== n.length) {
          const l = t.get(r) ?? r;
          for (; a < n.length; a++)
            l.push(n[a]);
          l.splice(n.length);
        }
        return ro;
      }
      if (!s && !o && r !== null && n !== null && hi(r) && hi(n)) {
        const i = Object.keys(r);
        let a = i.length;
        for (let u = 0; u < a; u++) {
          const c = i[u];
          c in n || delete r[c];
        }
        const l = Object.keys(n);
        a = l.length;
        for (let u = 0; u < a; u++) {
          const c = l[u], f = e(r[c], n[c]);
          f !== ro && (r[c] = f);
        }
        return ro;
      }
    }
    return n;
  };
}
const gk = "uiOptionsRegistry";
function pk(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
function hb(t) {
  const e = /* @__PURE__ */ O(() => t.idPrefix ?? Iy), r = /* @__PURE__ */ O(() => t.uiSchema ?? {}), n = /* @__PURE__ */ O(() => nl(d(r), t.uiSchema) ?? {}), s = /* @__PURE__ */ O(() => t[gk] ?? {}), o = /* @__PURE__ */ O(() => (t.schema, { current: void 0 })), i = /* @__PURE__ */ O(() => Yl(d(o), [])), a = /* @__PURE__ */ O(() => Iu(t.validator, {
    uiSchema: d(r),
    uiOptionsRegistry: d(s),
    schema: t.schema,
    merger: () => d(l)
  })), l = /* @__PURE__ */ O(() => Iu(t.merger, {
    validator: d(a),
    schema: t.schema,
    uiSchema: d(r),
    uiOptionsRegistry: d(s)
  })), u = /* @__PURE__ */ O(() => t.value ? ak(t.value) : pk(d(l).mergeFormDataAndSchemaDefaults({ formData: t.initialValue, schema: t.schema }))), c = /* @__PURE__ */ O(() => Iu(t.idBuilder, {
    idPrefix: d(e),
    schema: t.schema,
    uiSchema: d(r),
    uiOptionsRegistry: d(s),
    merger: d(l),
    validator: d(a),
    valueRef: d(u)
  })), f = /* @__PURE__ */ O(() => Lr(d(a), d(l), t.schema, t.schema, d(u).current)), h = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ O(() => zl(h, (j) => d(c).fromPath(j))), b = /* @__PURE__ */ O(() => {
    const j = new $C(d(o)), ee = t.initialErrors;
    return ee === void 0 ? j : Array.isArray(ee) ? j.updateErrors(ee) : j.assign(ee);
  }), p = /* @__PURE__ */ O(() => t.disabled ?? !1), g = /* @__PURE__ */ O(() => t.fieldsValidationMode ?? 0), y = /* @__PURE__ */ O(() => t.keyedArraysMap ?? /* @__PURE__ */ new WeakMap()), S = /* @__PURE__ */ O(() => hk(d(y))), x = /* @__PURE__ */ O(() => t.schedulerYield ?? (typeof scheduler < "u" && "yield" in scheduler) ? scheduler.yield.bind(scheduler) : ({ signal: j }) => new Promise((ee, L) => {
    setTimeout(
      () => {
        j.aborted ? L(j.reason) : ee();
      },
      0
    );
  })), P = /* @__PURE__ */ O(() => ck(d(x))), w = /* @__PURE__ */ O(() => Ny(t.translation)), C = new $d(), k = /* @__PURE__ */ O(() => C.size > 0), $ = /* @__PURE__ */ O(() => kC(C, d(i), Lg));
  let T = !0, E = /* @__PURE__ */ O(() => {
    t.schema;
    const j = T;
    return T = !1, j;
  });
  const I = /* @__PURE__ */ O(() => "validateFormValueAsync" in d(a) ? (j, ee, L) => d(a).validateFormValueAsync(j, ee, L) : (j, ee, L) => Promise.resolve(d(a).validateFormValue(ee, L))), F = bo({
    async execute(j) {
      return $s(Y, d(i), Lg), await d(I)(j, t.validateByRetrievedSchema ? d(f) : t.schema, Po(d(u).current));
    },
    onSuccess(j, ee) {
      if (RC(Y, j.errors ?? []), j.errors === void 0) {
        t.onSubmit?.(j.value, ee), C.clear();
        return;
      }
      t.onSubmitError?.(j, ee, Y);
    },
    onFailure(j, ee) {
      ci(Y, d(i), [d(w)("validation-process-error", { error: j })]), t.onSubmissionFailure?.(j, ee);
    },
    get combinator() {
      return t.submissionCombinator;
    },
    get delayedMs() {
      return t.submissionDelayedMs;
    },
    get timeoutMs() {
      return t.submissionTimeoutMs;
    }
  }), U = /* @__PURE__ */ O(() => xC(d(a)) ? (j, ee, L) => d(a).validateFieldValueAsync(j, ee, L) : SC(d(a)) ? (j, ee, L) => Promise.resolve(d(a).validateFieldValue(ee, L)) : () => Promise.resolve([])), B = bo({
    execute(j, ee, L) {
      const N = t.fieldsValidationDebounceMs ?? 300;
      if (N < 0)
        return d(U)(j, ee, L);
      const V = Promise.withResolvers(), G = setTimeout(
        () => {
          V.resolve(d(U)(j, ee, L));
        },
        N
      ), fe = () => {
        clearTimeout(G), V.reject(new DOMException("field validation has been aborted", "AbortError"));
      };
      return j.addEventListener("abort", fe), V.promise.finally(() => {
        j.removeEventListener("abort", fe);
      });
    },
    onSuccess(j, ee) {
      ci(Y, ee.path, j);
    },
    onFailure(j, ee, L) {
      j.reason !== "aborted" && ci(Y, ee.path, [d(w)("validation-process-error", { error: j })]), t.onFieldsValidationFailure?.(j, ee, L);
    },
    get combinator() {
      return t.fieldsValidationCombinator ?? yi;
    },
    get delayedMs() {
      return t.fieldsValidationDelayedMs;
    },
    get timeoutMs() {
      return t.fieldsValidationTimeoutMs;
    }
  });
  function R(j) {
    j.preventDefault(), F.run(j);
  }
  function Z(j) {
    j?.preventDefault(), C.clear(), d(b).clear(), d(u).current = d(l).mergeFormDataAndSchemaDefaults({ formData: t.initialValue, schema: t.schema }), t.onReset?.(j);
  }
  const Y = {
    submission: F,
    fieldsValidation: B,
    get isSubmitted() {
      return d($);
    },
    get isChanged() {
      return d(k);
    },
    submit: R,
    reset: Z,
    // INTERNALS
    [vi]: C,
    get [Ly]() {
      return d(e);
    },
    get [Ks]() {
      return d(b);
    },
    get [Wl]() {
      return d(o);
    },
    get [jy]() {
      return d(_);
    },
    get [Hl]() {
      return d(i);
    },
    get [Kn]() {
      return d(u).current;
    },
    set [Kn](j) {
      d(u).current = j;
    },
    get [Dd]() {
      return d(g);
    },
    get [Ky]() {
      return d(P);
    },
    get [$c]() {
      return d(y);
    },
    get [Zt]() {
      return t.schema;
    },
    get [Ac]() {
      return d(f);
    },
    get [Gl]() {
      return d(r);
    },
    get [vo]() {
      return d(n);
    },
    get [Eo]() {
      return t.extraUiOptions;
    },
    get [zy]() {
      return d(s);
    },
    get [Uy]() {
      return d(p);
    },
    get [jr]() {
      return d(a);
    },
    get [sn]() {
      return d(l);
    },
    get [Hy]() {
      return d(X);
    },
    get [Tc]() {
      return t.theme;
    },
    get [Wy]() {
      return t.translation;
    },
    get [Ec]() {
      return d(w);
    },
    get [qy]() {
      return t.icons;
    },
    [By]() {
      ae || (ae = !0, queueMicrotask(J));
    }
  }, X = /* @__PURE__ */ O(() => t.resolver(Y));
  let ae = !1;
  function J() {
    ae = !1;
    const j = d(l).mergeFormDataAndSchemaDefaults({
      formData: d(u).current,
      schema: t.schema,
      initialDefaultsGenerated: d(E)
    });
    q(E, !0);
    const ee = d(S)(d(u).current, j);
    ee !== ro && (d(u).current = ee);
  }
  return Y;
}
var mk = /* @__PURE__ */ ne('<input type="hidden"/>');
function gb(t, e) {
  W(e, !0);
  const r = v(e, "form", 7), n = v(e, "name", 7, jg);
  var s = {
    get form() {
      return r();
    },
    set form(i) {
      r(i), m();
    },
    get name() {
      return n();
    },
    set name(i = jg) {
      n(i), m();
    }
  }, o = mk();
  return sy(o), ke(() => {
    An(o, "name", n()), ZP(o, r()[Ly]);
  }), A(t, o), H(s);
}
K(gb, { form: {}, name: {} }, [], [], { mode: "open" });
var vk = /* @__PURE__ */ ne("<!> <!>", 1);
function pb(t, e) {
  W(e, !0);
  const r = Ee(), n = /* @__PURE__ */ O(() => ({
    path: r[Hl],
    title: Xr(r, r[vo]) ?? r[Ac].title ?? "",
    schema: r[Ac],
    uiSchema: r[vo],
    required: !0
  })), s = /* @__PURE__ */ O(() => yo(r, d(n)));
  var o = vk(), i = D(o);
  gb(i, {
    get form() {
      return r;
    }
  });
  var a = be(i, 2);
  {
    let l = /* @__PURE__ */ O(() => Rs(r, d(n)));
    Q(a, () => d(s), (u, c) => {
      c(u, {
        type: "field",
        get config() {
          return d(n);
        },
        uiOption: (f) => Nt(r, d(n), f),
        get translate() {
          return d(l);
        },
        get value() {
          return r[Kn];
        },
        set value(f) {
          r[Kn] = f;
        }
      });
    });
  }
  A(t, o), H();
}
K(pb, {}, [], [], { mode: "open" });
function _n(t, e) {
  W(e, !0);
  const r = Ee(), n = v(e, "id", 7), s = v(e, "config", 7), o = v(e, "translate", 7), i = v(e, "args", 23, () => ({})), a = /* @__PURE__ */ O(() => o()(n(), i())), l = /* @__PURE__ */ O(() => ({
    config: s(),
    params: i(),
    translation: d(a)
  })), u = /* @__PURE__ */ O(() => r[qy]?.(n(), d(
    //@ts-expect-error TODO: fix if possible
    l
  )));
  var c = {
    get id() {
      return n();
    },
    set id(p) {
      n(p), m();
    },
    get config() {
      return s();
    },
    set config(p) {
      s(p), m();
    },
    get translate() {
      return o();
    },
    set translate(p) {
      o(p), m();
    },
    get args() {
      return i();
    },
    set args(p = {}) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, () => d(u), () => d(l)), A(p, g);
    }, b = (p) => {
      var g = tt();
      ke(() => Ie(g, d(a))), A(p, g);
    };
    ue(h, (p) => {
      d(u) ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(_n, { id: {}, config: {}, translate: {}, args: {} }, [], [], { mode: "open" });
function mb(t, e) {
  W(e, !0);
  const r = Ee(), n = /* @__PURE__ */ O(() => ({
    path: Mi(r, r[Hl], "submit"),
    title: "",
    schema: r[Zt],
    uiSchema: r[vo],
    required: !1
  })), s = /* @__PURE__ */ O(() => Me(r, "submitButton", d(n)));
  var o = M(), i = D(o);
  Q(i, () => d(s), (a, l) => {
    l(a, {
      get config() {
        return d(n);
      },
      children: (u, c) => {
        {
          let f = /* @__PURE__ */ O(() => Rs(r, d(n)));
          _n(u, {
            get config() {
              return d(n);
            },
            id: "submit",
            get translate() {
              return d(f);
            }
          });
        }
      },
      $$slots: { default: !0 }
    });
  }), A(t, o), H();
}
K(mb, {}, [], [], { mode: "open" });
function vb(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15), n = v(e, "children", 7), s = v(e, "attributes", 7);
  const o = Ee(), i = /* @__PURE__ */ O(() => ({
    path: Mi(o, o[Hl], "form"),
    title: "",
    schema: o[Zt],
    uiSchema: o[vo],
    required: !1
  })), a = /* @__PURE__ */ O(() => Me(o, "form", d(i)));
  var l = {
    get ref() {
      return r();
    },
    set ref(f) {
      r(f), m();
    },
    get children() {
      return n();
    },
    set children(f) {
      n(f), m();
    },
    get attributes() {
      return s();
    },
    set attributes(f) {
      s(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(a), (f, h) => {
    h(f, {
      get config() {
        return d(i);
      },
      get children() {
        return n();
      },
      get attributes() {
        return s();
      },
      get ref() {
        return r();
      },
      set ref(_) {
        r(_);
      }
    });
  }), A(t, u), H(l);
}
K(vb, { ref: {}, children: {}, attributes: {} }, [], [], { mode: "open" });
var yk = /* @__PURE__ */ ne("<!> <!>", 1);
function Rd(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15), n = v(e, "form", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "form"]);
  Gy(n());
  var o = {
    get ref() {
      return r();
    },
    set ref(i) {
      r(i), m();
    },
    get form() {
      return n();
    },
    set form(i) {
      n(i), m();
    }
  };
  return vb(t, {
    get attributes() {
      return s;
    },
    get ref() {
      return r();
    },
    set ref(i) {
      r(i);
    },
    children: (i, a) => {
      var l = yk(), u = D(l);
      pb(u, {});
      var c = be(u, 2);
      mb(c, {}), A(i, l);
    },
    $$slots: { default: !0 }
  }), H(o);
}
K(Rd, { ref: {}, form: {} }, [], [], { mode: "open" });
function bk(t, e) {
  W(e, !0);
  const n = hb(/* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]));
  jP(() => {
    n.submission.abort(), n.fieldsValidation.abort();
  }), Rd(t, {
    get form() {
      return n;
    }
  }), H();
}
K(bk, {}, [], [], { mode: "open" });
var _k = /* @__PURE__ */ ne("<option></option>"), wk = /* @__PURE__ */ ne("<datalist></datalist>");
function Vd(t, e) {
  W(e, !0);
  const r = v(e, "id", 7), n = v(e, "config", 7), s = /* @__PURE__ */ O(() => {
    const { default: u, examples: c } = n().schema;
    if (!(!Array.isArray(c) || !r()))
      return u !== void 0 && !c.includes(u) ? [u].concat(c) : c;
  });
  var o = {
    get id() {
      return r();
    },
    set id(u) {
      r(u), m();
    },
    get config() {
      return n();
    },
    set config(u) {
      n(u), m();
    }
  }, i = M(), a = D(i);
  {
    var l = (u) => {
      var c = wk();
      st(c, 20, () => d(s), (f) => f, (f, h) => {
        var _ = _k(), b = {};
        ke(() => {
          b !== (b = h) && (_.value = (_.__value = h) ?? "");
        }), A(f, _);
      }), de(c), ke(() => An(c, "id", r())), A(u, c);
    };
    ue(a, (u) => {
      d(s) && u(l);
    });
  }
  return A(t, i), H(o);
}
K(Vd, { id: {}, config: {} }, [], [], { mode: "open" });
function Sk(t, e) {
  W(e, !0);
  const r = v(e, "form", 7), n = v(e, "path", 7), s = v(e, "required", 7), o = v(e, "uiSchema", 7), i = v(e, "render", 7), a = /* @__PURE__ */ O(() => Yl(r()[Wl], n())), l = /* @__PURE__ */ O(() => {
    if (d(a).length === 0)
      return {
        get current() {
          return r()[Kn];
        },
        set current(E) {
          r()[Kn] = E;
        }
      };
    let C = r()[Kn], k = -1;
    const $ = d(a).length - 1;
    for (; Is(C) && ++k < $; )
      C = C[d(a)[k]];
    if (k !== $)
      throw console.error("Current form state", Po(r()[Kn])), new Error(`Path "[${d(a).join(", ")}]" is not populated or invalid, check current form state`);
    const T = d(a)[$];
    return {
      get current() {
        return C[T];
      },
      set current(E) {
        C[T] = E;
      }
    };
  }), u = /* @__PURE__ */ O(() => {
    if (d(a).length < 2)
      return r()[Zt];
    const k = Rg(r()[jr], r()[sn], r()[Zt], r()[Zt], d(a).slice(0, -1), d(l).current);
    return k === void 0 || typeof k == "boolean" ? {} : k;
  }), c = /* @__PURE__ */ O(() => {
    if (d(a).length === 0)
      return r()[Zt];
    let C = d(l).current;
    const k = d(a).slice(0, -1);
    for (let T = 0; T < k.length && C !== void 0; T++) {
      const E = k[T];
      typeof E == "number" ? C = Array.isArray(C) ? C[E] : void 0 : C = Be(C) ? C[E] : void 0;
    }
    const $ = Rg(r()[jr], r()[sn], r()[Zt], d(u), d(a).slice(-1), C);
    return $ === void 0 || typeof $ == "boolean" ? {} : $;
  }), f = /* @__PURE__ */ O(() => Tr(r(), d(c), d(l).current)), h = /* @__PURE__ */ O(() => o() ?? kd(r()[Gl], r()[vo], d(a)) ?? {}), _ = /* @__PURE__ */ O(() => {
    if (s() !== void 0)
      return s();
    if (d(a).length === 0)
      return !1;
    const C = d(a)[d(a).length - 1], { required: k, items: $, minItems: T } = d(u);
    if (Array.isArray(k))
      return k.includes(C);
    const E = Number(C);
    if (Number.isInteger(E) && E >= 0) {
      if (T !== void 0)
        return E < T;
      if (Array.isArray($))
        return E < $.length;
    }
    return !1;
  }), b = /* @__PURE__ */ O(() => ({
    path: d(a),
    title: Xr(r(), d(h)) ?? d(f).title ?? "",
    schema: d(f),
    uiSchema: d(h),
    required: d(_)
  })), p = /* @__PURE__ */ O(() => Rs(r(), d(b))), g = (C) => Nt(r(), d(b), C);
  Gy(r());
  var y = {
    get form() {
      return r();
    },
    set form(C) {
      r(C), m();
    },
    get path() {
      return n();
    },
    set path(C) {
      n(C), m();
    },
    get required() {
      return s();
    },
    set required(C) {
      s(C), m();
    },
    get uiSchema() {
      return o();
    },
    set uiSchema(C) {
      o(C), m();
    },
    get render() {
      return i();
    },
    set render(C) {
      i(C), m();
    }
  }, S = M(), x = D(S);
  {
    var P = (C) => {
      var k = M(), $ = D(k);
      te($, i, () => ({
        type: "field",
        config: d(b),
        translate: d(p),
        uiOption: g,
        valueRef: d(l)
      })), A(C, k);
    }, w = (C) => {
      const k = /* @__PURE__ */ O(() => yo(r(), d(b)));
      var $ = M(), T = D($);
      Q(T, () => d(k), (E, I) => {
        I(E, {
          type: "field",
          get config() {
            return d(b);
          },
          uiOption: g,
          get translate() {
            return d(p);
          },
          get value() {
            return d(l).current;
          },
          set value(F) {
            d(l).current = F;
          }
        });
      }), A(C, $);
    };
    ue(x, (C) => {
      i() ? C(P) : C(w, !1);
    });
  }
  return A(t, S), H(y);
}
K(Sk, { form: {}, path: {}, required: {}, uiSchema: {}, render: {} }, [], [], { mode: "open" });
function xk(t) {
  Xe(() => Ye(window, "beforeunload", (e) => {
    t.isChanged && (e.preventDefault(), e.returnValue = "");
  }));
}
const Pk = {
  allErrors: !0,
  multipleOfPrecision: 8,
  strict: !1,
  verbose: !0,
  discriminator: !0
}, Ok = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, Ck = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function kk(t) {
  return t.addFormat("color", Ok), t.addFormat(fy, Ck), t;
}
function $k(t) {
  return t.addKeyword(Bl), t;
}
function Ak(t) {
  return $k(kk(t));
}
function Ek(t, e, r = /* @__PURE__ */ new WeakMap()) {
  let n = "", s = !1;
  const o = hy(r, (i) => {
    let a = i;
    return s && (a = iC(i, n), delete a[Pg]), t.compile(a);
  });
  return (i, a) => {
    n = a[Pg] ?? lO;
    let l = t.getSchema(n)?.schema;
    return l !== void 0 && l !== a && (t.removeSchema(n), r.delete(i), l = void 0), l === void 0 && t.addSchema(a, n), s = i !== a, o(i);
  };
}
function Tk(t, e) {
  const n = zl(/* @__PURE__ */ new WeakMap(), (s) => t.compile({ ...s, $async: e }));
  return (s) => n(s.schema);
}
var Hi = { exports: {} }, Fu = {}, hn = {}, ys = {}, Ru = {}, Vu = {}, Lu = {}, Kg;
function ol() {
  return Kg || (Kg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
    class e {
    }
    t._CodeOrName = e, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends e {
      constructor(S) {
        if (super(), !t.IDENTIFIER.test(S))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = S;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    t.Name = r;
    class n extends e {
      constructor(S) {
        super(), this._items = typeof S == "string" ? [S] : S;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const S = this._items[0];
        return S === "" || S === '""';
      }
      get str() {
        var S;
        return (S = this._str) !== null && S !== void 0 ? S : this._str = this._items.reduce((x, P) => `${x}${P}`, "");
      }
      get names() {
        var S;
        return (S = this._names) !== null && S !== void 0 ? S : this._names = this._items.reduce((x, P) => (P instanceof r && (x[P.str] = (x[P.str] || 0) + 1), x), {});
      }
    }
    t._Code = n, t.nil = new n("");
    function s(y, ...S) {
      const x = [y[0]];
      let P = 0;
      for (; P < S.length; )
        a(x, S[P]), x.push(y[++P]);
      return new n(x);
    }
    t._ = s;
    const o = new n("+");
    function i(y, ...S) {
      const x = [_(y[0])];
      let P = 0;
      for (; P < S.length; )
        x.push(o), a(x, S[P]), x.push(o, _(y[++P]));
      return l(x), new n(x);
    }
    t.str = i;
    function a(y, S) {
      S instanceof n ? y.push(...S._items) : S instanceof r ? y.push(S) : y.push(f(S));
    }
    t.addCodeArg = a;
    function l(y) {
      let S = 1;
      for (; S < y.length - 1; ) {
        if (y[S] === o) {
          const x = u(y[S - 1], y[S + 1]);
          if (x !== void 0) {
            y.splice(S - 1, 3, x);
            continue;
          }
          y[S++] = "+";
        }
        S++;
      }
    }
    function u(y, S) {
      if (S === '""')
        return y;
      if (y === '""')
        return S;
      if (typeof y == "string")
        return S instanceof r || y[y.length - 1] !== '"' ? void 0 : typeof S != "string" ? `${y.slice(0, -1)}${S}"` : S[0] === '"' ? y.slice(0, -1) + S.slice(1) : void 0;
      if (typeof S == "string" && S[0] === '"' && !(y instanceof r))
        return `"${y}${S.slice(1)}`;
    }
    function c(y, S) {
      return S.emptyStr() ? y : y.emptyStr() ? S : i`${y}${S}`;
    }
    t.strConcat = c;
    function f(y) {
      return typeof y == "number" || typeof y == "boolean" || y === null ? y : _(Array.isArray(y) ? y.join(",") : y);
    }
    function h(y) {
      return new n(_(y));
    }
    t.stringify = h;
    function _(y) {
      return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    t.safeStringify = _;
    function b(y) {
      return typeof y == "string" && t.IDENTIFIER.test(y) ? new n(`.${y}`) : s`[${y}]`;
    }
    t.getProperty = b;
    function p(y) {
      if (typeof y == "string" && t.IDENTIFIER.test(y))
        return new n(`${y}`);
      throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
    }
    t.getEsmExportName = p;
    function g(y) {
      return new n(y.toString());
    }
    t.regexpCode = g;
  })(Lu)), Lu;
}
var ju = {}, Wg;
function Hg() {
  return Wg || (Wg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
    const e = ol();
    class r extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var n;
    (function(l) {
      l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
    })(n || (t.UsedValueState = n = {})), t.varKinds = {
      const: new e.Name("const"),
      let: new e.Name("let"),
      var: new e.Name("var")
    };
    class s {
      constructor({ prefixes: u, parent: c } = {}) {
        this._names = {}, this._prefixes = u, this._parent = c;
      }
      toName(u) {
        return u instanceof e.Name ? u : this.name(u);
      }
      name(u) {
        return new e.Name(this._newName(u));
      }
      _newName(u) {
        const c = this._names[u] || this._nameGroup(u);
        return `${u}${c.index++}`;
      }
      _nameGroup(u) {
        var c, f;
        if (!((f = (c = this._parent) === null || c === void 0 ? void 0 : c._prefixes) === null || f === void 0) && f.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    t.Scope = s;
    class o extends e.Name {
      constructor(u, c) {
        super(c), this.prefix = u;
      }
      setValue(u, { property: c, itemIndex: f }) {
        this.value = u, this.scopePath = (0, e._)`.${new e.Name(c)}[${f}]`;
      }
    }
    t.ValueScopeName = o;
    const i = (0, e._)`\n`;
    class a extends s {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? i : e.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new o(u, this._newName(u));
      }
      value(u, c) {
        var f;
        if (c.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const h = this.toName(u), { prefix: _ } = h, b = (f = c.key) !== null && f !== void 0 ? f : c.ref;
        let p = this._values[_];
        if (p) {
          const S = p.get(b);
          if (S)
            return S;
        } else
          p = this._values[_] = /* @__PURE__ */ new Map();
        p.set(b, h);
        const g = this._scope[_] || (this._scope[_] = []), y = g.length;
        return g[y] = c.ref, h.setValue(c, { property: _, itemIndex: y }), h;
      }
      getValue(u, c) {
        const f = this._values[u];
        if (f)
          return f.get(c);
      }
      scopeRefs(u, c = this._values) {
        return this._reduceValues(c, (f) => {
          if (f.scopePath === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return (0, e._)`${u}${f.scopePath}`;
        });
      }
      scopeCode(u = this._values, c, f) {
        return this._reduceValues(u, (h) => {
          if (h.value === void 0)
            throw new Error(`CodeGen: name "${h}" has no value`);
          return h.value.code;
        }, c, f);
      }
      _reduceValues(u, c, f = {}, h) {
        let _ = e.nil;
        for (const b in u) {
          const p = u[b];
          if (!p)
            continue;
          const g = f[b] = f[b] || /* @__PURE__ */ new Map();
          p.forEach((y) => {
            if (g.has(y))
              return;
            g.set(y, n.Started);
            let S = c(y);
            if (S) {
              const x = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
              _ = (0, e._)`${_}${x} ${y} = ${S};${this.opts._n}`;
            } else if (S = h?.(y))
              _ = (0, e._)`${_}${S}${this.opts._n}`;
            else
              throw new r(y);
            g.set(y, n.Completed);
          });
        }
        return _;
      }
    }
    t.ValueScope = a;
  })(ju)), ju;
}
var Gg;
function He() {
  return Gg || (Gg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
    const e = ol(), r = Hg();
    var n = ol();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var s = Hg();
    Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
      return s.Scope;
    } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
      return s.ValueScope;
    } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
      return s.ValueScopeName;
    } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
      return s.varKinds;
    } }), t.operators = {
      GT: new e._Code(">"),
      GTE: new e._Code(">="),
      LT: new e._Code("<"),
      LTE: new e._Code("<="),
      EQ: new e._Code("==="),
      NEQ: new e._Code("!=="),
      NOT: new e._Code("!"),
      OR: new e._Code("||"),
      AND: new e._Code("&&"),
      ADD: new e._Code("+")
    };
    class o {
      optimizeNodes() {
        return this;
      }
      optimizeNames(N, V) {
        return this;
      }
    }
    class i extends o {
      constructor(N, V, G) {
        super(), this.varKind = N, this.name = V, this.rhs = G;
      }
      render({ es5: N, _n: V }) {
        const G = N ? r.varKinds.var : this.varKind, fe = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${G} ${this.name}${fe};` + V;
      }
      optimizeNames(N, V) {
        if (N[this.name.str])
          return this.rhs && (this.rhs = B(this.rhs, N, V)), this;
      }
      get names() {
        return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
      }
    }
    class a extends o {
      constructor(N, V, G) {
        super(), this.lhs = N, this.rhs = V, this.sideEffects = G;
      }
      render({ _n: N }) {
        return `${this.lhs} = ${this.rhs};` + N;
      }
      optimizeNames(N, V) {
        if (!(this.lhs instanceof e.Name && !N[this.lhs.str] && !this.sideEffects))
          return this.rhs = B(this.rhs, N, V), this;
      }
      get names() {
        const N = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
        return U(N, this.rhs);
      }
    }
    class l extends a {
      constructor(N, V, G, fe) {
        super(N, G, fe), this.op = V;
      }
      render({ _n: N }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + N;
      }
    }
    class u extends o {
      constructor(N) {
        super(), this.label = N, this.names = {};
      }
      render({ _n: N }) {
        return `${this.label}:` + N;
      }
    }
    class c extends o {
      constructor(N) {
        super(), this.label = N, this.names = {};
      }
      render({ _n: N }) {
        return `break${this.label ? ` ${this.label}` : ""};` + N;
      }
    }
    class f extends o {
      constructor(N) {
        super(), this.error = N;
      }
      render({ _n: N }) {
        return `throw ${this.error};` + N;
      }
      get names() {
        return this.error.names;
      }
    }
    class h extends o {
      constructor(N) {
        super(), this.code = N;
      }
      render({ _n: N }) {
        return `${this.code};` + N;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(N, V) {
        return this.code = B(this.code, N, V), this;
      }
      get names() {
        return this.code instanceof e._CodeOrName ? this.code.names : {};
      }
    }
    class _ extends o {
      constructor(N = []) {
        super(), this.nodes = N;
      }
      render(N) {
        return this.nodes.reduce((V, G) => V + G.render(N), "");
      }
      optimizeNodes() {
        const { nodes: N } = this;
        let V = N.length;
        for (; V--; ) {
          const G = N[V].optimizeNodes();
          Array.isArray(G) ? N.splice(V, 1, ...G) : G ? N[V] = G : N.splice(V, 1);
        }
        return N.length > 0 ? this : void 0;
      }
      optimizeNames(N, V) {
        const { nodes: G } = this;
        let fe = G.length;
        for (; fe--; ) {
          const se = G[fe];
          se.optimizeNames(N, V) || (R(N, se.names), G.splice(fe, 1));
        }
        return G.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((N, V) => F(N, V.names), {});
      }
    }
    class b extends _ {
      render(N) {
        return "{" + N._n + super.render(N) + "}" + N._n;
      }
    }
    class p extends _ {
    }
    class g extends b {
    }
    g.kind = "else";
    class y extends b {
      constructor(N, V) {
        super(V), this.condition = N;
      }
      render(N) {
        let V = `if(${this.condition})` + super.render(N);
        return this.else && (V += "else " + this.else.render(N)), V;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const N = this.condition;
        if (N === !0)
          return this.nodes;
        let V = this.else;
        if (V) {
          const G = V.optimizeNodes();
          V = this.else = Array.isArray(G) ? new g(G) : G;
        }
        if (V)
          return N === !1 ? V instanceof y ? V : V.nodes : this.nodes.length ? this : new y(Z(N), V instanceof y ? [V] : V.nodes);
        if (!(N === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(N, V) {
        var G;
        if (this.else = (G = this.else) === null || G === void 0 ? void 0 : G.optimizeNames(N, V), !!(super.optimizeNames(N, V) || this.else))
          return this.condition = B(this.condition, N, V), this;
      }
      get names() {
        const N = super.names;
        return U(N, this.condition), this.else && F(N, this.else.names), N;
      }
    }
    y.kind = "if";
    class S extends b {
    }
    S.kind = "for";
    class x extends S {
      constructor(N) {
        super(), this.iteration = N;
      }
      render(N) {
        return `for(${this.iteration})` + super.render(N);
      }
      optimizeNames(N, V) {
        if (super.optimizeNames(N, V))
          return this.iteration = B(this.iteration, N, V), this;
      }
      get names() {
        return F(super.names, this.iteration.names);
      }
    }
    class P extends S {
      constructor(N, V, G, fe) {
        super(), this.varKind = N, this.name = V, this.from = G, this.to = fe;
      }
      render(N) {
        const V = N.es5 ? r.varKinds.var : this.varKind, { name: G, from: fe, to: se } = this;
        return `for(${V} ${G}=${fe}; ${G}<${se}; ${G}++)` + super.render(N);
      }
      get names() {
        const N = U(super.names, this.from);
        return U(N, this.to);
      }
    }
    class w extends S {
      constructor(N, V, G, fe) {
        super(), this.loop = N, this.varKind = V, this.name = G, this.iterable = fe;
      }
      render(N) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(N);
      }
      optimizeNames(N, V) {
        if (super.optimizeNames(N, V))
          return this.iterable = B(this.iterable, N, V), this;
      }
      get names() {
        return F(super.names, this.iterable.names);
      }
    }
    class C extends b {
      constructor(N, V, G) {
        super(), this.name = N, this.args = V, this.async = G;
      }
      render(N) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(N);
      }
    }
    C.kind = "func";
    class k extends _ {
      render(N) {
        return "return " + super.render(N);
      }
    }
    k.kind = "return";
    class $ extends b {
      render(N) {
        let V = "try" + super.render(N);
        return this.catch && (V += this.catch.render(N)), this.finally && (V += this.finally.render(N)), V;
      }
      optimizeNodes() {
        var N, V;
        return super.optimizeNodes(), (N = this.catch) === null || N === void 0 || N.optimizeNodes(), (V = this.finally) === null || V === void 0 || V.optimizeNodes(), this;
      }
      optimizeNames(N, V) {
        var G, fe;
        return super.optimizeNames(N, V), (G = this.catch) === null || G === void 0 || G.optimizeNames(N, V), (fe = this.finally) === null || fe === void 0 || fe.optimizeNames(N, V), this;
      }
      get names() {
        const N = super.names;
        return this.catch && F(N, this.catch.names), this.finally && F(N, this.finally.names), N;
      }
    }
    class T extends b {
      constructor(N) {
        super(), this.error = N;
      }
      render(N) {
        return `catch(${this.error})` + super.render(N);
      }
    }
    T.kind = "catch";
    class E extends b {
      render(N) {
        return "finally" + super.render(N);
      }
    }
    E.kind = "finally";
    class I {
      constructor(N, V = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...V, _n: V.lines ? `
` : "" }, this._extScope = N, this._scope = new r.Scope({ parent: N }), this._nodes = [new p()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(N) {
        return this._scope.name(N);
      }
      // reserves unique name in the external scope
      scopeName(N) {
        return this._extScope.name(N);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(N, V) {
        const G = this._extScope.value(N, V);
        return (this._values[G.prefix] || (this._values[G.prefix] = /* @__PURE__ */ new Set())).add(G), G;
      }
      getScopeValue(N, V) {
        return this._extScope.getValue(N, V);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(N) {
        return this._extScope.scopeRefs(N, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(N, V, G, fe) {
        const se = this._scope.toName(V);
        return G !== void 0 && fe && (this._constants[se.str] = G), this._leafNode(new i(N, se, G)), se;
      }
      // `const` declaration (`var` in es5 mode)
      const(N, V, G) {
        return this._def(r.varKinds.const, N, V, G);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(N, V, G) {
        return this._def(r.varKinds.let, N, V, G);
      }
      // `var` declaration with optional assignment
      var(N, V, G) {
        return this._def(r.varKinds.var, N, V, G);
      }
      // assignment code
      assign(N, V, G) {
        return this._leafNode(new a(N, V, G));
      }
      // `+=` code
      add(N, V) {
        return this._leafNode(new l(N, t.operators.ADD, V));
      }
      // appends passed SafeExpr to code or executes Block
      code(N) {
        return typeof N == "function" ? N() : N !== e.nil && this._leafNode(new h(N)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...N) {
        const V = ["{"];
        for (const [G, fe] of N)
          V.length > 1 && V.push(","), V.push(G), (G !== fe || this.opts.es5) && (V.push(":"), (0, e.addCodeArg)(V, fe));
        return V.push("}"), new e._Code(V);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(N, V, G) {
        if (this._blockNode(new y(N)), V && G)
          this.code(V).else().code(G).endIf();
        else if (V)
          this.code(V).endIf();
        else if (G)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(N) {
        return this._elseNode(new y(N));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new g());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(y, g);
      }
      _for(N, V) {
        return this._blockNode(N), V && this.code(V).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(N, V) {
        return this._for(new x(N), V);
      }
      // `for` statement for a range of values
      forRange(N, V, G, fe, se = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const we = this._scope.toName(N);
        return this._for(new P(se, we, V, G), () => fe(we));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(N, V, G, fe = r.varKinds.const) {
        const se = this._scope.toName(N);
        if (this.opts.es5) {
          const we = V instanceof e.Name ? V : this.var("_arr", V);
          return this.forRange("_i", 0, (0, e._)`${we}.length`, (le) => {
            this.var(se, (0, e._)`${we}[${le}]`), G(se);
          });
        }
        return this._for(new w("of", fe, se, V), () => G(se));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(N, V, G, fe = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(N, (0, e._)`Object.keys(${V})`, G);
        const se = this._scope.toName(N);
        return this._for(new w("in", fe, se, V), () => G(se));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(S);
      }
      // `label` statement
      label(N) {
        return this._leafNode(new u(N));
      }
      // `break` statement
      break(N) {
        return this._leafNode(new c(N));
      }
      // `return` statement
      return(N) {
        const V = new k();
        if (this._blockNode(V), this.code(N), V.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(k);
      }
      // `try` statement
      try(N, V, G) {
        if (!V && !G)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const fe = new $();
        if (this._blockNode(fe), this.code(N), V) {
          const se = this.name("e");
          this._currNode = fe.catch = new T(se), V(se);
        }
        return G && (this._currNode = fe.finally = new E(), this.code(G)), this._endBlockNode(T, E);
      }
      // `throw` statement
      throw(N) {
        return this._leafNode(new f(N));
      }
      // start self-balancing block
      block(N, V) {
        return this._blockStarts.push(this._nodes.length), N && this.code(N).endBlock(V), this;
      }
      // end the current self-balancing block
      endBlock(N) {
        const V = this._blockStarts.pop();
        if (V === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const G = this._nodes.length - V;
        if (G < 0 || N !== void 0 && G !== N)
          throw new Error(`CodeGen: wrong number of nodes: ${G} vs ${N} expected`);
        return this._nodes.length = V, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(N, V = e.nil, G, fe) {
        return this._blockNode(new C(N, V, G)), fe && this.code(fe).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(C);
      }
      optimize(N = 1) {
        for (; N-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(N) {
        return this._currNode.nodes.push(N), this;
      }
      _blockNode(N) {
        this._currNode.nodes.push(N), this._nodes.push(N);
      }
      _endBlockNode(N, V) {
        const G = this._currNode;
        if (G instanceof N || V && G instanceof V)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${V ? `${N.kind}/${V.kind}` : N.kind}"`);
      }
      _elseNode(N) {
        const V = this._currNode;
        if (!(V instanceof y))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = V.else = N, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const N = this._nodes;
        return N[N.length - 1];
      }
      set _currNode(N) {
        const V = this._nodes;
        V[V.length - 1] = N;
      }
    }
    t.CodeGen = I;
    function F(L, N) {
      for (const V in N)
        L[V] = (L[V] || 0) + (N[V] || 0);
      return L;
    }
    function U(L, N) {
      return N instanceof e._CodeOrName ? F(L, N.names) : L;
    }
    function B(L, N, V) {
      if (L instanceof e.Name)
        return G(L);
      if (!fe(L))
        return L;
      return new e._Code(L._items.reduce((se, we) => (we instanceof e.Name && (we = G(we)), we instanceof e._Code ? se.push(...we._items) : se.push(we), se), []));
      function G(se) {
        const we = V[se.str];
        return we === void 0 || N[se.str] !== 1 ? se : (delete N[se.str], we);
      }
      function fe(se) {
        return se instanceof e._Code && se._items.some((we) => we instanceof e.Name && N[we.str] === 1 && V[we.str] !== void 0);
      }
    }
    function R(L, N) {
      for (const V in N)
        L[V] = (L[V] || 0) - (N[V] || 0);
    }
    function Z(L) {
      return typeof L == "boolean" || typeof L == "number" || L === null ? !L : (0, e._)`!${ee(L)}`;
    }
    t.not = Z;
    const Y = j(t.operators.AND);
    function X(...L) {
      return L.reduce(Y);
    }
    t.and = X;
    const ae = j(t.operators.OR);
    function J(...L) {
      return L.reduce(ae);
    }
    t.or = J;
    function j(L) {
      return (N, V) => N === e.nil ? V : V === e.nil ? N : (0, e._)`${ee(N)} ${L} ${ee(V)}`;
    }
    function ee(L) {
      return L instanceof e.Name ? L : (0, e._)`(${L})`;
    }
  })(Vu)), Vu;
}
var qe = {}, Yg;
function Qe() {
  if (Yg) return qe;
  Yg = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.checkStrictMode = qe.getErrorPath = qe.Type = qe.useFunc = qe.setEvaluated = qe.evaluatedPropsToName = qe.mergeEvaluated = qe.eachItem = qe.unescapeJsonPointer = qe.escapeJsonPointer = qe.escapeFragment = qe.unescapeFragment = qe.schemaRefOrVal = qe.schemaHasRulesButRef = qe.schemaHasRules = qe.checkUnknownRules = qe.alwaysValidSchema = qe.toHash = void 0;
  const t = He(), e = ol();
  function r(w) {
    const C = {};
    for (const k of w)
      C[k] = !0;
    return C;
  }
  qe.toHash = r;
  function n(w, C) {
    return typeof C == "boolean" ? C : Object.keys(C).length === 0 ? !0 : (s(w, C), !o(C, w.self.RULES.all));
  }
  qe.alwaysValidSchema = n;
  function s(w, C = w.schema) {
    const { opts: k, self: $ } = w;
    if (!k.strictSchema || typeof C == "boolean")
      return;
    const T = $.RULES.keywords;
    for (const E in C)
      T[E] || P(w, `unknown keyword: "${E}"`);
  }
  qe.checkUnknownRules = s;
  function o(w, C) {
    if (typeof w == "boolean")
      return !w;
    for (const k in w)
      if (C[k])
        return !0;
    return !1;
  }
  qe.schemaHasRules = o;
  function i(w, C) {
    if (typeof w == "boolean")
      return !w;
    for (const k in w)
      if (k !== "$ref" && C.all[k])
        return !0;
    return !1;
  }
  qe.schemaHasRulesButRef = i;
  function a({ topSchemaRef: w, schemaPath: C }, k, $, T) {
    if (!T) {
      if (typeof k == "number" || typeof k == "boolean")
        return k;
      if (typeof k == "string")
        return (0, t._)`${k}`;
    }
    return (0, t._)`${w}${C}${(0, t.getProperty)($)}`;
  }
  qe.schemaRefOrVal = a;
  function l(w) {
    return f(decodeURIComponent(w));
  }
  qe.unescapeFragment = l;
  function u(w) {
    return encodeURIComponent(c(w));
  }
  qe.escapeFragment = u;
  function c(w) {
    return typeof w == "number" ? `${w}` : w.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  qe.escapeJsonPointer = c;
  function f(w) {
    return w.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  qe.unescapeJsonPointer = f;
  function h(w, C) {
    if (Array.isArray(w))
      for (const k of w)
        C(k);
    else
      C(w);
  }
  qe.eachItem = h;
  function _({ mergeNames: w, mergeToName: C, mergeValues: k, resultToName: $ }) {
    return (T, E, I, F) => {
      const U = I === void 0 ? E : I instanceof t.Name ? (E instanceof t.Name ? w(T, E, I) : C(T, E, I), I) : E instanceof t.Name ? (C(T, I, E), E) : k(E, I);
      return F === t.Name && !(U instanceof t.Name) ? $(T, U) : U;
    };
  }
  qe.mergeEvaluated = {
    props: _({
      mergeNames: (w, C, k) => w.if((0, t._)`${k} !== true && ${C} !== undefined`, () => {
        w.if((0, t._)`${C} === true`, () => w.assign(k, !0), () => w.assign(k, (0, t._)`${k} || {}`).code((0, t._)`Object.assign(${k}, ${C})`));
      }),
      mergeToName: (w, C, k) => w.if((0, t._)`${k} !== true`, () => {
        C === !0 ? w.assign(k, !0) : (w.assign(k, (0, t._)`${k} || {}`), p(w, k, C));
      }),
      mergeValues: (w, C) => w === !0 ? !0 : { ...w, ...C },
      resultToName: b
    }),
    items: _({
      mergeNames: (w, C, k) => w.if((0, t._)`${k} !== true && ${C} !== undefined`, () => w.assign(k, (0, t._)`${C} === true ? true : ${k} > ${C} ? ${k} : ${C}`)),
      mergeToName: (w, C, k) => w.if((0, t._)`${k} !== true`, () => w.assign(k, C === !0 ? !0 : (0, t._)`${k} > ${C} ? ${k} : ${C}`)),
      mergeValues: (w, C) => w === !0 ? !0 : Math.max(w, C),
      resultToName: (w, C) => w.var("items", C)
    })
  };
  function b(w, C) {
    if (C === !0)
      return w.var("props", !0);
    const k = w.var("props", (0, t._)`{}`);
    return C !== void 0 && p(w, k, C), k;
  }
  qe.evaluatedPropsToName = b;
  function p(w, C, k) {
    Object.keys(k).forEach(($) => w.assign((0, t._)`${C}${(0, t.getProperty)($)}`, !0));
  }
  qe.setEvaluated = p;
  const g = {};
  function y(w, C) {
    return w.scopeValue("func", {
      ref: C,
      code: g[C.code] || (g[C.code] = new e._Code(C.code))
    });
  }
  qe.useFunc = y;
  var S;
  (function(w) {
    w[w.Num = 0] = "Num", w[w.Str = 1] = "Str";
  })(S || (qe.Type = S = {}));
  function x(w, C, k) {
    if (w instanceof t.Name) {
      const $ = C === S.Num;
      return k ? $ ? (0, t._)`"[" + ${w} + "]"` : (0, t._)`"['" + ${w} + "']"` : $ ? (0, t._)`"/" + ${w}` : (0, t._)`"/" + ${w}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return k ? (0, t.getProperty)(w).toString() : "/" + c(w);
  }
  qe.getErrorPath = x;
  function P(w, C, k = w.opts.strictSchema) {
    if (k) {
      if (C = `strict mode: ${C}`, k === !0)
        throw new Error(C);
      w.self.logger.warn(C);
    }
  }
  return qe.checkStrictMode = P, qe;
}
var Gi = {}, Xg;
function cs() {
  if (Xg) return Gi;
  Xg = 1, Object.defineProperty(Gi, "__esModule", { value: !0 });
  const t = He(), e = {
    // validation function arguments
    data: new t.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new t.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new t.Name("instancePath"),
    parentData: new t.Name("parentData"),
    parentDataProperty: new t.Name("parentDataProperty"),
    rootData: new t.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new t.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new t.Name("vErrors"),
    // null or array of validation errors
    errors: new t.Name("errors"),
    // counter of validation errors
    this: new t.Name("this"),
    // "globals"
    self: new t.Name("self"),
    scope: new t.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new t.Name("json"),
    jsonPos: new t.Name("jsonPos"),
    jsonLen: new t.Name("jsonLen"),
    jsonPart: new t.Name("jsonPart")
  };
  return Gi.default = e, Gi;
}
var Jg;
function Ql() {
  return Jg || (Jg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
    const e = He(), r = Qe(), n = cs();
    t.keywordError = {
      message: ({ keyword: g }) => (0, e.str)`must pass "${g}" keyword validation`
    }, t.keyword$DataError = {
      message: ({ keyword: g, schemaType: y }) => y ? (0, e.str)`"${g}" keyword must be ${y} ($data)` : (0, e.str)`"${g}" keyword is invalid ($data)`
    };
    function s(g, y = t.keywordError, S, x) {
      const { it: P } = g, { gen: w, compositeRule: C, allErrors: k } = P, $ = f(g, y, S);
      x ?? (C || k) ? l(w, $) : u(P, (0, e._)`[${$}]`);
    }
    t.reportError = s;
    function o(g, y = t.keywordError, S) {
      const { it: x } = g, { gen: P, compositeRule: w, allErrors: C } = x, k = f(g, y, S);
      l(P, k), w || C || u(x, n.default.vErrors);
    }
    t.reportExtraError = o;
    function i(g, y) {
      g.assign(n.default.errors, y), g.if((0, e._)`${n.default.vErrors} !== null`, () => g.if(y, () => g.assign((0, e._)`${n.default.vErrors}.length`, y), () => g.assign(n.default.vErrors, null)));
    }
    t.resetErrorsCount = i;
    function a({ gen: g, keyword: y, schemaValue: S, data: x, errsCount: P, it: w }) {
      if (P === void 0)
        throw new Error("ajv implementation error");
      const C = g.name("err");
      g.forRange("i", P, n.default.errors, (k) => {
        g.const(C, (0, e._)`${n.default.vErrors}[${k}]`), g.if((0, e._)`${C}.instancePath === undefined`, () => g.assign((0, e._)`${C}.instancePath`, (0, e.strConcat)(n.default.instancePath, w.errorPath))), g.assign((0, e._)`${C}.schemaPath`, (0, e.str)`${w.errSchemaPath}/${y}`), w.opts.verbose && (g.assign((0, e._)`${C}.schema`, S), g.assign((0, e._)`${C}.data`, x));
      });
    }
    t.extendErrors = a;
    function l(g, y) {
      const S = g.const("err", y);
      g.if((0, e._)`${n.default.vErrors} === null`, () => g.assign(n.default.vErrors, (0, e._)`[${S}]`), (0, e._)`${n.default.vErrors}.push(${S})`), g.code((0, e._)`${n.default.errors}++`);
    }
    function u(g, y) {
      const { gen: S, validateName: x, schemaEnv: P } = g;
      P.$async ? S.throw((0, e._)`new ${g.ValidationError}(${y})`) : (S.assign((0, e._)`${x}.errors`, y), S.return(!1));
    }
    const c = {
      keyword: new e.Name("keyword"),
      schemaPath: new e.Name("schemaPath"),
      // also used in JTD errors
      params: new e.Name("params"),
      propertyName: new e.Name("propertyName"),
      message: new e.Name("message"),
      schema: new e.Name("schema"),
      parentSchema: new e.Name("parentSchema")
    };
    function f(g, y, S) {
      const { createErrors: x } = g.it;
      return x === !1 ? (0, e._)`{}` : h(g, y, S);
    }
    function h(g, y, S = {}) {
      const { gen: x, it: P } = g, w = [
        _(P, S),
        b(g, S)
      ];
      return p(g, y, w), x.object(...w);
    }
    function _({ errorPath: g }, { instancePath: y }) {
      const S = y ? (0, e.str)`${g}${(0, r.getErrorPath)(y, r.Type.Str)}` : g;
      return [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, S)];
    }
    function b({ keyword: g, it: { errSchemaPath: y } }, { schemaPath: S, parentSchema: x }) {
      let P = x ? y : (0, e.str)`${y}/${g}`;
      return S && (P = (0, e.str)`${P}${(0, r.getErrorPath)(S, r.Type.Str)}`), [c.schemaPath, P];
    }
    function p(g, { params: y, message: S }, x) {
      const { keyword: P, data: w, schemaValue: C, it: k } = g, { opts: $, propertyName: T, topSchemaRef: E, schemaPath: I } = k;
      x.push([c.keyword, P], [c.params, typeof y == "function" ? y(g) : y || (0, e._)`{}`]), $.messages && x.push([c.message, typeof S == "function" ? S(g) : S]), $.verbose && x.push([c.schema, C], [c.parentSchema, (0, e._)`${E}${I}`], [n.default.data, w]), T && x.push([c.propertyName, T]);
    }
  })(Ru)), Ru;
}
var Zg;
function Dk() {
  if (Zg) return ys;
  Zg = 1, Object.defineProperty(ys, "__esModule", { value: !0 }), ys.boolOrEmptySchema = ys.topBoolOrEmptySchema = void 0;
  const t = Ql(), e = He(), r = cs(), n = {
    message: "boolean schema is false"
  };
  function s(a) {
    const { gen: l, schema: u, validateName: c } = a;
    u === !1 ? i(a, !1) : typeof u == "object" && u.$async === !0 ? l.return(r.default.data) : (l.assign((0, e._)`${c}.errors`, null), l.return(!0));
  }
  ys.topBoolOrEmptySchema = s;
  function o(a, l) {
    const { gen: u, schema: c } = a;
    c === !1 ? (u.var(l, !1), i(a)) : u.var(l, !0);
  }
  ys.boolOrEmptySchema = o;
  function i(a, l) {
    const { gen: u, data: c } = a, f = {
      gen: u,
      keyword: "false schema",
      data: c,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: a
    };
    (0, t.reportError)(f, n, void 0, l);
  }
  return ys;
}
var At = {}, bs = {}, Qg;
function yb() {
  if (Qg) return bs;
  Qg = 1, Object.defineProperty(bs, "__esModule", { value: !0 }), bs.getRules = bs.isJSONType = void 0;
  const t = ["string", "number", "integer", "boolean", "null", "object", "array"], e = new Set(t);
  function r(s) {
    return typeof s == "string" && e.has(s);
  }
  bs.isJSONType = r;
  function n() {
    const s = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...s, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, s.number, s.string, s.array, s.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return bs.getRules = n, bs;
}
var gn = {}, ep;
function bb() {
  if (ep) return gn;
  ep = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.shouldUseRule = gn.shouldUseGroup = gn.schemaHasRulesForType = void 0;
  function t({ schema: n, self: s }, o) {
    const i = s.RULES.types[o];
    return i && i !== !0 && e(n, i);
  }
  gn.schemaHasRulesForType = t;
  function e(n, s) {
    return s.rules.some((o) => r(n, o));
  }
  gn.shouldUseGroup = e;
  function r(n, s) {
    var o;
    return n[s.keyword] !== void 0 || ((o = s.definition.implements) === null || o === void 0 ? void 0 : o.some((i) => n[i] !== void 0));
  }
  return gn.shouldUseRule = r, gn;
}
var tp;
function il() {
  if (tp) return At;
  tp = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.reportTypeError = At.checkDataTypes = At.checkDataType = At.coerceAndCheckDataType = At.getJSONTypes = At.getSchemaTypes = At.DataType = void 0;
  const t = yb(), e = bb(), r = Ql(), n = He(), s = Qe();
  var o;
  (function(S) {
    S[S.Correct = 0] = "Correct", S[S.Wrong = 1] = "Wrong";
  })(o || (At.DataType = o = {}));
  function i(S) {
    const x = a(S.type);
    if (x.includes("null")) {
      if (S.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!x.length && S.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      S.nullable === !0 && x.push("null");
    }
    return x;
  }
  At.getSchemaTypes = i;
  function a(S) {
    const x = Array.isArray(S) ? S : S ? [S] : [];
    if (x.every(t.isJSONType))
      return x;
    throw new Error("type must be JSONType or JSONType[]: " + x.join(","));
  }
  At.getJSONTypes = a;
  function l(S, x) {
    const { gen: P, data: w, opts: C } = S, k = c(x, C.coerceTypes), $ = x.length > 0 && !(k.length === 0 && x.length === 1 && (0, e.schemaHasRulesForType)(S, x[0]));
    if ($) {
      const T = b(x, w, C.strictNumbers, o.Wrong);
      P.if(T, () => {
        k.length ? f(S, x, k) : g(S);
      });
    }
    return $;
  }
  At.coerceAndCheckDataType = l;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function c(S, x) {
    return x ? S.filter((P) => u.has(P) || x === "array" && P === "array") : [];
  }
  function f(S, x, P) {
    const { gen: w, data: C, opts: k } = S, $ = w.let("dataType", (0, n._)`typeof ${C}`), T = w.let("coerced", (0, n._)`undefined`);
    k.coerceTypes === "array" && w.if((0, n._)`${$} == 'object' && Array.isArray(${C}) && ${C}.length == 1`, () => w.assign(C, (0, n._)`${C}[0]`).assign($, (0, n._)`typeof ${C}`).if(b(x, C, k.strictNumbers), () => w.assign(T, C))), w.if((0, n._)`${T} !== undefined`);
    for (const I of P)
      (u.has(I) || I === "array" && k.coerceTypes === "array") && E(I);
    w.else(), g(S), w.endIf(), w.if((0, n._)`${T} !== undefined`, () => {
      w.assign(C, T), h(S, T);
    });
    function E(I) {
      switch (I) {
        case "string":
          w.elseIf((0, n._)`${$} == "number" || ${$} == "boolean"`).assign(T, (0, n._)`"" + ${C}`).elseIf((0, n._)`${C} === null`).assign(T, (0, n._)`""`);
          return;
        case "number":
          w.elseIf((0, n._)`${$} == "boolean" || ${C} === null
              || (${$} == "string" && ${C} && ${C} == +${C})`).assign(T, (0, n._)`+${C}`);
          return;
        case "integer":
          w.elseIf((0, n._)`${$} === "boolean" || ${C} === null
              || (${$} === "string" && ${C} && ${C} == +${C} && !(${C} % 1))`).assign(T, (0, n._)`+${C}`);
          return;
        case "boolean":
          w.elseIf((0, n._)`${C} === "false" || ${C} === 0 || ${C} === null`).assign(T, !1).elseIf((0, n._)`${C} === "true" || ${C} === 1`).assign(T, !0);
          return;
        case "null":
          w.elseIf((0, n._)`${C} === "" || ${C} === 0 || ${C} === false`), w.assign(T, null);
          return;
        case "array":
          w.elseIf((0, n._)`${$} === "string" || ${$} === "number"
              || ${$} === "boolean" || ${C} === null`).assign(T, (0, n._)`[${C}]`);
      }
    }
  }
  function h({ gen: S, parentData: x, parentDataProperty: P }, w) {
    S.if((0, n._)`${x} !== undefined`, () => S.assign((0, n._)`${x}[${P}]`, w));
  }
  function _(S, x, P, w = o.Correct) {
    const C = w === o.Correct ? n.operators.EQ : n.operators.NEQ;
    let k;
    switch (S) {
      case "null":
        return (0, n._)`${x} ${C} null`;
      case "array":
        k = (0, n._)`Array.isArray(${x})`;
        break;
      case "object":
        k = (0, n._)`${x} && typeof ${x} == "object" && !Array.isArray(${x})`;
        break;
      case "integer":
        k = $((0, n._)`!(${x} % 1) && !isNaN(${x})`);
        break;
      case "number":
        k = $();
        break;
      default:
        return (0, n._)`typeof ${x} ${C} ${S}`;
    }
    return w === o.Correct ? k : (0, n.not)(k);
    function $(T = n.nil) {
      return (0, n.and)((0, n._)`typeof ${x} == "number"`, T, P ? (0, n._)`isFinite(${x})` : n.nil);
    }
  }
  At.checkDataType = _;
  function b(S, x, P, w) {
    if (S.length === 1)
      return _(S[0], x, P, w);
    let C;
    const k = (0, s.toHash)(S);
    if (k.array && k.object) {
      const $ = (0, n._)`typeof ${x} != "object"`;
      C = k.null ? $ : (0, n._)`!${x} || ${$}`, delete k.null, delete k.array, delete k.object;
    } else
      C = n.nil;
    k.number && delete k.integer;
    for (const $ in k)
      C = (0, n.and)(C, _($, x, P, w));
    return C;
  }
  At.checkDataTypes = b;
  const p = {
    message: ({ schema: S }) => `must be ${S}`,
    params: ({ schema: S, schemaValue: x }) => typeof S == "string" ? (0, n._)`{type: ${S}}` : (0, n._)`{type: ${x}}`
  };
  function g(S) {
    const x = y(S);
    (0, r.reportError)(x, p);
  }
  At.reportTypeError = g;
  function y(S) {
    const { gen: x, data: P, schema: w } = S, C = (0, s.schemaRefOrVal)(S, w, "type");
    return {
      gen: x,
      keyword: "type",
      data: P,
      schema: w.type,
      schemaCode: C,
      schemaValue: C,
      parentSchema: w,
      params: {},
      it: S
    };
  }
  return At;
}
var Jo = {}, rp;
function Mk() {
  if (rp) return Jo;
  rp = 1, Object.defineProperty(Jo, "__esModule", { value: !0 }), Jo.assignDefaults = void 0;
  const t = He(), e = Qe();
  function r(s, o) {
    const { properties: i, items: a } = s.schema;
    if (o === "object" && i)
      for (const l in i)
        n(s, l, i[l].default);
    else o === "array" && Array.isArray(a) && a.forEach((l, u) => n(s, u, l.default));
  }
  Jo.assignDefaults = r;
  function n(s, o, i) {
    const { gen: a, compositeRule: l, data: u, opts: c } = s;
    if (i === void 0)
      return;
    const f = (0, t._)`${u}${(0, t.getProperty)(o)}`;
    if (l) {
      (0, e.checkStrictMode)(s, `default is ignored for: ${f}`);
      return;
    }
    let h = (0, t._)`${f} === undefined`;
    c.useDefaults === "empty" && (h = (0, t._)`${h} || ${f} === null || ${f} === ""`), a.if(h, (0, t._)`${f} = ${(0, t.stringify)(i)}`);
  }
  return Jo;
}
var Ar = {}, rt = {}, np;
function Kr() {
  if (np) return rt;
  np = 1, Object.defineProperty(rt, "__esModule", { value: !0 }), rt.validateUnion = rt.validateArray = rt.usePattern = rt.callValidateCode = rt.schemaProperties = rt.allSchemaProperties = rt.noPropertyInData = rt.propertyInData = rt.isOwnProperty = rt.hasPropFunc = rt.reportMissingProp = rt.checkMissingProp = rt.checkReportMissingProp = void 0;
  const t = He(), e = Qe(), r = cs(), n = Qe();
  function s(S, x) {
    const { gen: P, data: w, it: C } = S;
    P.if(c(P, w, x, C.opts.ownProperties), () => {
      S.setParams({ missingProperty: (0, t._)`${x}` }, !0), S.error();
    });
  }
  rt.checkReportMissingProp = s;
  function o({ gen: S, data: x, it: { opts: P } }, w, C) {
    return (0, t.or)(...w.map((k) => (0, t.and)(c(S, x, k, P.ownProperties), (0, t._)`${C} = ${k}`)));
  }
  rt.checkMissingProp = o;
  function i(S, x) {
    S.setParams({ missingProperty: x }, !0), S.error();
  }
  rt.reportMissingProp = i;
  function a(S) {
    return S.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, t._)`Object.prototype.hasOwnProperty`
    });
  }
  rt.hasPropFunc = a;
  function l(S, x, P) {
    return (0, t._)`${a(S)}.call(${x}, ${P})`;
  }
  rt.isOwnProperty = l;
  function u(S, x, P, w) {
    const C = (0, t._)`${x}${(0, t.getProperty)(P)} !== undefined`;
    return w ? (0, t._)`${C} && ${l(S, x, P)}` : C;
  }
  rt.propertyInData = u;
  function c(S, x, P, w) {
    const C = (0, t._)`${x}${(0, t.getProperty)(P)} === undefined`;
    return w ? (0, t.or)(C, (0, t.not)(l(S, x, P))) : C;
  }
  rt.noPropertyInData = c;
  function f(S) {
    return S ? Object.keys(S).filter((x) => x !== "__proto__") : [];
  }
  rt.allSchemaProperties = f;
  function h(S, x) {
    return f(x).filter((P) => !(0, e.alwaysValidSchema)(S, x[P]));
  }
  rt.schemaProperties = h;
  function _({ schemaCode: S, data: x, it: { gen: P, topSchemaRef: w, schemaPath: C, errorPath: k }, it: $ }, T, E, I) {
    const F = I ? (0, t._)`${S}, ${x}, ${w}${C}` : x, U = [
      [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, k)],
      [r.default.parentData, $.parentData],
      [r.default.parentDataProperty, $.parentDataProperty],
      [r.default.rootData, r.default.rootData]
    ];
    $.opts.dynamicRef && U.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const B = (0, t._)`${F}, ${P.object(...U)}`;
    return E !== t.nil ? (0, t._)`${T}.call(${E}, ${B})` : (0, t._)`${T}(${B})`;
  }
  rt.callValidateCode = _;
  const b = (0, t._)`new RegExp`;
  function p({ gen: S, it: { opts: x } }, P) {
    const w = x.unicodeRegExp ? "u" : "", { regExp: C } = x.code, k = C(P, w);
    return S.scopeValue("pattern", {
      key: k.toString(),
      ref: k,
      code: (0, t._)`${C.code === "new RegExp" ? b : (0, n.useFunc)(S, C)}(${P}, ${w})`
    });
  }
  rt.usePattern = p;
  function g(S) {
    const { gen: x, data: P, keyword: w, it: C } = S, k = x.name("valid");
    if (C.allErrors) {
      const T = x.let("valid", !0);
      return $(() => x.assign(T, !1)), T;
    }
    return x.var(k, !0), $(() => x.break()), k;
    function $(T) {
      const E = x.const("len", (0, t._)`${P}.length`);
      x.forRange("i", 0, E, (I) => {
        S.subschema({
          keyword: w,
          dataProp: I,
          dataPropType: e.Type.Num
        }, k), x.if((0, t.not)(k), T);
      });
    }
  }
  rt.validateArray = g;
  function y(S) {
    const { gen: x, schema: P, keyword: w, it: C } = S;
    if (!Array.isArray(P))
      throw new Error("ajv implementation error");
    if (P.some((E) => (0, e.alwaysValidSchema)(C, E)) && !C.opts.unevaluated)
      return;
    const $ = x.let("valid", !1), T = x.name("_valid");
    x.block(() => P.forEach((E, I) => {
      const F = S.subschema({
        keyword: w,
        schemaProp: I,
        compositeRule: !0
      }, T);
      x.assign($, (0, t._)`${$} || ${T}`), S.mergeValidEvaluated(F, T) || x.if((0, t.not)($));
    })), S.result($, () => S.reset(), () => S.error(!0));
  }
  return rt.validateUnion = y, rt;
}
var sp;
function Ik() {
  if (sp) return Ar;
  sp = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.validateKeywordUsage = Ar.validSchemaType = Ar.funcKeywordCode = Ar.macroKeywordCode = void 0;
  const t = He(), e = cs(), r = Kr(), n = Ql();
  function s(h, _) {
    const { gen: b, keyword: p, schema: g, parentSchema: y, it: S } = h, x = _.macro.call(S.self, g, y, S), P = u(b, p, x);
    S.opts.validateSchema !== !1 && S.self.validateSchema(x, !0);
    const w = b.name("valid");
    h.subschema({
      schema: x,
      schemaPath: t.nil,
      errSchemaPath: `${S.errSchemaPath}/${p}`,
      topSchemaRef: P,
      compositeRule: !0
    }, w), h.pass(w, () => h.error(!0));
  }
  Ar.macroKeywordCode = s;
  function o(h, _) {
    var b;
    const { gen: p, keyword: g, schema: y, parentSchema: S, $data: x, it: P } = h;
    l(P, _);
    const w = !x && _.compile ? _.compile.call(P.self, y, S, P) : _.validate, C = u(p, g, w), k = p.let("valid");
    h.block$data(k, $), h.ok((b = _.valid) !== null && b !== void 0 ? b : k);
    function $() {
      if (_.errors === !1)
        I(), _.modifying && i(h), F(() => h.error());
      else {
        const U = _.async ? T() : E();
        _.modifying && i(h), F(() => a(h, U));
      }
    }
    function T() {
      const U = p.let("ruleErrs", null);
      return p.try(() => I((0, t._)`await `), (B) => p.assign(k, !1).if((0, t._)`${B} instanceof ${P.ValidationError}`, () => p.assign(U, (0, t._)`${B}.errors`), () => p.throw(B))), U;
    }
    function E() {
      const U = (0, t._)`${C}.errors`;
      return p.assign(U, null), I(t.nil), U;
    }
    function I(U = _.async ? (0, t._)`await ` : t.nil) {
      const B = P.opts.passContext ? e.default.this : e.default.self, R = !("compile" in _ && !x || _.schema === !1);
      p.assign(k, (0, t._)`${U}${(0, r.callValidateCode)(h, C, B, R)}`, _.modifying);
    }
    function F(U) {
      var B;
      p.if((0, t.not)((B = _.valid) !== null && B !== void 0 ? B : k), U);
    }
  }
  Ar.funcKeywordCode = o;
  function i(h) {
    const { gen: _, data: b, it: p } = h;
    _.if(p.parentData, () => _.assign(b, (0, t._)`${p.parentData}[${p.parentDataProperty}]`));
  }
  function a(h, _) {
    const { gen: b } = h;
    b.if((0, t._)`Array.isArray(${_})`, () => {
      b.assign(e.default.vErrors, (0, t._)`${e.default.vErrors} === null ? ${_} : ${e.default.vErrors}.concat(${_})`).assign(e.default.errors, (0, t._)`${e.default.vErrors}.length`), (0, n.extendErrors)(h);
    }, () => h.error());
  }
  function l({ schemaEnv: h }, _) {
    if (_.async && !h.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(h, _, b) {
    if (b === void 0)
      throw new Error(`keyword "${_}" failed to compile`);
    return h.scopeValue("keyword", typeof b == "function" ? { ref: b } : { ref: b, code: (0, t.stringify)(b) });
  }
  function c(h, _, b = !1) {
    return !_.length || _.some((p) => p === "array" ? Array.isArray(h) : p === "object" ? h && typeof h == "object" && !Array.isArray(h) : typeof h == p || b && typeof h > "u");
  }
  Ar.validSchemaType = c;
  function f({ schema: h, opts: _, self: b, errSchemaPath: p }, g, y) {
    if (Array.isArray(g.keyword) ? !g.keyword.includes(y) : g.keyword !== y)
      throw new Error("ajv implementation error");
    const S = g.dependencies;
    if (S?.some((x) => !Object.prototype.hasOwnProperty.call(h, x)))
      throw new Error(`parent schema must have dependencies of ${y}: ${S.join(",")}`);
    if (g.validateSchema && !g.validateSchema(h[y])) {
      const P = `keyword "${y}" value is invalid at path "${p}": ` + b.errorsText(g.validateSchema.errors);
      if (_.validateSchema === "log")
        b.logger.error(P);
      else
        throw new Error(P);
    }
  }
  return Ar.validateKeywordUsage = f, Ar;
}
var pn = {}, op;
function Nk() {
  if (op) return pn;
  op = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.extendSubschemaMode = pn.extendSubschemaData = pn.getSubschema = void 0;
  const t = He(), e = Qe();
  function r(o, { keyword: i, schemaProp: a, schema: l, schemaPath: u, errSchemaPath: c, topSchemaRef: f }) {
    if (i !== void 0 && l !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (i !== void 0) {
      const h = o.schema[i];
      return a === void 0 ? {
        schema: h,
        schemaPath: (0, t._)`${o.schemaPath}${(0, t.getProperty)(i)}`,
        errSchemaPath: `${o.errSchemaPath}/${i}`
      } : {
        schema: h[a],
        schemaPath: (0, t._)`${o.schemaPath}${(0, t.getProperty)(i)}${(0, t.getProperty)(a)}`,
        errSchemaPath: `${o.errSchemaPath}/${i}/${(0, e.escapeFragment)(a)}`
      };
    }
    if (l !== void 0) {
      if (u === void 0 || c === void 0 || f === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: l,
        schemaPath: u,
        topSchemaRef: f,
        errSchemaPath: c
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  pn.getSubschema = r;
  function n(o, i, { dataProp: a, dataPropType: l, data: u, dataTypes: c, propertyName: f }) {
    if (u !== void 0 && a !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: h } = i;
    if (a !== void 0) {
      const { errorPath: b, dataPathArr: p, opts: g } = i, y = h.let("data", (0, t._)`${i.data}${(0, t.getProperty)(a)}`, !0);
      _(y), o.errorPath = (0, t.str)`${b}${(0, e.getErrorPath)(a, l, g.jsPropertySyntax)}`, o.parentDataProperty = (0, t._)`${a}`, o.dataPathArr = [...p, o.parentDataProperty];
    }
    if (u !== void 0) {
      const b = u instanceof t.Name ? u : h.let("data", u, !0);
      _(b), f !== void 0 && (o.propertyName = f);
    }
    c && (o.dataTypes = c);
    function _(b) {
      o.data = b, o.dataLevel = i.dataLevel + 1, o.dataTypes = [], i.definedProperties = /* @__PURE__ */ new Set(), o.parentData = i.data, o.dataNames = [...i.dataNames, b];
    }
  }
  pn.extendSubschemaData = n;
  function s(o, { jtdDiscriminator: i, jtdMetadata: a, compositeRule: l, createErrors: u, allErrors: c }) {
    l !== void 0 && (o.compositeRule = l), u !== void 0 && (o.createErrors = u), c !== void 0 && (o.allErrors = c), o.jtdDiscriminator = i, o.jtdMetadata = a;
  }
  return pn.extendSubschemaMode = s, pn;
}
var Lt = {}, Bu, ip;
function _b() {
  return ip || (ip = 1, Bu = function t(e, r) {
    if (e === r) return !0;
    if (e && r && typeof e == "object" && typeof r == "object") {
      if (e.constructor !== r.constructor) return !1;
      var n, s, o;
      if (Array.isArray(e)) {
        if (n = e.length, n != r.length) return !1;
        for (s = n; s-- !== 0; )
          if (!t(e[s], r[s])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === r.source && e.flags === r.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === r.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === r.toString();
      if (o = Object.keys(e), n = o.length, n !== Object.keys(r).length) return !1;
      for (s = n; s-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, o[s])) return !1;
      for (s = n; s-- !== 0; ) {
        var i = o[s];
        if (!t(e[i], r[i])) return !1;
      }
      return !0;
    }
    return e !== e && r !== r;
  }), Bu;
}
var zu = { exports: {} }, ap;
function Fk() {
  if (ap) return zu.exports;
  ap = 1;
  var t = zu.exports = function(n, s, o) {
    typeof s == "function" && (o = s, s = {}), o = s.cb || o;
    var i = typeof o == "function" ? o : o.pre || function() {
    }, a = o.post || function() {
    };
    e(s, i, a, n, "", n);
  };
  t.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, t.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, t.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, t.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function e(n, s, o, i, a, l, u, c, f, h) {
    if (i && typeof i == "object" && !Array.isArray(i)) {
      s(i, a, l, u, c, f, h);
      for (var _ in i) {
        var b = i[_];
        if (Array.isArray(b)) {
          if (_ in t.arrayKeywords)
            for (var p = 0; p < b.length; p++)
              e(n, s, o, b[p], a + "/" + _ + "/" + p, l, a, _, i, p);
        } else if (_ in t.propsKeywords) {
          if (b && typeof b == "object")
            for (var g in b)
              e(n, s, o, b[g], a + "/" + _ + "/" + r(g), l, a, _, i, g);
        } else (_ in t.keywords || n.allKeys && !(_ in t.skipKeywords)) && e(n, s, o, b, a + "/" + _, l, a, _, i);
      }
      o(i, a, l, u, c, f, h);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return zu.exports;
}
var lp;
function eu() {
  if (lp) return Lt;
  lp = 1, Object.defineProperty(Lt, "__esModule", { value: !0 }), Lt.getSchemaRefs = Lt.resolveUrl = Lt.normalizeId = Lt._getFullPath = Lt.getFullPath = Lt.inlineRef = void 0;
  const t = Qe(), e = _b(), r = Fk(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function s(p, g = !0) {
    return typeof p == "boolean" ? !0 : g === !0 ? !i(p) : g ? a(p) <= g : !1;
  }
  Lt.inlineRef = s;
  const o = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function i(p) {
    for (const g in p) {
      if (o.has(g))
        return !0;
      const y = p[g];
      if (Array.isArray(y) && y.some(i) || typeof y == "object" && i(y))
        return !0;
    }
    return !1;
  }
  function a(p) {
    let g = 0;
    for (const y in p) {
      if (y === "$ref")
        return 1 / 0;
      if (g++, !n.has(y) && (typeof p[y] == "object" && (0, t.eachItem)(p[y], (S) => g += a(S)), g === 1 / 0))
        return 1 / 0;
    }
    return g;
  }
  function l(p, g = "", y) {
    y !== !1 && (g = f(g));
    const S = p.parse(g);
    return u(p, S);
  }
  Lt.getFullPath = l;
  function u(p, g) {
    return p.serialize(g).split("#")[0] + "#";
  }
  Lt._getFullPath = u;
  const c = /#\/?$/;
  function f(p) {
    return p ? p.replace(c, "") : "";
  }
  Lt.normalizeId = f;
  function h(p, g, y) {
    return y = f(y), p.resolve(g, y);
  }
  Lt.resolveUrl = h;
  const _ = /^[a-z_][-a-z0-9._]*$/i;
  function b(p, g) {
    if (typeof p == "boolean")
      return {};
    const { schemaId: y, uriResolver: S } = this.opts, x = f(p[y] || g), P = { "": x }, w = l(S, x, !1), C = {}, k = /* @__PURE__ */ new Set();
    return r(p, { allKeys: !0 }, (E, I, F, U) => {
      if (U === void 0)
        return;
      const B = w + I;
      let R = P[U];
      typeof E[y] == "string" && (R = Z.call(this, E[y])), Y.call(this, E.$anchor), Y.call(this, E.$dynamicAnchor), P[I] = R;
      function Z(X) {
        const ae = this.opts.uriResolver.resolve;
        if (X = f(R ? ae(R, X) : X), k.has(X))
          throw T(X);
        k.add(X);
        let J = this.refs[X];
        return typeof J == "string" && (J = this.refs[J]), typeof J == "object" ? $(E, J.schema, X) : X !== f(B) && (X[0] === "#" ? ($(E, C[X], X), C[X] = E) : this.refs[X] = B), X;
      }
      function Y(X) {
        if (typeof X == "string") {
          if (!_.test(X))
            throw new Error(`invalid anchor "${X}"`);
          Z.call(this, `#${X}`);
        }
      }
    }), C;
    function $(E, I, F) {
      if (I !== void 0 && !e(E, I))
        throw T(F);
    }
    function T(E) {
      return new Error(`reference "${E}" resolves to more than one schema`);
    }
  }
  return Lt.getSchemaRefs = b, Lt;
}
var up;
function tu() {
  if (up) return hn;
  up = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.getData = hn.KeywordCxt = hn.validateFunctionCode = void 0;
  const t = Dk(), e = il(), r = bb(), n = il(), s = Mk(), o = Ik(), i = Nk(), a = He(), l = cs(), u = eu(), c = Qe(), f = Ql();
  function h(re) {
    if (w(re) && (k(re), P(re))) {
      g(re);
      return;
    }
    _(re, () => (0, t.topBoolOrEmptySchema)(re));
  }
  hn.validateFunctionCode = h;
  function _({ gen: re, validateName: oe, schema: pe, schemaEnv: ye, opts: Pe }, Oe) {
    Pe.code.es5 ? re.func(oe, (0, a._)`${l.default.data}, ${l.default.valCxt}`, ye.$async, () => {
      re.code((0, a._)`"use strict"; ${S(pe, Pe)}`), p(re, Pe), re.code(Oe);
    }) : re.func(oe, (0, a._)`${l.default.data}, ${b(Pe)}`, ye.$async, () => re.code(S(pe, Pe)).code(Oe));
  }
  function b(re) {
    return (0, a._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${re.dynamicRef ? (0, a._)`, ${l.default.dynamicAnchors}={}` : a.nil}}={}`;
  }
  function p(re, oe) {
    re.if(l.default.valCxt, () => {
      re.var(l.default.instancePath, (0, a._)`${l.default.valCxt}.${l.default.instancePath}`), re.var(l.default.parentData, (0, a._)`${l.default.valCxt}.${l.default.parentData}`), re.var(l.default.parentDataProperty, (0, a._)`${l.default.valCxt}.${l.default.parentDataProperty}`), re.var(l.default.rootData, (0, a._)`${l.default.valCxt}.${l.default.rootData}`), oe.dynamicRef && re.var(l.default.dynamicAnchors, (0, a._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
    }, () => {
      re.var(l.default.instancePath, (0, a._)`""`), re.var(l.default.parentData, (0, a._)`undefined`), re.var(l.default.parentDataProperty, (0, a._)`undefined`), re.var(l.default.rootData, l.default.data), oe.dynamicRef && re.var(l.default.dynamicAnchors, (0, a._)`{}`);
    });
  }
  function g(re) {
    const { schema: oe, opts: pe, gen: ye } = re;
    _(re, () => {
      pe.$comment && oe.$comment && U(re), E(re), ye.let(l.default.vErrors, null), ye.let(l.default.errors, 0), pe.unevaluated && y(re), $(re), B(re);
    });
  }
  function y(re) {
    const { gen: oe, validateName: pe } = re;
    re.evaluated = oe.const("evaluated", (0, a._)`${pe}.evaluated`), oe.if((0, a._)`${re.evaluated}.dynamicProps`, () => oe.assign((0, a._)`${re.evaluated}.props`, (0, a._)`undefined`)), oe.if((0, a._)`${re.evaluated}.dynamicItems`, () => oe.assign((0, a._)`${re.evaluated}.items`, (0, a._)`undefined`));
  }
  function S(re, oe) {
    const pe = typeof re == "object" && re[oe.schemaId];
    return pe && (oe.code.source || oe.code.process) ? (0, a._)`/*# sourceURL=${pe} */` : a.nil;
  }
  function x(re, oe) {
    if (w(re) && (k(re), P(re))) {
      C(re, oe);
      return;
    }
    (0, t.boolOrEmptySchema)(re, oe);
  }
  function P({ schema: re, self: oe }) {
    if (typeof re == "boolean")
      return !re;
    for (const pe in re)
      if (oe.RULES.all[pe])
        return !0;
    return !1;
  }
  function w(re) {
    return typeof re.schema != "boolean";
  }
  function C(re, oe) {
    const { schema: pe, gen: ye, opts: Pe } = re;
    Pe.$comment && pe.$comment && U(re), I(re), F(re);
    const Oe = ye.const("_errs", l.default.errors);
    $(re, Oe), ye.var(oe, (0, a._)`${Oe} === ${l.default.errors}`);
  }
  function k(re) {
    (0, c.checkUnknownRules)(re), T(re);
  }
  function $(re, oe) {
    if (re.opts.jtd)
      return Z(re, [], !1, oe);
    const pe = (0, e.getSchemaTypes)(re.schema), ye = (0, e.coerceAndCheckDataType)(re, pe);
    Z(re, pe, !ye, oe);
  }
  function T(re) {
    const { schema: oe, errSchemaPath: pe, opts: ye, self: Pe } = re;
    oe.$ref && ye.ignoreKeywordsWithRef && (0, c.schemaHasRulesButRef)(oe, Pe.RULES) && Pe.logger.warn(`$ref: keywords ignored in schema at path "${pe}"`);
  }
  function E(re) {
    const { schema: oe, opts: pe } = re;
    oe.default !== void 0 && pe.useDefaults && pe.strictSchema && (0, c.checkStrictMode)(re, "default is ignored in the schema root");
  }
  function I(re) {
    const oe = re.schema[re.opts.schemaId];
    oe && (re.baseId = (0, u.resolveUrl)(re.opts.uriResolver, re.baseId, oe));
  }
  function F(re) {
    if (re.schema.$async && !re.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function U({ gen: re, schemaEnv: oe, schema: pe, errSchemaPath: ye, opts: Pe }) {
    const Oe = pe.$comment;
    if (Pe.$comment === !0)
      re.code((0, a._)`${l.default.self}.logger.log(${Oe})`);
    else if (typeof Pe.$comment == "function") {
      const Ve = (0, a.str)`${ye}/$comment`, Ke = re.scopeValue("root", { ref: oe.root });
      re.code((0, a._)`${l.default.self}.opts.$comment(${Oe}, ${Ve}, ${Ke}.schema)`);
    }
  }
  function B(re) {
    const { gen: oe, schemaEnv: pe, validateName: ye, ValidationError: Pe, opts: Oe } = re;
    pe.$async ? oe.if((0, a._)`${l.default.errors} === 0`, () => oe.return(l.default.data), () => oe.throw((0, a._)`new ${Pe}(${l.default.vErrors})`)) : (oe.assign((0, a._)`${ye}.errors`, l.default.vErrors), Oe.unevaluated && R(re), oe.return((0, a._)`${l.default.errors} === 0`));
  }
  function R({ gen: re, evaluated: oe, props: pe, items: ye }) {
    pe instanceof a.Name && re.assign((0, a._)`${oe}.props`, pe), ye instanceof a.Name && re.assign((0, a._)`${oe}.items`, ye);
  }
  function Z(re, oe, pe, ye) {
    const { gen: Pe, schema: Oe, data: Ve, allErrors: Ke, opts: Le, self: je } = re, { RULES: We } = je;
    if (Oe.$ref && (Le.ignoreKeywordsWithRef || !(0, c.schemaHasRulesButRef)(Oe, We))) {
      Pe.block(() => fe(re, "$ref", We.all.$ref.definition));
      return;
    }
    Le.jtd || X(re, oe), Pe.block(() => {
      for (const Ze of We.rules)
        gt(Ze);
      gt(We.post);
    });
    function gt(Ze) {
      (0, r.shouldUseGroup)(Oe, Ze) && (Ze.type ? (Pe.if((0, n.checkDataType)(Ze.type, Ve, Le.strictNumbers)), Y(re, Ze), oe.length === 1 && oe[0] === Ze.type && pe && (Pe.else(), (0, n.reportTypeError)(re)), Pe.endIf()) : Y(re, Ze), Ke || Pe.if((0, a._)`${l.default.errors} === ${ye || 0}`));
    }
  }
  function Y(re, oe) {
    const { gen: pe, schema: ye, opts: { useDefaults: Pe } } = re;
    Pe && (0, s.assignDefaults)(re, oe.type), pe.block(() => {
      for (const Oe of oe.rules)
        (0, r.shouldUseRule)(ye, Oe) && fe(re, Oe.keyword, Oe.definition, oe.type);
    });
  }
  function X(re, oe) {
    re.schemaEnv.meta || !re.opts.strictTypes || (ae(re, oe), re.opts.allowUnionTypes || J(re, oe), j(re, re.dataTypes));
  }
  function ae(re, oe) {
    if (oe.length) {
      if (!re.dataTypes.length) {
        re.dataTypes = oe;
        return;
      }
      oe.forEach((pe) => {
        L(re.dataTypes, pe) || V(re, `type "${pe}" not allowed by context "${re.dataTypes.join(",")}"`);
      }), N(re, oe);
    }
  }
  function J(re, oe) {
    oe.length > 1 && !(oe.length === 2 && oe.includes("null")) && V(re, "use allowUnionTypes to allow union type keyword");
  }
  function j(re, oe) {
    const pe = re.self.RULES.all;
    for (const ye in pe) {
      const Pe = pe[ye];
      if (typeof Pe == "object" && (0, r.shouldUseRule)(re.schema, Pe)) {
        const { type: Oe } = Pe.definition;
        Oe.length && !Oe.some((Ve) => ee(oe, Ve)) && V(re, `missing type "${Oe.join(",")}" for keyword "${ye}"`);
      }
    }
  }
  function ee(re, oe) {
    return re.includes(oe) || oe === "number" && re.includes("integer");
  }
  function L(re, oe) {
    return re.includes(oe) || oe === "integer" && re.includes("number");
  }
  function N(re, oe) {
    const pe = [];
    for (const ye of re.dataTypes)
      L(oe, ye) ? pe.push(ye) : oe.includes("integer") && ye === "number" && pe.push("integer");
    re.dataTypes = pe;
  }
  function V(re, oe) {
    const pe = re.schemaEnv.baseId + re.errSchemaPath;
    oe += ` at "${pe}" (strictTypes)`, (0, c.checkStrictMode)(re, oe, re.opts.strictTypes);
  }
  class G {
    constructor(oe, pe, ye) {
      if ((0, o.validateKeywordUsage)(oe, pe, ye), this.gen = oe.gen, this.allErrors = oe.allErrors, this.keyword = ye, this.data = oe.data, this.schema = oe.schema[ye], this.$data = pe.$data && oe.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, c.schemaRefOrVal)(oe, this.schema, ye, this.$data), this.schemaType = pe.schemaType, this.parentSchema = oe.schema, this.params = {}, this.it = oe, this.def = pe, this.$data)
        this.schemaCode = oe.gen.const("vSchema", le(this.$data, oe));
      else if (this.schemaCode = this.schemaValue, !(0, o.validSchemaType)(this.schema, pe.schemaType, pe.allowUndefined))
        throw new Error(`${ye} value must be ${JSON.stringify(pe.schemaType)}`);
      ("code" in pe ? pe.trackErrors : pe.errors !== !1) && (this.errsCount = oe.gen.const("_errs", l.default.errors));
    }
    result(oe, pe, ye) {
      this.failResult((0, a.not)(oe), pe, ye);
    }
    failResult(oe, pe, ye) {
      this.gen.if(oe), ye ? ye() : this.error(), pe ? (this.gen.else(), pe(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(oe, pe) {
      this.failResult((0, a.not)(oe), void 0, pe);
    }
    fail(oe) {
      if (oe === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(oe), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(oe) {
      if (!this.$data)
        return this.fail(oe);
      const { schemaCode: pe } = this;
      this.fail((0, a._)`${pe} !== undefined && (${(0, a.or)(this.invalid$data(), oe)})`);
    }
    error(oe, pe, ye) {
      if (pe) {
        this.setParams(pe), this._error(oe, ye), this.setParams({});
        return;
      }
      this._error(oe, ye);
    }
    _error(oe, pe) {
      (oe ? f.reportExtraError : f.reportError)(this, this.def.error, pe);
    }
    $dataError() {
      (0, f.reportError)(this, this.def.$dataError || f.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, f.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(oe) {
      this.allErrors || this.gen.if(oe);
    }
    setParams(oe, pe) {
      pe ? Object.assign(this.params, oe) : this.params = oe;
    }
    block$data(oe, pe, ye = a.nil) {
      this.gen.block(() => {
        this.check$data(oe, ye), pe();
      });
    }
    check$data(oe = a.nil, pe = a.nil) {
      if (!this.$data)
        return;
      const { gen: ye, schemaCode: Pe, schemaType: Oe, def: Ve } = this;
      ye.if((0, a.or)((0, a._)`${Pe} === undefined`, pe)), oe !== a.nil && ye.assign(oe, !0), (Oe.length || Ve.validateSchema) && (ye.elseIf(this.invalid$data()), this.$dataError(), oe !== a.nil && ye.assign(oe, !1)), ye.else();
    }
    invalid$data() {
      const { gen: oe, schemaCode: pe, schemaType: ye, def: Pe, it: Oe } = this;
      return (0, a.or)(Ve(), Ke());
      function Ve() {
        if (ye.length) {
          if (!(pe instanceof a.Name))
            throw new Error("ajv implementation error");
          const Le = Array.isArray(ye) ? ye : [ye];
          return (0, a._)`${(0, n.checkDataTypes)(Le, pe, Oe.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return a.nil;
      }
      function Ke() {
        if (Pe.validateSchema) {
          const Le = oe.scopeValue("validate$data", { ref: Pe.validateSchema });
          return (0, a._)`!${Le}(${pe})`;
        }
        return a.nil;
      }
    }
    subschema(oe, pe) {
      const ye = (0, i.getSubschema)(this.it, oe);
      (0, i.extendSubschemaData)(ye, this.it, oe), (0, i.extendSubschemaMode)(ye, oe);
      const Pe = { ...this.it, ...ye, items: void 0, props: void 0 };
      return x(Pe, pe), Pe;
    }
    mergeEvaluated(oe, pe) {
      const { it: ye, gen: Pe } = this;
      ye.opts.unevaluated && (ye.props !== !0 && oe.props !== void 0 && (ye.props = c.mergeEvaluated.props(Pe, oe.props, ye.props, pe)), ye.items !== !0 && oe.items !== void 0 && (ye.items = c.mergeEvaluated.items(Pe, oe.items, ye.items, pe)));
    }
    mergeValidEvaluated(oe, pe) {
      const { it: ye, gen: Pe } = this;
      if (ye.opts.unevaluated && (ye.props !== !0 || ye.items !== !0))
        return Pe.if(pe, () => this.mergeEvaluated(oe, a.Name)), !0;
    }
  }
  hn.KeywordCxt = G;
  function fe(re, oe, pe, ye) {
    const Pe = new G(re, pe, oe);
    "code" in pe ? pe.code(Pe, ye) : Pe.$data && pe.validate ? (0, o.funcKeywordCode)(Pe, pe) : "macro" in pe ? (0, o.macroKeywordCode)(Pe, pe) : (pe.compile || pe.validate) && (0, o.funcKeywordCode)(Pe, pe);
  }
  const se = /^\/(?:[^~]|~0|~1)*$/, we = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function le(re, { dataLevel: oe, dataNames: pe, dataPathArr: ye }) {
    let Pe, Oe;
    if (re === "")
      return l.default.rootData;
    if (re[0] === "/") {
      if (!se.test(re))
        throw new Error(`Invalid JSON-pointer: ${re}`);
      Pe = re, Oe = l.default.rootData;
    } else {
      const je = we.exec(re);
      if (!je)
        throw new Error(`Invalid JSON-pointer: ${re}`);
      const We = +je[1];
      if (Pe = je[2], Pe === "#") {
        if (We >= oe)
          throw new Error(Le("property/index", We));
        return ye[oe - We];
      }
      if (We > oe)
        throw new Error(Le("data", We));
      if (Oe = pe[oe - We], !Pe)
        return Oe;
    }
    let Ve = Oe;
    const Ke = Pe.split("/");
    for (const je of Ke)
      je && (Oe = (0, a._)`${Oe}${(0, a.getProperty)((0, c.unescapeJsonPointer)(je))}`, Ve = (0, a._)`${Ve} && ${Oe}`);
    return Ve;
    function Le(je, We) {
      return `Cannot access ${je} ${We} levels up, current level is ${oe}`;
    }
  }
  return hn.getData = le, hn;
}
var Yi = {}, cp;
function Ld() {
  if (cp) return Yi;
  cp = 1, Object.defineProperty(Yi, "__esModule", { value: !0 });
  class t extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return Yi.default = t, Yi;
}
var Xi = {}, dp;
function ru() {
  if (dp) return Xi;
  dp = 1, Object.defineProperty(Xi, "__esModule", { value: !0 });
  const t = eu();
  class e extends Error {
    constructor(n, s, o, i) {
      super(i || `can't resolve reference ${o} from id ${s}`), this.missingRef = (0, t.resolveUrl)(n, s, o), this.missingSchema = (0, t.normalizeId)((0, t.getFullPath)(n, this.missingRef));
    }
  }
  return Xi.default = e, Xi;
}
var ar = {}, fp;
function jd() {
  if (fp) return ar;
  fp = 1, Object.defineProperty(ar, "__esModule", { value: !0 }), ar.resolveSchema = ar.getCompilingSchema = ar.resolveRef = ar.compileSchema = ar.SchemaEnv = void 0;
  const t = He(), e = Ld(), r = cs(), n = eu(), s = Qe(), o = tu();
  class i {
    constructor(y) {
      var S;
      this.refs = {}, this.dynamicAnchors = {};
      let x;
      typeof y.schema == "object" && (x = y.schema), this.schema = y.schema, this.schemaId = y.schemaId, this.root = y.root || this, this.baseId = (S = y.baseId) !== null && S !== void 0 ? S : (0, n.normalizeId)(x?.[y.schemaId || "$id"]), this.schemaPath = y.schemaPath, this.localRefs = y.localRefs, this.meta = y.meta, this.$async = x?.$async, this.refs = {};
    }
  }
  ar.SchemaEnv = i;
  function a(g) {
    const y = c.call(this, g);
    if (y)
      return y;
    const S = (0, n.getFullPath)(this.opts.uriResolver, g.root.baseId), { es5: x, lines: P } = this.opts.code, { ownProperties: w } = this.opts, C = new t.CodeGen(this.scope, { es5: x, lines: P, ownProperties: w });
    let k;
    g.$async && (k = C.scopeValue("Error", {
      ref: e.default,
      code: (0, t._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const $ = C.scopeName("validate");
    g.validateName = $;
    const T = {
      gen: C,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [t.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: C.scopeValue("schema", this.opts.code.source === !0 ? { ref: g.schema, code: (0, t.stringify)(g.schema) } : { ref: g.schema }),
      validateName: $,
      ValidationError: k,
      schema: g.schema,
      schemaEnv: g,
      rootId: S,
      baseId: g.baseId || S,
      schemaPath: t.nil,
      errSchemaPath: g.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, t._)`""`,
      opts: this.opts,
      self: this
    };
    let E;
    try {
      this._compilations.add(g), (0, o.validateFunctionCode)(T), C.optimize(this.opts.code.optimize);
      const I = C.toString();
      E = `${C.scopeRefs(r.default.scope)}return ${I}`, this.opts.code.process && (E = this.opts.code.process(E, g));
      const U = new Function(`${r.default.self}`, `${r.default.scope}`, E)(this, this.scope.get());
      if (this.scope.value($, { ref: U }), U.errors = null, U.schema = g.schema, U.schemaEnv = g, g.$async && (U.$async = !0), this.opts.code.source === !0 && (U.source = { validateName: $, validateCode: I, scopeValues: C._values }), this.opts.unevaluated) {
        const { props: B, items: R } = T;
        U.evaluated = {
          props: B instanceof t.Name ? void 0 : B,
          items: R instanceof t.Name ? void 0 : R,
          dynamicProps: B instanceof t.Name,
          dynamicItems: R instanceof t.Name
        }, U.source && (U.source.evaluated = (0, t.stringify)(U.evaluated));
      }
      return g.validate = U, g;
    } catch (I) {
      throw delete g.validate, delete g.validateName, E && this.logger.error("Error compiling schema, function code:", E), I;
    } finally {
      this._compilations.delete(g);
    }
  }
  ar.compileSchema = a;
  function l(g, y, S) {
    var x;
    S = (0, n.resolveUrl)(this.opts.uriResolver, y, S);
    const P = g.refs[S];
    if (P)
      return P;
    let w = h.call(this, g, S);
    if (w === void 0) {
      const C = (x = g.localRefs) === null || x === void 0 ? void 0 : x[S], { schemaId: k } = this.opts;
      C && (w = new i({ schema: C, schemaId: k, root: g, baseId: y }));
    }
    if (w !== void 0)
      return g.refs[S] = u.call(this, w);
  }
  ar.resolveRef = l;
  function u(g) {
    return (0, n.inlineRef)(g.schema, this.opts.inlineRefs) ? g.schema : g.validate ? g : a.call(this, g);
  }
  function c(g) {
    for (const y of this._compilations)
      if (f(y, g))
        return y;
  }
  ar.getCompilingSchema = c;
  function f(g, y) {
    return g.schema === y.schema && g.root === y.root && g.baseId === y.baseId;
  }
  function h(g, y) {
    let S;
    for (; typeof (S = this.refs[y]) == "string"; )
      y = S;
    return S || this.schemas[y] || _.call(this, g, y);
  }
  function _(g, y) {
    const S = this.opts.uriResolver.parse(y), x = (0, n._getFullPath)(this.opts.uriResolver, S);
    let P = (0, n.getFullPath)(this.opts.uriResolver, g.baseId, void 0);
    if (Object.keys(g.schema).length > 0 && x === P)
      return p.call(this, S, g);
    const w = (0, n.normalizeId)(x), C = this.refs[w] || this.schemas[w];
    if (typeof C == "string") {
      const k = _.call(this, g, C);
      return typeof k?.schema != "object" ? void 0 : p.call(this, S, k);
    }
    if (typeof C?.schema == "object") {
      if (C.validate || a.call(this, C), w === (0, n.normalizeId)(y)) {
        const { schema: k } = C, { schemaId: $ } = this.opts, T = k[$];
        return T && (P = (0, n.resolveUrl)(this.opts.uriResolver, P, T)), new i({ schema: k, schemaId: $, root: g, baseId: P });
      }
      return p.call(this, S, C);
    }
  }
  ar.resolveSchema = _;
  const b = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function p(g, { baseId: y, schema: S, root: x }) {
    var P;
    if (((P = g.fragment) === null || P === void 0 ? void 0 : P[0]) !== "/")
      return;
    for (const k of g.fragment.slice(1).split("/")) {
      if (typeof S == "boolean")
        return;
      const $ = S[(0, s.unescapeFragment)(k)];
      if ($ === void 0)
        return;
      S = $;
      const T = typeof S == "object" && S[this.opts.schemaId];
      !b.has(k) && T && (y = (0, n.resolveUrl)(this.opts.uriResolver, y, T));
    }
    let w;
    if (typeof S != "boolean" && S.$ref && !(0, s.schemaHasRulesButRef)(S, this.RULES)) {
      const k = (0, n.resolveUrl)(this.opts.uriResolver, y, S.$ref);
      w = _.call(this, x, k);
    }
    const { schemaId: C } = this.opts;
    if (w = w || new i({ schema: S, schemaId: C, root: x, baseId: y }), w.schema !== w.root.schema)
      return w;
  }
  return ar;
}
const Rk = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", Vk = "Meta-schema for $data reference (JSON AnySchema extension proposal)", Lk = "object", jk = ["$data"], Bk = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, zk = !1, qk = {
  $id: Rk,
  description: Vk,
  type: Lk,
  required: jk,
  properties: Bk,
  additionalProperties: zk
};
var Ji = {}, Zo = { exports: {} }, qu, hp;
function wb() {
  if (hp) return qu;
  hp = 1;
  const t = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), e = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function r(h) {
    let _ = "", b = 0, p = 0;
    for (p = 0; p < h.length; p++)
      if (b = h[p].charCodeAt(0), b !== 48) {
        if (!(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
          return "";
        _ += h[p];
        break;
      }
    for (p += 1; p < h.length; p++) {
      if (b = h[p].charCodeAt(0), !(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
        return "";
      _ += h[p];
    }
    return _;
  }
  const n = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function s(h) {
    return h.length = 0, !0;
  }
  function o(h, _, b) {
    if (h.length) {
      const p = r(h);
      if (p !== "")
        _.push(p);
      else
        return b.error = !0, !1;
      h.length = 0;
    }
    return !0;
  }
  function i(h) {
    let _ = 0;
    const b = { error: !1, address: "", zone: "" }, p = [], g = [];
    let y = !1, S = !1, x = o;
    for (let P = 0; P < h.length; P++) {
      const w = h[P];
      if (!(w === "[" || w === "]"))
        if (w === ":") {
          if (y === !0 && (S = !0), !x(g, p, b))
            break;
          if (++_ > 7) {
            b.error = !0;
            break;
          }
          P > 0 && h[P - 1] === ":" && (y = !0), p.push(":");
          continue;
        } else if (w === "%") {
          if (!x(g, p, b))
            break;
          x = s;
        } else {
          g.push(w);
          continue;
        }
    }
    return g.length && (x === s ? b.zone = g.join("") : S ? p.push(g.join("")) : p.push(r(g))), b.address = p.join(""), b;
  }
  function a(h) {
    if (l(h, ":") < 2)
      return { host: h, isIPV6: !1 };
    const _ = i(h);
    if (_.error)
      return { host: h, isIPV6: !1 };
    {
      let b = _.address, p = _.address;
      return _.zone && (b += "%" + _.zone, p += "%25" + _.zone), { host: b, isIPV6: !0, escapedHost: p };
    }
  }
  function l(h, _) {
    let b = 0;
    for (let p = 0; p < h.length; p++)
      h[p] === _ && b++;
    return b;
  }
  function u(h) {
    let _ = h;
    const b = [];
    let p = -1, g = 0;
    for (; g = _.length; ) {
      if (g === 1) {
        if (_ === ".")
          break;
        if (_ === "/") {
          b.push("/");
          break;
        } else {
          b.push(_);
          break;
        }
      } else if (g === 2) {
        if (_[0] === ".") {
          if (_[1] === ".")
            break;
          if (_[1] === "/") {
            _ = _.slice(2);
            continue;
          }
        } else if (_[0] === "/" && (_[1] === "." || _[1] === "/")) {
          b.push("/");
          break;
        }
      } else if (g === 3 && _ === "/..") {
        b.length !== 0 && b.pop(), b.push("/");
        break;
      }
      if (_[0] === ".") {
        if (_[1] === ".") {
          if (_[2] === "/") {
            _ = _.slice(3);
            continue;
          }
        } else if (_[1] === "/") {
          _ = _.slice(2);
          continue;
        }
      } else if (_[0] === "/" && _[1] === ".") {
        if (_[2] === "/") {
          _ = _.slice(2);
          continue;
        } else if (_[2] === "." && _[3] === "/") {
          _ = _.slice(3), b.length !== 0 && b.pop();
          continue;
        }
      }
      if ((p = _.indexOf("/", 1)) === -1) {
        b.push(_);
        break;
      } else
        b.push(_.slice(0, p)), _ = _.slice(p);
    }
    return b.join("");
  }
  function c(h, _) {
    const b = _ !== !0 ? escape : unescape;
    return h.scheme !== void 0 && (h.scheme = b(h.scheme)), h.userinfo !== void 0 && (h.userinfo = b(h.userinfo)), h.host !== void 0 && (h.host = b(h.host)), h.path !== void 0 && (h.path = b(h.path)), h.query !== void 0 && (h.query = b(h.query)), h.fragment !== void 0 && (h.fragment = b(h.fragment)), h;
  }
  function f(h) {
    const _ = [];
    if (h.userinfo !== void 0 && (_.push(h.userinfo), _.push("@")), h.host !== void 0) {
      let b = unescape(h.host);
      if (!e(b)) {
        const p = a(b);
        p.isIPV6 === !0 ? b = `[${p.escapedHost}]` : b = h.host;
      }
      _.push(b);
    }
    return (typeof h.port == "number" || typeof h.port == "string") && (_.push(":"), _.push(String(h.port))), _.length ? _.join("") : void 0;
  }
  return qu = {
    nonSimpleDomain: n,
    recomposeAuthority: f,
    normalizeComponentEncoding: c,
    removeDotSegments: u,
    isIPv4: e,
    isUUID: t,
    normalizeIPv6: a,
    stringArrayToHexStripped: r
  }, qu;
}
var Uu, gp;
function Uk() {
  if (gp) return Uu;
  gp = 1;
  const { isUUID: t } = wb(), e = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, r = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function n(w) {
    return r.indexOf(
      /** @type {*} */
      w
    ) !== -1;
  }
  function s(w) {
    return w.secure === !0 ? !0 : w.secure === !1 ? !1 : w.scheme ? w.scheme.length === 3 && (w.scheme[0] === "w" || w.scheme[0] === "W") && (w.scheme[1] === "s" || w.scheme[1] === "S") && (w.scheme[2] === "s" || w.scheme[2] === "S") : !1;
  }
  function o(w) {
    return w.host || (w.error = w.error || "HTTP URIs must have a host."), w;
  }
  function i(w) {
    const C = String(w.scheme).toLowerCase() === "https";
    return (w.port === (C ? 443 : 80) || w.port === "") && (w.port = void 0), w.path || (w.path = "/"), w;
  }
  function a(w) {
    return w.secure = s(w), w.resourceName = (w.path || "/") + (w.query ? "?" + w.query : ""), w.path = void 0, w.query = void 0, w;
  }
  function l(w) {
    if ((w.port === (s(w) ? 443 : 80) || w.port === "") && (w.port = void 0), typeof w.secure == "boolean" && (w.scheme = w.secure ? "wss" : "ws", w.secure = void 0), w.resourceName) {
      const [C, k] = w.resourceName.split("?");
      w.path = C && C !== "/" ? C : void 0, w.query = k, w.resourceName = void 0;
    }
    return w.fragment = void 0, w;
  }
  function u(w, C) {
    if (!w.path)
      return w.error = "URN can not be parsed", w;
    const k = w.path.match(e);
    if (k) {
      const $ = C.scheme || w.scheme || "urn";
      w.nid = k[1].toLowerCase(), w.nss = k[2];
      const T = `${$}:${C.nid || w.nid}`, E = P(T);
      w.path = void 0, E && (w = E.parse(w, C));
    } else
      w.error = w.error || "URN can not be parsed.";
    return w;
  }
  function c(w, C) {
    if (w.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const k = C.scheme || w.scheme || "urn", $ = w.nid.toLowerCase(), T = `${k}:${C.nid || $}`, E = P(T);
    E && (w = E.serialize(w, C));
    const I = w, F = w.nss;
    return I.path = `${$ || C.nid}:${F}`, C.skipEscape = !0, I;
  }
  function f(w, C) {
    const k = w;
    return k.uuid = k.nss, k.nss = void 0, !C.tolerant && (!k.uuid || !t(k.uuid)) && (k.error = k.error || "UUID is not valid."), k;
  }
  function h(w) {
    const C = w;
    return C.nss = (w.uuid || "").toLowerCase(), C;
  }
  const _ = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: o,
      serialize: i
    }
  ), b = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: _.domainHost,
      parse: o,
      serialize: i
    }
  ), p = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: a,
      serialize: l
    }
  ), g = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: p.domainHost,
      parse: p.parse,
      serialize: p.serialize
    }
  ), x = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: _,
      https: b,
      ws: p,
      wss: g,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: u,
          serialize: c,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: f,
          serialize: h,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(x, null);
  function P(w) {
    return w && (x[
      /** @type {SchemeName} */
      w
    ] || x[
      /** @type {SchemeName} */
      w.toLowerCase()
    ]) || void 0;
  }
  return Uu = {
    wsIsSecure: s,
    SCHEMES: x,
    isValidSchemeName: n,
    getSchemeHandler: P
  }, Uu;
}
var pp;
function Kk() {
  if (pp) return Zo.exports;
  pp = 1;
  const { normalizeIPv6: t, removeDotSegments: e, recomposeAuthority: r, normalizeComponentEncoding: n, isIPv4: s, nonSimpleDomain: o } = wb(), { SCHEMES: i, getSchemeHandler: a } = Uk();
  function l(g, y) {
    return typeof g == "string" ? g = /** @type {T} */
    h(b(g, y), y) : typeof g == "object" && (g = /** @type {T} */
    b(h(g, y), y)), g;
  }
  function u(g, y, S) {
    const x = S ? Object.assign({ scheme: "null" }, S) : { scheme: "null" }, P = c(b(g, x), b(y, x), x, !0);
    return x.skipEscape = !0, h(P, x);
  }
  function c(g, y, S, x) {
    const P = {};
    return x || (g = b(h(g, S), S), y = b(h(y, S), S)), S = S || {}, !S.tolerant && y.scheme ? (P.scheme = y.scheme, P.userinfo = y.userinfo, P.host = y.host, P.port = y.port, P.path = e(y.path || ""), P.query = y.query) : (y.userinfo !== void 0 || y.host !== void 0 || y.port !== void 0 ? (P.userinfo = y.userinfo, P.host = y.host, P.port = y.port, P.path = e(y.path || ""), P.query = y.query) : (y.path ? (y.path[0] === "/" ? P.path = e(y.path) : ((g.userinfo !== void 0 || g.host !== void 0 || g.port !== void 0) && !g.path ? P.path = "/" + y.path : g.path ? P.path = g.path.slice(0, g.path.lastIndexOf("/") + 1) + y.path : P.path = y.path, P.path = e(P.path)), P.query = y.query) : (P.path = g.path, y.query !== void 0 ? P.query = y.query : P.query = g.query), P.userinfo = g.userinfo, P.host = g.host, P.port = g.port), P.scheme = g.scheme), P.fragment = y.fragment, P;
  }
  function f(g, y, S) {
    return typeof g == "string" ? (g = unescape(g), g = h(n(b(g, S), !0), { ...S, skipEscape: !0 })) : typeof g == "object" && (g = h(n(g, !0), { ...S, skipEscape: !0 })), typeof y == "string" ? (y = unescape(y), y = h(n(b(y, S), !0), { ...S, skipEscape: !0 })) : typeof y == "object" && (y = h(n(y, !0), { ...S, skipEscape: !0 })), g.toLowerCase() === y.toLowerCase();
  }
  function h(g, y) {
    const S = {
      host: g.host,
      scheme: g.scheme,
      userinfo: g.userinfo,
      port: g.port,
      path: g.path,
      query: g.query,
      nid: g.nid,
      nss: g.nss,
      uuid: g.uuid,
      fragment: g.fragment,
      reference: g.reference,
      resourceName: g.resourceName,
      secure: g.secure,
      error: ""
    }, x = Object.assign({}, y), P = [], w = a(x.scheme || S.scheme);
    w && w.serialize && w.serialize(S, x), S.path !== void 0 && (x.skipEscape ? S.path = unescape(S.path) : (S.path = escape(S.path), S.scheme !== void 0 && (S.path = S.path.split("%3A").join(":")))), x.reference !== "suffix" && S.scheme && P.push(S.scheme, ":");
    const C = r(S);
    if (C !== void 0 && (x.reference !== "suffix" && P.push("//"), P.push(C), S.path && S.path[0] !== "/" && P.push("/")), S.path !== void 0) {
      let k = S.path;
      !x.absolutePath && (!w || !w.absolutePath) && (k = e(k)), C === void 0 && k[0] === "/" && k[1] === "/" && (k = "/%2F" + k.slice(2)), P.push(k);
    }
    return S.query !== void 0 && P.push("?", S.query), S.fragment !== void 0 && P.push("#", S.fragment), P.join("");
  }
  const _ = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function b(g, y) {
    const S = Object.assign({}, y), x = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let P = !1;
    S.reference === "suffix" && (S.scheme ? g = S.scheme + ":" + g : g = "//" + g);
    const w = g.match(_);
    if (w) {
      if (x.scheme = w[1], x.userinfo = w[3], x.host = w[4], x.port = parseInt(w[5], 10), x.path = w[6] || "", x.query = w[7], x.fragment = w[8], isNaN(x.port) && (x.port = w[5]), x.host)
        if (s(x.host) === !1) {
          const $ = t(x.host);
          x.host = $.host.toLowerCase(), P = $.isIPV6;
        } else
          P = !0;
      x.scheme === void 0 && x.userinfo === void 0 && x.host === void 0 && x.port === void 0 && x.query === void 0 && !x.path ? x.reference = "same-document" : x.scheme === void 0 ? x.reference = "relative" : x.fragment === void 0 ? x.reference = "absolute" : x.reference = "uri", S.reference && S.reference !== "suffix" && S.reference !== x.reference && (x.error = x.error || "URI is not a " + S.reference + " reference.");
      const C = a(S.scheme || x.scheme);
      if (!S.unicodeSupport && (!C || !C.unicodeSupport) && x.host && (S.domainHost || C && C.domainHost) && P === !1 && o(x.host))
        try {
          x.host = URL.domainToASCII(x.host.toLowerCase());
        } catch (k) {
          x.error = x.error || "Host's domain name can not be converted to ASCII: " + k;
        }
      (!C || C && !C.skipNormalize) && (g.indexOf("%") !== -1 && (x.scheme !== void 0 && (x.scheme = unescape(x.scheme)), x.host !== void 0 && (x.host = unescape(x.host))), x.path && (x.path = escape(unescape(x.path))), x.fragment && (x.fragment = encodeURI(decodeURIComponent(x.fragment)))), C && C.parse && C.parse(x, S);
    } else
      x.error = x.error || "URI can not be parsed.";
    return x;
  }
  const p = {
    SCHEMES: i,
    normalize: l,
    resolve: u,
    resolveComponent: c,
    equal: f,
    serialize: h,
    parse: b
  };
  return Zo.exports = p, Zo.exports.default = p, Zo.exports.fastUri = p, Zo.exports;
}
var mp;
function Wk() {
  if (mp) return Ji;
  mp = 1, Object.defineProperty(Ji, "__esModule", { value: !0 });
  const t = Kk();
  return t.code = 'require("ajv/dist/runtime/uri").default', Ji.default = t, Ji;
}
var vp;
function Hk() {
  return vp || (vp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    var e = tu();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return e.KeywordCxt;
    } });
    var r = He();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = Ld(), s = ru(), o = yb(), i = jd(), a = He(), l = eu(), u = il(), c = Qe(), f = qk, h = Wk(), _ = (J, j) => new RegExp(J, j);
    _.code = "new RegExp";
    const b = ["removeAdditional", "useDefaults", "coerceTypes"], p = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), g = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, y = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, S = 200;
    function x(J) {
      var j, ee, L, N, V, G, fe, se, we, le, re, oe, pe, ye, Pe, Oe, Ve, Ke, Le, je, We, gt, Ze, $t, lt;
      const ct = J.strict, pt = (j = J.code) === null || j === void 0 ? void 0 : j.optimize, Kt = pt === !0 || pt === void 0 ? 1 : pt || 0, yt = (L = (ee = J.code) === null || ee === void 0 ? void 0 : ee.regExp) !== null && L !== void 0 ? L : _, Vt = (N = J.uriResolver) !== null && N !== void 0 ? N : h.default;
      return {
        strictSchema: (G = (V = J.strictSchema) !== null && V !== void 0 ? V : ct) !== null && G !== void 0 ? G : !0,
        strictNumbers: (se = (fe = J.strictNumbers) !== null && fe !== void 0 ? fe : ct) !== null && se !== void 0 ? se : !0,
        strictTypes: (le = (we = J.strictTypes) !== null && we !== void 0 ? we : ct) !== null && le !== void 0 ? le : "log",
        strictTuples: (oe = (re = J.strictTuples) !== null && re !== void 0 ? re : ct) !== null && oe !== void 0 ? oe : "log",
        strictRequired: (ye = (pe = J.strictRequired) !== null && pe !== void 0 ? pe : ct) !== null && ye !== void 0 ? ye : !1,
        code: J.code ? { ...J.code, optimize: Kt, regExp: yt } : { optimize: Kt, regExp: yt },
        loopRequired: (Pe = J.loopRequired) !== null && Pe !== void 0 ? Pe : S,
        loopEnum: (Oe = J.loopEnum) !== null && Oe !== void 0 ? Oe : S,
        meta: (Ve = J.meta) !== null && Ve !== void 0 ? Ve : !0,
        messages: (Ke = J.messages) !== null && Ke !== void 0 ? Ke : !0,
        inlineRefs: (Le = J.inlineRefs) !== null && Le !== void 0 ? Le : !0,
        schemaId: (je = J.schemaId) !== null && je !== void 0 ? je : "$id",
        addUsedSchema: (We = J.addUsedSchema) !== null && We !== void 0 ? We : !0,
        validateSchema: (gt = J.validateSchema) !== null && gt !== void 0 ? gt : !0,
        validateFormats: (Ze = J.validateFormats) !== null && Ze !== void 0 ? Ze : !0,
        unicodeRegExp: ($t = J.unicodeRegExp) !== null && $t !== void 0 ? $t : !0,
        int32range: (lt = J.int32range) !== null && lt !== void 0 ? lt : !0,
        uriResolver: Vt
      };
    }
    class P {
      constructor(j = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), j = this.opts = { ...j, ...x(j) };
        const { es5: ee, lines: L } = this.opts.code;
        this.scope = new a.ValueScope({ scope: {}, prefixes: p, es5: ee, lines: L }), this.logger = F(j.logger);
        const N = j.validateFormats;
        j.validateFormats = !1, this.RULES = (0, o.getRules)(), w.call(this, g, j, "NOT SUPPORTED"), w.call(this, y, j, "DEPRECATED", "warn"), this._metaOpts = E.call(this), j.formats && $.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), j.keywords && T.call(this, j.keywords), typeof j.meta == "object" && this.addMetaSchema(j.meta), k.call(this), j.validateFormats = N;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: j, meta: ee, schemaId: L } = this.opts;
        let N = f;
        L === "id" && (N = { ...f }, N.id = N.$id, delete N.$id), ee && j && this.addMetaSchema(N, N[L], !1);
      }
      defaultMeta() {
        const { meta: j, schemaId: ee } = this.opts;
        return this.opts.defaultMeta = typeof j == "object" ? j[ee] || j : void 0;
      }
      validate(j, ee) {
        let L;
        if (typeof j == "string") {
          if (L = this.getSchema(j), !L)
            throw new Error(`no schema with key or ref "${j}"`);
        } else
          L = this.compile(j);
        const N = L(ee);
        return "$async" in L || (this.errors = L.errors), N;
      }
      compile(j, ee) {
        const L = this._addSchema(j, ee);
        return L.validate || this._compileSchemaEnv(L);
      }
      compileAsync(j, ee) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: L } = this.opts;
        return N.call(this, j, ee);
        async function N(le, re) {
          await V.call(this, le.$schema);
          const oe = this._addSchema(le, re);
          return oe.validate || G.call(this, oe);
        }
        async function V(le) {
          le && !this.getSchema(le) && await N.call(this, { $ref: le }, !0);
        }
        async function G(le) {
          try {
            return this._compileSchemaEnv(le);
          } catch (re) {
            if (!(re instanceof s.default))
              throw re;
            return fe.call(this, re), await se.call(this, re.missingSchema), G.call(this, le);
          }
        }
        function fe({ missingSchema: le, missingRef: re }) {
          if (this.refs[le])
            throw new Error(`AnySchema ${le} is loaded but ${re} cannot be resolved`);
        }
        async function se(le) {
          const re = await we.call(this, le);
          this.refs[le] || await V.call(this, re.$schema), this.refs[le] || this.addSchema(re, le, ee);
        }
        async function we(le) {
          const re = this._loading[le];
          if (re)
            return re;
          try {
            return await (this._loading[le] = L(le));
          } finally {
            delete this._loading[le];
          }
        }
      }
      // Adds schema to the instance
      addSchema(j, ee, L, N = this.opts.validateSchema) {
        if (Array.isArray(j)) {
          for (const G of j)
            this.addSchema(G, void 0, L, N);
          return this;
        }
        let V;
        if (typeof j == "object") {
          const { schemaId: G } = this.opts;
          if (V = j[G], V !== void 0 && typeof V != "string")
            throw new Error(`schema ${G} must be string`);
        }
        return ee = (0, l.normalizeId)(ee || V), this._checkUnique(ee), this.schemas[ee] = this._addSchema(j, L, ee, N, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(j, ee, L = this.opts.validateSchema) {
        return this.addSchema(j, ee, !0, L), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(j, ee) {
        if (typeof j == "boolean")
          return !0;
        let L;
        if (L = j.$schema, L !== void 0 && typeof L != "string")
          throw new Error("$schema must be a string");
        if (L = L || this.opts.defaultMeta || this.defaultMeta(), !L)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const N = this.validate(L, j);
        if (!N && ee) {
          const V = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(V);
          else
            throw new Error(V);
        }
        return N;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(j) {
        let ee;
        for (; typeof (ee = C.call(this, j)) == "string"; )
          j = ee;
        if (ee === void 0) {
          const { schemaId: L } = this.opts, N = new i.SchemaEnv({ schema: {}, schemaId: L });
          if (ee = i.resolveSchema.call(this, N, j), !ee)
            return;
          this.refs[j] = ee;
        }
        return ee.validate || this._compileSchemaEnv(ee);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(j) {
        if (j instanceof RegExp)
          return this._removeAllSchemas(this.schemas, j), this._removeAllSchemas(this.refs, j), this;
        switch (typeof j) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const ee = C.call(this, j);
            return typeof ee == "object" && this._cache.delete(ee.schema), delete this.schemas[j], delete this.refs[j], this;
          }
          case "object": {
            const ee = j;
            this._cache.delete(ee);
            let L = j[this.opts.schemaId];
            return L && (L = (0, l.normalizeId)(L), delete this.schemas[L], delete this.refs[L]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(j) {
        for (const ee of j)
          this.addKeyword(ee);
        return this;
      }
      addKeyword(j, ee) {
        let L;
        if (typeof j == "string")
          L = j, typeof ee == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), ee.keyword = L);
        else if (typeof j == "object" && ee === void 0) {
          if (ee = j, L = ee.keyword, Array.isArray(L) && !L.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (B.call(this, L, ee), !ee)
          return (0, c.eachItem)(L, (V) => R.call(this, V)), this;
        Y.call(this, ee);
        const N = {
          ...ee,
          type: (0, u.getJSONTypes)(ee.type),
          schemaType: (0, u.getJSONTypes)(ee.schemaType)
        };
        return (0, c.eachItem)(L, N.type.length === 0 ? (V) => R.call(this, V, N) : (V) => N.type.forEach((G) => R.call(this, V, N, G))), this;
      }
      getKeyword(j) {
        const ee = this.RULES.all[j];
        return typeof ee == "object" ? ee.definition : !!ee;
      }
      // Remove keyword
      removeKeyword(j) {
        const { RULES: ee } = this;
        delete ee.keywords[j], delete ee.all[j];
        for (const L of ee.rules) {
          const N = L.rules.findIndex((V) => V.keyword === j);
          N >= 0 && L.rules.splice(N, 1);
        }
        return this;
      }
      // Add format
      addFormat(j, ee) {
        return typeof ee == "string" && (ee = new RegExp(ee)), this.formats[j] = ee, this;
      }
      errorsText(j = this.errors, { separator: ee = ", ", dataVar: L = "data" } = {}) {
        return !j || j.length === 0 ? "No errors" : j.map((N) => `${L}${N.instancePath} ${N.message}`).reduce((N, V) => N + ee + V);
      }
      $dataMetaSchema(j, ee) {
        const L = this.RULES.all;
        j = JSON.parse(JSON.stringify(j));
        for (const N of ee) {
          const V = N.split("/").slice(1);
          let G = j;
          for (const fe of V)
            G = G[fe];
          for (const fe in L) {
            const se = L[fe];
            if (typeof se != "object")
              continue;
            const { $data: we } = se.definition, le = G[fe];
            we && le && (G[fe] = ae(le));
          }
        }
        return j;
      }
      _removeAllSchemas(j, ee) {
        for (const L in j) {
          const N = j[L];
          (!ee || ee.test(L)) && (typeof N == "string" ? delete j[L] : N && !N.meta && (this._cache.delete(N.schema), delete j[L]));
        }
      }
      _addSchema(j, ee, L, N = this.opts.validateSchema, V = this.opts.addUsedSchema) {
        let G;
        const { schemaId: fe } = this.opts;
        if (typeof j == "object")
          G = j[fe];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof j != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let se = this._cache.get(j);
        if (se !== void 0)
          return se;
        L = (0, l.normalizeId)(G || L);
        const we = l.getSchemaRefs.call(this, j, L);
        return se = new i.SchemaEnv({ schema: j, schemaId: fe, meta: ee, baseId: L, localRefs: we }), this._cache.set(se.schema, se), V && !L.startsWith("#") && (L && this._checkUnique(L), this.refs[L] = se), N && this.validateSchema(j, !0), se;
      }
      _checkUnique(j) {
        if (this.schemas[j] || this.refs[j])
          throw new Error(`schema with key or id "${j}" already exists`);
      }
      _compileSchemaEnv(j) {
        if (j.meta ? this._compileMetaSchema(j) : i.compileSchema.call(this, j), !j.validate)
          throw new Error("ajv implementation error");
        return j.validate;
      }
      _compileMetaSchema(j) {
        const ee = this.opts;
        this.opts = this._metaOpts;
        try {
          i.compileSchema.call(this, j);
        } finally {
          this.opts = ee;
        }
      }
    }
    P.ValidationError = n.default, P.MissingRefError = s.default, t.default = P;
    function w(J, j, ee, L = "error") {
      for (const N in J) {
        const V = N;
        V in j && this.logger[L](`${ee}: option ${N}. ${J[V]}`);
      }
    }
    function C(J) {
      return J = (0, l.normalizeId)(J), this.schemas[J] || this.refs[J];
    }
    function k() {
      const J = this.opts.schemas;
      if (J)
        if (Array.isArray(J))
          this.addSchema(J);
        else
          for (const j in J)
            this.addSchema(J[j], j);
    }
    function $() {
      for (const J in this.opts.formats) {
        const j = this.opts.formats[J];
        j && this.addFormat(J, j);
      }
    }
    function T(J) {
      if (Array.isArray(J)) {
        this.addVocabulary(J);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const j in J) {
        const ee = J[j];
        ee.keyword || (ee.keyword = j), this.addKeyword(ee);
      }
    }
    function E() {
      const J = { ...this.opts };
      for (const j of b)
        delete J[j];
      return J;
    }
    const I = { log() {
    }, warn() {
    }, error() {
    } };
    function F(J) {
      if (J === !1)
        return I;
      if (J === void 0)
        return console;
      if (J.log && J.warn && J.error)
        return J;
      throw new Error("logger must implement log, warn and error methods");
    }
    const U = /^[a-z_$][a-z0-9_$:-]*$/i;
    function B(J, j) {
      const { RULES: ee } = this;
      if ((0, c.eachItem)(J, (L) => {
        if (ee.keywords[L])
          throw new Error(`Keyword ${L} is already defined`);
        if (!U.test(L))
          throw new Error(`Keyword ${L} has invalid name`);
      }), !!j && j.$data && !("code" in j || "validate" in j))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function R(J, j, ee) {
      var L;
      const N = j?.post;
      if (ee && N)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: V } = this;
      let G = N ? V.post : V.rules.find(({ type: se }) => se === ee);
      if (G || (G = { type: ee, rules: [] }, V.rules.push(G)), V.keywords[J] = !0, !j)
        return;
      const fe = {
        keyword: J,
        definition: {
          ...j,
          type: (0, u.getJSONTypes)(j.type),
          schemaType: (0, u.getJSONTypes)(j.schemaType)
        }
      };
      j.before ? Z.call(this, G, fe, j.before) : G.rules.push(fe), V.all[J] = fe, (L = j.implements) === null || L === void 0 || L.forEach((se) => this.addKeyword(se));
    }
    function Z(J, j, ee) {
      const L = J.rules.findIndex((N) => N.keyword === ee);
      L >= 0 ? J.rules.splice(L, 0, j) : (J.rules.push(j), this.logger.warn(`rule ${ee} is not defined`));
    }
    function Y(J) {
      let { metaSchema: j } = J;
      j !== void 0 && (J.$data && this.opts.$data && (j = ae(j)), J.validateSchema = this.compile(j, !0));
    }
    const X = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function ae(J) {
      return { anyOf: [J, X] };
    }
  })(Fu)), Fu;
}
var Zi = {}, Qi = {}, ea = {}, yp;
function Gk() {
  if (yp) return ea;
  yp = 1, Object.defineProperty(ea, "__esModule", { value: !0 });
  const t = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return ea.default = t, ea;
}
var Vn = {}, bp;
function Yk() {
  if (bp) return Vn;
  bp = 1, Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.callRef = Vn.getValidate = void 0;
  const t = ru(), e = Kr(), r = He(), n = cs(), s = jd(), o = Qe(), i = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: c, schema: f, it: h } = u, { baseId: _, schemaEnv: b, validateName: p, opts: g, self: y } = h, { root: S } = b;
      if ((f === "#" || f === "#/") && _ === S.baseId)
        return P();
      const x = s.resolveRef.call(y, S, _, f);
      if (x === void 0)
        throw new t.default(h.opts.uriResolver, _, f);
      if (x instanceof s.SchemaEnv)
        return w(x);
      return C(x);
      function P() {
        if (b === S)
          return l(u, p, b, b.$async);
        const k = c.scopeValue("root", { ref: S });
        return l(u, (0, r._)`${k}.validate`, S, S.$async);
      }
      function w(k) {
        const $ = a(u, k);
        l(u, $, k, k.$async);
      }
      function C(k) {
        const $ = c.scopeValue("schema", g.code.source === !0 ? { ref: k, code: (0, r.stringify)(k) } : { ref: k }), T = c.name("valid"), E = u.subschema({
          schema: k,
          dataTypes: [],
          schemaPath: r.nil,
          topSchemaRef: $,
          errSchemaPath: f
        }, T);
        u.mergeEvaluated(E), u.ok(T);
      }
    }
  };
  function a(u, c) {
    const { gen: f } = u;
    return c.validate ? f.scopeValue("validate", { ref: c.validate }) : (0, r._)`${f.scopeValue("wrapper", { ref: c })}.validate`;
  }
  Vn.getValidate = a;
  function l(u, c, f, h) {
    const { gen: _, it: b } = u, { allErrors: p, schemaEnv: g, opts: y } = b, S = y.passContext ? n.default.this : r.nil;
    h ? x() : P();
    function x() {
      if (!g.$async)
        throw new Error("async schema referenced by sync schema");
      const k = _.let("valid");
      _.try(() => {
        _.code((0, r._)`await ${(0, e.callValidateCode)(u, c, S)}`), C(c), p || _.assign(k, !0);
      }, ($) => {
        _.if((0, r._)`!(${$} instanceof ${b.ValidationError})`, () => _.throw($)), w($), p || _.assign(k, !1);
      }), u.ok(k);
    }
    function P() {
      u.result((0, e.callValidateCode)(u, c, S), () => C(c), () => w(c));
    }
    function w(k) {
      const $ = (0, r._)`${k}.errors`;
      _.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${$} : ${n.default.vErrors}.concat(${$})`), _.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function C(k) {
      var $;
      if (!b.opts.unevaluated)
        return;
      const T = ($ = f?.validate) === null || $ === void 0 ? void 0 : $.evaluated;
      if (b.props !== !0)
        if (T && !T.dynamicProps)
          T.props !== void 0 && (b.props = o.mergeEvaluated.props(_, T.props, b.props));
        else {
          const E = _.var("props", (0, r._)`${k}.evaluated.props`);
          b.props = o.mergeEvaluated.props(_, E, b.props, r.Name);
        }
      if (b.items !== !0)
        if (T && !T.dynamicItems)
          T.items !== void 0 && (b.items = o.mergeEvaluated.items(_, T.items, b.items));
        else {
          const E = _.var("items", (0, r._)`${k}.evaluated.items`);
          b.items = o.mergeEvaluated.items(_, E, b.items, r.Name);
        }
    }
  }
  return Vn.callRef = l, Vn.default = i, Vn;
}
var _p;
function Xk() {
  if (_p) return Qi;
  _p = 1, Object.defineProperty(Qi, "__esModule", { value: !0 });
  const t = Gk(), e = Yk(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    t.default,
    e.default
  ];
  return Qi.default = r, Qi;
}
var ta = {}, ra = {}, wp;
function Jk() {
  if (wp) return ra;
  wp = 1, Object.defineProperty(ra, "__esModule", { value: !0 });
  const t = He(), e = t.operators, r = {
    maximum: { okStr: "<=", ok: e.LTE, fail: e.GT },
    minimum: { okStr: ">=", ok: e.GTE, fail: e.LT },
    exclusiveMaximum: { okStr: "<", ok: e.LT, fail: e.GTE },
    exclusiveMinimum: { okStr: ">", ok: e.GT, fail: e.LTE }
  }, n = {
    message: ({ keyword: o, schemaCode: i }) => (0, t.str)`must be ${r[o].okStr} ${i}`,
    params: ({ keyword: o, schemaCode: i }) => (0, t._)`{comparison: ${r[o].okStr}, limit: ${i}}`
  }, s = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(o) {
      const { keyword: i, data: a, schemaCode: l } = o;
      o.fail$data((0, t._)`${a} ${r[i].fail} ${l} || isNaN(${a})`);
    }
  };
  return ra.default = s, ra;
}
var na = {}, Sp;
function Zk() {
  if (Sp) return na;
  Sp = 1, Object.defineProperty(na, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, t.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, t._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: s, data: o, schemaCode: i, it: a } = n, l = a.opts.multipleOfPrecision, u = s.let("res"), c = l ? (0, t._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}` : (0, t._)`${u} !== parseInt(${u})`;
      n.fail$data((0, t._)`(${i} === 0 || (${u} = ${o}/${i}, ${c}))`);
    }
  };
  return na.default = r, na;
}
var sa = {}, oa = {}, xp;
function Qk() {
  if (xp) return oa;
  xp = 1, Object.defineProperty(oa, "__esModule", { value: !0 });
  function t(e) {
    const r = e.length;
    let n = 0, s = 0, o;
    for (; s < r; )
      n++, o = e.charCodeAt(s++), o >= 55296 && o <= 56319 && s < r && (o = e.charCodeAt(s), (o & 64512) === 56320 && s++);
    return n;
  }
  return oa.default = t, t.code = 'require("ajv/dist/runtime/ucs2length").default', oa;
}
var Pp;
function e$() {
  if (Pp) return sa;
  Pp = 1, Object.defineProperty(sa, "__esModule", { value: !0 });
  const t = He(), e = Qe(), r = Qk(), s = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: o, schemaCode: i }) {
        const a = o === "maxLength" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${a} than ${i} characters`;
      },
      params: ({ schemaCode: o }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { keyword: i, data: a, schemaCode: l, it: u } = o, c = i === "maxLength" ? t.operators.GT : t.operators.LT, f = u.opts.unicode === !1 ? (0, t._)`${a}.length` : (0, t._)`${(0, e.useFunc)(o.gen, r.default)}(${a})`;
      o.fail$data((0, t._)`${f} ${c} ${l}`);
    }
  };
  return sa.default = s, sa;
}
var ia = {}, Op;
function t$() {
  if (Op) return ia;
  Op = 1, Object.defineProperty(ia, "__esModule", { value: !0 });
  const t = Kr(), e = He(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: s }) => (0, e.str)`must match pattern "${s}"`,
      params: ({ schemaCode: s }) => (0, e._)`{pattern: ${s}}`
    },
    code(s) {
      const { data: o, $data: i, schema: a, schemaCode: l, it: u } = s, c = u.opts.unicodeRegExp ? "u" : "", f = i ? (0, e._)`(new RegExp(${l}, ${c}))` : (0, t.usePattern)(s, a);
      s.fail$data((0, e._)`!${f}.test(${o})`);
    }
  };
  return ia.default = n, ia;
}
var aa = {}, Cp;
function r$() {
  if (Cp) return aa;
  Cp = 1, Object.defineProperty(aa, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: s }) {
        const o = n === "maxProperties" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${o} than ${s} properties`;
      },
      params: ({ schemaCode: n }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: s, data: o, schemaCode: i } = n, a = s === "maxProperties" ? t.operators.GT : t.operators.LT;
      n.fail$data((0, t._)`Object.keys(${o}).length ${a} ${i}`);
    }
  };
  return aa.default = r, aa;
}
var la = {}, kp;
function n$() {
  if (kp) return la;
  kp = 1, Object.defineProperty(la, "__esModule", { value: !0 });
  const t = Kr(), e = He(), r = Qe(), s = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: o } }) => (0, e.str)`must have required property '${o}'`,
      params: ({ params: { missingProperty: o } }) => (0, e._)`{missingProperty: ${o}}`
    },
    code(o) {
      const { gen: i, schema: a, schemaCode: l, data: u, $data: c, it: f } = o, { opts: h } = f;
      if (!c && a.length === 0)
        return;
      const _ = a.length >= h.loopRequired;
      if (f.allErrors ? b() : p(), h.strictRequired) {
        const S = o.parentSchema.properties, { definedProperties: x } = o.it;
        for (const P of a)
          if (S?.[P] === void 0 && !x.has(P)) {
            const w = f.schemaEnv.baseId + f.errSchemaPath, C = `required property "${P}" is not defined at "${w}" (strictRequired)`;
            (0, r.checkStrictMode)(f, C, f.opts.strictRequired);
          }
      }
      function b() {
        if (_ || c)
          o.block$data(e.nil, g);
        else
          for (const S of a)
            (0, t.checkReportMissingProp)(o, S);
      }
      function p() {
        const S = i.let("missing");
        if (_ || c) {
          const x = i.let("valid", !0);
          o.block$data(x, () => y(S, x)), o.ok(x);
        } else
          i.if((0, t.checkMissingProp)(o, a, S)), (0, t.reportMissingProp)(o, S), i.else();
      }
      function g() {
        i.forOf("prop", l, (S) => {
          o.setParams({ missingProperty: S }), i.if((0, t.noPropertyInData)(i, u, S, h.ownProperties), () => o.error());
        });
      }
      function y(S, x) {
        o.setParams({ missingProperty: S }), i.forOf(S, l, () => {
          i.assign(x, (0, t.propertyInData)(i, u, S, h.ownProperties)), i.if((0, e.not)(x), () => {
            o.error(), i.break();
          });
        }, e.nil);
      }
    }
  };
  return la.default = s, la;
}
var ua = {}, $p;
function s$() {
  if ($p) return ua;
  $p = 1, Object.defineProperty(ua, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: s }) {
        const o = n === "maxItems" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${o} than ${s} items`;
      },
      params: ({ schemaCode: n }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: s, data: o, schemaCode: i } = n, a = s === "maxItems" ? t.operators.GT : t.operators.LT;
      n.fail$data((0, t._)`${o}.length ${a} ${i}`);
    }
  };
  return ua.default = r, ua;
}
var ca = {}, da = {}, Ap;
function Bd() {
  if (Ap) return da;
  Ap = 1, Object.defineProperty(da, "__esModule", { value: !0 });
  const t = _b();
  return t.code = 'require("ajv/dist/runtime/equal").default', da.default = t, da;
}
var Ep;
function o$() {
  if (Ep) return ca;
  Ep = 1, Object.defineProperty(ca, "__esModule", { value: !0 });
  const t = il(), e = He(), r = Qe(), n = Bd(), o = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i, j: a } }) => (0, e.str)`must NOT have duplicate items (items ## ${a} and ${i} are identical)`,
      params: ({ params: { i, j: a } }) => (0, e._)`{i: ${i}, j: ${a}}`
    },
    code(i) {
      const { gen: a, data: l, $data: u, schema: c, parentSchema: f, schemaCode: h, it: _ } = i;
      if (!u && !c)
        return;
      const b = a.let("valid"), p = f.items ? (0, t.getSchemaTypes)(f.items) : [];
      i.block$data(b, g, (0, e._)`${h} === false`), i.ok(b);
      function g() {
        const P = a.let("i", (0, e._)`${l}.length`), w = a.let("j");
        i.setParams({ i: P, j: w }), a.assign(b, !0), a.if((0, e._)`${P} > 1`, () => (y() ? S : x)(P, w));
      }
      function y() {
        return p.length > 0 && !p.some((P) => P === "object" || P === "array");
      }
      function S(P, w) {
        const C = a.name("item"), k = (0, t.checkDataTypes)(p, C, _.opts.strictNumbers, t.DataType.Wrong), $ = a.const("indices", (0, e._)`{}`);
        a.for((0, e._)`;${P}--;`, () => {
          a.let(C, (0, e._)`${l}[${P}]`), a.if(k, (0, e._)`continue`), p.length > 1 && a.if((0, e._)`typeof ${C} == "string"`, (0, e._)`${C} += "_"`), a.if((0, e._)`typeof ${$}[${C}] == "number"`, () => {
            a.assign(w, (0, e._)`${$}[${C}]`), i.error(), a.assign(b, !1).break();
          }).code((0, e._)`${$}[${C}] = ${P}`);
        });
      }
      function x(P, w) {
        const C = (0, r.useFunc)(a, n.default), k = a.name("outer");
        a.label(k).for((0, e._)`;${P}--;`, () => a.for((0, e._)`${w} = ${P}; ${w}--;`, () => a.if((0, e._)`${C}(${l}[${P}], ${l}[${w}])`, () => {
          i.error(), a.assign(b, !1).break(k);
        })));
      }
    }
  };
  return ca.default = o, ca;
}
var fa = {}, Tp;
function i$() {
  if (Tp) return fa;
  Tp = 1, Object.defineProperty(fa, "__esModule", { value: !0 });
  const t = He(), e = Qe(), r = Bd(), s = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: o }) => (0, t._)`{allowedValue: ${o}}`
    },
    code(o) {
      const { gen: i, data: a, $data: l, schemaCode: u, schema: c } = o;
      l || c && typeof c == "object" ? o.fail$data((0, t._)`!${(0, e.useFunc)(i, r.default)}(${a}, ${u})`) : o.fail((0, t._)`${c} !== ${a}`);
    }
  };
  return fa.default = s, fa;
}
var ha = {}, Dp;
function a$() {
  if (Dp) return ha;
  Dp = 1, Object.defineProperty(ha, "__esModule", { value: !0 });
  const t = He(), e = Qe(), r = Bd(), s = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: o }) => (0, t._)`{allowedValues: ${o}}`
    },
    code(o) {
      const { gen: i, data: a, $data: l, schema: u, schemaCode: c, it: f } = o;
      if (!l && u.length === 0)
        throw new Error("enum must have non-empty array");
      const h = u.length >= f.opts.loopEnum;
      let _;
      const b = () => _ ?? (_ = (0, e.useFunc)(i, r.default));
      let p;
      if (h || l)
        p = i.let("valid"), o.block$data(p, g);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const S = i.const("vSchema", c);
        p = (0, t.or)(...u.map((x, P) => y(S, P)));
      }
      o.pass(p);
      function g() {
        i.assign(p, !1), i.forOf("v", c, (S) => i.if((0, t._)`${b()}(${a}, ${S})`, () => i.assign(p, !0).break()));
      }
      function y(S, x) {
        const P = u[x];
        return typeof P == "object" && P !== null ? (0, t._)`${b()}(${a}, ${S}[${x}])` : (0, t._)`${a} === ${P}`;
      }
    }
  };
  return ha.default = s, ha;
}
var Mp;
function l$() {
  if (Mp) return ta;
  Mp = 1, Object.defineProperty(ta, "__esModule", { value: !0 });
  const t = Jk(), e = Zk(), r = e$(), n = t$(), s = r$(), o = n$(), i = s$(), a = o$(), l = i$(), u = a$(), c = [
    // number
    t.default,
    e.default,
    // string
    r.default,
    n.default,
    // object
    s.default,
    o.default,
    // array
    i.default,
    a.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    l.default,
    u.default
  ];
  return ta.default = c, ta;
}
var ga = {}, Zs = {}, Ip;
function Sb() {
  if (Ip) return Zs;
  Ip = 1, Object.defineProperty(Zs, "__esModule", { value: !0 }), Zs.validateAdditionalItems = void 0;
  const t = He(), e = Qe(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: o } }) => (0, t.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { parentSchema: i, it: a } = o, { items: l } = i;
      if (!Array.isArray(l)) {
        (0, e.checkStrictMode)(a, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      s(o, l);
    }
  };
  function s(o, i) {
    const { gen: a, schema: l, data: u, keyword: c, it: f } = o;
    f.items = !0;
    const h = a.const("len", (0, t._)`${u}.length`);
    if (l === !1)
      o.setParams({ len: i.length }), o.pass((0, t._)`${h} <= ${i.length}`);
    else if (typeof l == "object" && !(0, e.alwaysValidSchema)(f, l)) {
      const b = a.var("valid", (0, t._)`${h} <= ${i.length}`);
      a.if((0, t.not)(b), () => _(b)), o.ok(b);
    }
    function _(b) {
      a.forRange("i", i.length, h, (p) => {
        o.subschema({ keyword: c, dataProp: p, dataPropType: e.Type.Num }, b), f.allErrors || a.if((0, t.not)(b), () => a.break());
      });
    }
  }
  return Zs.validateAdditionalItems = s, Zs.default = n, Zs;
}
var pa = {}, Qs = {}, Np;
function xb() {
  if (Np) return Qs;
  Np = 1, Object.defineProperty(Qs, "__esModule", { value: !0 }), Qs.validateTuple = void 0;
  const t = He(), e = Qe(), r = Kr(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(o) {
      const { schema: i, it: a } = o;
      if (Array.isArray(i))
        return s(o, "additionalItems", i);
      a.items = !0, !(0, e.alwaysValidSchema)(a, i) && o.ok((0, r.validateArray)(o));
    }
  };
  function s(o, i, a = o.schema) {
    const { gen: l, parentSchema: u, data: c, keyword: f, it: h } = o;
    p(u), h.opts.unevaluated && a.length && h.items !== !0 && (h.items = e.mergeEvaluated.items(l, a.length, h.items));
    const _ = l.name("valid"), b = l.const("len", (0, t._)`${c}.length`);
    a.forEach((g, y) => {
      (0, e.alwaysValidSchema)(h, g) || (l.if((0, t._)`${b} > ${y}`, () => o.subschema({
        keyword: f,
        schemaProp: y,
        dataProp: y
      }, _)), o.ok(_));
    });
    function p(g) {
      const { opts: y, errSchemaPath: S } = h, x = a.length, P = x === g.minItems && (x === g.maxItems || g[i] === !1);
      if (y.strictTuples && !P) {
        const w = `"${f}" is ${x}-tuple, but minItems or maxItems/${i} are not specified or different at path "${S}"`;
        (0, e.checkStrictMode)(h, w, y.strictTuples);
      }
    }
  }
  return Qs.validateTuple = s, Qs.default = n, Qs;
}
var Fp;
function u$() {
  if (Fp) return pa;
  Fp = 1, Object.defineProperty(pa, "__esModule", { value: !0 });
  const t = xb(), e = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, t.validateTuple)(r, "items")
  };
  return pa.default = e, pa;
}
var ma = {}, Rp;
function c$() {
  if (Rp) return ma;
  Rp = 1, Object.defineProperty(ma, "__esModule", { value: !0 });
  const t = He(), e = Qe(), r = Kr(), n = Sb(), o = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: i } }) => (0, t.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, t._)`{limit: ${i}}`
    },
    code(i) {
      const { schema: a, parentSchema: l, it: u } = i, { prefixItems: c } = l;
      u.items = !0, !(0, e.alwaysValidSchema)(u, a) && (c ? (0, n.validateAdditionalItems)(i, c) : i.ok((0, r.validateArray)(i)));
    }
  };
  return ma.default = o, ma;
}
var va = {}, Vp;
function d$() {
  if (Vp) return va;
  Vp = 1, Object.defineProperty(va, "__esModule", { value: !0 });
  const t = He(), e = Qe(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: s, max: o } }) => o === void 0 ? (0, t.str)`must contain at least ${s} valid item(s)` : (0, t.str)`must contain at least ${s} and no more than ${o} valid item(s)`,
      params: ({ params: { min: s, max: o } }) => o === void 0 ? (0, t._)`{minContains: ${s}}` : (0, t._)`{minContains: ${s}, maxContains: ${o}}`
    },
    code(s) {
      const { gen: o, schema: i, parentSchema: a, data: l, it: u } = s;
      let c, f;
      const { minContains: h, maxContains: _ } = a;
      u.opts.next ? (c = h === void 0 ? 1 : h, f = _) : c = 1;
      const b = o.const("len", (0, t._)`${l}.length`);
      if (s.setParams({ min: c, max: f }), f === void 0 && c === 0) {
        (0, e.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (f !== void 0 && c > f) {
        (0, e.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), s.fail();
        return;
      }
      if ((0, e.alwaysValidSchema)(u, i)) {
        let x = (0, t._)`${b} >= ${c}`;
        f !== void 0 && (x = (0, t._)`${x} && ${b} <= ${f}`), s.pass(x);
        return;
      }
      u.items = !0;
      const p = o.name("valid");
      f === void 0 && c === 1 ? y(p, () => o.if(p, () => o.break())) : c === 0 ? (o.let(p, !0), f !== void 0 && o.if((0, t._)`${l}.length > 0`, g)) : (o.let(p, !1), g()), s.result(p, () => s.reset());
      function g() {
        const x = o.name("_valid"), P = o.let("count", 0);
        y(x, () => o.if(x, () => S(P)));
      }
      function y(x, P) {
        o.forRange("i", 0, b, (w) => {
          s.subschema({
            keyword: "contains",
            dataProp: w,
            dataPropType: e.Type.Num,
            compositeRule: !0
          }, x), P();
        });
      }
      function S(x) {
        o.code((0, t._)`${x}++`), f === void 0 ? o.if((0, t._)`${x} >= ${c}`, () => o.assign(p, !0).break()) : (o.if((0, t._)`${x} > ${f}`, () => o.assign(p, !1).break()), c === 1 ? o.assign(p, !0) : o.if((0, t._)`${x} >= ${c}`, () => o.assign(p, !0)));
      }
    }
  };
  return va.default = n, va;
}
var Ku = {}, Lp;
function f$() {
  return Lp || (Lp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
    const e = He(), r = Qe(), n = Kr();
    t.error = {
      message: ({ params: { property: l, depsCount: u, deps: c } }) => {
        const f = u === 1 ? "property" : "properties";
        return (0, e.str)`must have ${f} ${c} when property ${l} is present`;
      },
      params: ({ params: { property: l, depsCount: u, deps: c, missingProperty: f } }) => (0, e._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${u},
    deps: ${c}}`
      // TODO change to reference
    };
    const s = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: t.error,
      code(l) {
        const [u, c] = o(l);
        i(l, u), a(l, c);
      }
    };
    function o({ schema: l }) {
      const u = {}, c = {};
      for (const f in l) {
        if (f === "__proto__")
          continue;
        const h = Array.isArray(l[f]) ? u : c;
        h[f] = l[f];
      }
      return [u, c];
    }
    function i(l, u = l.schema) {
      const { gen: c, data: f, it: h } = l;
      if (Object.keys(u).length === 0)
        return;
      const _ = c.let("missing");
      for (const b in u) {
        const p = u[b];
        if (p.length === 0)
          continue;
        const g = (0, n.propertyInData)(c, f, b, h.opts.ownProperties);
        l.setParams({
          property: b,
          depsCount: p.length,
          deps: p.join(", ")
        }), h.allErrors ? c.if(g, () => {
          for (const y of p)
            (0, n.checkReportMissingProp)(l, y);
        }) : (c.if((0, e._)`${g} && (${(0, n.checkMissingProp)(l, p, _)})`), (0, n.reportMissingProp)(l, _), c.else());
      }
    }
    t.validatePropertyDeps = i;
    function a(l, u = l.schema) {
      const { gen: c, data: f, keyword: h, it: _ } = l, b = c.name("valid");
      for (const p in u)
        (0, r.alwaysValidSchema)(_, u[p]) || (c.if(
          (0, n.propertyInData)(c, f, p, _.opts.ownProperties),
          () => {
            const g = l.subschema({ keyword: h, schemaProp: p }, b);
            l.mergeValidEvaluated(g, b);
          },
          () => c.var(b, !0)
          // TODO var
        ), l.ok(b));
    }
    t.validateSchemaDeps = a, t.default = s;
  })(Ku)), Ku;
}
var ya = {}, jp;
function h$() {
  if (jp) return ya;
  jp = 1, Object.defineProperty(ya, "__esModule", { value: !0 });
  const t = He(), e = Qe(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: s }) => (0, t._)`{propertyName: ${s.propertyName}}`
    },
    code(s) {
      const { gen: o, schema: i, data: a, it: l } = s;
      if ((0, e.alwaysValidSchema)(l, i))
        return;
      const u = o.name("valid");
      o.forIn("key", a, (c) => {
        s.setParams({ propertyName: c }), s.subschema({
          keyword: "propertyNames",
          data: c,
          dataTypes: ["string"],
          propertyName: c,
          compositeRule: !0
        }, u), o.if((0, t.not)(u), () => {
          s.error(!0), l.allErrors || o.break();
        });
      }), s.ok(u);
    }
  };
  return ya.default = n, ya;
}
var ba = {}, Bp;
function Pb() {
  if (Bp) return ba;
  Bp = 1, Object.defineProperty(ba, "__esModule", { value: !0 });
  const t = Kr(), e = He(), r = cs(), n = Qe(), o = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: i }) => (0, e._)`{additionalProperty: ${i.additionalProperty}}`
    },
    code(i) {
      const { gen: a, schema: l, parentSchema: u, data: c, errsCount: f, it: h } = i;
      if (!f)
        throw new Error("ajv implementation error");
      const { allErrors: _, opts: b } = h;
      if (h.props = !0, b.removeAdditional !== "all" && (0, n.alwaysValidSchema)(h, l))
        return;
      const p = (0, t.allSchemaProperties)(u.properties), g = (0, t.allSchemaProperties)(u.patternProperties);
      y(), i.ok((0, e._)`${f} === ${r.default.errors}`);
      function y() {
        a.forIn("key", c, (C) => {
          !p.length && !g.length ? P(C) : a.if(S(C), () => P(C));
        });
      }
      function S(C) {
        let k;
        if (p.length > 8) {
          const $ = (0, n.schemaRefOrVal)(h, u.properties, "properties");
          k = (0, t.isOwnProperty)(a, $, C);
        } else p.length ? k = (0, e.or)(...p.map(($) => (0, e._)`${C} === ${$}`)) : k = e.nil;
        return g.length && (k = (0, e.or)(k, ...g.map(($) => (0, e._)`${(0, t.usePattern)(i, $)}.test(${C})`))), (0, e.not)(k);
      }
      function x(C) {
        a.code((0, e._)`delete ${c}[${C}]`);
      }
      function P(C) {
        if (b.removeAdditional === "all" || b.removeAdditional && l === !1) {
          x(C);
          return;
        }
        if (l === !1) {
          i.setParams({ additionalProperty: C }), i.error(), _ || a.break();
          return;
        }
        if (typeof l == "object" && !(0, n.alwaysValidSchema)(h, l)) {
          const k = a.name("valid");
          b.removeAdditional === "failing" ? (w(C, k, !1), a.if((0, e.not)(k), () => {
            i.reset(), x(C);
          })) : (w(C, k), _ || a.if((0, e.not)(k), () => a.break()));
        }
      }
      function w(C, k, $) {
        const T = {
          keyword: "additionalProperties",
          dataProp: C,
          dataPropType: n.Type.Str
        };
        $ === !1 && Object.assign(T, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), i.subschema(T, k);
      }
    }
  };
  return ba.default = o, ba;
}
var _a = {}, zp;
function g$() {
  if (zp) return _a;
  zp = 1, Object.defineProperty(_a, "__esModule", { value: !0 });
  const t = tu(), e = Kr(), r = Qe(), n = Pb(), s = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(o) {
      const { gen: i, schema: a, parentSchema: l, data: u, it: c } = o;
      c.opts.removeAdditional === "all" && l.additionalProperties === void 0 && n.default.code(new t.KeywordCxt(c, n.default, "additionalProperties"));
      const f = (0, e.allSchemaProperties)(a);
      for (const g of f)
        c.definedProperties.add(g);
      c.opts.unevaluated && f.length && c.props !== !0 && (c.props = r.mergeEvaluated.props(i, (0, r.toHash)(f), c.props));
      const h = f.filter((g) => !(0, r.alwaysValidSchema)(c, a[g]));
      if (h.length === 0)
        return;
      const _ = i.name("valid");
      for (const g of h)
        b(g) ? p(g) : (i.if((0, e.propertyInData)(i, u, g, c.opts.ownProperties)), p(g), c.allErrors || i.else().var(_, !0), i.endIf()), o.it.definedProperties.add(g), o.ok(_);
      function b(g) {
        return c.opts.useDefaults && !c.compositeRule && a[g].default !== void 0;
      }
      function p(g) {
        o.subschema({
          keyword: "properties",
          schemaProp: g,
          dataProp: g
        }, _);
      }
    }
  };
  return _a.default = s, _a;
}
var wa = {}, qp;
function p$() {
  if (qp) return wa;
  qp = 1, Object.defineProperty(wa, "__esModule", { value: !0 });
  const t = Kr(), e = He(), r = Qe(), n = Qe(), s = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(o) {
      const { gen: i, schema: a, data: l, parentSchema: u, it: c } = o, { opts: f } = c, h = (0, t.allSchemaProperties)(a), _ = h.filter((P) => (0, r.alwaysValidSchema)(c, a[P]));
      if (h.length === 0 || _.length === h.length && (!c.opts.unevaluated || c.props === !0))
        return;
      const b = f.strictSchema && !f.allowMatchingProperties && u.properties, p = i.name("valid");
      c.props !== !0 && !(c.props instanceof e.Name) && (c.props = (0, n.evaluatedPropsToName)(i, c.props));
      const { props: g } = c;
      y();
      function y() {
        for (const P of h)
          b && S(P), c.allErrors ? x(P) : (i.var(p, !0), x(P), i.if(p));
      }
      function S(P) {
        for (const w in b)
          new RegExp(P).test(w) && (0, r.checkStrictMode)(c, `property ${w} matches pattern ${P} (use allowMatchingProperties)`);
      }
      function x(P) {
        i.forIn("key", l, (w) => {
          i.if((0, e._)`${(0, t.usePattern)(o, P)}.test(${w})`, () => {
            const C = _.includes(P);
            C || o.subschema({
              keyword: "patternProperties",
              schemaProp: P,
              dataProp: w,
              dataPropType: n.Type.Str
            }, p), c.opts.unevaluated && g !== !0 ? i.assign((0, e._)`${g}[${w}]`, !0) : !C && !c.allErrors && i.if((0, e.not)(p), () => i.break());
          });
        });
      }
    }
  };
  return wa.default = s, wa;
}
var Sa = {}, Up;
function m$() {
  if (Up) return Sa;
  Up = 1, Object.defineProperty(Sa, "__esModule", { value: !0 });
  const t = Qe(), e = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: s, it: o } = r;
      if ((0, t.alwaysValidSchema)(o, s)) {
        r.fail();
        return;
      }
      const i = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, i), r.failResult(i, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Sa.default = e, Sa;
}
var xa = {}, Kp;
function v$() {
  if (Kp) return xa;
  Kp = 1, Object.defineProperty(xa, "__esModule", { value: !0 });
  const e = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: Kr().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return xa.default = e, xa;
}
var Pa = {}, Wp;
function y$() {
  if (Wp) return Pa;
  Wp = 1, Object.defineProperty(Pa, "__esModule", { value: !0 });
  const t = He(), e = Qe(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: s }) => (0, t._)`{passingSchemas: ${s.passing}}`
    },
    code(s) {
      const { gen: o, schema: i, parentSchema: a, it: l } = s;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      if (l.opts.discriminator && a.discriminator)
        return;
      const u = i, c = o.let("valid", !1), f = o.let("passing", null), h = o.name("_valid");
      s.setParams({ passing: f }), o.block(_), s.result(c, () => s.reset(), () => s.error(!0));
      function _() {
        u.forEach((b, p) => {
          let g;
          (0, e.alwaysValidSchema)(l, b) ? o.var(h, !0) : g = s.subschema({
            keyword: "oneOf",
            schemaProp: p,
            compositeRule: !0
          }, h), p > 0 && o.if((0, t._)`${h} && ${c}`).assign(c, !1).assign(f, (0, t._)`[${f}, ${p}]`).else(), o.if(h, () => {
            o.assign(c, !0), o.assign(f, p), g && s.mergeEvaluated(g, t.Name);
          });
        });
      }
    }
  };
  return Pa.default = n, Pa;
}
var Oa = {}, Hp;
function b$() {
  if (Hp) return Oa;
  Hp = 1, Object.defineProperty(Oa, "__esModule", { value: !0 });
  const t = Qe(), e = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: s, it: o } = r;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const i = n.name("valid");
      s.forEach((a, l) => {
        if ((0, t.alwaysValidSchema)(o, a))
          return;
        const u = r.subschema({ keyword: "allOf", schemaProp: l }, i);
        r.ok(i), r.mergeEvaluated(u);
      });
    }
  };
  return Oa.default = e, Oa;
}
var Ca = {}, Gp;
function _$() {
  if (Gp) return Ca;
  Gp = 1, Object.defineProperty(Ca, "__esModule", { value: !0 });
  const t = He(), e = Qe(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: o }) => (0, t.str)`must match "${o.ifClause}" schema`,
      params: ({ params: o }) => (0, t._)`{failingKeyword: ${o.ifClause}}`
    },
    code(o) {
      const { gen: i, parentSchema: a, it: l } = o;
      a.then === void 0 && a.else === void 0 && (0, e.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
      const u = s(l, "then"), c = s(l, "else");
      if (!u && !c)
        return;
      const f = i.let("valid", !0), h = i.name("_valid");
      if (_(), o.reset(), u && c) {
        const p = i.let("ifClause");
        o.setParams({ ifClause: p }), i.if(h, b("then", p), b("else", p));
      } else u ? i.if(h, b("then")) : i.if((0, t.not)(h), b("else"));
      o.pass(f, () => o.error(!0));
      function _() {
        const p = o.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, h);
        o.mergeEvaluated(p);
      }
      function b(p, g) {
        return () => {
          const y = o.subschema({ keyword: p }, h);
          i.assign(f, h), o.mergeValidEvaluated(y, f), g ? i.assign(g, (0, t._)`${p}`) : o.setParams({ ifClause: p });
        };
      }
    }
  };
  function s(o, i) {
    const a = o.schema[i];
    return a !== void 0 && !(0, e.alwaysValidSchema)(o, a);
  }
  return Ca.default = n, Ca;
}
var ka = {}, Yp;
function w$() {
  if (Yp) return ka;
  Yp = 1, Object.defineProperty(ka, "__esModule", { value: !0 });
  const t = Qe(), e = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: s }) {
      n.if === void 0 && (0, t.checkStrictMode)(s, `"${r}" without "if" is ignored`);
    }
  };
  return ka.default = e, ka;
}
var Xp;
function S$() {
  if (Xp) return ga;
  Xp = 1, Object.defineProperty(ga, "__esModule", { value: !0 });
  const t = Sb(), e = u$(), r = xb(), n = c$(), s = d$(), o = f$(), i = h$(), a = Pb(), l = g$(), u = p$(), c = m$(), f = v$(), h = y$(), _ = b$(), b = _$(), p = w$();
  function g(y = !1) {
    const S = [
      // any
      c.default,
      f.default,
      h.default,
      _.default,
      b.default,
      p.default,
      // object
      i.default,
      a.default,
      o.default,
      l.default,
      u.default
    ];
    return y ? S.push(e.default, n.default) : S.push(t.default, r.default), S.push(s.default), S;
  }
  return ga.default = g, ga;
}
var $a = {}, Aa = {}, Jp;
function x$() {
  if (Jp) return Aa;
  Jp = 1, Object.defineProperty(Aa, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, t.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, t._)`{format: ${n}}`
    },
    code(n, s) {
      const { gen: o, data: i, $data: a, schema: l, schemaCode: u, it: c } = n, { opts: f, errSchemaPath: h, schemaEnv: _, self: b } = c;
      if (!f.validateFormats)
        return;
      a ? p() : g();
      function p() {
        const y = o.scopeValue("formats", {
          ref: b.formats,
          code: f.code.formats
        }), S = o.const("fDef", (0, t._)`${y}[${u}]`), x = o.let("fType"), P = o.let("format");
        o.if((0, t._)`typeof ${S} == "object" && !(${S} instanceof RegExp)`, () => o.assign(x, (0, t._)`${S}.type || "string"`).assign(P, (0, t._)`${S}.validate`), () => o.assign(x, (0, t._)`"string"`).assign(P, S)), n.fail$data((0, t.or)(w(), C()));
        function w() {
          return f.strictSchema === !1 ? t.nil : (0, t._)`${u} && !${P}`;
        }
        function C() {
          const k = _.$async ? (0, t._)`(${S}.async ? await ${P}(${i}) : ${P}(${i}))` : (0, t._)`${P}(${i})`, $ = (0, t._)`(typeof ${P} == "function" ? ${k} : ${P}.test(${i}))`;
          return (0, t._)`${P} && ${P} !== true && ${x} === ${s} && !${$}`;
        }
      }
      function g() {
        const y = b.formats[l];
        if (!y) {
          w();
          return;
        }
        if (y === !0)
          return;
        const [S, x, P] = C(y);
        S === s && n.pass(k());
        function w() {
          if (f.strictSchema === !1) {
            b.logger.warn($());
            return;
          }
          throw new Error($());
          function $() {
            return `unknown format "${l}" ignored in schema at path "${h}"`;
          }
        }
        function C($) {
          const T = $ instanceof RegExp ? (0, t.regexpCode)($) : f.code.formats ? (0, t._)`${f.code.formats}${(0, t.getProperty)(l)}` : void 0, E = o.scopeValue("formats", { key: l, ref: $, code: T });
          return typeof $ == "object" && !($ instanceof RegExp) ? [$.type || "string", $.validate, (0, t._)`${E}.validate`] : ["string", $, E];
        }
        function k() {
          if (typeof y == "object" && !(y instanceof RegExp) && y.async) {
            if (!_.$async)
              throw new Error("async format in sync schema");
            return (0, t._)`await ${P}(${i})`;
          }
          return typeof x == "function" ? (0, t._)`${P}(${i})` : (0, t._)`${P}.test(${i})`;
        }
      }
    }
  };
  return Aa.default = r, Aa;
}
var Zp;
function P$() {
  if (Zp) return $a;
  Zp = 1, Object.defineProperty($a, "__esModule", { value: !0 });
  const e = [x$().default];
  return $a.default = e, $a;
}
var _s = {}, Qp;
function O$() {
  return Qp || (Qp = 1, Object.defineProperty(_s, "__esModule", { value: !0 }), _s.contentVocabulary = _s.metadataVocabulary = void 0, _s.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], _s.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), _s;
}
var em;
function C$() {
  if (em) return Zi;
  em = 1, Object.defineProperty(Zi, "__esModule", { value: !0 });
  const t = Xk(), e = l$(), r = S$(), n = P$(), s = O$(), o = [
    t.default,
    e.default,
    (0, r.default)(),
    n.default,
    s.metadataVocabulary,
    s.contentVocabulary
  ];
  return Zi.default = o, Zi;
}
var Ea = {}, Qo = {}, tm;
function k$() {
  if (tm) return Qo;
  tm = 1, Object.defineProperty(Qo, "__esModule", { value: !0 }), Qo.DiscrError = void 0;
  var t;
  return (function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  })(t || (Qo.DiscrError = t = {})), Qo;
}
var rm;
function $$() {
  if (rm) return Ea;
  rm = 1, Object.defineProperty(Ea, "__esModule", { value: !0 });
  const t = He(), e = k$(), r = jd(), n = ru(), s = Qe(), i = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: a, tagName: l } }) => a === e.DiscrError.Tag ? `tag "${l}" must be string` : `value of tag "${l}" must be in oneOf`,
      params: ({ params: { discrError: a, tag: l, tagName: u } }) => (0, t._)`{error: ${a}, tag: ${u}, tagValue: ${l}}`
    },
    code(a) {
      const { gen: l, data: u, schema: c, parentSchema: f, it: h } = a, { oneOf: _ } = f;
      if (!h.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const b = c.propertyName;
      if (typeof b != "string")
        throw new Error("discriminator: requires propertyName");
      if (c.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!_)
        throw new Error("discriminator: requires oneOf keyword");
      const p = l.let("valid", !1), g = l.const("tag", (0, t._)`${u}${(0, t.getProperty)(b)}`);
      l.if((0, t._)`typeof ${g} == "string"`, () => y(), () => a.error(!1, { discrError: e.DiscrError.Tag, tag: g, tagName: b })), a.ok(p);
      function y() {
        const P = x();
        l.if(!1);
        for (const w in P)
          l.elseIf((0, t._)`${g} === ${w}`), l.assign(p, S(P[w]));
        l.else(), a.error(!1, { discrError: e.DiscrError.Mapping, tag: g, tagName: b }), l.endIf();
      }
      function S(P) {
        const w = l.name("valid"), C = a.subschema({ keyword: "oneOf", schemaProp: P }, w);
        return a.mergeEvaluated(C, t.Name), w;
      }
      function x() {
        var P;
        const w = {}, C = $(f);
        let k = !0;
        for (let I = 0; I < _.length; I++) {
          let F = _[I];
          if (F?.$ref && !(0, s.schemaHasRulesButRef)(F, h.self.RULES)) {
            const B = F.$ref;
            if (F = r.resolveRef.call(h.self, h.schemaEnv.root, h.baseId, B), F instanceof r.SchemaEnv && (F = F.schema), F === void 0)
              throw new n.default(h.opts.uriResolver, h.baseId, B);
          }
          const U = (P = F?.properties) === null || P === void 0 ? void 0 : P[b];
          if (typeof U != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${b}"`);
          k = k && (C || $(F)), T(U, I);
        }
        if (!k)
          throw new Error(`discriminator: "${b}" must be required`);
        return w;
        function $({ required: I }) {
          return Array.isArray(I) && I.includes(b);
        }
        function T(I, F) {
          if (I.const)
            E(I.const, F);
          else if (I.enum)
            for (const U of I.enum)
              E(U, F);
          else
            throw new Error(`discriminator: "properties/${b}" must have "const" or "enum"`);
        }
        function E(I, F) {
          if (typeof I != "string" || I in w)
            throw new Error(`discriminator: "${b}" values must be unique strings`);
          w[I] = F;
        }
      }
    }
  };
  return Ea.default = i, Ea;
}
const A$ = "http://json-schema.org/draft-07/schema#", E$ = "http://json-schema.org/draft-07/schema#", T$ = "Core schema meta-schema", D$ = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, M$ = ["object", "boolean"], I$ = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, N$ = {
  $schema: A$,
  $id: E$,
  title: T$,
  definitions: D$,
  type: M$,
  properties: I$,
  default: !0
};
var nm;
function F$() {
  return nm || (nm = 1, (function(t, e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = e.Ajv = void 0;
    const r = Hk(), n = C$(), s = $$(), o = N$, i = ["/properties"], a = "http://json-schema.org/draft-07/schema";
    class l extends r.default {
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((b) => this.addVocabulary(b)), this.opts.discriminator && this.addKeyword(s.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const b = this.opts.$data ? this.$dataMetaSchema(o, i) : o;
        this.addMetaSchema(b, a, !1), this.refs["http://json-schema.org/schema"] = a;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
      }
    }
    e.Ajv = l, t.exports = e = l, t.exports.Ajv = l, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l;
    var u = tu();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return u.KeywordCxt;
    } });
    var c = He();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return c._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return c.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return c.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return c.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return c.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return c.CodeGen;
    } });
    var f = Ld();
    Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
      return f.default;
    } });
    var h = ru();
    Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
      return h.default;
    } });
  })(Hi, Hi.exports)), Hi.exports;
}
var R$ = F$();
function V$({ params: { missingProperty: t, propertyName: e }, propertyName: r = e }, n) {
  let s = n;
  return s = t !== void 0 ? n.concat(t) : s, s = r !== void 0 ? n.concat(r, Td("key-input")) : s, s;
}
function Ob({ params: { missingProperty: t }, parentSchema: e, message: r }, n) {
  if (!r)
    return "";
  if (t === void 0)
    return r;
  const s = n(t, e);
  return s === void 0 ? r : r.replace(t, s);
}
function L$({ uiSchema: t = {} }) {
  return (e, r) => ({
    value: r,
    errors: e.map((n) => {
      const s = lC(n.instancePath, r);
      return {
        path: V$(n, s),
        message: Ob(n, (o, i) => {
          const a = fC(t, s.concat(o));
          if (a !== void 0)
            return a;
          const l = i?.properties?.[o];
          if (typeof l == "object")
            return l.title;
        })
      };
    })
  });
}
function Cb(t) {
  return t.instancePath === "";
}
function j$(t) {
  return Cb(t) && t.keyword !== "type";
}
function B$(t) {
  return (e) => e.filter(t.required ? Cb : j$).map((r) => Ob(r, () => t.title));
}
function kb(t, e, r, n) {
  t(e);
  const s = t.errors;
  return t.errors = null, s ? n(s, e) : r(e);
}
const z$ = (t) => ({ value: t }), q$ = () => [];
function U$({ compileSchema: t }) {
  return {
    isValid(e, r, n) {
      if (typeof e == "boolean")
        return e;
      const s = t(e, r);
      try {
        return s(n);
      } catch (o) {
        return console.warn("Failed to validate", o), !1;
      }
    }
  };
}
function K$(t) {
  const e = L$(t);
  return {
    validateFormValue(r, n) {
      return kb(t.compileSchema(r, r), n, z$, e);
    }
  };
}
function W$({ compileFieldSchema: t }) {
  return {
    validateFieldValue(e, r) {
      return kb(t(e), r, q$, B$(e));
    }
  };
}
function H$({ ajvOptions: t = Pk, ajvPlugins: e = Ak, ajv: r = e(new R$.Ajv(t)), validatorsCache: n, compileSchema: s = Ek(r, !1, n), compileFieldSchema: o = Tk(r, !1), ...i } = {}) {
  const a = {
    ...i,
    compileSchema: s,
    compileFieldSchema: o
  };
  return Object.assign(U$(a), K$(a), W$(a));
}
function G$(t, e, { checkVisibility: r = !1 } = {}) {
  const n = t.querySelector(`[id="${e}"]`);
  return (n instanceof HTMLElement || n instanceof SVGElement) && n.tabIndex >= 0 && "disabled" in n && n.disabled !== !0 && (!r || window.getComputedStyle(n).visibility !== "hidden") ? n : null;
}
function Y$(t, e) {
  return t.querySelector(`#${e}`);
}
function X$(t, e) {
  if (t !== null)
    return () => t.focus();
  const r = e();
  return r !== null ? () => r.scrollIntoView({ behavior: "auto", block: "center" }) : null;
}
function J$(t = {}) {
  return ({ errors: e }, r, n) => {
    if (e.length === 0)
      return !1;
    const s = r.target;
    if (!(s instanceof HTMLElement))
      return console.warn("Expected form to be an HTMLElement, got", s), !1;
    const { path: o } = e[0], i = X$(G$(s, Bg(n, o), t), () => Y$(s, Bg(n, o.concat(Td("errors")))));
    return i === null ? !1 : Vl().then(i);
  };
}
const Z$ = "_";
function Q$({ idPrefix: t = Iy, separator: e = Z$ } = {}) {
  return {
    fromPath: (r) => {
      let n = "";
      for (let s = 0; s < r.length; s++) {
        const o = r[s], i = CC(o);
        n += i !== void 0 ? `${e}${e}${i}` : `${e}${o}`;
      }
      return `${t}${n}`;
    }
  };
}
function eA({ jsonSchemaMerger: { mergeSchemaDefinitions: t, mergeArrayOfSchemaDefinitions: e } = OO(), jsonSchemaAllOfMerge: r = kO(e) } = {}) {
  return {
    mergeSchemas(n, s) {
      return t(n, s);
    },
    mergeAllOf(n) {
      return r(n);
    }
  };
}
function tA(t) {
  const e = eA(t);
  return {
    ...e,
    mergeFormDataAndSchemaDefaults({ formData: r, schema: n, initialDefaultsGenerated: s = !1, includeUndefinedValues: o = !1 }) {
      return XO(t.validator, e, n, r, t.schema, o, t, s);
    }
  };
}
const rA = {
  submit: "Submit",
  "array-schema-missing-items": "Missing items definition",
  yes: "Yes",
  no: "No",
  "multi-schema-option-label-with-title": ({ title: t, index: e }) => `${t} option ${e + 1}`,
  "multi-schema-option-label": ({ index: t }) => `Option ${t + 1}`,
  "add-array-item": "Add item",
  "copy-array-item": "Copy",
  "add-object-property": "Add property",
  "move-array-item-down": "Down",
  "move-array-item-up": "Up",
  "remove-array-item": "Del",
  "remove-object-property": "Del",
  edit: "Edit",
  clear: "Clear",
  "validation-process-error": ({ error: t }) => nA[t.reason],
  "component-not-found": ({ type: t }) => `"${t}" component not found`,
  "key-input-title": ({ name: t }) => `${t} Key`,
  "additional-property": "Additional property",
  "unknown-field-error": ({ schema: t }) => `You're seeing this error because your JSON Schema doesnâ€™t contain enough information
to determine its type. You can:
- specify the schema type (for example, using the 'type' keyword)
- specify which component to use via UiSchema
  ('{ "ui:components": { "unknownField": "myField" } }')
- specify which component to use by providing a custom 'resolver'
  (https://x0k.dev/svelte-jsonschema-form/guides/fields-resolution/)

JSON Schema:
${JSON.stringify(t, null, 2)}`
}, nA = {
  aborted: "Validation aborted",
  timeout: "Validation terminated by timeout",
  error: "Something went wrong during validation"
}, sA = Ii(rA);
var Wu, sm;
function oA() {
  if (sm) return Wu;
  sm = 1;
  function t(c) {
    return c === void 0;
  }
  function e(c) {
    return c === null;
  }
  function r(c) {
    return typeof c == "boolean";
  }
  function n(c) {
    return c === Object(c);
  }
  function s(c) {
    return Array.isArray(c);
  }
  function o(c) {
    return c instanceof Date;
  }
  function i(c, f) {
    return f ? n(c) && !t(c.uri) : n(c) && typeof c.size == "number" && typeof c.type == "string" && typeof c.slice == "function";
  }
  function a(c, f) {
    return i(c, f) && typeof c.name == "string" && (n(c.lastModifiedDate) || typeof c.lastModified == "number");
  }
  function l(c) {
    return t(c) ? !1 : c;
  }
  function u(c, f, h, _) {
    f = f || {}, h = h || new FormData(), f.indices = l(f.indices), f.nullsAsUndefineds = l(f.nullsAsUndefineds), f.booleansAsIntegers = l(f.booleansAsIntegers), f.allowEmptyArrays = l(f.allowEmptyArrays), f.noAttributesWithArrayNotation = l(
      f.noAttributesWithArrayNotation
    ), f.noFilesWithArrayNotation = l(f.noFilesWithArrayNotation), f.dotsForObjectNotation = l(f.dotsForObjectNotation);
    const b = typeof h.getParts == "function";
    return t(c) || (e(c) ? f.nullsAsUndefineds || h.append(_, "") : r(c) ? f.booleansAsIntegers ? h.append(_, c ? 1 : 0) : h.append(_, c) : s(c) ? c.length ? c.forEach((p, g) => {
      let y = _ + "[" + (f.indices ? g : "") + "]";
      (f.noAttributesWithArrayNotation || f.noFilesWithArrayNotation && a(p, b)) && (y = _), u(p, f, h, y);
    }) : f.allowEmptyArrays && h.append(f.noAttributesWithArrayNotation ? _ : _ + "[]", "") : o(c) ? h.append(_, c.toISOString()) : n(c) && !i(c, b) ? Object.keys(c).forEach((p) => {
      const g = c[p];
      if (s(g))
        for (; p.length > 2 && p.lastIndexOf("[]") === p.length - 2; )
          p = p.substring(0, p.length - 2);
      const y = _ ? f.dotsForObjectNotation ? _ + "." + p : _ + "[" + p + "]" : p;
      u(g, f, h, y);
    }) : h.append(_, c)), h;
  }
  return Wu = {
    serialize: u
  }, Wu;
}
var iA = oA(), aA = /* @__PURE__ */ ne("<!> <!>", 1);
function zd(t, e) {
  W(e, !0);
  const r = (B) => {
    var R = M(), Z = D(R);
    te(
      Z,
      () => d($) ?? he,
      () => l,
      s,
      () => ({
        get current() {
          return n();
        },
        set current(Y) {
          n(Y);
        }
      }),
      () => d(w)
    ), A(B, R);
  };
  let n = v(e, "value", 15), s = v(e, "config", 7), o = v(e, "combinationKey", 7), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = Ee(), u = /* @__PURE__ */ O(() => Me(l, "multiFieldTemplate", s())), c = /* @__PURE__ */ O(() => Me(l, "selectWidget", s())), f = /* @__PURE__ */ O(() => {
    const { [o()]: B, ...R } = s().schema;
    if (po(s().schema) !== "object")
      return null;
    const Y = po(R);
    return {
      ...s(),
      schema: Y === "unknown" ? { type: "object" } : R
    };
  }), h = /* @__PURE__ */ O(() => d(f) && yo(l, d(f))), _ = /* @__PURE__ */ O(() => (s().schema[o()] ?? []).map((B) => typeof B != "boolean" ? Tr(l, B, n()) : {}));
  let b = /* @__PURE__ */ xe(void 0), p = /* @__PURE__ */ O(() => MC(l, n(), d(_), d(b) ?? 0, Ns(s().schema)));
  Xe(() => {
    const B = d(p);
    d(b) !== B && (n(ot(() => {
      const R = d(_)[B];
      if (R === void 0)
        return;
      const Z = d(b) !== void 0 ? d(_)[d(b)] : void 0;
      return Md(l, {
        schema: R,
        formData: Z !== void 0 ? DC(l, R, Z, n()) : n(),
        includeUndefinedValues: "excludeObjectChildren"
      });
    })), q(b, B));
  });
  const g = /* @__PURE__ */ O(() => {
    const B = s().uiSchema[o()];
    return Array.isArray(B) ? B.map((R) => Yn(l, R)) : [];
  }), y = /* @__PURE__ */ O(() => {
    const B = Xr(l, s().uiSchema) ?? s().schema.title;
    return B ? (R) => a()("multi-schema-option-label-with-title", { index: R, title: B }) : (R) => a()("multi-schema-option-label", { index: R });
  }), S = /* @__PURE__ */ O(() => {
    const B = Ns(s().schema);
    return d(_).map((R, Z) => {
      if (B !== void 0) {
        const X = d(g)[Z]?.[B];
        if (typeof X == "object" && !Array.isArray(X)) {
          const J = Xr(l, Yn(l, X));
          if (J !== void 0)
            return J;
        }
        const ae = R.properties?.[B];
        if (ae !== void 0 && typeof ae != "boolean") {
          const { title: J } = Tr(l, ae, void 0);
          if (J !== void 0)
            return J;
        }
      }
      const Y = d(g)[Z];
      return (Y && Xr(l, Y)) ?? R.title ?? d(y)(Z);
    });
  }), x = /* @__PURE__ */ O(() => d(S).map((B, R) => ({
    id: Fs(l, s().path, R),
    label: B,
    value: R,
    disabled: !1
  }))), P = /* @__PURE__ */ O(() => {
    const B = o().toLowerCase(), R = Yn(l, s().uiSchema.combinationFieldOptionSelector);
    return {
      path: Mi(l, s().path, B),
      title: Xr(l, R) ?? s().title,
      schema: { type: "integer", default: 0 },
      uiSchema: R,
      required: !0
    };
  }), w = /* @__PURE__ */ O(() => kt(l, s().path)), C = /* @__PURE__ */ O(() => {
    const B = d(b) ?? d(p);
    if (B < 0)
      return null;
    const R = d(_)[B], { required: Z } = s().schema, Y = Z ? {
      ...R,
      required: R.required ? Z.concat(R.required) : Z
    } : R, X = B < d(g).length ? d(g)[B] : s().uiSchema;
    return {
      path: s().path,
      title: "",
      schema: Y,
      uiSchema: X,
      required: s().required
    };
  }), k = /* @__PURE__ */ O(() => d(C) && yo(l, d(C))), $ = /* @__PURE__ */ O(() => vr(l, s(), `${o()}Field`));
  var T = {
    get value() {
      return n();
    },
    set value(B) {
      n(B), m();
    },
    get config() {
      return s();
    },
    set config(B) {
      s(B), m();
    },
    get combinationKey() {
      return o();
    },
    set combinationKey(B) {
      o(B), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(B) {
      i(B), m();
    },
    get translate() {
      return a();
    },
    set translate(B) {
      a(B), m();
    }
  }, E = aA(), I = D(E);
  {
    var F = (B) => {
      var R = M(), Z = D(R);
      {
        let Y = /* @__PURE__ */ O(() => Rs(l, d(f)));
        Q(Z, () => d(h), (X, ae) => {
          ae(X, {
            type: "field",
            get config() {
              return d(f);
            },
            uiOption: (J) => Nt(l, d(f), J),
            get translate() {
              return d(Y);
            },
            get value() {
              return n();
            },
            set value(J) {
              n(J);
            }
          });
        });
      }
      A(B, R);
    };
    ue(I, (B) => {
      d(f) && B(F);
    });
  }
  var U = be(I, 2);
  {
    const B = (Z) => {
      var Y = M(), X = D(Y), ae = () => d(b) ?? d(p), J = (j) => q(p, j);
      Q(X, () => d(c), (j, ee) => {
        ee(j, {
          type: "widget",
          get errors() {
            return d(w);
          },
          handlers: {},
          get config() {
            return d(P);
          },
          uiOption: (L) => Nt(l, d(P), L),
          get options() {
            return d(x);
          },
          get value() {
            return ae();
          },
          set value(L) {
            J(L);
          }
        });
      }), A(Z, Y);
    };
    let R = /* @__PURE__ */ O(() => d($) && r);
    Q(U, () => d(u), (Z, Y) => {
      Y(Z, {
        type: "template",
        get config() {
          return s();
        },
        get value() {
          return n();
        },
        get errors() {
          return d(w);
        },
        get uiOption() {
          return i();
        },
        get action() {
          return d(R);
        },
        optionSelector: B,
        children: (X, ae) => {
          var J = M(), j = D(J);
          {
            var ee = (L) => {
              var N = M(), V = D(N);
              {
                let G = /* @__PURE__ */ O(() => Rs(l, d(C)));
                Q(V, () => d(k), (fe, se) => {
                  se(fe, {
                    type: "field",
                    get config() {
                      return d(C);
                    },
                    uiOption: (we) => Nt(l, d(C), we),
                    get translate() {
                      return d(G);
                    },
                    get value() {
                      return n();
                    },
                    set value(we) {
                      n(we);
                    }
                  });
                });
              }
              A(L, N);
            };
            ue(j, (L) => {
              d(C) && L(ee);
            });
          }
          A(X, J);
        },
        $$slots: { optionSelector: !0, default: !0 }
      });
    });
  }
  return A(t, E), H(T);
}
K(
  zd,
  {
    value: {},
    config: {},
    combinationKey: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
class lA {
  array;
  nextKey;
  #e = /* @__PURE__ */ xe(0);
  get changesPropagator() {
    return d(this.#e);
  }
  set changesPropagator(e) {
    q(this.#e, e);
  }
  keys;
  constructor(e, r) {
    this.array = e, this.nextKey = r;
    const n = new Array(e.length);
    for (let s = 0; s < e.length; s++)
      n[s] = r();
    this.keys = n;
  }
  key(e) {
    return this.changesPropagator, this.keys[e];
  }
  push(e) {
    return this.keys.push(this.nextKey()), this.array.push(e);
  }
  swap(e, r) {
    const n = this.keys[e];
    if (this.keys[e] = this.keys[r], this.keys[r] = n, this.array[e] !== this.array[r]) {
      const s = this.array[e];
      this.array[e] = this.array[r], this.array[r] = s;
    }
    this.changesPropagator++;
  }
  insert(e, r) {
    this.keys.splice(e, 0, this.nextKey()), this.array.splice(e, 0, r);
  }
  remove(e) {
    return this.keys.splice(e, 1), this.array.splice(e, 1)[0];
  }
  splice(e, r, ...n) {
    const s = n.length;
    let o;
    if (s > 0) {
      const i = new Array(n.length);
      for (let a = 0; a < s; a++)
        i[a] = this.nextKey();
      this.keys.splice(e, r, ...i), o = this.array.splice(e, r, ...n);
    } else
      this.keys.splice(e, r), o = this.array.splice(e, r);
    return this.changesPropagator++, o;
  }
}
function uA(t, e, r) {
  return e >= r ? `${t}-${e - r + 1}` : t;
}
const $b = /* @__PURE__ */ Symbol("array-context");
function cA() {
  return Ms($b);
}
function dA(t) {
  Oo($b, t);
}
function Ab({ ctx: t, config: e, itemSchema: r, keyedArray: n, value: s }) {
  const o = (b) => Nt(t, e(), b);
  function i() {
    $s(t, e().path, sl);
    const b = rb(t);
    !(b & mC) || b & Ad && !t.isSubmitted || Cr(t, e(), s());
  }
  const a = /* @__PURE__ */ O(n), l = /* @__PURE__ */ O(() => kt(t, e().path)), u = /* @__PURE__ */ O(() => o("addable") ?? !0), c = /* @__PURE__ */ O(() => o("orderable") ?? !0), f = /* @__PURE__ */ O(() => o("removable") ?? !0), h = /* @__PURE__ */ O(() => o("copyable") ?? !1), _ = /* @__PURE__ */ O(() => o("itemTitle") ?? uA);
  return {
    config: e,
    uiOption: o,
    itemTitle(b, p, g, y) {
      return d(_)(b, p, g, y);
    },
    addable: () => d(u),
    orderable: () => d(c),
    removable: () => d(f),
    copyable: () => d(h),
    errors: () => d(l),
    key: (b) => d(a).key(b),
    pushItem: () => {
      const b = r();
      b !== void 0 && (d(a).push(Md(t, { schema: b, formData: void 0 }) ?? Ey(po(b))), i());
    },
    moveItemUp(b) {
      d(a).swap(b, b - 1), i();
    },
    moveItemDown(b) {
      d(a).swap(b, b + 1), i();
    },
    copyItem(b) {
      d(a).insert(b, Po(s()[b])), i();
    },
    removeItem(b) {
      d(a).remove(b), i();
    }
  };
}
function Eb(t, e, r) {
  let n;
  return () => r() && (n = t().schema.maxItems, n === void 0 || e() < n);
}
function fA({ ctx: t, config: e, value: r, keyedArray: n }) {
  const s = /* @__PURE__ */ O(r), o = /* @__PURE__ */ O(() => {
    const { schema: { items: f } } = e();
    return Be(f) ? f : {};
  }), i = Ab({
    ctx: t,
    config: e,
    value: r,
    keyedArray: n,
    itemSchema: () => d(o)
  }), a = /* @__PURE__ */ O(() => {
    const { uiSchema: { items: f } } = e();
    return Yn(t, Array.isArray(f) ? void 0 : f);
  }), l = /* @__PURE__ */ O(() => Xr(t, d(a))), u = () => d(s)?.length ?? 0, c = /* @__PURE__ */ O(Eb(e, u, i.addable));
  return {
    ...i,
    length: u,
    set(f, h) {
      d(s)[f] = h;
    },
    canAdd() {
      return d(c);
    },
    canCopy() {
      return i.copyable() && d(c);
    },
    canRemove: i.removable,
    canMoveUp(f) {
      return i.orderable() && f > 0;
    },
    canMoveDown(f) {
      return i.orderable() && f < d(s).length - 1;
    },
    itemConfig(f, h, _) {
      const b = Tr(t, d(o), h);
      return {
        path: Xl(t, f.path, _),
        title: i.itemTitle(d(l) ?? b.title ?? f.title, _, 0, h),
        schema: b,
        uiSchema: d(a),
        required: !my(b)
      };
    }
  };
}
function hA({ ctx: t, config: e, value: r, keyedArray: n }) {
  const s = /* @__PURE__ */ O(r), o = /* @__PURE__ */ O(() => {
    const { items: b } = e().schema;
    return Array.isArray(b) ? b.map((p, g) => {
      if (typeof p == "boolean")
        throw new Error("Invalid schema: items must be an array of schemas");
      return Tr(t, p, d(s)?.[g]);
    }) : [];
  }), i = (b) => b >= d(o).length, a = /* @__PURE__ */ O(() => {
    const { additionalItems: b } = e().schema;
    return Be(b) ? b : void 0;
  }), l = /* @__PURE__ */ O(n), u = Ab({
    ctx: t,
    config: e,
    value: r,
    keyedArray: () => d(l),
    itemSchema: () => d(a)
  }), c = /* @__PURE__ */ O(() => Math.max(d(s)?.length ?? 0, d(o).length)), f = () => d(c), h = /* @__PURE__ */ O(Eb(e, f, () => u.addable() && d(a) !== void 0));
  function _(b = gy) {
    const p = new Array(d(c));
    b(p), d(l).splice(0, 0, ...p);
  }
  return {
    ...u,
    length: f,
    pushItem() {
      d(s) || _(), u.pushItem();
    },
    set(b, p) {
      d(s) ? d(s)[b] = p : _((g) => {
        g[b] = p;
      });
    },
    canAdd() {
      return d(h);
    },
    canCopy(b) {
      return u.copyable() && d(h) && i(b);
    },
    canRemove(b) {
      return u.removable() && i(b);
    },
    canMoveUp(b) {
      return u.orderable() && b > d(o).length;
    },
    canMoveDown(b) {
      return u.orderable() && b < d(c) - 1 && i(b);
    },
    itemConfig(b, p, g) {
      const y = i(g), S = Tr(
        t,
        y ? d(a) : d(o)[g],
        p
      ), x = Yn(t, y ? b.uiSchema.additionalItems : Array.isArray(b.uiSchema.items) ? b.uiSchema.items[g] : b.uiSchema.items);
      return {
        path: Xl(t, b.path, g),
        title: u.itemTitle(Xr(t, x) ?? S.title ?? b.title, g, d(o).length, p),
        schema: S,
        uiSchema: x,
        required: !my(S)
      };
    }
  };
}
class gA {
  setValue;
  constructor(e) {
    this.setValue = e;
  }
  key(e) {
    return e;
  }
  push(e) {
    return this.setValue([e]), 1;
  }
  swap() {
    throw new Error('Method "swap" cannot be called on "VirtualKeyedArray" instance');
  }
  insert(e, r) {
    if (e !== 0)
      throw new Error(`Method "insert" cannot be called on "VirtualKeyedArray" instance with those args (index=${e}), expected (0)`);
    this.setValue([r]);
  }
  remove(e) {
    throw new Error('Method "remove" cannot be called on "VirtualKeyedArray" instance');
  }
  splice(e, r, ...n) {
    if (e !== 0 || r !== 0)
      throw new Error(`Method "splice" cannot be called on "VirtualKeyedArray" instance with those args(start=${e}, count=${r}) expected (0, 0)`);
    return this.setValue(n), [];
  }
}
function qd(t, e) {
  W(e, !0);
  const r = (x) => {
    var P = M(), w = D(P);
    {
      let C = /* @__PURE__ */ O(() => f.errors());
      Q(w, () => d(b), (k, $) => {
        $(k, {
          get errors() {
            return d(C);
          },
          get config() {
            return o();
          },
          disabled: !1,
          type: "array-item-add",
          get onclick() {
            return f.pushItem;
          },
          children: (T, E) => {
            _n(T, {
              get config() {
                return o();
              },
              id: "add-array-item",
              get translate() {
                return l();
              }
            });
          },
          $$slots: { default: !0 }
        });
      });
    }
    A(x, P);
  }, n = (x) => {
    var P = M(), w = D(P);
    {
      let C = /* @__PURE__ */ O(() => f.errors());
      te(
        w,
        () => d(p) ?? he,
        () => c,
        o,
        () => ({
          get current() {
            return s();
          },
          set current(k) {
            s(k);
          }
        }),
        () => d(C)
      );
    }
    A(x, P);
  };
  let s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "createContext", 7), a = v(e, "uiOption", 7), l = v(e, "translate", 7), u = v(e, "field", 7);
  const c = Ee(), f = i()({
    ctx: c,
    config: () => o(),
    value: () => s(),
    keyedArray: nk(c, () => s(), () => new gA((x) => s(x)), (x, P) => new lA(x, P))
  });
  dA(f);
  const h = /* @__PURE__ */ O(() => Me(c, "arrayItemField", o())), _ = /* @__PURE__ */ O(() => Me(c, "arrayTemplate", o())), b = /* @__PURE__ */ O(() => Me(c, "button", o())), p = /* @__PURE__ */ O(() => vr(c, o(), u()));
  var g = {
    get value() {
      return s();
    },
    set value(x) {
      s(x), m();
    },
    get config() {
      return o();
    },
    set config(x) {
      o(x), m();
    },
    get createContext() {
      return i();
    },
    set createContext(x) {
      i(x), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(x) {
      a(x), m();
    },
    get translate() {
      return l();
    },
    set translate(x) {
      l(x), m();
    },
    get field() {
      return u();
    },
    set field(x) {
      u(x), m();
    }
  }, y = M(), S = D(y);
  {
    let x = /* @__PURE__ */ O(() => f.errors()), P = /* @__PURE__ */ O(() => f.canAdd() ? r : void 0), w = /* @__PURE__ */ O(() => d(p) && n);
    Q(S, () => d(_), (C, k) => {
      k(C, {
        type: "template",
        get errors() {
          return d(x);
        },
        get config() {
          return o();
        },
        get value() {
          return s();
        },
        get uiOption() {
          return a();
        },
        get addButton() {
          return d(P);
        },
        get action() {
          return d(w);
        },
        children: ($, T) => {
          var E = M(), I = D(E);
          st(I, 19, () => ({ length: f.length() }), (F, U) => f.key(U), (F, U, B) => {
            const R = /* @__PURE__ */ O(() => f.itemConfig(o(), s()?.[d(B)], d(B)));
            var Z = M(), Y = D(Z), X = () => s()?.[d(B)], ae = (J) => f.set(d(B), J);
            {
              let J = /* @__PURE__ */ O(() => Rs(c, d(R)));
              Q(Y, () => d(h), (j, ee) => {
                ee(j, {
                  type: "field",
                  get index() {
                    return d(B);
                  },
                  get config() {
                    return d(R);
                  },
                  get value() {
                    return X();
                  },
                  set value(L) {
                    ae(L);
                  },
                  uiOption: (L) => Nt(c, d(R), L),
                  get translate() {
                    return d(J);
                  }
                });
              });
            }
            A(F, Z);
          }), A($, E);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, y), H(g);
}
K(
  qd,
  {
    value: {},
    config: {},
    createContext: {},
    uiOption: {},
    translate: {},
    field: {}
  },
  [],
  [],
  { mode: "open" }
);
function Tb(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return qd(t, {
    type: "field",
    field: "arrayField",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get createContext() {
      return fA;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), H(i);
}
K(Tb, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Db(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return qd(t, {
    type: "field",
    field: "tupleField",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get createContext() {
      return hA;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), H(i);
}
K(Db, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
var pA = /* @__PURE__ */ ne("<!> <!>", 1), mA = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function Mb(t, e) {
  W(e, !0);
  const r = (C) => {
    var k = mA(), $ = D(k);
    {
      var T = (B) => {
        var R = pA(), Z = D(R);
        {
          let X = /* @__PURE__ */ O(() => !d(p));
          Q(Z, () => d(h), (ae, J) => {
            J(ae, {
              get errors() {
                return d(S);
              },
              get config() {
                return o();
              },
              type: "array-item-move-up",
              get disabled() {
                return d(X);
              },
              onclick: () => {
                u.moveItemUp(n());
              },
              children: (j, ee) => {
                _n(j, {
                  get config() {
                    return o();
                  },
                  id: "move-array-item-up",
                  get translate() {
                    return a();
                  }
                });
              },
              $$slots: { default: !0 }
            });
          });
        }
        var Y = be(Z, 2);
        {
          let X = /* @__PURE__ */ O(() => !d(g));
          Q(Y, () => d(h), (ae, J) => {
            J(ae, {
              get errors() {
                return d(S);
              },
              get config() {
                return o();
              },
              get disabled() {
                return d(X);
              },
              type: "array-item-move-down",
              onclick: () => {
                u.moveItemDown(n());
              },
              children: (j, ee) => {
                _n(j, {
                  get config() {
                    return o();
                  },
                  id: "move-array-item-down",
                  get translate() {
                    return a();
                  }
                });
              },
              $$slots: { default: !0 }
            });
          });
        }
        A(B, R);
      };
      ue($, (B) => {
        u.orderable() && B(T);
      });
    }
    var E = be($, 2);
    {
      var I = (B) => {
        var R = M(), Z = D(R);
        Q(Z, () => d(h), (Y, X) => {
          X(Y, {
            get errors() {
              return d(S);
            },
            get config() {
              return o();
            },
            type: "array-item-copy",
            onclick: () => {
              u.copyItem(n());
            },
            disabled: !1,
            children: (ae, J) => {
              _n(ae, {
                get config() {
                  return o();
                },
                id: "copy-array-item",
                get translate() {
                  return a();
                }
              });
            },
            $$slots: { default: !0 }
          });
        }), A(B, R);
      };
      ue(E, (B) => {
        d(_) && B(I);
      });
    }
    var F = be(E, 2);
    {
      var U = (B) => {
        var R = M(), Z = D(R);
        Q(Z, () => d(h), (Y, X) => {
          X(Y, {
            get errors() {
              return d(S);
            },
            get config() {
              return o();
            },
            disabled: !1,
            type: "array-item-remove",
            onclick: () => {
              u.removeItem(n());
            },
            children: (ae, J) => {
              _n(ae, {
                get config() {
                  return o();
                },
                id: "remove-array-item",
                get translate() {
                  return a();
                }
              });
            },
            $$slots: { default: !0 }
          });
        }), A(B, R);
      };
      ue(F, (B) => {
        d(b) && B(U);
      });
    }
    A(C, k);
  };
  let n = v(e, "index", 7), s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = Ee(), u = cA(), c = /* @__PURE__ */ O(() => Me(l, "arrayItemTemplate", o())), f = /* @__PURE__ */ O(() => yo(l, o())), h = /* @__PURE__ */ O(() => Me(l, "button", o())), _ = /* @__PURE__ */ O(() => u.canCopy(n())), b = /* @__PURE__ */ O(() => u.canRemove(n())), p = /* @__PURE__ */ O(() => u.canMoveUp(n())), g = /* @__PURE__ */ O(() => u.canMoveDown(n())), y = /* @__PURE__ */ O(() => d(_) || d(b) || d(p) || d(g)), S = /* @__PURE__ */ O(() => kt(l, o().path));
  var x = {
    get index() {
      return n();
    },
    set index(C) {
      n(C), m();
    },
    get value() {
      return s();
    },
    set value(C) {
      s(C), m();
    },
    get config() {
      return o();
    },
    set config(C) {
      o(C), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(C) {
      i(C), m();
    },
    get translate() {
      return a();
    },
    set translate(C) {
      a(C), m();
    }
  }, P = M(), w = D(P);
  {
    let C = /* @__PURE__ */ O(() => d(y) ? r : void 0);
    Q(w, () => d(c), (k, $) => {
      $(k, {
        type: "template",
        get index() {
          return n();
        },
        get value() {
          return s();
        },
        get config() {
          return o();
        },
        get errors() {
          return d(S);
        },
        get buttons() {
          return d(C);
        },
        get uiOption() {
          return i();
        },
        children: (T, E) => {
          var I = M(), F = D(I);
          Q(F, () => d(f), (U, B) => {
            B(U, {
              type: "field",
              get config() {
                return o();
              },
              get uiOption() {
                return i();
              },
              get translate() {
                return a();
              },
              get value() {
                return s();
              },
              set value(R) {
                s(R);
              }
            });
          }), A(T, I);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, P), H(x);
}
K(
  Mb,
  {
    index: {},
    value: {},
    config: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
function om(t, e, r) {
  let n = 0, s;
  do
    s = r(e, n++);
  while (s in t);
  return s;
}
function vA(t, e) {
  return e === 0 ? t : `${t}-${e}`;
}
function yA(t) {
  const e = [], r = Object.keys(t);
  for (const n of r) {
    const s = t[n];
    !er(s) || Bl in s || e.push(n);
  }
  return e.length < r.length && e.push("*"), e;
}
const Ib = /* @__PURE__ */ Symbol("object-context");
function Nb() {
  return Ms(Ib);
}
function bA(t) {
  Oo(Ib, t);
}
function _A({ ctx: t, config: e, value: r, setValue: n, translate: s }) {
  const o = /* @__PURE__ */ O(() => Tr(t, e().schema, r(), !0));
  let i;
  const a = /* @__PURE__ */ O(() => {
    const y = Po(d(o).properties);
    return zO(i, y) || (i = y), i;
  });
  Xe(() => {
    d(a), IC(t);
  });
  const l = (y) => Nt(t, e(), y), u = /* @__PURE__ */ O(() => Be(d(a)) ? tC(d(a), l("order") ?? yA(d(a))) : []), c = /* @__PURE__ */ O(() => new Set(d(o).required)), f = /* @__PURE__ */ O(() => {
    const { additionalProperties: y, patternProperties: S } = d(o);
    let x;
    if (S !== void 0 && (x = Object.keys(S), x.length > 0)) {
      const P = x.map((C) => {
        const k = S[C];
        return [
          new RegExp(C),
          typeof k == "boolean" ? {} : k
        ];
      }), w = Be(y) ? (C) => Tr(t, y, C) : () => P[0][1];
      return (C, k) => Tr(t, P.find(([$]) => $.test(k))?.[1] ?? w(C), C);
    }
    return Be(y) ? (P) => Tr(t, y, P) : () => ({});
  }), h = /* @__PURE__ */ O(() => l("expandable") !== !1 && sC(d(o), r())), _ = /* @__PURE__ */ O(() => kt(t, e().path)), b = /* @__PURE__ */ O(() => s("additional-property", {}));
  function p(y) {
    $s(t, e().path, sl);
    const S = rb(t);
    !(S & vC) || S & Ad && !t.isSubmitted || Cr(t, e(), y);
  }
  const g = /* @__PURE__ */ O(() => l("additionalPropertyKey") ?? vA);
  return {
    errors() {
      return d(_);
    },
    canExpand() {
      return d(h);
    },
    propertiesOrder() {
      return d(u);
    },
    isAdditionalProperty(y) {
      return rC(d(a), y);
    },
    propertyConfig(y, S, x) {
      const P = d(a)[S] ?? !1, w = typeof P == "boolean" ? {} : Tr(t, P, r()?.[S]), C = Yn(t, x ? y.uiSchema.additionalProperties : y.uiSchema[S]);
      return {
        path: Xl(t, y.path, S),
        title: Xr(t, C) ?? w.title ?? S,
        schema: w,
        uiSchema: C,
        required: d(c).has(S)
      };
    },
    addProperty() {
      let y = r();
      const S = y ? om(y, d(b), d(g)) : d(g)(d(b), 0), x = d(f)(y, S), P = Md(t, { schema: x, formData: void 0 }) ?? Ey(po(x));
      y ? y[S] = P : (y = { [S]: P }, n(y)), p(y);
    },
    removeProperty(y) {
      const S = r();
      S && (delete S[y], p(S));
    },
    renameProperty(y, S, x) {
      const P = r();
      if (!P)
        return;
      const w = om(P, S, d(g));
      VC(t, e(), w, x) && (P[w] = P[y], delete P[y], p(P));
    }
  };
}
const wA = "objectField";
function Fb(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    {
      let P = /* @__PURE__ */ O(() => u.errors());
      Q(x, () => d(h), (w, C) => {
        C(w, {
          type: "object-property-add",
          get config() {
            return o();
          },
          get errors() {
            return d(P);
          },
          disabled: !1,
          get onclick() {
            return u.addProperty;
          },
          children: (k, $) => {
            _n(k, {
              get config() {
                return o();
              },
              id: "add-object-property",
              get translate() {
                return l();
              }
            });
          },
          $$slots: { default: !0 }
        });
      });
    }
    A(y, S);
  }, n = (y) => {
    var S = M(), x = D(S);
    {
      let P = /* @__PURE__ */ O(() => u.errors());
      te(
        x,
        () => d(_) ?? he,
        () => s,
        o,
        () => ({
          get current() {
            return i();
          },
          set current(w) {
            i(w);
          }
        }),
        () => d(P)
      );
    }
    A(y, S);
  }, s = Ee();
  let o = v(e, "config", 7), i = v(e, "value", 15), a = v(e, "uiOption", 7), l = v(e, "translate", 7);
  const u = _A({
    ctx: s,
    config: () => o(),
    value: () => i(),
    setValue: (y) => i(y),
    translate: l()
  });
  bA(u);
  const c = /* @__PURE__ */ O(() => Me(s, "objectPropertyField", o())), f = /* @__PURE__ */ O(() => Me(s, "objectTemplate", o())), h = /* @__PURE__ */ O(() => Me(s, "button", o())), _ = /* @__PURE__ */ O(() => vr(s, o(), wA));
  var b = {
    get config() {
      return o();
    },
    set config(y) {
      o(y), m();
    },
    get value() {
      return i();
    },
    set value(y) {
      i(y), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(y) {
      a(y), m();
    },
    get translate() {
      return l();
    },
    set translate(y) {
      l(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => u.errors()), S = /* @__PURE__ */ O(() => u.canExpand() ? r : void 0), x = /* @__PURE__ */ O(() => d(_) && n);
    Q(g, () => d(f), (P, w) => {
      w(P, {
        type: "template",
        get value() {
          return i();
        },
        get config() {
          return o();
        },
        get uiOption() {
          return a();
        },
        get errors() {
          return d(y);
        },
        get addButton() {
          return d(S);
        },
        get action() {
          return d(x);
        },
        children: (C, k) => {
          var $ = M(), T = D($);
          st(T, 16, () => u.propertiesOrder(), (E) => E, (E, I) => {
            const F = /* @__PURE__ */ O(() => u.isAdditionalProperty(I)), U = /* @__PURE__ */ O(() => u.propertyConfig(o(), I, d(F)));
            var B = M(), R = D(B), Z = () => i()?.[I], Y = (X) => {
              const ae = i();
              ae ? ae[I] = X : i({ [I]: X });
            };
            {
              let X = /* @__PURE__ */ O(() => Rs(s, d(U)));
              Q(R, () => d(c), (ae, J) => {
                J(ae, {
                  type: "field",
                  get property() {
                    return I;
                  },
                  get isAdditional() {
                    return d(F);
                  },
                  get value() {
                    return Z();
                  },
                  set value(j) {
                    Y(j);
                  },
                  get config() {
                    return d(U);
                  },
                  uiOption: (j) => Nt(s, d(U), j),
                  get translate() {
                    return d(X);
                  }
                });
              });
            }
            A(E, B);
          }), A(C, $);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Fb, { config: {}, value: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Rb(t, e) {
  W(e, !0);
  const r = v(e, "parent", 7), n = v(e, "property", 7), s = v(e, "uiSchema", 7), o = v(e, "translate", 7), i = Ee(), a = Nb(), l = /* @__PURE__ */ O(() => ({
    path: Mi(i, r().path, "key-input"),
    title: Xr(i, s()) ?? o()("key-input-title", { name: n() }),
    schema: { type: "string" },
    uiSchema: s(),
    required: !0
  })), u = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", d(l))), c = "textWidget", f = /* @__PURE__ */ O(() => Me(i, c, d(l)));
  let h = /* @__PURE__ */ O(n);
  const _ = {
    onblur: () => {
      d(h) === void 0 || d(h) === n() || a.renameProperty(n(), d(h), d(l));
    }
  }, b = /* @__PURE__ */ O(() => kt(i, d(l).path)), p = (x) => Nt(i, d(l), x);
  var g = {
    get parent() {
      return r();
    },
    set parent(x) {
      r(x), m();
    },
    get property() {
      return n();
    },
    set property(x) {
      n(x), m();
    },
    get uiSchema() {
      return s();
    },
    set uiSchema(x) {
      s(x), m();
    },
    get translate() {
      return o();
    },
    set translate(x) {
      o(x), m();
    }
  }, y = M(), S = D(y);
  return Q(S, () => d(u), (x, P) => {
    P(x, {
      type: "template",
      showTitle: !0,
      useLabel: !0,
      widgetType: c,
      get value() {
        return n();
      },
      get config() {
        return d(l);
      },
      get errors() {
        return d(b);
      },
      uiOption: p,
      children: (w, C) => {
        var k = M(), $ = D(k);
        Q($, () => d(f), (T, E) => {
          E(T, {
            type: "widget",
            get errors() {
              return d(b);
            },
            get handlers() {
              return _;
            },
            get config() {
              return d(l);
            },
            uiOption: p,
            get value() {
              return d(h);
            },
            set value(I) {
              q(h, I);
            }
          });
        }), A(w, k);
      },
      $$slots: { default: !0 }
    });
  }), A(t, y), H(g);
}
K(Rb, { parent: {}, property: {}, uiSchema: {}, translate: {} }, [], [], { mode: "open" });
function Vb(t, e) {
  W(e, !0);
  const r = (x) => {
    {
      let P = /* @__PURE__ */ O(() => Yn(c, s().uiSchema.additionalPropertyKeyInput));
      Rb(x, {
        get translate() {
          return u();
        },
        get property() {
          return o();
        },
        get parent() {
          return s();
        },
        get uiSchema() {
          return d(P);
        }
      });
    }
  }, n = (x) => {
    var P = M(), w = D(P);
    Q(w, () => d(b), (C, k) => {
      k(C, {
        get errors() {
          return d(p);
        },
        get config() {
          return s();
        },
        type: "object-property-remove",
        disabled: !1,
        onclick: () => {
          f.removeProperty(o());
        },
        children: ($, T) => {
          _n($, {
            get config() {
              return s();
            },
            id: "remove-object-property",
            get translate() {
              return u();
            }
          });
        },
        $$slots: { default: !0 }
      });
    }), A(x, P);
  };
  let s = v(e, "config", 7), o = v(e, "property", 7), i = v(e, "isAdditional", 7), a = v(e, "value", 15), l = v(e, "uiOption", 7), u = v(e, "translate", 7);
  const c = Ee(), f = Nb(), h = /* @__PURE__ */ O(() => Me(c, "objectPropertyTemplate", s())), _ = /* @__PURE__ */ O(() => yo(c, s())), b = /* @__PURE__ */ O(() => Me(c, "button", s())), p = /* @__PURE__ */ O(() => kt(c, s().path));
  var g = {
    get config() {
      return s();
    },
    set config(x) {
      s(x), m();
    },
    get property() {
      return o();
    },
    set property(x) {
      o(x), m();
    },
    get isAdditional() {
      return i();
    },
    set isAdditional(x) {
      i(x), m();
    },
    get value() {
      return a();
    },
    set value(x) {
      a(x), m();
    },
    get uiOption() {
      return l();
    },
    set uiOption(x) {
      l(x), m();
    },
    get translate() {
      return u();
    },
    set translate(x) {
      u(x), m();
    }
  }, y = M(), S = D(y);
  {
    let x = /* @__PURE__ */ O(() => i() ? r : void 0), P = /* @__PURE__ */ O(() => i() ? n : void 0);
    Q(S, () => d(h), (w, C) => {
      C(w, {
        type: "template",
        get property() {
          return o();
        },
        get value() {
          return a();
        },
        get config() {
          return s();
        },
        get errors() {
          return d(p);
        },
        get keyInput() {
          return d(x);
        },
        get removeButton() {
          return d(P);
        },
        get uiOption() {
          return l();
        },
        children: (k, $) => {
          var T = M(), E = D(T);
          Q(E, () => d(_), (I, F) => {
            F(I, {
              type: "field",
              get config() {
                return s();
              },
              get uiOption() {
                return l();
              },
              get translate() {
                return u();
              },
              get value() {
                return a();
              },
              set value(U) {
                a(U);
              }
            });
          }), A(k, T);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, y), H(g);
}
K(
  Vb,
  {
    config: {},
    property: {},
    isAdditional: {},
    value: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
function Fi(t, e) {
  W(e, !0);
  const r = (w) => {
    var C = M(), k = D(C);
    te(
      k,
      () => d(y) ?? he,
      () => n,
      a,
      () => ({
        get current() {
          return i();
        },
        set current($) {
          i($);
        }
      }),
      () => d(g)
    ), A(w, C);
  }, n = Ee();
  let s = v(e, "field", 7), o = v(e, "widgetType", 7), i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "uiOption", 7), u = v(e, "fromValue", 7), c = v(e, "toValue", 7), f = v(e, "showTitle", 7), h = v(e, "useLabel", 7);
  const _ = /* @__PURE__ */ O(() => Me(n, "fieldTemplate", a())), b = /* @__PURE__ */ O(() => Me(n, o(), a())), p = un(n, () => a(), () => Cr(n, a(), i())), g = /* @__PURE__ */ O(() => kt(n, a().path)), y = /* @__PURE__ */ O(() => vr(n, a(), s()));
  var S = {
    get field() {
      return s();
    },
    set field(w) {
      s(w), m();
    },
    get widgetType() {
      return o();
    },
    set widgetType(w) {
      o(w), m();
    },
    get value() {
      return i();
    },
    set value(w) {
      i(w), m();
    },
    get config() {
      return a();
    },
    set config(w) {
      a(w), m();
    },
    get uiOption() {
      return l();
    },
    set uiOption(w) {
      l(w), m();
    },
    get fromValue() {
      return u();
    },
    set fromValue(w) {
      u(w), m();
    },
    get toValue() {
      return c();
    },
    set toValue(w) {
      c(w), m();
    },
    get showTitle() {
      return f();
    },
    set showTitle(w) {
      f(w), m();
    },
    get useLabel() {
      return h();
    },
    set useLabel(w) {
      h(w), m();
    }
  }, x = M(), P = D(x);
  {
    let w = /* @__PURE__ */ O(() => d(y) && r);
    Q(P, () => d(_), (C, k) => {
      k(C, {
        type: "template",
        get showTitle() {
          return f();
        },
        get useLabel() {
          return h();
        },
        get widgetType() {
          return o();
        },
        get uiOption() {
          return l();
        },
        get value() {
          return i();
        },
        get config() {
          return a();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(w);
        },
        children: ($, T) => {
          var E = M(), I = D(E), F = () => u()(i()), U = (B) => i(c()(B));
          Q(I, () => d(b), (B, R) => {
            R(B, {
              type: "widget",
              get config() {
                return a();
              },
              get errors() {
                return d(g);
              },
              get uiOption() {
                return l();
              },
              get value() {
                return F();
              },
              set value(Z) {
                U(Z);
              },
              get handlers() {
                return p;
              }
            });
          }), A($, E);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, x), H(S);
}
K(
  Fi,
  {
    field: {},
    widgetType: {},
    value: {},
    config: {},
    uiOption: {},
    fromValue: {},
    toValue: {},
    showTitle: {},
    useLabel: {}
  },
  [],
  [],
  { mode: "open" }
);
const SA = "booleanField";
function Lb(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "uiOption", 7);
  var o = {
    get config() {
      return r();
    },
    set config(i) {
      r(i), m();
    },
    get value() {
      return n();
    },
    set value(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  {
    let i = /* @__PURE__ */ O(() => s()("hideTitle") === !1);
    Fi(t, {
      field: SA,
      get config() {
        return r();
      },
      get uiOption() {
        return s();
      },
      widgetType: "checkboxWidget",
      get showTitle() {
        return d(i);
      },
      useLabel: !0,
      fromValue: (a) => a ?? void 0,
      get toValue() {
        return rl;
      },
      get value() {
        return n();
      },
      set value(a) {
        n(a);
      }
    });
  }
  return H(o);
}
K(Lb, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
const xA = "integerField";
function jb(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  var o = {
    get value() {
      return r();
    },
    set value(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(l) {
      s(l), m();
    }
  }, i = () => r(), a = (l) => {
    Number.isInteger(l) ? r(l) : l === void 0 && r(s()("numberEmptyValue"));
  };
  return Fi(t, {
    field: xA,
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "numberWidget",
    get value() {
      return i();
    },
    set value(l) {
      a(l);
    },
    fromValue: (l) => l ?? void 0,
    get toValue() {
      return rl;
    }
  }), H(o);
}
K(jb, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
function Bb(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  Xe(() => {
    r() === void 0 && r(null);
  });
  const o = Ee(), i = /* @__PURE__ */ O(() => Me(o, "fieldTemplate", n())), a = /* @__PURE__ */ O(() => kt(o, n().path));
  var l = {
    get value() {
      return r();
    },
    set value(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(f) {
      s(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(i), (f, h) => {
    h(f, {
      type: "template",
      showTitle: !0,
      useLabel: !1,
      widgetType: "nullField",
      get uiOption() {
        return s();
      },
      get errors() {
        return d(a);
      },
      get value() {
        return r();
      },
      get config() {
        return n();
      },
      children: (_, b) => {
        vt();
        var p = tt();
        p.nodeValue = "", A(_, p);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), H(l);
}
K(Bb, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
const PA = "numberField";
function zb(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  var o = {
    get value() {
      return r();
    },
    set value(i) {
      r(i), m();
    },
    get config() {
      return n();
    },
    set config(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  return Fi(t, {
    field: PA,
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "numberWidget",
    fromValue: (i) => i ?? void 0,
    toValue: (i) => i ?? s()("numberEmptyValue"),
    get value() {
      return r();
    },
    set value(i) {
      r(i);
    }
  }), H(o);
}
K(zb, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
const OA = "stringField";
function Ud(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "uiOption", 7);
  var o = {
    get config() {
      return r();
    },
    set config(i) {
      r(i), m();
    },
    get value() {
      return n();
    },
    set value(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  return Fi(t, {
    field: OA,
    get config() {
      return r();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "textWidget",
    fromValue: (i) => i ?? void 0,
    toValue: (i) => i || s()("stringEmptyValue"),
    get value() {
      return n();
    },
    set value(i) {
      n(i);
    }
  }), H(o);
}
K(Ud, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function qb(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return zd(t, {
    type: "field",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get combinationKey() {
      return so;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), H(i);
}
K(qb, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Ub(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "uiOption", 7), s = v(e, "value", 15), o = v(e, "translate", 7);
  var i = {
    get config() {
      return r();
    },
    set config(a) {
      r(a), m();
    },
    get uiOption() {
      return n();
    },
    set uiOption(a) {
      n(a), m();
    },
    get value() {
      return s();
    },
    set value(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return zd(t, {
    type: "field",
    get config() {
      return r();
    },
    get uiOption() {
      return n();
    },
    get translate() {
      return o();
    },
    get combinationKey() {
      return oo;
    },
    get value() {
      return s();
    },
    set value(a) {
      s(a);
    }
  }), H(i);
}
K(Ub, { config: {}, uiOption: {}, value: {}, translate: {} }, [], [], { mode: "open" });
function Kb(t, e) {
  W(e, !0);
  const r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7), i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = /* @__PURE__ */ O(() => kt(i, n().path));
  var u = {
    get value() {
      return r();
    },
    set value(h) {
      r(h), m();
    },
    get config() {
      return n();
    },
    set config(h) {
      n(h), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(h) {
      s(h), m();
    },
    get translate() {
      return o();
    },
    set translate(h) {
      o(h), m();
    }
  }, c = M(), f = D(c);
  return Q(f, () => d(a), (h, _) => {
    _(h, {
      type: "template",
      showTitle: !0,
      useLabel: !1,
      widgetType: "unknownField",
      get uiOption() {
        return s();
      },
      get errors() {
        return d(l);
      },
      get config() {
        return n();
      },
      value: void 0,
      children: (b, p) => {
        {
          let g = /* @__PURE__ */ O(() => o()("unknown-field-error", { schema: n().schema }));
          Nd(b, {
            get message() {
              return d(g);
            }
          });
        }
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), H(u);
}
K(Kb, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
const CA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anyOfField: qb,
  arrayField: Tb,
  arrayItemField: Mb,
  booleanField: Lb,
  integerField: jb,
  nullField: Bb,
  numberField: zb,
  objectField: Fb,
  objectPropertyField: Vb,
  oneOfField: Ub,
  stringField: Ud,
  tupleField: Db,
  unknownField: Kb
}, Symbol.toStringTag, { value: "Module" }));
function Kd(t, e) {
  return {
    title: e.title,
    showMeta: t("hideTitle") !== !0,
    description: t("description") ?? e.schema.description
  };
}
var kA = /* @__PURE__ */ ne("<!> <!>", 1), $A = /* @__PURE__ */ ne("<!> <!>", 1), AA = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function Wb(t, e) {
  W(e, !0);
  const r = "fieldTemplate", n = v(e, "children", 7), s = v(e, "config", 7), o = v(e, "uiOption", 7), i = v(e, "showTitle", 7), a = v(e, "useLabel", 7), l = v(e, "errors", 7), u = v(e, "action", 7), c = Ee(), f = /* @__PURE__ */ O(() => Me(c, "layout", s())), h = /* @__PURE__ */ O(() => Me(c, o()("useLabel") ?? a() ? "label" : "title", s())), _ = /* @__PURE__ */ O(() => Me(c, "description", s())), b = /* @__PURE__ */ O(() => Me(c, "errorsList", s())), p = /* @__PURE__ */ O(() => Me(c, "help", s())), g = /* @__PURE__ */ O(() => Kd(o(), s())), y = /* @__PURE__ */ O(() => d(g).title), S = /* @__PURE__ */ O(() => d(g).description), x = /* @__PURE__ */ O(() => d(g).showMeta), P = /* @__PURE__ */ O(() => o()("help"));
  var w = {
    get children() {
      return n();
    },
    set children($) {
      n($), m();
    },
    get config() {
      return s();
    },
    set config($) {
      s($), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption($) {
      o($), m();
    },
    get showTitle() {
      return i();
    },
    set showTitle($) {
      i($), m();
    },
    get useLabel() {
      return a();
    },
    set useLabel($) {
      a($), m();
    },
    get errors() {
      return l();
    },
    set errors($) {
      l($), m();
    },
    get action() {
      return u();
    },
    set action($) {
      u($), m();
    }
  }, C = M(), k = D(C);
  return Q(k, () => d(f), ($, T) => {
    T($, {
      type: "field",
      get config() {
        return s();
      },
      get errors() {
        return l();
      },
      children: (E, I) => {
        var F = AA(), U = D(F);
        {
          var B = (J) => {
            var j = M(), ee = D(j);
            Q(ee, () => d(f), (L, N) => {
              N(L, {
                type: "field-meta",
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                },
                children: (V, G) => {
                  var fe = $A(), se = D(fe);
                  {
                    var we = (oe) => {
                      var pe = M(), ye = D(pe);
                      Q(ye, () => d(f), (Pe, Oe) => {
                        Oe(Pe, {
                          type: "field-title-row",
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          },
                          children: (Ve, Ke) => {
                            var Le = kA(), je = D(Le);
                            Q(je, () => d(h), (gt, Ze) => {
                              Ze(gt, {
                                templateType: r,
                                get title() {
                                  return d(y);
                                },
                                get config() {
                                  return s();
                                },
                                get errors() {
                                  return l();
                                }
                              });
                            });
                            var We = be(je, 2);
                            te(We, () => u() ?? he), A(Ve, Le);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(oe, pe);
                    };
                    ue(se, (oe) => {
                      i() && d(y) && oe(we);
                    });
                  }
                  var le = be(se, 2);
                  {
                    var re = (oe) => {
                      var pe = M(), ye = D(pe);
                      Q(ye, () => d(_), (Pe, Oe) => {
                        Oe(Pe, {
                          templateType: r,
                          get description() {
                            return d(S);
                          },
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          }
                        });
                      }), A(oe, pe);
                    };
                    ue(le, (oe) => {
                      d(S) && oe(re);
                    });
                  }
                  A(V, fe);
                },
                $$slots: { default: !0 }
              });
            }), A(J, j);
          };
          ue(U, (J) => {
            d(x) && (i() && d(y) || d(S)) && J(B);
          });
        }
        var R = be(U, 2);
        Q(R, () => d(f), (J, j) => {
          j(J, {
            type: "field-content",
            get config() {
              return s();
            },
            get errors() {
              return l();
            },
            children: (ee, L) => {
              var N = M(), V = D(N);
              te(V, n), A(ee, N);
            },
            $$slots: { default: !0 }
          });
        });
        var Z = be(R, 2);
        {
          var Y = (J) => {
            var j = M(), ee = D(j);
            Q(ee, () => d(b), (L, N) => {
              N(L, {
                get errors() {
                  return l();
                },
                get config() {
                  return s();
                }
              });
            }), A(J, j);
          };
          ue(Z, (J) => {
            l().length > 0 && J(Y);
          });
        }
        var X = be(Z, 2);
        {
          var ae = (J) => {
            var j = M(), ee = D(j);
            Q(ee, () => d(p), (L, N) => {
              N(L, {
                get help() {
                  return d(P);
                },
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                }
              });
            }), A(J, j);
          };
          ue(X, (J) => {
            d(P) !== void 0 && J(ae);
          });
        }
        A(E, F);
      },
      $$slots: { default: !0 }
    });
  }), A(t, C), H(w);
}
K(
  Wb,
  {
    children: {},
    config: {},
    uiOption: {},
    showTitle: {},
    useLabel: {},
    errors: {},
    action: {}
  },
  [],
  [],
  { mode: "open" }
);
var EA = /* @__PURE__ */ ne("<!> <!>", 1), TA = /* @__PURE__ */ ne("<!> <!>", 1), DA = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function Hb(t, e) {
  W(e, !0);
  const r = Ee(), n = "objectTemplate", s = v(e, "config", 7), o = v(e, "children", 7), i = v(e, "addButton", 7), a = v(e, "action", 7), l = v(e, "errors", 7), u = v(e, "uiOption", 7), c = /* @__PURE__ */ O(() => Me(r, "layout", s())), f = /* @__PURE__ */ O(() => Me(r, "title", s())), h = /* @__PURE__ */ O(() => Me(r, "description", s())), _ = /* @__PURE__ */ O(() => Me(r, "errorsList", s())), b = /* @__PURE__ */ O(() => Kd(u(), s())), p = /* @__PURE__ */ O(() => d(b).title), g = /* @__PURE__ */ O(() => d(b).description), y = /* @__PURE__ */ O(() => d(b).showMeta);
  var S = {
    get config() {
      return s();
    },
    set config(w) {
      s(w), m();
    },
    get children() {
      return o();
    },
    set children(w) {
      o(w), m();
    },
    get addButton() {
      return i();
    },
    set addButton(w) {
      i(w), m();
    },
    get action() {
      return a();
    },
    set action(w) {
      a(w), m();
    },
    get errors() {
      return l();
    },
    set errors(w) {
      l(w), m();
    },
    get uiOption() {
      return u();
    },
    set uiOption(w) {
      u(w), m();
    }
  }, x = M(), P = D(x);
  return Q(P, () => d(c), (w, C) => {
    C(w, {
      type: "object-field",
      get config() {
        return s();
      },
      get errors() {
        return l();
      },
      children: (k, $) => {
        var T = DA(), E = D(T);
        {
          var I = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(c), (ae, J) => {
              J(ae, {
                type: "object-field-meta",
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                },
                children: (j, ee) => {
                  var L = TA(), N = D(L);
                  {
                    var V = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(c), (re, oe) => {
                        oe(re, {
                          type: "object-field-title-row",
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          },
                          children: (pe, ye) => {
                            var Pe = EA(), Oe = D(Pe);
                            Q(Oe, () => d(f), (Ke, Le) => {
                              Le(Ke, {
                                templateType: n,
                                get title() {
                                  return d(p);
                                },
                                get config() {
                                  return s();
                                },
                                get errors() {
                                  return l();
                                }
                              });
                            });
                            var Ve = be(Oe, 2);
                            te(Ve, () => a() ?? he), A(pe, Pe);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(se, we);
                    };
                    ue(N, (se) => {
                      d(p) && se(V);
                    });
                  }
                  var G = be(N, 2);
                  {
                    var fe = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(h), (re, oe) => {
                        oe(re, {
                          templateType: n,
                          get description() {
                            return d(g);
                          },
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          }
                        });
                      }), A(se, we);
                    };
                    ue(G, (se) => {
                      d(g) && se(fe);
                    });
                  }
                  A(j, L);
                },
                $$slots: { default: !0 }
              });
            }), A(Z, Y);
          };
          ue(E, (Z) => {
            d(y) && (d(p) || d(g)) && Z(I);
          });
        }
        var F = be(E, 2);
        Q(F, () => d(c), (Z, Y) => {
          Y(Z, {
            type: "object-properties",
            get config() {
              return s();
            },
            get errors() {
              return l();
            },
            children: (X, ae) => {
              var J = M(), j = D(J);
              te(j, o), A(X, J);
            },
            $$slots: { default: !0 }
          });
        });
        var U = be(F, 2);
        te(U, () => i() ?? he);
        var B = be(U, 2);
        {
          var R = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(_), (ae, J) => {
              J(ae, {
                get errors() {
                  return l();
                },
                get config() {
                  return s();
                }
              });
            }), A(Z, Y);
          };
          ue(B, (Z) => {
            l().length > 0 && Z(R);
          });
        }
        A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), H(S);
}
K(
  Hb,
  {
    config: {},
    children: {},
    addButton: {},
    action: {},
    errors: {},
    uiOption: {}
  },
  [],
  [],
  { mode: "open" }
);
var MA = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function Gb(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "keyInput", 7), s = v(e, "removeButton", 7), o = v(e, "config", 7), i = v(e, "errors", 7), a = Ee(), l = /* @__PURE__ */ O(() => Me(a, "layout", o()));
  var u = {
    get children() {
      return r();
    },
    set children(h) {
      r(h), m();
    },
    get keyInput() {
      return n();
    },
    set keyInput(h) {
      n(h), m();
    },
    get removeButton() {
      return s();
    },
    set removeButton(h) {
      s(h), m();
    },
    get config() {
      return o();
    },
    set config(h) {
      o(h), m();
    },
    get errors() {
      return i();
    },
    set errors(h) {
      i(h), m();
    }
  }, c = M(), f = D(c);
  return Q(f, () => d(l), (h, _) => {
    _(h, {
      type: "object-property",
      get config() {
        return o();
      },
      get errors() {
        return i();
      },
      children: (b, p) => {
        var g = MA(), y = D(g);
        {
          var S = (C) => {
            var k = M(), $ = D(k);
            Q($, () => d(l), (T, E) => {
              E(T, {
                type: "object-property-key-input",
                get config() {
                  return o();
                },
                get errors() {
                  return i();
                },
                children: (I, F) => {
                  var U = M(), B = D(U);
                  te(B, n), A(I, U);
                },
                $$slots: { default: !0 }
              });
            }), A(C, k);
          };
          ue(y, (C) => {
            n() && C(S);
          });
        }
        var x = be(y, 2);
        Q(x, () => d(l), (C, k) => {
          k(C, {
            type: "object-property-content",
            get config() {
              return o();
            },
            get errors() {
              return i();
            },
            children: ($, T) => {
              var E = M(), I = D(E);
              te(I, r), A($, E);
            },
            $$slots: { default: !0 }
          });
        });
        var P = be(x, 2);
        {
          var w = (C) => {
            var k = M(), $ = D(k);
            Q($, () => d(l), (T, E) => {
              E(T, {
                type: "object-property-controls",
                get config() {
                  return o();
                },
                get errors() {
                  return i();
                },
                children: (I, F) => {
                  var U = M(), B = D(U);
                  te(B, s), A(I, U);
                },
                $$slots: { default: !0 }
              });
            }), A(C, k);
          };
          ue(P, (C) => {
            s() && C(w);
          });
        }
        A(b, g);
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), H(u);
}
K(
  Gb,
  {
    children: {},
    keyInput: {},
    removeButton: {},
    config: {},
    errors: {}
  },
  [],
  [],
  { mode: "open" }
);
var IA = /* @__PURE__ */ ne("<!> <!>", 1), NA = /* @__PURE__ */ ne("<!> <!>", 1), FA = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function Yb(t, e) {
  W(e, !0);
  const r = Ee(), n = "arrayTemplate", s = v(e, "children", 7), o = v(e, "addButton", 7), i = v(e, "action", 7), a = v(e, "uiOption", 7), l = v(e, "config", 7), u = v(e, "errors", 7), c = /* @__PURE__ */ O(() => Me(r, "layout", l())), f = /* @__PURE__ */ O(() => Me(r, "title", l())), h = /* @__PURE__ */ O(() => Me(r, "description", l())), _ = /* @__PURE__ */ O(() => Me(r, "errorsList", l())), b = /* @__PURE__ */ O(() => Kd(a(), l())), p = /* @__PURE__ */ O(() => d(b).title), g = /* @__PURE__ */ O(() => d(b).description), y = /* @__PURE__ */ O(() => d(b).showMeta);
  var S = {
    get children() {
      return s();
    },
    set children(w) {
      s(w), m();
    },
    get addButton() {
      return o();
    },
    set addButton(w) {
      o(w), m();
    },
    get action() {
      return i();
    },
    set action(w) {
      i(w), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(w) {
      a(w), m();
    },
    get config() {
      return l();
    },
    set config(w) {
      l(w), m();
    },
    get errors() {
      return u();
    },
    set errors(w) {
      u(w), m();
    }
  }, x = M(), P = D(x);
  return Q(P, () => d(c), (w, C) => {
    C(w, {
      type: "array-field",
      get config() {
        return l();
      },
      get errors() {
        return u();
      },
      children: (k, $) => {
        var T = FA(), E = D(T);
        {
          var I = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(c), (ae, J) => {
              J(ae, {
                type: "array-field-meta",
                get config() {
                  return l();
                },
                get errors() {
                  return u();
                },
                children: (j, ee) => {
                  var L = NA(), N = D(L);
                  {
                    var V = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(c), (re, oe) => {
                        oe(re, {
                          type: "array-field-title-row",
                          get config() {
                            return l();
                          },
                          get errors() {
                            return u();
                          },
                          children: (pe, ye) => {
                            var Pe = IA(), Oe = D(Pe);
                            Q(Oe, () => d(f), (Ke, Le) => {
                              Le(Ke, {
                                templateType: n,
                                get title() {
                                  return d(p);
                                },
                                get config() {
                                  return l();
                                },
                                get errors() {
                                  return u();
                                }
                              });
                            });
                            var Ve = be(Oe, 2);
                            te(Ve, () => i() ?? he), A(pe, Pe);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(se, we);
                    };
                    ue(N, (se) => {
                      d(p) && se(V);
                    });
                  }
                  var G = be(N, 2);
                  {
                    var fe = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(h), (re, oe) => {
                        oe(re, {
                          templateType: n,
                          get description() {
                            return d(g);
                          },
                          get config() {
                            return l();
                          },
                          get errors() {
                            return u();
                          }
                        });
                      }), A(se, we);
                    };
                    ue(G, (se) => {
                      d(g) && se(fe);
                    });
                  }
                  A(j, L);
                },
                $$slots: { default: !0 }
              });
            }), A(Z, Y);
          };
          ue(E, (Z) => {
            d(y) && (d(p) || d(g)) && Z(I);
          });
        }
        var F = be(E, 2);
        Q(F, () => d(c), (Z, Y) => {
          Y(Z, {
            type: "array-items",
            get config() {
              return l();
            },
            get errors() {
              return u();
            },
            children: (X, ae) => {
              var J = M(), j = D(J);
              te(j, s), A(X, J);
            },
            $$slots: { default: !0 }
          });
        });
        var U = be(F, 2);
        te(U, () => o() ?? he);
        var B = be(U, 2);
        {
          var R = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(_), (ae, J) => {
              J(ae, {
                get errors() {
                  return u();
                },
                get config() {
                  return l();
                }
              });
            }), A(Z, Y);
          };
          ue(B, (Z) => {
            u().length > 0 && Z(R);
          });
        }
        A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), H(S);
}
K(
  Yb,
  {
    children: {},
    addButton: {},
    action: {},
    uiOption: {},
    config: {},
    errors: {}
  },
  [],
  [],
  { mode: "open" }
);
var RA = /* @__PURE__ */ ne("<!> <!>", 1);
function Xb(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "buttons", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "layout", s()));
  var l = {
    get children() {
      return r();
    },
    set children(f) {
      r(f), m();
    },
    get buttons() {
      return n();
    },
    set buttons(f) {
      n(f), m();
    },
    get config() {
      return s();
    },
    set config(f) {
      s(f), m();
    },
    get errors() {
      return o();
    },
    set errors(f) {
      o(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(a), (f, h) => {
    h(f, {
      type: "array-item",
      get config() {
        return s();
      },
      get errors() {
        return o();
      },
      children: (_, b) => {
        var p = RA(), g = D(p);
        Q(g, () => d(a), (x, P) => {
          P(x, {
            type: "array-item-content",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, C) => {
              var k = M(), $ = D(k);
              te($, r), A(w, k);
            },
            $$slots: { default: !0 }
          });
        });
        var y = be(g, 2);
        {
          var S = (x) => {
            var P = M(), w = D(P);
            Q(w, () => d(a), (C, k) => {
              k(C, {
                type: "array-item-controls",
                get config() {
                  return s();
                },
                get errors() {
                  return o();
                },
                children: ($, T) => {
                  var E = M(), I = D(E);
                  te(I, n), A($, E);
                },
                $$slots: { default: !0 }
              });
            }), A(x, P);
          };
          ue(y, (x) => {
            n() && x(S);
          });
        }
        A(_, p);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), H(l);
}
K(Xb, { children: {}, buttons: {}, config: {}, errors: {} }, [], [], { mode: "open" });
var VA = /* @__PURE__ */ ne("<!> <!>", 1), LA = /* @__PURE__ */ ne("<!> <!>", 1);
function Jb(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "optionSelector", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = v(e, "action", 7), a = Ee(), l = /* @__PURE__ */ O(() => Me(a, "layout", s()));
  var u = {
    get children() {
      return r();
    },
    set children(h) {
      r(h), m();
    },
    get optionSelector() {
      return n();
    },
    set optionSelector(h) {
      n(h), m();
    },
    get config() {
      return s();
    },
    set config(h) {
      s(h), m();
    },
    get errors() {
      return o();
    },
    set errors(h) {
      o(h), m();
    },
    get action() {
      return i();
    },
    set action(h) {
      i(h), m();
    }
  }, c = M(), f = D(c);
  return Q(f, () => d(l), (h, _) => {
    _(h, {
      type: "multi-field",
      get config() {
        return s();
      },
      get errors() {
        return o();
      },
      children: (b, p) => {
        var g = LA(), y = D(g);
        Q(y, () => d(l), (x, P) => {
          P(x, {
            type: "multi-field-controls",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, C) => {
              var k = VA(), $ = D(k);
              te($, n);
              var T = be($, 2);
              te(T, () => i() ?? he), A(w, k);
            },
            $$slots: { default: !0 }
          });
        });
        var S = be(y, 2);
        Q(S, () => d(l), (x, P) => {
          P(x, {
            type: "multi-field-content",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, C) => {
              var k = M(), $ = D(k);
              te($, r), A(w, k);
            },
            $$slots: { default: !0 }
          });
        }), A(b, g);
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), H(u);
}
K(
  Jb,
  {
    children: {},
    optionSelector: {},
    config: {},
    errors: {},
    action: {}
  },
  [],
  [],
  { mode: "open" }
);
const jA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayItemTemplate: Xb,
  arrayTemplate: Yb,
  fieldTemplate: Wb,
  multiFieldTemplate: Jb,
  objectPropertyTemplate: Gb,
  objectTemplate: Hb
}, Symbol.toStringTag, { value: "Module" })), tr = Object.assign({}, CA, jA);
function Zb(t, e) {
  return (r) => {
    const n = r?.findIndex((s) => s === void 0 || !e(s)) ?? -1;
    if (n >= 0) {
      const s = r[n];
      throw new TypeError(`Expected array of "${t}" or "undefined", but got (${typeof s}: ${JSON.stringify(s)})`);
    }
  };
}
const Qb = Zb("string", (t) => typeof t == "string"), BA = Zb("File", (t) => t instanceof File);
function zA(t) {
  if (t !== void 0 && !(t instanceof File))
    throw new Error(`expected "File" or "undefined", but got (${typeof t}: ${JSON.stringify(t)})`);
}
const qA = "nativeFilesField";
function Wd(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(f)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => kt(i, n().path)), h = bo({
    combinator: yi,
    async execute(y, S) {
      if (S === void 0)
        return;
      const x = Array.from(S);
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return x;
    },
    onSuccess(y) {
      s(y);
    }
  }), _ = /* @__PURE__ */ O(() => vr(i, n(), qA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(f);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => {
            const E = s(), I = new DataTransfer();
            if (E)
              for (const F of E)
                I.items.add(F);
            return I.files;
          }, T = h.run;
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get processing() {
                return h.isProcessed;
              },
              loading: !1,
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(f);
              },
              get config() {
                return n();
              },
              multiple: !0
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Wd, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function e_(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (BA(r()), r()), i = (a) => {
    r(a);
  };
  return Wd(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), H(s);
}
K(e_, { value: {} }, [], [], { mode: "open" });
tr.arrayNativeFilesField = e_;
function UA(t, e) {
  return t.anyOf ? [t.anyOf, e.anyOf] : [t.oneOf, e.oneOf];
}
function al(t, e, r, n) {
  const s = n.enum, o = new Set(r("disabledEnumValues"));
  if (s) {
    const l = r("enumNames");
    return s.map((u, c) => {
      const f = l?.[c] ?? Ig(u);
      return {
        id: Fs(t, e.path, c),
        label: f,
        value: u,
        disabled: o.has(u)
      };
    });
  }
  const [i, a] = UA(n, e.uiSchema);
  return i && i.map((l, u) => {
    if (typeof l == "boolean")
      throw new Error(`Invalid enum definition in anyOf ${u}`);
    const c = Cy(l), f = Yn(t, a?.[u])["ui:options"]?.title ?? l.title ?? Ig(c);
    return {
      id: Fs(t, e.path, u),
      schema: l,
      label: f,
      value: c,
      disabled: o.has(c)
    };
  });
}
const KA = "enumField";
function t_(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(h)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "selectWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => al(i, n(), o(), n().schema) ?? []), h = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), KA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get handlers() {
                return c;
              },
              get config() {
                return n();
              },
              get errors() {
                return d(h);
              },
              get uiOption() {
                return o();
              },
              get options() {
                return d(f);
              },
              get value() {
                return s();
              },
              set value(E) {
                s(E);
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(t_, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
tr.enumField = t_;
const WA = "fileField";
function r_(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(h)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = db({
    initialOutput: void 0,
    getInput: () => s(),
    setInput: (y) => s(y),
    async toOutput(y, S) {
      const x = new DataTransfer();
      return S && await cb(i, y, x, S), x.files;
    },
    async toInput(y, S) {
      if (S === void 0 || S.length === 0)
        return;
      const x = S[0];
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return fb(y, x);
    }
  }), h = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), WA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get processing() {
                return f.inputProcessing;
              },
              get loading() {
                return f.outputProcessing;
              },
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(h);
              },
              get config() {
                return n();
              },
              multiple: !1,
              get value() {
                return f.current;
              },
              set value(E) {
                f.current = E;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(r_, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
tr.fileField = r_;
const HA = "filesField";
function Hd(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(h)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = db({
    initialOutput: void 0,
    getInput: () => s(),
    setInput: (y) => s(y),
    isEqual: (y, S) => y === void 0 && S === void 0 || Array.isArray(y) && Array.isArray(S) && y.length === S.length && y.every((x, P) => x === S[P]),
    async toOutput(y, S) {
      const x = new DataTransfer();
      return S && await ek(i, y, x, S), x.files;
    },
    async toInput(y, S) {
      if (S === void 0)
        return;
      const x = Array.from(S);
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return Promise.all(x.map((P) => fb(y, P)));
    }
  }), h = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), HA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get processing() {
                return f.inputProcessing;
              },
              get loading() {
                return f.outputProcessing;
              },
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(h);
              },
              get config() {
                return n();
              },
              multiple: !0,
              get value() {
                return f.current;
              },
              set value(E) {
                f.current = E;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Hd, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
tr.filesField = Hd;
const GA = "multiEnumField";
function n_(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return o();
        },
        set current(P) {
          o(P);
        }
      }),
      () => d(h)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "value", 15);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "checkboxesWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), o())), f = /* @__PURE__ */ O(() => {
    const { items: y } = n().schema, S = Be(y) ? y : {};
    return al(i, n(), s(), S) ?? [];
  }), h = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), GA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(y) {
      s(y), m();
    },
    get value() {
      return o();
    },
    set value(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !1,
        get uiOption() {
          return s();
        },
        widgetType: l,
        get value() {
          return o();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => o() ?? void 0, T = (E) => o(E);
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get handlers() {
                return c;
              },
              get config() {
                return n();
              },
              get errors() {
                return d(h);
              },
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get options() {
                return d(f);
              },
              get uiOption() {
                return s();
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(n_, { config: {}, uiOption: {}, value: {} }, [], [], { mode: "open" });
tr.multiEnumField = n_;
const YA = "nativeFileField";
function Gd(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(f)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => kt(i, n().path)), h = bo({
    combinator: yi,
    async execute(y, S) {
      if (S === void 0 || S.length === 0)
        return;
      const x = S[0];
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return x;
    },
    onSuccess(y) {
      s(y);
    }
  }), _ = /* @__PURE__ */ O(() => vr(i, n(), YA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(f);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => {
            const E = s(), I = new DataTransfer();
            return E && I.items.add(E), I.files;
          }, T = h.run;
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get processing() {
                return h.isProcessed;
              },
              loading: !1,
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(f);
              },
              get config() {
                return n();
              },
              multiple: !1
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Gd, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
tr.nativeFileField = Gd;
tr.nativeFilesField = Wd;
function s_(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (zA(r()), r()), i = (a) => {
    r(a);
  };
  return Gd(t, ce(
    {
      get value() {
        return o();
      },
      set value(a) {
        i(a);
      }
    },
    () => n
  )), H(s);
}
K(s_, { value: {} }, [], [], { mode: "open" });
tr.unknownNativeFileField = s_;
function XA(t) {
  return (e) => {
    const { schema: r } = e;
    if (AC(t, r))
      return "enumField";
    if (r.oneOf !== void 0)
      return "oneOfField";
    if (r.anyOf !== void 0)
      return "anyOfField";
    const n = po(r);
    return n === "array" ? EC(t, r) ? "multiEnumField" : $y(r) ? "tupleField" : TC(t, r) && Nt(t, e, "orderable") !== !0 ? "filesField" : "arrayField" : My(r) ? "fileField" : `${n}Field`;
  };
}
const JA = "aggregatedField";
function o_(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(h)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "aggregatedWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => o()("collectErrors") ?? !1), h = /* @__PURE__ */ O(() => d(f) ? tb(i, Jy(i, n().path)) : kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), JA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        widgetType: l,
        get uiOption() {
          return o();
        },
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => s() ?? void 0, T = (E) => s(E);
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get config() {
                return n();
              },
              get errors() {
                return d(h);
              },
              get uiOption() {
                return o();
              },
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get handlers() {
                return c;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(o_, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
tr.aggregatedField = o_;
function i_(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (Qb(r()), r()), i = (a) => {
    r(a);
  };
  return Hd(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), H(s);
}
K(i_, { value: {} }, [], [], { mode: "open" });
tr.arrayFilesField = i_;
const ZA = "tagsField";
function Yd(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => a,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(h)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = "tagsWidget", a = Ee(), l = /* @__PURE__ */ O(() => Me(a, "fieldTemplate", n())), u = /* @__PURE__ */ O(() => Me(a, i, n())), c = un(a, () => n(), () => Cr(a, n(), s())), f = /* @__PURE__ */ O(() => o()("collectErrors") ?? !1), h = /* @__PURE__ */ O(() => d(f) ? tb(a, Jy(a, n().path)) : kt(a, n().path)), _ = /* @__PURE__ */ O(() => vr(a, n(), ZA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), g = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(g, () => d(l), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        widgetType: i,
        get uiOption() {
          return o();
        },
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => s() ?? void 0, T = (E) => s(E);
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get config() {
                return n();
              },
              get errors() {
                return d(h);
              },
              get uiOption() {
                return o();
              },
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get handlers() {
                return c;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Yd, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function a_(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (Qb(r()), r()), i = (a) => {
    r(a);
  };
  return Yd(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), H(s);
}
K(a_, { value: {} }, [], [], { mode: "open" });
tr.arrayTagsField = a_;
const QA = "booleanSelectField";
function l_(t, e) {
  W(e, !0);
  const r = (S) => {
    var x = M(), P = D(x);
    te(
      P,
      () => d(b) ?? he,
      () => n,
      s,
      () => ({
        get current() {
          return o();
        },
        set current(w) {
          o(w);
        }
      }),
      () => d(_)
    ), A(S, x);
  }, n = Ee();
  let s = v(e, "config", 7), o = v(e, "value", 15), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = /* @__PURE__ */ O(() => Me(n, "fieldTemplate", s())), u = "selectWidget", c = /* @__PURE__ */ O(() => Me(n, u, s())), f = /* @__PURE__ */ O(() => {
    const S = a()("yes", {}), x = a()("no", {});
    if (Array.isArray(s().schema.oneOf))
      return al(n, s(), i(), {
        oneOf: s().schema.oneOf.map((w) => typeof w == "boolean" ? w ? { const: !0, title: S } : { const: !1, title: x } : {
          ...w,
          title: w.title ?? (w.const === !0 ? S : x)
        })
      }) ?? [];
    const P = s().schema.enum ?? uC;
    return P.length === 2 && P.every((w) => typeof w == "boolean") && i()("enumNames") === void 0 ? P.map((w, C) => ({
      id: Fs(n, s().path, C),
      label: w ? S : x,
      value: w,
      disabled: !1
    })) : al(n, s(), i(), Object.setPrototypeOf({ enum: P }, s().schema)) ?? [];
  }), h = un(n, () => s(), () => Cr(n, s(), o())), _ = /* @__PURE__ */ O(() => kt(n, s().path)), b = /* @__PURE__ */ O(() => vr(n, s(), QA));
  var p = {
    get config() {
      return s();
    },
    set config(S) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S) {
      o(S), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(S) {
      i(S), m();
    },
    get translate() {
      return a();
    },
    set translate(S) {
      a(S), m();
    }
  }, g = M(), y = D(g);
  {
    let S = /* @__PURE__ */ O(() => d(b) && r);
    Q(y, () => d(l), (x, P) => {
      P(x, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return i();
        },
        widgetType: u,
        get value() {
          return o();
        },
        get config() {
          return s();
        },
        get errors() {
          return d(_);
        },
        get action() {
          return d(S);
        },
        children: (w, C) => {
          var k = M(), $ = D(k);
          Q($, () => d(c), (T, E) => {
            E(T, {
              type: "widget",
              get options() {
                return d(f);
              },
              get errors() {
                return d(_);
              },
              get handlers() {
                return h;
              },
              get uiOption() {
                return i();
              },
              get config() {
                return s();
              },
              get value() {
                return o();
              },
              set value(I) {
                o(I);
              }
            });
          }), A(w, k);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), H(p);
}
K(l_, { config: {}, value: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
tr.booleanSelectField = l_;
tr.tagsField = Yd;
const eE = Ii(tr);
var tE = /* @__PURE__ */ ne("<form><!></form>");
function rE(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "ref", 15), s = v(e, "config", 7), o = v(e, "attributes", 7);
  const i = Ee();
  var a = {
    get children() {
      return r();
    },
    set children(c) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    },
    get attributes() {
      return o();
    },
    set attributes(c) {
      o(c), m();
    }
  }, l = tE();
  ve(l, (c) => ({ onsubmit: i.submit, onreset: i.reset, ...c }), [
    () => ib(i, s(), "form", o(), { class: "sjsf-form" })
  ]);
  var u = ge(l);
  return te(u, r), de(l), et(l, (c) => n(c), () => n()), A(t, l), H(a);
}
K(rE, { children: {}, ref: {}, config: {}, attributes: {} }, [], [], { mode: "open" });
var nE = /* @__PURE__ */ ne("<form><!></form>");
function u_(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "ref", 15), s = v(e, "config", 7), o = v(e, "attributes", 7);
  const i = Ee();
  var a = {
    get children() {
      return r();
    },
    set children(c) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    },
    get attributes() {
      return o();
    },
    set attributes(c) {
      o(c), m();
    }
  }, l = nE();
  ve(
    l,
    (c) => ({
      onsubmit: i.submit,
      onreset: i.reset,
      class: "flex flex-col gap-4",
      ...c
    }),
    [
      () => ib(i, s(), "form", o(), {})
    ]
  );
  var u = ge(l);
  return te(u, () => r() ?? he), de(l), et(l, (c) => n(c), () => n()), A(t, l), H(a);
}
K(u_, { children: {}, ref: {}, config: {}, attributes: {} }, [], [], { mode: "open" });
const c_ = /* @__PURE__ */ Symbol("theme-context");
function ut() {
  return Ms(c_);
}
function sE(t) {
  Oo(c_, t);
}
function d_(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "disabled", 7), s = v(e, "onclick", 7), o = v(e, "config", 7), i = v(e, "type", 7), a = Ee(), l = ut(), u = /* @__PURE__ */ O(() => l.components), c = /* @__PURE__ */ O(() => d(u).Button);
  var f = {
    get children() {
      return r();
    },
    set children(b) {
      r(b), m();
    },
    get disabled() {
      return n();
    },
    set disabled(b) {
      n(b), m();
    },
    get onclick() {
      return s();
    },
    set onclick(b) {
      s(b), m();
    },
    get config() {
      return o();
    },
    set config(b) {
      o(b), m();
    },
    get type() {
      return i();
    },
    set type(b) {
      i(b), m();
    }
  }, h = M(), _ = D(h);
  {
    let b = /* @__PURE__ */ O(() => Ft(
      a,
      o(),
      {
        type: "button",
        disabled: n(),
        onclick: s(),
        variant: "outline"
      },
      St("shadcn4Button"),
      eb("shadcn4Buttons", (p) => p[i()]),
      Do
    ));
    Q(_, () => d(c), (p, g) => {
      g(p, ce(() => d(b), {
        children: (y, S) => {
          var x = M(), P = D(x);
          te(P, r), A(y, x);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, h), H(f);
}
K(
  d_,
  {
    children: {},
    disabled: {},
    onclick: {},
    config: {},
    type: {}
  },
  [],
  [],
  { mode: "open" }
);
function f_(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).Button);
  var l = {
    get children() {
      return r();
    },
    set children(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => QC(s, n(), "shadcn4SubmitButton", "submit", {}));
    Q(c, () => d(a), (h, _) => {
      _(h, ce(() => d(f), {
        children: (b, p) => {
          var g = M(), y = D(g);
          te(y, r), A(b, g);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(f_, { children: {}, config: {} }, [], [], { mode: "open" });
var oE = /* @__PURE__ */ ne("<div><!></div>");
function iE(t, e) {
  W(e, !0);
  const r = v(e, "type", 7), n = v(e, "children", 7), s = v(e, "config", 7), o = Ee(), i = /* @__PURE__ */ O(() => lb(o, s(), "layout", "layouts", r(), { class: "sjsf-layout" }));
  var a = {
    get type() {
      return r();
    },
    set type(c) {
      r(c), m();
    },
    get children() {
      return n();
    },
    set children(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    }
  }, l = oE();
  ve(l, () => ({ ...d(i) }));
  var u = ge(l);
  return te(u, n), de(l), A(t, l), H(a);
}
K(iE, { type: {}, children: {}, config: {} }, [], [], { mode: "open" });
var aE = /* @__PURE__ */ ne("<div><!></div>"), lE = /* @__PURE__ */ ne("<div><!></div>");
function h_(t, e) {
  W(e, !0);
  const r = v(e, "type", 7), n = v(e, "children", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = /* @__PURE__ */ O(() => r() === "array-item"), a = /* @__PURE__ */ O(() => r() === "array-item-content" || r() === "object-property-key-input" || r() === "object-property-content"), l = /* @__PURE__ */ O(() => r() === "object-property"), u = /* @__PURE__ */ O(() => r() === "field-meta" || r() === "array-field-meta" || r() === "object-field-meta"), c = /* @__PURE__ */ O(() => r() === "multi-field-controls"), f = Ee(), h = ut(), _ = /* @__PURE__ */ O(() => h.components), b = /* @__PURE__ */ O(() => d(_).ButtonGroup), p = /* @__PURE__ */ O(() => d(_).FieldSet), g = /* @__PURE__ */ O(() => d(_).FieldLegend), y = /* @__PURE__ */ O(() => d(_).Field), S = /* @__PURE__ */ O(() => d(_).FieldGroup), x = /* @__PURE__ */ O(() => lb(f, s(), "layout", "layouts", r(), {}));
  var P = {
    get type() {
      return r();
    },
    set type(T) {
      r(T), m();
    },
    get children() {
      return n();
    },
    set children(T) {
      n(T), m();
    },
    get config() {
      return s();
    },
    set config(T) {
      s(T), m();
    },
    get errors() {
      return o();
    },
    set errors(T) {
      o(T), m();
    }
  }, w = M(), C = D(w);
  {
    var k = (T) => {
      var E = M(), I = D(E);
      te(I, n), A(T, E);
    }, $ = (T) => {
      var E = M(), I = D(E);
      {
        var F = (B) => {
          var R = M(), Z = D(R);
          {
            let Y = /* @__PURE__ */ O(() => St("shadcn4ButtonGroup")(d(x), s(), f));
            Q(Z, () => d(b), (X, ae) => {
              ae(X, ce(() => d(Y), {
                children: (J, j) => {
                  var ee = M(), L = D(ee);
                  te(L, n), A(J, ee);
                },
                $$slots: { default: !0 }
              }));
            });
          }
          A(B, R);
        }, U = (B) => {
          var R = M(), Z = D(R);
          {
            var Y = (ae) => {
              var J = M(), j = D(J);
              {
                let ee = /* @__PURE__ */ O(() => St("shadcn4FieldSet")(d(x), s(), f));
                Q(j, () => d(p), (L, N) => {
                  N(L, ce(() => d(ee), {
                    children: (V, G) => {
                      var fe = M(), se = D(fe);
                      te(se, n), A(V, fe);
                    },
                    $$slots: { default: !0 }
                  }));
                });
              }
              A(ae, J);
            }, X = (ae) => {
              var J = M(), j = D(J);
              {
                var ee = (N) => {
                  var V = M(), G = D(V);
                  {
                    let fe = /* @__PURE__ */ O(() => o().length > 0), se = /* @__PURE__ */ O(() => St("shadcn4Field")(d(x), s(), f));
                    Q(G, () => d(y), (we, le) => {
                      le(we, ce(
                        {
                          get "data-invalid"() {
                            return d(fe);
                          }
                        },
                        () => d(se),
                        {
                          children: (re, oe) => {
                            var pe = M(), ye = D(pe);
                            te(ye, n), A(re, pe);
                          },
                          $$slots: { default: !0 }
                        }
                      ));
                    });
                  }
                  A(N, V);
                }, L = (N) => {
                  var V = M(), G = D(V);
                  {
                    var fe = (we) => {
                      var le = aE();
                      ve(le, () => ({
                        class: "flex w-full items-center justify-between",
                        ...d(x)
                      }));
                      var re = ge(le);
                      te(re, n), de(le), A(we, le);
                    }, se = (we) => {
                      var le = M(), re = D(le);
                      {
                        var oe = (ye) => {
                          var Pe = M(), Oe = D(Pe);
                          Q(Oe, () => d(g), (Ve, Ke) => {
                            Ke(Ve, ce({ class: "flex w-full items-center justify-between" }, () => d(x), {
                              children: (Le, je) => {
                                var We = M(), gt = D(We);
                                te(gt, n), A(Le, We);
                              },
                              $$slots: { default: !0 }
                            }));
                          }), A(ye, Pe);
                        }, pe = (ye) => {
                          var Pe = M(), Oe = D(Pe);
                          {
                            var Ve = (Le) => {
                              var je = M(), We = D(je);
                              Q(We, () => d(S), (gt, Ze) => {
                                Ze(gt, ce(() => d(x), {
                                  children: ($t, lt) => {
                                    var ct = M(), pt = D(ct);
                                    te(pt, n), A($t, ct);
                                  },
                                  $$slots: { default: !0 }
                                }));
                              }), A(Le, je);
                            }, Ke = (Le) => {
                              var je = lE();
                              ve(je, () => ({
                                class: {
                                  grow: d(a),
                                  "flex items-center gap-2": d(c),
                                  "flex items-start gap-1.5": d(i),
                                  "grid grid-cols-1 grid-rows-[1fr] items-start gap-x-1.5 [&:has(>:nth-child(2))]:grid-cols-[1fr_1fr_auto]": d(l)
                                },
                                ...d(x)
                              }));
                              var We = ge(je);
                              te(We, n), de(je), A(Le, je);
                            };
                            ue(
                              Oe,
                              (Le) => {
                                r() === "array-items" || r() === "object-properties" || r() === "multi-field" || r() === "multi-field-content" ? Le(Ve) : Le(Ke, !1);
                              },
                              !0
                            );
                          }
                          A(ye, Pe);
                        };
                        ue(
                          re,
                          (ye) => {
                            r() === "array-field-title-row" || r() === "object-field-title-row" ? ye(oe) : ye(pe, !1);
                          },
                          !0
                        );
                      }
                      A(we, le);
                    };
                    ue(
                      G,
                      (we) => {
                        r() === "field-title-row" ? we(fe) : we(se, !1);
                      },
                      !0
                    );
                  }
                  A(N, V);
                };
                ue(
                  j,
                  (N) => {
                    r() == "field" ? N(ee) : N(L, !1);
                  },
                  !0
                );
              }
              A(ae, J);
            };
            ue(
              Z,
              (ae) => {
                r() === "array-field" || r() === "object-field" ? ae(Y) : ae(X, !1);
              },
              !0
            );
          }
          A(B, R);
        };
        ue(
          I,
          (B) => {
            r() === "array-item-controls" ? B(F) : B(U, !1);
          },
          !0
        );
      }
      A(T, E);
    };
    ue(C, (T) => {
      (r() === "field-content" || d(u)) && Object.keys(d(x)).length < 2 ? T(k) : T($, !1);
    });
  }
  return A(t, w), H(P);
}
K(h_, { type: {}, children: {}, config: {}, errors: {} }, [], [], { mode: "open" });
var uE = /* @__PURE__ */ ne("<legend> <!></legend>");
function cE(t, e) {
  W(e, !0);
  const r = v(e, "title", 7), n = v(e, "config", 7), s = v(e, "templateType", 7), o = Ee();
  var i = {
    get title() {
      return r();
    },
    set title(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    },
    get templateType() {
      return s();
    },
    set templateType(f) {
      s(f), m();
    }
  }, a = uE();
  ve(a, (f) => ({ ...f }), [
    () => Dc(o, n(), "titleAttributes", { class: "sjsf-title", "data-template": s() })
  ]);
  var l = ge(a), u = be(l);
  {
    var c = (f) => {
      var h = tt("*");
      A(f, h);
    };
    ue(u, (f) => {
      n().required && s() === "fieldTemplate" && f(c);
    });
  }
  return de(a), ke(() => Ie(l, `${r() ?? ""} `)), A(t, a), H(i);
}
K(cE, { title: {}, config: {}, templateType: {} }, [], [], { mode: "open" });
var dE = /* @__PURE__ */ ne(" <!>", 1), fE = /* @__PURE__ */ ne("<div> </div>");
function g_(t, e) {
  W(e, !0);
  const r = v(e, "title", 7), n = v(e, "templateType", 7), s = v(e, "config", 7), o = Ee(), i = ut(), a = /* @__PURE__ */ O(() => i.components), l = /* @__PURE__ */ O(() => d(a).FieldTitle);
  var u = {
    get title() {
      return r();
    },
    set title(b) {
      r(b), m();
    },
    get templateType() {
      return n();
    },
    set templateType(b) {
      n(b), m();
    },
    get config() {
      return s();
    },
    set config(b) {
      s(b), m();
    }
  }, c = M(), f = D(c);
  {
    var h = (b) => {
      var p = M(), g = D(p);
      {
        let y = /* @__PURE__ */ O(() => Dc(o, s(), "titleAttributes", {}));
        Q(g, () => d(l), (S, x) => {
          x(S, ce(() => d(y), {
            children: (P, w) => {
              vt();
              var C = dE(), k = D(C), $ = be(k);
              {
                var T = (E) => {
                  var I = tt("*");
                  A(E, I);
                };
                ue($, (E) => {
                  s().required && E(T);
                });
              }
              ke(() => Ie(k, `${r() ?? ""} `)), A(P, C);
            },
            $$slots: { default: !0 }
          }));
        });
      }
      A(b, p);
    }, _ = (b) => {
      var p = fE();
      ve(p, (y) => ({ ...y }), [() => Dc(o, s(), "titleAttributes", {})]);
      var g = ge(p, !0);
      de(p), ke(() => Ie(g, r())), A(b, p);
    };
    ue(f, (b) => {
      n() === "fieldTemplate" ? b(h) : b(_, !1);
    });
  }
  return A(t, c), H(u);
}
K(g_, { title: {}, templateType: {}, config: {} }, [], [], { mode: "open" });
var hE = /* @__PURE__ */ ne("<span>*</span>"), gE = /* @__PURE__ */ ne(" <!>", 1);
function p_(t, e) {
  W(e, !0);
  const r = v(e, "title", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldLabel);
  var l = {
    get title() {
      return r();
    },
    set title(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => ZC(s, n(), "shadcn4Label", {}));
    Q(c, () => d(a), (h, _) => {
      _(h, ce(() => d(f), {
        children: (b, p) => {
          vt();
          var g = gE(), y = D(g), S = be(y);
          {
            var x = (P) => {
              var w = hE();
              A(P, w);
            };
            ue(S, (P) => {
              n().required && P(x);
            });
          }
          ke(() => Ie(y, `${r() ?? ""} `)), A(b, g);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(p_, { title: {}, config: {} }, [], [], { mode: "open" });
var pE = /* @__PURE__ */ ne("<div> </div>");
function mE(t, e) {
  W(e, !0);
  const r = v(e, "description", 7), n = v(e, "config", 7), s = Ee();
  var o = {
    get description() {
      return r();
    },
    set description(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    }
  }, i = pE();
  ve(i, (l) => ({ ...l }), [
    () => sb(s, n(), "descriptionAttributes", { class: "sjsf-description" })
  ]);
  var a = ge(i, !0);
  return de(i), ke(() => Ie(a, r())), A(t, i), H(o);
}
K(mE, { description: {}, config: {} }, [], [], { mode: "open" });
function m_(t, e) {
  W(e, !0);
  const r = v(e, "description", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldDescription);
  var l = {
    get description() {
      return r();
    },
    set description(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => sb(s, n(), "descriptionAttributes", {}));
    Q(c, () => d(a), (h, _) => {
      _(h, ce(() => d(f), {
        children: (b, p) => {
          vt();
          var g = tt();
          ke(() => Ie(g, r())), A(b, g);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(m_, { description: {}, config: {} }, [], [], { mode: "open" });
var vE = /* @__PURE__ */ ne("<div> </div>");
function yE(t, e) {
  W(e, !0);
  const r = v(e, "help", 7), n = v(e, "config", 7), s = Ee();
  var o = {
    get help() {
      return r();
    },
    set help(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    }
  }, i = vE();
  ve(i, (l) => ({ ...l }), [
    () => ab(s, n(), "helpAttributes", { class: "sjsf-help" })
  ]);
  var a = ge(i, !0);
  return de(i), ke(() => Ie(a, r())), A(t, i), H(o);
}
K(yE, { help: {}, config: {} }, [], [], { mode: "open" });
function v_(t, e) {
  W(e, !0);
  const r = v(e, "help", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldDescription);
  var l = {
    get help() {
      return r();
    },
    set help(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => ab(s, n(), "helpAttributes", {}));
    Q(c, () => d(a), (h, _) => {
      _(h, ce(() => d(f), {
        children: (b, p) => {
          vt();
          var g = tt();
          ke(() => Ie(g, r())), A(b, g);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(v_, { help: {}, config: {} }, [], [], { mode: "open" });
var bE = /* @__PURE__ */ ne("<li> </li>"), _E = /* @__PURE__ */ ne("<ul></ul>");
function wE(t, e) {
  W(e, !0);
  const r = v(e, "errors", 7), n = v(e, "config", 7), s = Ee();
  var o = {
    get errors() {
      return r();
    },
    set errors(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    }
  }, i = _E();
  return ve(i, (a) => ({ ...a }), [
    () => ob(s, n(), "errorsList", { class: "sjsf-errors-list" })
  ]), st(i, 21, r, jl, (a, l) => {
    var u = bE(), c = ge(u, !0);
    de(u), ke(() => Ie(c, d(l))), A(a, u);
  }), de(i), A(t, i), H(o);
}
K(wE, { errors: {}, config: {} }, [], [], { mode: "open" });
var SE = /* @__PURE__ */ ne("<li> </li>"), xE = /* @__PURE__ */ ne("<ul></ul>");
function y_(t, e) {
  W(e, !0);
  const r = v(e, "errors", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldError);
  var l = {
    get errors() {
      return r();
    },
    set errors(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(a), (f, h) => {
    h(f, {
      children: (_, b) => {
        var p = xE();
        ve(p, (g) => ({ class: "ml-4 flex list-disc flex-col gap-1", ...g }), [() => ob(s, n(), "errorsList", {})]), st(p, 21, r, jl, (g, y) => {
          var S = SE(), x = ge(S, !0);
          de(S), ke(() => Ie(x, d(y))), A(g, S);
        }), de(p), A(_, p);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), H(l);
}
K(y_, { errors: {}, config: {} }, [], [], { mode: "open" });
const PE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  button: d_,
  description: m_,
  errorsList: y_,
  form: u_,
  help: v_,
  label: p_,
  layout: h_,
  submitButton: f_,
  title: g_
}, Symbol.toStringTag, { value: "Module" }));
var OE = /* @__PURE__ */ ne("<!> <!>", 1);
function b_(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Input);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ O(() => Ni(r, a(), "shadcn4Text", l(), {}));
  var c = {
    get value() {
      return i();
    },
    set value(b) {
      i(b), m();
    },
    get config() {
      return a();
    },
    set config(b) {
      a(b), m();
    },
    get handlers() {
      return l();
    },
    set handlers(b) {
      l(b), m();
    }
  }, f = OE(), h = D(f);
  Q(h, () => d(o), (b, p) => {
    p(b, ce(() => d(u), {
      get value() {
        return i();
      },
      set value(g) {
        i(g);
      }
    }));
  });
  var _ = be(h, 2);
  return Vd(_, {
    get id() {
      return d(u).list;
    },
    get config() {
      return a();
    }
  }), A(t, f), H(c);
}
K(b_, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
var CE = /* @__PURE__ */ ne("<!> <!>", 1);
function __(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Input);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ O(() => Ni(r, a(), "shadcn4Number", l(), { type: "number" }));
  var c = {
    get value() {
      return i();
    },
    set value(g) {
      i(g), m();
    },
    get config() {
      return a();
    },
    set config(g) {
      a(g), m();
    },
    get handlers() {
      return l();
    },
    set handlers(g) {
      l(g), m();
    }
  }, f = CE(), h = D(f), _ = () => i() ?? null, b = (g) => i(g ?? void 0);
  Q(h, () => d(o), (g, y) => {
    y(g, ce(
      {
        get value() {
          return _();
        },
        set value(S) {
          b(S);
        }
      },
      () => d(u)
    ));
  });
  var p = be(h, 2);
  return Vd(p, {
    get id() {
      return d(u).list;
    },
    get config() {
      return a();
    }
  }), A(t, f), H(c);
}
K(__, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
const Wa = "-1";
function Mo(t) {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  for (const n of t)
    e.set(n.id, n.value), r.set(n.value, n.id);
  return {
    fromValue(n) {
      if (n === void 0)
        return Wa;
      const s = r.get(n);
      return s !== void 0 ? s : Is(n) ? t.find((o) => Ul(o.value, n))?.id ?? Wa : t.find((o) => o.value === n)?.id ?? Wa;
    },
    toValue(n) {
      return e.get(n);
    }
  };
}
function nu({ mapper: t, value: e, update: r }) {
  const n = /* @__PURE__ */ O(t), s = /* @__PURE__ */ O(() => d(n).fromValue), o = /* @__PURE__ */ O(() => d(n).toValue), i = /* @__PURE__ */ O(() => d(s)(e()));
  return {
    get value() {
      return d(i);
    },
    set value(a) {
      r(d(o)(a));
    },
    get current() {
      return d(i);
    },
    set current(a) {
      r(d(o)(a));
    }
  };
}
function w_({ mapper: t, value: e, update: r }) {
  const n = /* @__PURE__ */ O(t), s = /* @__PURE__ */ O(() => d(n).fromValue), o = /* @__PURE__ */ O(() => d(n).toValue), i = /* @__PURE__ */ O(() => e()?.map(d(s)) ?? []);
  return {
    get value() {
      return d(i);
    },
    set value(a) {
      r(a.map(d(o)));
    },
    get current() {
      return d(i);
    },
    set current(a) {
      r(a.map(d(o)));
    }
  };
}
var kE = /* @__PURE__ */ ne("<span> </span>"), $E = /* @__PURE__ */ ne('<span class="min-h-5"> </span>'), AE = /* @__PURE__ */ ne("<!> <!>", 1), EE = /* @__PURE__ */ ne("<!> <!>", 1);
function S_(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Select), i = /* @__PURE__ */ O(() => d(s).SelectTrigger), a = /* @__PURE__ */ O(() => d(s).SelectContent), l = /* @__PURE__ */ O(() => d(s).SelectItem);
  let u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7), h = v(e, "config", 7);
  const _ = /* @__PURE__ */ O(() => new Map(f().map(($) => [$.id, $.label]))), b = nu({
    mapper: () => Mo(f()),
    value: () => c(),
    update: ($) => c($)
  }), p = /* @__PURE__ */ O(() => u().oninput), g = /* @__PURE__ */ O(() => u().onchange), y = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), S = /* @__PURE__ */ O(() => pr(r, h(), "shadcn4Select", {
    required: h().required,
    onValueChange: () => {
      d(p)?.(), d(g)?.();
    }
  })), x = /* @__PURE__ */ O(() => d(_).get(b.current) ?? d(S).placeholder), P = /* @__PURE__ */ O(() => mr(r, h().path));
  var w = {
    get handlers() {
      return u();
    },
    set handlers($) {
      u($), m();
    },
    get value() {
      return c();
    },
    set value($) {
      c($), m();
    },
    get options() {
      return f();
    },
    set options($) {
      f($), m();
    },
    get config() {
      return h();
    },
    set config($) {
      h($), m();
    }
  }, C = M(), k = D(C);
  return Q(k, () => d(o), ($, T) => {
    T($, ce(() => d(S), {
      type: "single",
      get value() {
        return b.current;
      },
      set value(E) {
        b.current = E;
      },
      children: (E, I) => {
        var F = EE(), U = D(F);
        {
          let R = /* @__PURE__ */ O(() => pr(r, h(), "shadcn4SelectTrigger", cn(d(y))({ id: d(P), name: d(P) })));
          Q(U, () => d(i), (Z, Y) => {
            Y(Z, ce({ class: "w-full" }, () => d(R), {
              children: (X, ae) => {
                var J = kE(), j = ge(J, !0);
                de(J), ke(() => Ie(j, d(x))), A(X, J);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var B = be(U, 2);
        Q(B, () => d(a), (R, Z) => {
          Z(R, {
            children: (Y, X) => {
              var ae = AE(), J = D(ae);
              {
                var j = (L) => {
                  var N = M(), V = D(N);
                  Q(V, () => d(l), (G, fe) => {
                    fe(G, {
                      get value() {
                        return Wa;
                      },
                      children: (se, we) => {
                        var le = $E(), re = ge(le, !0);
                        de(le), ke(() => Ie(re, d(S).placeholder)), A(se, le);
                      },
                      $$slots: { default: !0 }
                    });
                  }), A(L, N);
                };
                ue(J, (L) => {
                  h().schema.default === void 0 && L(j);
                });
              }
              var ee = be(J, 2);
              st(ee, 17, f, (L) => L.id, (L, N) => {
                var V = M(), G = D(V);
                Q(G, () => d(l), (fe, se) => {
                  se(fe, {
                    get value() {
                      return d(N).id;
                    },
                    get label() {
                      return d(N).label;
                    },
                    get disabled() {
                      return d(N).disabled;
                    }
                  });
                }), A(L, V);
              }), A(Y, ae);
            },
            $$slots: { default: !0 }
          });
        }), A(E, F);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, C), H(w);
}
K(S_, { handlers: {}, value: {}, options: {}, config: {} }, [], [], { mode: "open" });
var TE = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function x_(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "handlers", 7);
  const o = Ee(), i = ut(), a = /* @__PURE__ */ O(() => i.components), l = /* @__PURE__ */ O(() => d(a).Checkbox), u = /* @__PURE__ */ O(() => d(a).FieldLabel), c = /* @__PURE__ */ O(() => s().oninput), f = /* @__PURE__ */ O(() => s().onchange), h = /* @__PURE__ */ O(() => Nn(s(), ["oninput", "onchange"])), _ = /* @__PURE__ */ O(() => mr(o, r().path)), b = /* @__PURE__ */ O(() => pr(o, r(), "shadcn4Checkbox", cn(d(h))({
    id: d(_),
    name: d(_),
    required: r().required,
    onCheckedChange: () => {
      d(c)?.(), d(f)?.();
    }
  })));
  var p = {
    get config() {
      return r();
    },
    set config(w) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get handlers() {
      return s();
    },
    set handlers(w) {
      s(w), m();
    }
  }, g = TE(), y = ge(g), S = () => n() ?? !1, x = (w) => {
    n(w);
  };
  Q(y, () => d(l), (w, C) => {
    C(w, ce(
      {
        get checked() {
          return S();
        },
        set checked(k) {
          x(k);
        }
      },
      () => d(b)
    ));
  });
  var P = be(y, 2);
  return Q(P, () => d(u), (w, C) => {
    C(w, {
      get for() {
        return d(b).id;
      },
      children: (k, $) => {
        vt();
        var T = tt();
        ke(() => Ie(T, r().title)), A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), de(g), A(t, g), H(p);
}
K(x_, { config: {}, value: {}, handlers: {} }, [], [], { mode: "open" });
const DE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkboxWidget: x_,
  numberWidget: __,
  selectWidget: S_,
  textWidget: b_
}, Symbol.toStringTag, { value: "Module" })), rr = {
  ...PE,
  ...DE
}, ME = Qy(eE, rr);
const IE = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var NE = /* @__PURE__ */ AP("<svg><!><!></svg>");
function Dt(t, e) {
  W(e, !0);
  const r = v(e, "name", 7), n = v(e, "color", 7, "currentColor"), s = v(e, "size", 7, 24), o = v(e, "strokeWidth", 7, 2), i = v(e, "absoluteStrokeWidth", 7, !1), a = v(e, "iconNode", 23, () => []), l = v(e, "children", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode",
    "children"
  ]);
  var c = {
    get name() {
      return r();
    },
    set name(b) {
      r(b), m();
    },
    get color() {
      return n();
    },
    set color(b = "currentColor") {
      n(b), m();
    },
    get size() {
      return s();
    },
    set size(b = 24) {
      s(b), m();
    },
    get strokeWidth() {
      return o();
    },
    set strokeWidth(b = 2) {
      o(b), m();
    },
    get absoluteStrokeWidth() {
      return i();
    },
    set absoluteStrokeWidth(b = !1) {
      i(b), m();
    },
    get iconNode() {
      return a();
    },
    set iconNode(b = []) {
      a(b), m();
    },
    get children() {
      return l();
    },
    set children(b) {
      l(b), m();
    }
  }, f = NE();
  ve(
    f,
    (b) => ({
      ...IE,
      ...u,
      width: s(),
      height: s(),
      stroke: n(),
      "stroke-width": b,
      class: [
        "lucide-icon lucide",
        r() && `lucide-${r()}`,
        e.class
      ]
    }),
    [
      () => i() ? Number(o()) * 24 / Number(s()) : o()
    ]
  );
  var h = ge(f);
  st(h, 17, a, jl, (b, p) => {
    var g = /* @__PURE__ */ O(() => Rx(d(p), 2));
    let y = () => d(g)[0], S = () => d(g)[1];
    var x = M(), P = D(x);
    KP(P, y, !0, (w, C) => {
      ve(w, () => ({ ...S() }));
    }), A(b, x);
  });
  var _ = be(h);
  return te(_, () => l() ?? he), de(f), A(t, f), H(c);
}
K(
  Dt,
  {
    name: {},
    color: {},
    size: {},
    strokeWidth: {},
    absoluteStrokeWidth: {},
    iconNode: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
function P_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M12 5v14" }],
    ["path", { d: "m19 12-7 7-7-7" }]
  ];
  Dt(t, ce({ name: "arrow-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(P_, {}, [], [], { mode: "open" });
function O_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m5 12 7-7 7 7" }],
    ["path", { d: "M12 19V5" }]
  ];
  Dt(t, ce({ name: "arrow-up" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(O_, {}, [], [], { mode: "open" });
function C_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    [
      "rect",
      { width: "18", height: "18", x: "3", y: "4", rx: "2" }
    ],
    ["path", { d: "M3 10h18" }]
  ];
  Dt(t, ce({ name: "calendar" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(C_, {}, [], [], { mode: "open" });
function su(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "M20 6 9 17l-5-5" }]];
  Dt(t, ce({ name: "check" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(su, {}, [], [], { mode: "open" });
function Hs(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m6 9 6 6 6-6" }]];
  Dt(t, ce({ name: "chevron-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(Hs, {}, [], [], { mode: "open" });
function Xd(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m15 18-6-6 6-6" }]];
  Dt(t, ce({ name: "chevron-left" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(Xd, {}, [], [], { mode: "open" });
function Jd(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m9 18 6-6-6-6" }]];
  Dt(t, ce({ name: "chevron-right" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(Jd, {}, [], [], { mode: "open" });
function k_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m18 15-6-6-6 6" }]];
  Dt(t, ce({ name: "chevron-up" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(k_, {}, [], [], { mode: "open" });
function $_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m7 15 5 5 5-5" }],
    ["path", { d: "m7 9 5-5 5 5" }]
  ];
  Dt(t, ce({ name: "chevrons-up-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K($_, {}, [], [], { mode: "open" });
function A_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["circle", { cx: "12", cy: "12", r: "10" }]];
  Dt(t, ce({ name: "circle" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(A_, {}, [], [], { mode: "open" });
function E_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    [
      "rect",
      {
        width: "14",
        height: "14",
        x: "8",
        y: "8",
        rx: "2",
        ry: "2"
      }
    ],
    [
      "path",
      {
        d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
      }
    ]
  ];
  Dt(t, ce({ name: "copy" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(E_, {}, [], [], { mode: "open" });
function T_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "M5 12h14" }]];
  Dt(t, ce({ name: "minus" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(T_, {}, [], [], { mode: "open" });
function D_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m21 21-4.34-4.34" }],
    ["circle", { cx: "11", cy: "11", r: "8" }]
  ];
  Dt(t, ce({ name: "search" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(D_, {}, [], [], { mode: "open" });
function M_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }]
  ];
  Dt(t, ce({ name: "trash" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(M_, {}, [], [], { mode: "open" });
function I_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    [
      "path",
      {
        d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"
      }
    ],
    ["path", { d: "M12 9v4" }],
    ["path", { d: "M12 17h.01" }]
  ];
  Dt(t, ce({ name: "triangle-alert" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(I_, {}, [], [], { mode: "open" });
function N_(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M18 6 6 18" }],
    ["path", { d: "m6 6 12 12" }]
  ];
  Dt(t, ce({ name: "x" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(N_, {}, [], [], { mode: "open" });
function FE(t) {
  return t instanceof Error ? t.message : String(t);
}
const Io = function(t, e) {
  let s = t;
  const o = ii[e];
  let i = null, a = 0, l = null;
  const u = [], c = {}, f = function(k, $) {
    a = s * 4 + 17, i = (function(T) {
      const E = new Array(T);
      for (let I = 0; I < T; I += 1) {
        E[I] = new Array(T);
        for (let F = 0; F < T; F += 1)
          E[I][F] = null;
      }
      return E;
    })(a), h(0, 0), h(a - 7, 0), h(0, a - 7), p(), b(), y(k, $), s >= 7 && g(k), l == null && (l = P(s, o, u)), S(l, $);
  }, h = function(k, $) {
    for (let T = -1; T <= 7; T += 1)
      if (!(k + T <= -1 || a <= k + T))
        for (let E = -1; E <= 7; E += 1)
          $ + E <= -1 || a <= $ + E || (0 <= T && T <= 6 && (E == 0 || E == 6) || 0 <= E && E <= 6 && (T == 0 || T == 6) || 2 <= T && T <= 4 && 2 <= E && E <= 4 ? i[k + T][$ + E] = !0 : i[k + T][$ + E] = !1);
  }, _ = function() {
    let k = 0, $ = 0;
    for (let T = 0; T < 8; T += 1) {
      f(!0, T);
      const E = jn.getLostPoint(c);
      (T == 0 || k > E) && (k = E, $ = T);
    }
    return $;
  }, b = function() {
    for (let k = 8; k < a - 8; k += 1)
      i[k][6] == null && (i[k][6] = k % 2 == 0);
    for (let k = 8; k < a - 8; k += 1)
      i[6][k] == null && (i[6][k] = k % 2 == 0);
  }, p = function() {
    const k = jn.getPatternPosition(s);
    for (let $ = 0; $ < k.length; $ += 1)
      for (let T = 0; T < k.length; T += 1) {
        const E = k[$], I = k[T];
        if (i[E][I] == null)
          for (let F = -2; F <= 2; F += 1)
            for (let U = -2; U <= 2; U += 1)
              F == -2 || F == 2 || U == -2 || U == 2 || F == 0 && U == 0 ? i[E + F][I + U] = !0 : i[E + F][I + U] = !1;
      }
  }, g = function(k) {
    const $ = jn.getBCHTypeNumber(s);
    for (let T = 0; T < 18; T += 1) {
      const E = !k && ($ >> T & 1) == 1;
      i[Math.floor(T / 3)][T % 3 + a - 8 - 3] = E;
    }
    for (let T = 0; T < 18; T += 1) {
      const E = !k && ($ >> T & 1) == 1;
      i[T % 3 + a - 8 - 3][Math.floor(T / 3)] = E;
    }
  }, y = function(k, $) {
    const T = o << 3 | $, E = jn.getBCHTypeInfo(T);
    for (let I = 0; I < 15; I += 1) {
      const F = !k && (E >> I & 1) == 1;
      I < 6 ? i[I][8] = F : I < 8 ? i[I + 1][8] = F : i[a - 15 + I][8] = F;
    }
    for (let I = 0; I < 15; I += 1) {
      const F = !k && (E >> I & 1) == 1;
      I < 8 ? i[8][a - I - 1] = F : I < 9 ? i[8][15 - I - 1 + 1] = F : i[8][15 - I - 1] = F;
    }
    i[a - 8][8] = !k;
  }, S = function(k, $) {
    let T = -1, E = a - 1, I = 7, F = 0;
    const U = jn.getMaskFunction($);
    for (let B = a - 1; B > 0; B -= 2)
      for (B == 6 && (B -= 1); ; ) {
        for (let R = 0; R < 2; R += 1)
          if (i[E][B - R] == null) {
            let Z = !1;
            F < k.length && (Z = (k[F] >>> I & 1) == 1), U(E, B - R) && (Z = !Z), i[E][B - R] = Z, I -= 1, I == -1 && (F += 1, I = 7);
          }
        if (E += T, E < 0 || a <= E) {
          E -= T, T = -T;
          break;
        }
      }
  }, x = function(k, $) {
    let T = 0, E = 0, I = 0;
    const F = new Array($.length), U = new Array($.length);
    for (let Y = 0; Y < $.length; Y += 1) {
      const X = $[Y].dataCount, ae = $[Y].totalCount - X;
      E = Math.max(E, X), I = Math.max(I, ae), F[Y] = new Array(X);
      for (let L = 0; L < F[Y].length; L += 1)
        F[Y][L] = 255 & k.getBuffer()[L + T];
      T += X;
      const J = jn.getErrorCorrectPolynomial(ae), ee = bi(F[Y], J.getLength() - 1).mod(J);
      U[Y] = new Array(J.getLength() - 1);
      for (let L = 0; L < U[Y].length; L += 1) {
        const N = L + ee.getLength() - U[Y].length;
        U[Y][L] = N >= 0 ? ee.getAt(N) : 0;
      }
    }
    let B = 0;
    for (let Y = 0; Y < $.length; Y += 1)
      B += $[Y].totalCount;
    const R = new Array(B);
    let Z = 0;
    for (let Y = 0; Y < E; Y += 1)
      for (let X = 0; X < $.length; X += 1)
        Y < F[X].length && (R[Z] = F[X][Y], Z += 1);
    for (let Y = 0; Y < I; Y += 1)
      for (let X = 0; X < $.length; X += 1)
        Y < U[X].length && (R[Z] = U[X][Y], Z += 1);
    return R;
  }, P = function(k, $, T) {
    const E = im.getRSBlocks(k, $), I = am();
    for (let U = 0; U < T.length; U += 1) {
      const B = T[U];
      I.put(B.getMode(), 4), I.put(B.getLength(), jn.getLengthInBits(B.getMode(), k)), B.write(I);
    }
    let F = 0;
    for (let U = 0; U < E.length; U += 1)
      F += E[U].dataCount;
    if (I.getLengthInBits() > F * 8)
      throw "code length overflow. (" + I.getLengthInBits() + ">" + F * 8 + ")";
    for (I.getLengthInBits() + 4 <= F * 8 && I.put(0, 4); I.getLengthInBits() % 8 != 0; )
      I.putBit(!1);
    for (; !(I.getLengthInBits() >= F * 8 || (I.put(236, 8), I.getLengthInBits() >= F * 8)); )
      I.put(17, 8);
    return x(I, E);
  };
  c.addData = function(k, $) {
    $ = $ || "Byte";
    let T = null;
    switch ($) {
      case "Numeric":
        T = RE(k);
        break;
      case "Alphanumeric":
        T = VE(k);
        break;
      case "Byte":
        T = LE(k);
        break;
      case "Kanji":
        T = jE(k);
        break;
      default:
        throw "mode:" + $;
    }
    u.push(T), l = null;
  }, c.isDark = function(k, $) {
    if (k < 0 || a <= k || $ < 0 || a <= $)
      throw k + "," + $;
    return i[k][$];
  }, c.getModuleCount = function() {
    return a;
  }, c.make = function() {
    if (s < 1) {
      let k = 1;
      for (; k < 40; k++) {
        const $ = im.getRSBlocks(k, o), T = am();
        for (let I = 0; I < u.length; I++) {
          const F = u[I];
          T.put(F.getMode(), 4), T.put(F.getLength(), jn.getLengthInBits(F.getMode(), k)), F.write(T);
        }
        let E = 0;
        for (let I = 0; I < $.length; I++)
          E += $[I].dataCount;
        if (T.getLengthInBits() <= E * 8)
          break;
      }
      s = k;
    }
    f(!1, _());
  }, c.createTableTag = function(k, $) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    let T = "";
    T += '<table style="', T += " border-width: 0px; border-style: none;", T += " border-collapse: collapse;", T += " padding: 0px; margin: " + $ + "px;", T += '">', T += "<tbody>";
    for (let E = 0; E < c.getModuleCount(); E += 1) {
      T += "<tr>";
      for (let I = 0; I < c.getModuleCount(); I += 1)
        T += '<td style="', T += " border-width: 0px; border-style: none;", T += " border-collapse: collapse;", T += " padding: 0px; margin: 0px;", T += " width: " + k + "px;", T += " height: " + k + "px;", T += " background-color: ", T += c.isDark(E, I) ? "#000000" : "#ffffff", T += ";", T += '"/>';
      T += "</tr>";
    }
    return T += "</tbody>", T += "</table>", T;
  }, c.createSvgTag = function(k, $, T, E) {
    let I = {};
    typeof arguments[0] == "object" && (I = arguments[0], k = I.cellSize, $ = I.margin, T = I.alt, E = I.title), k = k || 2, $ = typeof $ > "u" ? k * 4 : $, T = typeof T == "string" ? { text: T } : T || {}, T.text = T.text || null, T.id = T.text ? T.id || "qrcode-description" : null, E = typeof E == "string" ? { text: E } : E || {}, E.text = E.text || null, E.id = E.text ? E.id || "qrcode-title" : null;
    const F = c.getModuleCount() * k + $ * 2;
    let U, B, R, Z, Y = "", X;
    for (X = "l" + k + ",0 0," + k + " -" + k + ",0 0,-" + k + "z ", Y += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Y += I.scalable ? "" : ' width="' + F + 'px" height="' + F + 'px"', Y += ' viewBox="0 0 ' + F + " " + F + '" ', Y += ' preserveAspectRatio="xMinYMin meet"', Y += E.text || T.text ? ' role="img" aria-labelledby="' + w([E.id, T.id].join(" ").trim()) + '"' : "", Y += ">", Y += E.text ? '<title id="' + w(E.id) + '">' + w(E.text) + "</title>" : "", Y += T.text ? '<description id="' + w(T.id) + '">' + w(T.text) + "</description>" : "", Y += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Y += '<path d="', R = 0; R < c.getModuleCount(); R += 1)
      for (Z = R * k + $, U = 0; U < c.getModuleCount(); U += 1)
        c.isDark(R, U) && (B = U * k + $, Y += "M" + B + "," + Z + X);
    return Y += '" stroke="transparent" fill="black"/>', Y += "</svg>", Y;
  }, c.createDataURL = function(k, $) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    const T = c.getModuleCount() * k + $ * 2, E = $, I = T - $;
    return UE(T, T, function(F, U) {
      if (E <= F && F < I && E <= U && U < I) {
        const B = Math.floor((F - E) / k), R = Math.floor((U - E) / k);
        return c.isDark(R, B) ? 0 : 1;
      } else
        return 1;
    });
  }, c.createImgTag = function(k, $, T) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    const E = c.getModuleCount() * k + $ * 2;
    let I = "";
    return I += "<img", I += ' src="', I += c.createDataURL(k, $), I += '"', I += ' width="', I += E, I += '"', I += ' height="', I += E, I += '"', T && (I += ' alt="', I += w(T), I += '"'), I += "/>", I;
  };
  const w = function(k) {
    let $ = "";
    for (let T = 0; T < k.length; T += 1) {
      const E = k.charAt(T);
      switch (E) {
        case "<":
          $ += "&lt;";
          break;
        case ">":
          $ += "&gt;";
          break;
        case "&":
          $ += "&amp;";
          break;
        case '"':
          $ += "&quot;";
          break;
        default:
          $ += E;
          break;
      }
    }
    return $;
  }, C = function(k) {
    k = typeof k > "u" ? 2 : k;
    const T = c.getModuleCount() * 1 + k * 2, E = k, I = T - k;
    let F, U, B, R, Z;
    const Y = {
      "â–ˆâ–ˆ": "â–ˆ",
      "â–ˆ ": "â–€",
      " â–ˆ": "â–„",
      "  ": " "
    }, X = {
      "â–ˆâ–ˆ": "â–€",
      "â–ˆ ": "â–€",
      " â–ˆ": " ",
      "  ": " "
    };
    let ae = "";
    for (F = 0; F < T; F += 2) {
      for (B = Math.floor((F - E) / 1), R = Math.floor((F + 1 - E) / 1), U = 0; U < T; U += 1)
        Z = "â–ˆ", E <= U && U < I && E <= F && F < I && c.isDark(B, Math.floor((U - E) / 1)) && (Z = " "), E <= U && U < I && E <= F + 1 && F + 1 < I && c.isDark(R, Math.floor((U - E) / 1)) ? Z += " " : Z += "â–ˆ", ae += k < 1 && F + 1 >= I ? X[Z] : Y[Z];
      ae += `
`;
    }
    return T % 2 && k > 0 ? ae.substring(0, ae.length - T - 1) + Array(T + 1).join("â–€") : ae.substring(0, ae.length - 1);
  };
  return c.createASCII = function(k, $) {
    if (k = k || 1, k < 2)
      return C($);
    k -= 1, $ = typeof $ > "u" ? k * 2 : $;
    const T = c.getModuleCount() * k + $ * 2, E = $, I = T - $;
    let F, U, B, R;
    const Z = Array(k + 1).join("â–ˆâ–ˆ"), Y = Array(k + 1).join("  ");
    let X = "", ae = "";
    for (F = 0; F < T; F += 1) {
      for (B = Math.floor((F - E) / k), ae = "", U = 0; U < T; U += 1)
        R = 1, E <= U && U < I && E <= F && F < I && c.isDark(B, Math.floor((U - E) / k)) && (R = 0), ae += R ? Z : Y;
      for (B = 0; B < k; B += 1)
        X += ae + `
`;
    }
    return X.substring(0, X.length - 1);
  }, c.renderTo2dContext = function(k, $) {
    $ = $ || 2;
    const T = c.getModuleCount();
    for (let E = 0; E < T; E++)
      for (let I = 0; I < T; I++)
        k.fillStyle = c.isDark(E, I) ? "black" : "white", k.fillRect(I * $, E * $, $, $);
  }, c;
};
Io.stringToBytes = function(t) {
  const e = [];
  for (let r = 0; r < t.length; r += 1) {
    const n = t.charCodeAt(r);
    e.push(n & 255);
  }
  return e;
};
Io.createStringToBytes = function(t, e) {
  const r = (function() {
    const s = zE(t), o = function() {
      const l = s.read();
      if (l == -1) throw "eof";
      return l;
    };
    let i = 0;
    const a = {};
    for (; ; ) {
      const l = s.read();
      if (l == -1) break;
      const u = o(), c = o(), f = o(), h = String.fromCharCode(l << 8 | u), _ = c << 8 | f;
      a[h] = _, i += 1;
    }
    if (i != e)
      throw i + " != " + e;
    return a;
  })(), n = 63;
  return function(s) {
    const o = [];
    for (let i = 0; i < s.length; i += 1) {
      const a = s.charCodeAt(i);
      if (a < 128)
        o.push(a);
      else {
        const l = r[s.charAt(i)];
        typeof l == "number" ? (l & 255) == l ? o.push(l) : (o.push(l >>> 8), o.push(l & 255)) : o.push(n);
      }
    }
    return o;
  };
};
const It = {
  MODE_NUMBER: 1,
  MODE_ALPHA_NUM: 2,
  MODE_8BIT_BYTE: 4,
  MODE_KANJI: 8
}, ii = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
}, Ln = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
}, jn = (function() {
  const t = [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
  ], e = 1335, r = 7973, n = 21522, s = {}, o = function(i) {
    let a = 0;
    for (; i != 0; )
      a += 1, i >>>= 1;
    return a;
  };
  return s.getBCHTypeInfo = function(i) {
    let a = i << 10;
    for (; o(a) - o(e) >= 0; )
      a ^= e << o(a) - o(e);
    return (i << 10 | a) ^ n;
  }, s.getBCHTypeNumber = function(i) {
    let a = i << 12;
    for (; o(a) - o(r) >= 0; )
      a ^= r << o(a) - o(r);
    return i << 12 | a;
  }, s.getPatternPosition = function(i) {
    return t[i - 1];
  }, s.getMaskFunction = function(i) {
    switch (i) {
      case Ln.PATTERN000:
        return function(a, l) {
          return (a + l) % 2 == 0;
        };
      case Ln.PATTERN001:
        return function(a, l) {
          return a % 2 == 0;
        };
      case Ln.PATTERN010:
        return function(a, l) {
          return l % 3 == 0;
        };
      case Ln.PATTERN011:
        return function(a, l) {
          return (a + l) % 3 == 0;
        };
      case Ln.PATTERN100:
        return function(a, l) {
          return (Math.floor(a / 2) + Math.floor(l / 3)) % 2 == 0;
        };
      case Ln.PATTERN101:
        return function(a, l) {
          return a * l % 2 + a * l % 3 == 0;
        };
      case Ln.PATTERN110:
        return function(a, l) {
          return (a * l % 2 + a * l % 3) % 2 == 0;
        };
      case Ln.PATTERN111:
        return function(a, l) {
          return (a * l % 3 + (a + l) % 2) % 2 == 0;
        };
      default:
        throw "bad maskPattern:" + i;
    }
  }, s.getErrorCorrectPolynomial = function(i) {
    let a = bi([1], 0);
    for (let l = 0; l < i; l += 1)
      a = a.multiply(bi([1, Un.gexp(l)], 0));
    return a;
  }, s.getLengthInBits = function(i, a) {
    if (1 <= a && a < 10)
      switch (i) {
        case It.MODE_NUMBER:
          return 10;
        case It.MODE_ALPHA_NUM:
          return 9;
        case It.MODE_8BIT_BYTE:
          return 8;
        case It.MODE_KANJI:
          return 8;
        default:
          throw "mode:" + i;
      }
    else if (a < 27)
      switch (i) {
        case It.MODE_NUMBER:
          return 12;
        case It.MODE_ALPHA_NUM:
          return 11;
        case It.MODE_8BIT_BYTE:
          return 16;
        case It.MODE_KANJI:
          return 10;
        default:
          throw "mode:" + i;
      }
    else if (a < 41)
      switch (i) {
        case It.MODE_NUMBER:
          return 14;
        case It.MODE_ALPHA_NUM:
          return 13;
        case It.MODE_8BIT_BYTE:
          return 16;
        case It.MODE_KANJI:
          return 12;
        default:
          throw "mode:" + i;
      }
    else
      throw "type:" + a;
  }, s.getLostPoint = function(i) {
    const a = i.getModuleCount();
    let l = 0;
    for (let f = 0; f < a; f += 1)
      for (let h = 0; h < a; h += 1) {
        let _ = 0;
        const b = i.isDark(f, h);
        for (let p = -1; p <= 1; p += 1)
          if (!(f + p < 0 || a <= f + p))
            for (let g = -1; g <= 1; g += 1)
              h + g < 0 || a <= h + g || p == 0 && g == 0 || b == i.isDark(f + p, h + g) && (_ += 1);
        _ > 5 && (l += 3 + _ - 5);
      }
    for (let f = 0; f < a - 1; f += 1)
      for (let h = 0; h < a - 1; h += 1) {
        let _ = 0;
        i.isDark(f, h) && (_ += 1), i.isDark(f + 1, h) && (_ += 1), i.isDark(f, h + 1) && (_ += 1), i.isDark(f + 1, h + 1) && (_ += 1), (_ == 0 || _ == 4) && (l += 3);
      }
    for (let f = 0; f < a; f += 1)
      for (let h = 0; h < a - 6; h += 1)
        i.isDark(f, h) && !i.isDark(f, h + 1) && i.isDark(f, h + 2) && i.isDark(f, h + 3) && i.isDark(f, h + 4) && !i.isDark(f, h + 5) && i.isDark(f, h + 6) && (l += 40);
    for (let f = 0; f < a; f += 1)
      for (let h = 0; h < a - 6; h += 1)
        i.isDark(h, f) && !i.isDark(h + 1, f) && i.isDark(h + 2, f) && i.isDark(h + 3, f) && i.isDark(h + 4, f) && !i.isDark(h + 5, f) && i.isDark(h + 6, f) && (l += 40);
    let u = 0;
    for (let f = 0; f < a; f += 1)
      for (let h = 0; h < a; h += 1)
        i.isDark(h, f) && (u += 1);
    const c = Math.abs(100 * u / a / a - 50) / 5;
    return l += c * 10, l;
  }, s;
})(), Un = (function() {
  const t = new Array(256), e = new Array(256);
  for (let n = 0; n < 8; n += 1)
    t[n] = 1 << n;
  for (let n = 8; n < 256; n += 1)
    t[n] = t[n - 4] ^ t[n - 5] ^ t[n - 6] ^ t[n - 8];
  for (let n = 0; n < 255; n += 1)
    e[t[n]] = n;
  const r = {};
  return r.glog = function(n) {
    if (n < 1)
      throw "glog(" + n + ")";
    return e[n];
  }, r.gexp = function(n) {
    for (; n < 0; )
      n += 255;
    for (; n >= 256; )
      n -= 255;
    return t[n];
  }, r;
})(), bi = function(t, e) {
  if (typeof t.length > "u")
    throw t.length + "/" + e;
  const r = (function() {
    let s = 0;
    for (; s < t.length && t[s] == 0; )
      s += 1;
    const o = new Array(t.length - s + e);
    for (let i = 0; i < t.length - s; i += 1)
      o[i] = t[i + s];
    return o;
  })(), n = {};
  return n.getAt = function(s) {
    return r[s];
  }, n.getLength = function() {
    return r.length;
  }, n.multiply = function(s) {
    const o = new Array(n.getLength() + s.getLength() - 1);
    for (let i = 0; i < n.getLength(); i += 1)
      for (let a = 0; a < s.getLength(); a += 1)
        o[i + a] ^= Un.gexp(Un.glog(n.getAt(i)) + Un.glog(s.getAt(a)));
    return bi(o, 0);
  }, n.mod = function(s) {
    if (n.getLength() - s.getLength() < 0)
      return n;
    const o = Un.glog(n.getAt(0)) - Un.glog(s.getAt(0)), i = new Array(n.getLength());
    for (let a = 0; a < n.getLength(); a += 1)
      i[a] = n.getAt(a);
    for (let a = 0; a < s.getLength(); a += 1)
      i[a] ^= Un.gexp(Un.glog(s.getAt(a)) + o);
    return bi(i, 0).mod(s);
  }, n;
}, im = (function() {
  const t = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12, 7, 37, 13],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ], e = function(s, o) {
    const i = {};
    return i.totalCount = s, i.dataCount = o, i;
  }, r = {}, n = function(s, o) {
    switch (o) {
      case ii.L:
        return t[(s - 1) * 4 + 0];
      case ii.M:
        return t[(s - 1) * 4 + 1];
      case ii.Q:
        return t[(s - 1) * 4 + 2];
      case ii.H:
        return t[(s - 1) * 4 + 3];
      default:
        return;
    }
  };
  return r.getRSBlocks = function(s, o) {
    const i = n(s, o);
    if (typeof i > "u")
      throw "bad rs block @ typeNumber:" + s + "/errorCorrectionLevel:" + o;
    const a = i.length / 3, l = [];
    for (let u = 0; u < a; u += 1) {
      const c = i[u * 3 + 0], f = i[u * 3 + 1], h = i[u * 3 + 2];
      for (let _ = 0; _ < c; _ += 1)
        l.push(e(f, h));
    }
    return l;
  }, r;
})(), am = function() {
  const t = [];
  let e = 0;
  const r = {};
  return r.getBuffer = function() {
    return t;
  }, r.getAt = function(n) {
    const s = Math.floor(n / 8);
    return (t[s] >>> 7 - n % 8 & 1) == 1;
  }, r.put = function(n, s) {
    for (let o = 0; o < s; o += 1)
      r.putBit((n >>> s - o - 1 & 1) == 1);
  }, r.getLengthInBits = function() {
    return e;
  }, r.putBit = function(n) {
    const s = Math.floor(e / 8);
    t.length <= s && t.push(0), n && (t[s] |= 128 >>> e % 8), e += 1;
  }, r;
}, RE = function(t) {
  const e = It.MODE_NUMBER, r = t, n = {};
  n.getMode = function() {
    return e;
  }, n.getLength = function(i) {
    return r.length;
  }, n.write = function(i) {
    const a = r;
    let l = 0;
    for (; l + 2 < a.length; )
      i.put(s(a.substring(l, l + 3)), 10), l += 3;
    l < a.length && (a.length - l == 1 ? i.put(s(a.substring(l, l + 1)), 4) : a.length - l == 2 && i.put(s(a.substring(l, l + 2)), 7));
  };
  const s = function(i) {
    let a = 0;
    for (let l = 0; l < i.length; l += 1)
      a = a * 10 + o(i.charAt(l));
    return a;
  }, o = function(i) {
    if ("0" <= i && i <= "9")
      return i.charCodeAt(0) - 48;
    throw "illegal char :" + i;
  };
  return n;
}, VE = function(t) {
  const e = It.MODE_ALPHA_NUM, r = t, n = {};
  n.getMode = function() {
    return e;
  }, n.getLength = function(o) {
    return r.length;
  }, n.write = function(o) {
    const i = r;
    let a = 0;
    for (; a + 1 < i.length; )
      o.put(
        s(i.charAt(a)) * 45 + s(i.charAt(a + 1)),
        11
      ), a += 2;
    a < i.length && o.put(s(i.charAt(a)), 6);
  };
  const s = function(o) {
    if ("0" <= o && o <= "9")
      return o.charCodeAt(0) - 48;
    if ("A" <= o && o <= "Z")
      return o.charCodeAt(0) - 65 + 10;
    switch (o) {
      case " ":
        return 36;
      case "$":
        return 37;
      case "%":
        return 38;
      case "*":
        return 39;
      case "+":
        return 40;
      case "-":
        return 41;
      case ".":
        return 42;
      case "/":
        return 43;
      case ":":
        return 44;
      default:
        throw "illegal char :" + o;
    }
  };
  return n;
}, LE = function(t) {
  const e = It.MODE_8BIT_BYTE, r = Io.stringToBytes(t), n = {};
  return n.getMode = function() {
    return e;
  }, n.getLength = function(s) {
    return r.length;
  }, n.write = function(s) {
    for (let o = 0; o < r.length; o += 1)
      s.put(r[o], 8);
  }, n;
}, jE = function(t) {
  const e = It.MODE_KANJI, r = Io.stringToBytes;
  (function(o, i) {
    const a = r(o);
    if (a.length != 2 || (a[0] << 8 | a[1]) != i)
      throw "sjis not supported.";
  })("å‹", 38726);
  const n = r(t), s = {};
  return s.getMode = function() {
    return e;
  }, s.getLength = function(o) {
    return ~~(n.length / 2);
  }, s.write = function(o) {
    const i = n;
    let a = 0;
    for (; a + 1 < i.length; ) {
      let l = (255 & i[a]) << 8 | 255 & i[a + 1];
      if (33088 <= l && l <= 40956)
        l -= 33088;
      else if (57408 <= l && l <= 60351)
        l -= 49472;
      else
        throw "illegal char at " + (a + 1) + "/" + l;
      l = (l >>> 8 & 255) * 192 + (l & 255), o.put(l, 13), a += 2;
    }
    if (a < i.length)
      throw "illegal char at " + (a + 1);
  }, s;
}, F_ = function() {
  const t = [], e = {};
  return e.writeByte = function(r) {
    t.push(r & 255);
  }, e.writeShort = function(r) {
    e.writeByte(r), e.writeByte(r >>> 8);
  }, e.writeBytes = function(r, n, s) {
    n = n || 0, s = s || r.length;
    for (let o = 0; o < s; o += 1)
      e.writeByte(r[o + n]);
  }, e.writeString = function(r) {
    for (let n = 0; n < r.length; n += 1)
      e.writeByte(r.charCodeAt(n));
  }, e.toByteArray = function() {
    return t;
  }, e.toString = function() {
    let r = "";
    r += "[";
    for (let n = 0; n < t.length; n += 1)
      n > 0 && (r += ","), r += t[n];
    return r += "]", r;
  }, e;
}, BE = function() {
  let t = 0, e = 0, r = 0, n = "";
  const s = {}, o = function(a) {
    n += String.fromCharCode(i(a & 63));
  }, i = function(a) {
    if (a < 0)
      throw "n:" + a;
    if (a < 26)
      return 65 + a;
    if (a < 52)
      return 97 + (a - 26);
    if (a < 62)
      return 48 + (a - 52);
    if (a == 62)
      return 43;
    if (a == 63)
      return 47;
    throw "n:" + a;
  };
  return s.writeByte = function(a) {
    for (t = t << 8 | a & 255, e += 8, r += 1; e >= 6; )
      o(t >>> e - 6), e -= 6;
  }, s.flush = function() {
    if (e > 0 && (o(t << 6 - e), t = 0, e = 0), r % 3 != 0) {
      const a = 3 - r % 3;
      for (let l = 0; l < a; l += 1)
        n += "=";
    }
  }, s.toString = function() {
    return n;
  }, s;
}, zE = function(t) {
  const e = t;
  let r = 0, n = 0, s = 0;
  const o = {};
  o.read = function() {
    for (; s < 8; ) {
      if (r >= e.length) {
        if (s == 0)
          return -1;
        throw "unexpected end of file./" + s;
      }
      const l = e.charAt(r);
      if (r += 1, l == "=")
        return s = 0, -1;
      if (l.match(/^\s$/))
        continue;
      n = n << 6 | i(l.charCodeAt(0)), s += 6;
    }
    const a = n >>> s - 8 & 255;
    return s -= 8, a;
  };
  const i = function(a) {
    if (65 <= a && a <= 90)
      return a - 65;
    if (97 <= a && a <= 122)
      return a - 97 + 26;
    if (48 <= a && a <= 57)
      return a - 48 + 52;
    if (a == 43)
      return 62;
    if (a == 47)
      return 63;
    throw "c:" + a;
  };
  return o;
}, qE = function(t, e) {
  const r = t, n = e, s = new Array(t * e), o = {};
  o.setPixel = function(u, c, f) {
    s[c * r + u] = f;
  }, o.write = function(u) {
    u.writeString("GIF87a"), u.writeShort(r), u.writeShort(n), u.writeByte(128), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(255), u.writeByte(255), u.writeByte(255), u.writeString(","), u.writeShort(0), u.writeShort(0), u.writeShort(r), u.writeShort(n), u.writeByte(0);
    const c = 2, f = a(c);
    u.writeByte(c);
    let h = 0;
    for (; f.length - h > 255; )
      u.writeByte(255), u.writeBytes(f, h, 255), h += 255;
    u.writeByte(f.length - h), u.writeBytes(f, h, f.length - h), u.writeByte(0), u.writeString(";");
  };
  const i = function(u) {
    const c = u;
    let f = 0, h = 0;
    const _ = {};
    return _.write = function(b, p) {
      if (b >>> p)
        throw "length over";
      for (; f + p >= 8; )
        c.writeByte(255 & (b << f | h)), p -= 8 - f, b >>>= 8 - f, h = 0, f = 0;
      h = b << f | h, f = f + p;
    }, _.flush = function() {
      f > 0 && c.writeByte(h);
    }, _;
  }, a = function(u) {
    const c = 1 << u, f = (1 << u) + 1;
    let h = u + 1;
    const _ = l();
    for (let S = 0; S < c; S += 1)
      _.add(String.fromCharCode(S));
    _.add(String.fromCharCode(c)), _.add(String.fromCharCode(f));
    const b = F_(), p = i(b);
    p.write(c, h);
    let g = 0, y = String.fromCharCode(s[g]);
    for (g += 1; g < s.length; ) {
      const S = String.fromCharCode(s[g]);
      g += 1, _.contains(y + S) ? y = y + S : (p.write(_.indexOf(y), h), _.size() < 4095 && (_.size() == 1 << h && (h += 1), _.add(y + S)), y = S);
    }
    return p.write(_.indexOf(y), h), p.write(f, h), p.flush(), b.toByteArray();
  }, l = function() {
    const u = {};
    let c = 0;
    const f = {};
    return f.add = function(h) {
      if (f.contains(h))
        throw "dup key:" + h;
      u[h] = c, c += 1;
    }, f.size = function() {
      return c;
    }, f.indexOf = function(h) {
      return u[h];
    }, f.contains = function(h) {
      return typeof u[h] < "u";
    }, f;
  };
  return o;
}, UE = function(t, e, r) {
  const n = qE(t, e);
  for (let a = 0; a < e; a += 1)
    for (let l = 0; l < t; l += 1)
      n.setPixel(l, a, r(l, a));
  const s = F_();
  n.write(s);
  const o = BE(), i = s.toByteArray();
  for (let a = 0; a < i.length; a += 1)
    o.writeByte(i[a]);
  return o.flush(), "data:image/gif;base64," + o;
};
Io.stringToBytes;
var KE = /* @__PURE__ */ ne("<!> <p> </p>", 1), WE = /* @__PURE__ */ ne('<img class="aspect-square h-full w-full object-contain" alt="QR Code"/>'), HE = /* @__PURE__ */ ne("<p>Type something to generate a QR Code</p>"), GE = /* @__PURE__ */ ne('<div class="flex gap-4"><!> <div><!></div></div>');
function R_(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  function s(_, b = 20) {
    const p = Io(0, "L");
    return p.addData(_), p.make(), p.createDataURL(b);
  }
  const o = /* @__PURE__ */ O(() => {
    if (r())
      try {
        return s(r());
      } catch (_) {
        return new Error(FE(_));
      }
  });
  var i = {
    get value() {
      return r();
    },
    set value(_) {
      r(_), m();
    }
  }, a = GE(), l = ge(a);
  Ud(l, ce(() => n, {
    get value() {
      return r();
    },
    set value(_) {
      r(_);
    }
  }));
  var u = be(l, 2), c = ge(u);
  {
    var f = (_) => {
      var b = KE(), p = D(b);
      I_(p, { size: 20 });
      var g = be(p, 2), y = ge(g, !0);
      de(g), ke(() => Ie(y, d(o).message)), A(_, b);
    }, h = (_) => {
      var b = M(), p = D(b);
      {
        var g = (S) => {
          var x = WE();
          ke(() => An(x, "src", d(o))), A(S, x);
        }, y = (S) => {
          var x = HE();
          A(S, x);
        };
        ue(
          p,
          (S) => {
            d(o) ? S(g) : S(y, !1);
          },
          !0
        );
      }
      A(_, b);
    };
    ue(c, (_) => {
      d(o) instanceof Error ? _(f) : _(h, !1);
    });
  }
  return de(u), de(a), ke(() => ls(u, 1, as([
    "aspect-square size-48 shrink-0 overflow-hidden rounded-md border bg-slate-50",
    "flex flex-col items-center justify-center gap-1",
    "text-center text-xs text-muted-foreground",
    (!d(o) || d(o) instanceof Error) && "p-3"
  ]))), A(t, a), H(i);
}
K(R_, { value: {} }, [], [], { mode: "open" });
tP();
const YE = (t) => {
  O_(t, { size: 20 });
}, XE = (t) => {
  P_(t, { size: 20 });
}, lm = (t) => {
  M_(t, { size: 20 });
}, JE = (t) => {
  E_(t, { size: 20 });
};
function ZE(t) {
}
K(ZE, {}, [], [], { mode: "open" });
const QE = {
  "move-array-item-up": YE,
  "move-array-item-down": XE,
  "remove-array-item": lm,
  "copy-array-item": JE,
  "remove-object-property": lm
}, e7 = QE, t7 = Ii(e7);
var r7 = /\s+/g, n7 = (t) => typeof t != "string" || !t ? t : t.replace(r7, " ").trim(), ll = (...t) => {
  const e = [], r = (n) => {
    if (!n && n !== 0 && n !== 0n) return;
    if (Array.isArray(n)) {
      for (let o = 0, i = n.length; o < i; o++) r(n[o]);
      return;
    }
    const s = typeof n;
    if (s === "string" || s === "number" || s === "bigint") {
      if (s === "number" && n !== n) return;
      e.push(String(n));
    } else if (s === "object") {
      const o = Object.keys(n);
      for (let i = 0, a = o.length; i < a; i++) {
        const l = o[i];
        n[l] && e.push(l);
      }
    }
  };
  for (let n = 0, s = t.length; n < s; n++) {
    const o = t[n];
    o != null && r(o);
  }
  return e.length > 0 ? n7(e.join(" ")) : void 0;
}, um = (t) => t === !1 ? "false" : t === !0 ? "true" : t === 0 ? "0" : t, Gt = (t) => {
  if (!t || typeof t != "object") return !0;
  for (const e in t) return !1;
  return !0;
}, s7 = (t, e) => {
  if (t === e) return !0;
  if (!t || !e) return !1;
  const r = Object.keys(t), n = Object.keys(e);
  if (r.length !== n.length) return !1;
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    if (!n.includes(o) || t[o] !== e[o]) return !1;
  }
  return !0;
}, o7 = (t, e) => {
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const n = e[r];
      r in t ? t[r] = ll(t[r], n) : t[r] = n;
    }
  return t;
}, V_ = (t, e) => {
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    Array.isArray(n) ? V_(n, e) : n && e.push(n);
  }
}, L_ = (...t) => {
  const e = [];
  V_(t, e);
  const r = [];
  for (let n = 0; n < e.length; n++)
    e[n] && r.push(e[n]);
  return r;
}, Ic = (t, e) => {
  const r = {};
  for (const n in t) {
    const s = t[n];
    if (n in e) {
      const o = e[n];
      Array.isArray(s) || Array.isArray(o) ? r[n] = L_(o, s) : typeof s == "object" && typeof o == "object" && s && o ? r[n] = Ic(s, o) : r[n] = o + " " + s;
    } else
      r[n] = s;
  }
  for (const n in e)
    n in t || (r[n] = e[n]);
  return r;
}, i7 = {
  twMerge: !0,
  twMergeConfig: {}
};
function a7() {
  let t = null, e = {}, r = !1;
  return {
    get cachedTwMerge() {
      return t;
    },
    set cachedTwMerge(n) {
      t = n;
    },
    get cachedTwMergeConfig() {
      return e;
    },
    set cachedTwMergeConfig(n) {
      e = n;
    },
    get didTwMergeConfigChange() {
      return r;
    },
    set didTwMergeConfigChange(n) {
      r = n;
    },
    reset() {
      t = null, e = {}, r = !1;
    }
  };
}
var yn = a7(), l7 = (t) => {
  const e = (n, s) => {
    const {
      extend: o = null,
      slots: i = {},
      variants: a = {},
      compoundVariants: l = [],
      compoundSlots: u = [],
      defaultVariants: c = {}
    } = n, f = { ...i7, ...s }, h = o?.base ? ll(o.base, n?.base) : n?.base, _ = o?.variants && !Gt(o.variants) ? Ic(a, o.variants) : a, b = o?.defaultVariants && !Gt(o.defaultVariants) ? { ...o.defaultVariants, ...c } : c;
    !Gt(f.twMergeConfig) && !s7(f.twMergeConfig, yn.cachedTwMergeConfig) && (yn.didTwMergeConfigChange = !0, yn.cachedTwMergeConfig = f.twMergeConfig);
    const p = Gt(o?.slots), g = Gt(i) ? {} : {
      // add "base" to the slots object
      base: ll(n?.base, p && o?.base),
      ...i
    }, y = p ? g : o7(
      { ...o?.slots },
      Gt(g) ? { base: n?.base } : g
    ), S = Gt(o?.compoundVariants) ? l : L_(o?.compoundVariants, l), x = (w) => {
      if (Gt(_) && Gt(i) && p)
        return t(h, w?.class, w?.className)(f);
      if (S && !Array.isArray(S))
        throw new TypeError(
          `The "compoundVariants" prop must be an array. Received: ${typeof S}`
        );
      if (u && !Array.isArray(u))
        throw new TypeError(
          `The "compoundSlots" prop must be an array. Received: ${typeof u}`
        );
      const C = (B, R = _, Z = null, Y = null) => {
        const X = R[B];
        if (!X || Gt(X))
          return null;
        const ae = Y?.[B] ?? w?.[B];
        if (ae === null) return null;
        const J = um(ae);
        if (typeof J == "object")
          return null;
        const j = b?.[B], ee = J ?? um(j);
        return X[ee || "false"];
      }, k = () => {
        if (!_) return null;
        const B = Object.keys(_), R = [];
        for (let Z = 0; Z < B.length; Z++) {
          const Y = C(B[Z], _);
          Y && R.push(Y);
        }
        return R;
      }, $ = (B, R) => {
        if (!_ || typeof _ != "object") return null;
        const Z = [];
        for (const Y in _) {
          const X = C(Y, _, B, R), ae = B === "base" && typeof X == "string" ? X : X && X[B];
          ae && Z.push(ae);
        }
        return Z;
      }, T = {};
      for (const B in w) {
        const R = w[B];
        R !== void 0 && (T[B] = R);
      }
      const E = (B, R) => {
        const Z = typeof w?.[B] == "object" ? {
          [B]: w[B]?.initial
        } : {};
        return {
          ...b,
          ...T,
          ...Z,
          ...R
        };
      }, I = (B = [], R) => {
        const Z = [], Y = B.length;
        for (let X = 0; X < Y; X++) {
          const { class: ae, className: J, ...j } = B[X];
          let ee = !0;
          const L = E(null, R);
          for (const N in j) {
            const V = j[N], G = L[N];
            if (Array.isArray(V)) {
              if (!V.includes(G)) {
                ee = !1;
                break;
              }
            } else {
              if ((V == null || V === !1) && (G == null || G === !1))
                continue;
              if (G !== V) {
                ee = !1;
                break;
              }
            }
          }
          ee && (ae && Z.push(ae), J && Z.push(J));
        }
        return Z;
      }, F = (B) => {
        const R = I(S, B);
        if (!Array.isArray(R)) return R;
        const Z = {}, Y = t;
        for (let X = 0; X < R.length; X++) {
          const ae = R[X];
          if (typeof ae == "string")
            Z.base = Y(Z.base, ae)(f);
          else if (typeof ae == "object")
            for (const J in ae)
              Z[J] = Y(Z[J], ae[J])(f);
        }
        return Z;
      }, U = (B) => {
        if (u.length < 1) return null;
        const R = {}, Z = E(null, B);
        for (let Y = 0; Y < u.length; Y++) {
          const {
            slots: X = [],
            class: ae,
            className: J,
            ...j
          } = u[Y];
          if (!Gt(j)) {
            let ee = !0;
            for (const L in j) {
              const N = Z[L], V = j[L];
              if (N === void 0 || (Array.isArray(V) ? !V.includes(N) : V !== N)) {
                ee = !1;
                break;
              }
            }
            if (!ee) continue;
          }
          for (let ee = 0; ee < X.length; ee++) {
            const L = X[ee];
            R[L] || (R[L] = []), R[L].push([ae, J]);
          }
        }
        return R;
      };
      if (!Gt(i) || !p) {
        const B = {};
        if (typeof y == "object" && !Gt(y)) {
          const R = t;
          for (const Z in y)
            B[Z] = (Y) => {
              const X = F(Y), ae = U(Y);
              return R(
                y[Z],
                $(Z, Y),
                X ? X[Z] : void 0,
                ae ? ae[Z] : void 0,
                Y?.class,
                Y?.className
              )(f);
            };
        }
        return B;
      }
      return t(
        h,
        k(),
        I(S),
        w?.class,
        w?.className
      )(f);
    }, P = () => {
      if (!(!_ || typeof _ != "object"))
        return Object.keys(_);
    };
    return x.variantKeys = P(), x.extend = o, x.base = h, x.slots = y, x.variants = _, x.defaultVariants = b, x.compoundSlots = u, x.compoundVariants = S, x;
  };
  return {
    tv: e,
    createTV: (n) => (s, o) => e(s, o ? Ic(n, o) : n)
  };
};
const u7 = (t, e) => {
  const r = new Array(t.length + e.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t[n];
  for (let n = 0; n < e.length; n++)
    r[t.length + n] = e[n];
  return r;
}, c7 = (t, e) => ({
  classGroupId: t,
  validator: e
}), j_ = (t = /* @__PURE__ */ new Map(), e = null, r) => ({
  nextPart: t,
  validators: e,
  classGroupId: r
}), ul = "-", cm = [], d7 = "arbitrary..", f7 = (t) => {
  const e = g7(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (i) => {
      if (i.startsWith("[") && i.endsWith("]"))
        return h7(i);
      const a = i.split(ul), l = a[0] === "" && a.length > 1 ? 1 : 0;
      return B_(a, l, e);
    },
    getConflictingClassGroupIds: (i, a) => {
      if (a) {
        const l = n[i], u = r[i];
        return l ? u ? u7(u, l) : l : u || cm;
      }
      return r[i] || cm;
    }
  };
}, B_ = (t, e, r) => {
  if (t.length - e === 0)
    return r.classGroupId;
  const s = t[e], o = r.nextPart.get(s);
  if (o) {
    const u = B_(t, e + 1, o);
    if (u) return u;
  }
  const i = r.validators;
  if (i === null)
    return;
  const a = e === 0 ? t.join(ul) : t.slice(e).join(ul), l = i.length;
  for (let u = 0; u < l; u++) {
    const c = i[u];
    if (c.validator(a))
      return c.classGroupId;
  }
}, h7 = (t) => t.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const e = t.slice(1, -1), r = e.indexOf(":"), n = e.slice(0, r);
  return n ? d7 + n : void 0;
})(), g7 = (t) => {
  const {
    theme: e,
    classGroups: r
  } = t;
  return p7(r, e);
}, p7 = (t, e) => {
  const r = j_();
  for (const n in t) {
    const s = t[n];
    Zd(s, r, n, e);
  }
  return r;
}, Zd = (t, e, r, n) => {
  const s = t.length;
  for (let o = 0; o < s; o++) {
    const i = t[o];
    m7(i, e, r, n);
  }
}, m7 = (t, e, r, n) => {
  if (typeof t == "string") {
    v7(t, e, r);
    return;
  }
  if (typeof t == "function") {
    y7(t, e, r, n);
    return;
  }
  b7(t, e, r, n);
}, v7 = (t, e, r) => {
  const n = t === "" ? e : z_(e, t);
  n.classGroupId = r;
}, y7 = (t, e, r, n) => {
  if (_7(t)) {
    Zd(t(n), e, r, n);
    return;
  }
  e.validators === null && (e.validators = []), e.validators.push(c7(r, t));
}, b7 = (t, e, r, n) => {
  const s = Object.entries(t), o = s.length;
  for (let i = 0; i < o; i++) {
    const [a, l] = s[i];
    Zd(l, z_(e, a), r, n);
  }
}, z_ = (t, e) => {
  let r = t;
  const n = e.split(ul), s = n.length;
  for (let o = 0; o < s; o++) {
    const i = n[o];
    let a = r.nextPart.get(i);
    a || (a = j_(), r.nextPart.set(i, a)), r = a;
  }
  return r;
}, _7 = (t) => "isThemeGetter" in t && t.isThemeGetter === !0, w7 = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  const s = (o, i) => {
    r[o] = i, e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let i = r[o];
      if (i !== void 0)
        return i;
      if ((i = n[o]) !== void 0)
        return s(o, i), i;
    },
    set(o, i) {
      o in r ? r[o] = i : s(o, i);
    }
  };
}, Nc = "!", dm = ":", S7 = [], fm = (t, e, r, n, s) => ({
  modifiers: t,
  hasImportantModifier: e,
  baseClassName: r,
  maybePostfixModifierPosition: n,
  isExternal: s
}), x7 = (t) => {
  const {
    prefix: e,
    experimentalParseClassName: r
  } = t;
  let n = (s) => {
    const o = [];
    let i = 0, a = 0, l = 0, u;
    const c = s.length;
    for (let p = 0; p < c; p++) {
      const g = s[p];
      if (i === 0 && a === 0) {
        if (g === dm) {
          o.push(s.slice(l, p)), l = p + 1;
          continue;
        }
        if (g === "/") {
          u = p;
          continue;
        }
      }
      g === "[" ? i++ : g === "]" ? i-- : g === "(" ? a++ : g === ")" && a--;
    }
    const f = o.length === 0 ? s : s.slice(l);
    let h = f, _ = !1;
    f.endsWith(Nc) ? (h = f.slice(0, -1), _ = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(Nc) && (h = f.slice(1), _ = !0)
    );
    const b = u && u > l ? u - l : void 0;
    return fm(o, _, h, b);
  };
  if (e) {
    const s = e + dm, o = n;
    n = (i) => i.startsWith(s) ? o(i.slice(s.length)) : fm(S7, !1, i, void 0, !0);
  }
  if (r) {
    const s = n;
    n = (o) => r({
      className: o,
      parseClassName: s
    });
  }
  return n;
}, P7 = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.orderSensitiveModifiers.forEach((r, n) => {
    e.set(r, 1e6 + n);
  }), (r) => {
    const n = [];
    let s = [];
    for (let o = 0; o < r.length; o++) {
      const i = r[o], a = i[0] === "[", l = e.has(i);
      a || l ? (s.length > 0 && (s.sort(), n.push(...s), s = []), n.push(i)) : s.push(i);
    }
    return s.length > 0 && (s.sort(), n.push(...s)), n;
  };
}, O7 = (t) => ({
  cache: w7(t.cacheSize),
  parseClassName: x7(t),
  sortModifiers: P7(t),
  ...f7(t)
}), C7 = /\s+/, k7 = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: s,
    sortModifiers: o
  } = e, i = [], a = t.trim().split(C7);
  let l = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const c = a[u], {
      isExternal: f,
      modifiers: h,
      hasImportantModifier: _,
      baseClassName: b,
      maybePostfixModifierPosition: p
    } = r(c);
    if (f) {
      l = c + (l.length > 0 ? " " + l : l);
      continue;
    }
    let g = !!p, y = n(g ? b.substring(0, p) : b);
    if (!y) {
      if (!g) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      if (y = n(b), !y) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      g = !1;
    }
    const S = h.length === 0 ? "" : h.length === 1 ? h[0] : o(h).join(":"), x = _ ? S + Nc : S, P = x + y;
    if (i.indexOf(P) > -1)
      continue;
    i.push(P);
    const w = s(y, g);
    for (let C = 0; C < w.length; ++C) {
      const k = w[C];
      i.push(x + k);
    }
    l = c + (l.length > 0 ? " " + l : l);
  }
  return l;
}, $7 = (...t) => {
  let e = 0, r, n, s = "";
  for (; e < t.length; )
    (r = t[e++]) && (n = q_(r)) && (s && (s += " "), s += n);
  return s;
}, q_ = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = q_(t[n])) && (r && (r += " "), r += e);
  return r;
}, Fc = (t, ...e) => {
  let r, n, s, o;
  const i = (l) => {
    const u = e.reduce((c, f) => f(c), t());
    return r = O7(u), n = r.cache.get, s = r.cache.set, o = a, a(l);
  }, a = (l) => {
    const u = n(l);
    if (u)
      return u;
    const c = k7(l, r);
    return s(l, c), c;
  };
  return o = i, (...l) => o($7(...l));
}, A7 = [], bt = (t) => {
  const e = (r) => r[t] || A7;
  return e.isThemeGetter = !0, e;
}, U_ = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, K_ = /^\((?:(\w[\w-]*):)?(.+)\)$/i, E7 = /^\d+\/\d+$/, T7 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, D7 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, M7 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, I7 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, N7 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, eo = (t) => E7.test(t), Ue = (t) => !!t && !Number.isNaN(Number(t)), Bn = (t) => !!t && Number.isInteger(Number(t)), Hu = (t) => t.endsWith("%") && Ue(t.slice(0, -1)), mn = (t) => T7.test(t), F7 = () => !0, R7 = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  D7.test(t) && !M7.test(t)
), W_ = () => !1, V7 = (t) => I7.test(t), L7 = (t) => N7.test(t), j7 = (t) => !$e(t) && !Ae(t), B7 = (t) => No(t, Y_, W_), $e = (t) => U_.test(t), ws = (t) => No(t, X_, R7), Gu = (t) => No(t, W7, Ue), hm = (t) => No(t, H_, W_), z7 = (t) => No(t, G_, L7), Ta = (t) => No(t, J_, V7), Ae = (t) => K_.test(t), ei = (t) => Fo(t, X_), q7 = (t) => Fo(t, H7), gm = (t) => Fo(t, H_), U7 = (t) => Fo(t, Y_), K7 = (t) => Fo(t, G_), Da = (t) => Fo(t, J_, !0), No = (t, e, r) => {
  const n = U_.exec(t);
  return n ? n[1] ? e(n[1]) : r(n[2]) : !1;
}, Fo = (t, e, r = !1) => {
  const n = K_.exec(t);
  return n ? n[1] ? e(n[1]) : r : !1;
}, H_ = (t) => t === "position" || t === "percentage", G_ = (t) => t === "image" || t === "url", Y_ = (t) => t === "length" || t === "size" || t === "bg-size", X_ = (t) => t === "length", W7 = (t) => t === "number", H7 = (t) => t === "family-name", J_ = (t) => t === "shadow", Rc = () => {
  const t = bt("color"), e = bt("font"), r = bt("text"), n = bt("font-weight"), s = bt("tracking"), o = bt("leading"), i = bt("breakpoint"), a = bt("container"), l = bt("spacing"), u = bt("radius"), c = bt("shadow"), f = bt("inset-shadow"), h = bt("text-shadow"), _ = bt("drop-shadow"), b = bt("blur"), p = bt("perspective"), g = bt("aspect"), y = bt("ease"), S = bt("animate"), x = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], P = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], w = () => [...P(), Ae, $e], C = () => ["auto", "hidden", "clip", "visible", "scroll"], k = () => ["auto", "contain", "none"], $ = () => [Ae, $e, l], T = () => [eo, "full", "auto", ...$()], E = () => [Bn, "none", "subgrid", Ae, $e], I = () => ["auto", {
    span: ["full", Bn, Ae, $e]
  }, Bn, Ae, $e], F = () => [Bn, "auto", Ae, $e], U = () => ["auto", "min", "max", "fr", Ae, $e], B = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], R = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], Z = () => ["auto", ...$()], Y = () => [eo, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...$()], X = () => [t, Ae, $e], ae = () => [...P(), gm, hm, {
    position: [Ae, $e]
  }], J = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], j = () => ["auto", "cover", "contain", U7, B7, {
    size: [Ae, $e]
  }], ee = () => [Hu, ei, ws], L = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    u,
    Ae,
    $e
  ], N = () => ["", Ue, ei, ws], V = () => ["solid", "dashed", "dotted", "double"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], fe = () => [Ue, Hu, gm, hm], se = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    b,
    Ae,
    $e
  ], we = () => ["none", Ue, Ae, $e], le = () => ["none", Ue, Ae, $e], re = () => [Ue, Ae, $e], oe = () => [eo, "full", ...$()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [mn],
      breakpoint: [mn],
      color: [F7],
      container: [mn],
      "drop-shadow": [mn],
      ease: ["in", "out", "in-out"],
      font: [j7],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [mn],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [mn],
      shadow: [mn],
      spacing: ["px", Ue],
      text: [mn],
      "text-shadow": [mn],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", eo, $e, Ae, g]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ue, $e, Ae, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": x()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": x()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: w()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: C()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": C()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": C()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: k()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": k()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": k()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: T()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": T()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": T()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: T()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: T()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: T()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: T()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: T()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: T()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Bn, "auto", Ae, $e]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [eo, "full", "auto", a, ...$()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Ue, eo, "auto", "initial", "none", $e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Ue, Ae, $e]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Ue, Ae, $e]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Bn, "first", "last", "none", Ae, $e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": E()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: I()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": E()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: I()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": U()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": U()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: $()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": $()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": $()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...B(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...R(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...R()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...B()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...R(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...R(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": B()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...R(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...R()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: $()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: $()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: $()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: $()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: $()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: $()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: $()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: $()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: $()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: Z()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: Z()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: Z()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: Z()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: Z()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: Z()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: Z()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: Z()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: Z()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": $()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": $()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Y()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...Y()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Y()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [i]
          },
          ...Y()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Y()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Y()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Y()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", r, ei, ws]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [n, Ae, Gu]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Hu, $e]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [q7, $e, e]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [s, Ae, $e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Ue, "none", Ae, Gu]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...$()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ae, $e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", Ae, $e]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: X()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: X()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...V(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Ue, "from-font", "auto", Ae, ws]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: X()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Ue, "auto", Ae, $e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: $()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ae, $e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ae, $e]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: ae()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: J()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: j()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Bn, Ae, $e],
          radial: ["", Ae, $e],
          conic: [Bn, Ae, $e]
        }, K7, z7]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: X()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: ee()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: ee()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: ee()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: X()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: L()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": L()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": L()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": L()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": L()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": L()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": L()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": L()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": L()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": L()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": L()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": L()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": L()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": L()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": L()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: N()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": N()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": N()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": N()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": N()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": N()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": N()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": N()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": N()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": N()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": N()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...V(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...V(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: X()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": X()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": X()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": X()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": X()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": X()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": X()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": X()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": X()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: X()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...V(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ue, Ae, $e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Ue, ei, ws]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: X()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          Da,
          Ta
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: X()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, Da, Ta]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": X()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: N()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: X()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Ue, ws]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": X()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": N()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": X()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", h, Da, Ta]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": X()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Ue, Ae, $e]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...G(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": G()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Ue]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": fe()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": fe()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": X()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": X()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": fe()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": fe()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": X()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": X()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": fe()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": fe()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": X()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": X()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": fe()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": fe()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": X()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": X()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": fe()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": fe()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": X()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": X()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": fe()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": fe()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": X()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": X()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": fe()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": fe()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": X()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": X()
      }],
      "mask-image-radial": [{
        "mask-radial": [Ae, $e]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": fe()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": fe()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": X()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": X()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": P()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Ue]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": fe()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": fe()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": X()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": X()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: ae()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: J()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: j()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", Ae, $e]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Ae,
          $e
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: se()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ue, Ae, $e]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Ue, Ae, $e]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          _,
          Da,
          Ta
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": X()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Ue, Ae, $e]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Ue, Ae, $e]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Ue, Ae, $e]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ue, Ae, $e]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Ae,
          $e
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": se()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Ue, Ae, $e]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": $()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": $()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": $()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Ae, $e]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Ue, "initial", Ae, $e]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", y, Ae, $e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Ue, Ae, $e]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, Ae, $e]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [p, Ae, $e]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": w()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: we()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": we()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": we()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": we()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: le()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": le()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": le()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": le()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: re()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": re()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": re()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [Ae, $e, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: w()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: oe()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": oe()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": oe()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": oe()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: X()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: X()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ae, $e]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": $()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": $()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": $()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": $()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": $()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": $()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": $()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": $()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": $()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": $()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": $()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": $()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": $()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": $()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": $()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": $()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": $()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": $()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ae, $e]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...X()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ue, ei, ws, Gu]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...X()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, G7 = (t, {
  cacheSize: e,
  prefix: r,
  experimentalParseClassName: n,
  extend: s = {},
  override: o = {}
}) => (ai(t, "cacheSize", e), ai(t, "prefix", r), ai(t, "experimentalParseClassName", n), Ma(t.theme, o.theme), Ma(t.classGroups, o.classGroups), Ma(t.conflictingClassGroups, o.conflictingClassGroups), Ma(t.conflictingClassGroupModifiers, o.conflictingClassGroupModifiers), ai(t, "orderSensitiveModifiers", o.orderSensitiveModifiers), Ia(t.theme, s.theme), Ia(t.classGroups, s.classGroups), Ia(t.conflictingClassGroups, s.conflictingClassGroups), Ia(t.conflictingClassGroupModifiers, s.conflictingClassGroupModifiers), Z_(t, s, "orderSensitiveModifiers"), t), ai = (t, e, r) => {
  r !== void 0 && (t[e] = r);
}, Ma = (t, e) => {
  if (e)
    for (const r in e)
      ai(t, r, e[r]);
}, Ia = (t, e) => {
  if (e)
    for (const r in e)
      Z_(t, e, r);
}, Z_ = (t, e, r) => {
  const n = e[r];
  n !== void 0 && (t[r] = t[r] ? t[r].concat(n) : n);
}, Y7 = (t, ...e) => typeof t == "function" ? Fc(Rc, t, ...e) : Fc(() => G7(Rc(), t), ...e), Qd = /* @__PURE__ */ Fc(Rc);
var X7 = (t) => Gt(t) ? Qd : Y7({
  ...t,
  extend: {
    theme: t.theme,
    classGroups: t.classGroups,
    conflictingClassGroupModifiers: t.conflictingClassGroupModifiers,
    conflictingClassGroups: t.conflictingClassGroups,
    ...t.extend
  }
}), J7 = (t, e) => {
  const r = ll(t);
  return !r || !(e?.twMerge ?? !0) ? r : ((!yn.cachedTwMerge || yn.didTwMergeConfigChange) && (yn.didTwMergeConfigChange = !1, yn.cachedTwMerge = X7(yn.cachedTwMergeConfig)), yn.cachedTwMerge(r) || void 0);
}, Z7 = (...t) => (e) => J7(t, e), { tv: Ri } = l7(Z7);
function Se(...t) {
  return Qd(io(t));
}
const Q7 = Ri({
  base: "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*]:focus-visible:relative [&>*]:focus-visible:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-e-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  variants: {
    orientation: {
      horizontal: "[&>*:not(:first-child)]:rounded-s-none [&>*:not(:first-child)]:border-s-0 [&>*:not(:last-child)]:rounded-e-none",
      vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
    }
  },
  defaultVariants: { orientation: "horizontal" }
});
var e2 = /* @__PURE__ */ ne("<div><!></div>");
function Q_(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "orientation", 7, "horizontal"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "orientation"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get orientation() {
      return o();
    },
    set orientation(c = "horizontal") {
      o(c), m();
    }
  }, l = e2();
  ve(
    l,
    (c) => ({
      role: "group",
      "data-slot": "button-group",
      "data-orientation": o(),
      class: c,
      ...i
    }),
    [
      () => Se(Q7({ orientation: o() }), n())
    ]
  );
  var u = ge(l);
  return te(u, () => s() ?? he), de(l), et(l, (c) => r(c), () => r()), A(t, l), H(a);
}
K(Q_, { ref: {}, class: {}, children: {}, orientation: {} }, [], [], { mode: "open" });
var t2 = /* @__PURE__ */ ne("<div><!></div>");
function r2(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "child", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "child"
  ]);
  const i = /* @__PURE__ */ O(() => ({
    ...o,
    class: Se("bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4", n())
  }));
  var a = {
    get ref() {
      return r();
    },
    set ref(h = null) {
      r(h), m();
    },
    get class() {
      return n();
    },
    set class(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    }
  }, l = M(), u = D(l);
  {
    var c = (h) => {
      var _ = M(), b = D(_);
      te(b, s, () => ({ props: d(i) })), A(h, _);
    }, f = (h) => {
      var _ = t2();
      ve(_, () => ({ ...d(i) }));
      var b = ge(_);
      te(b, () => d(i).children ?? he), de(_), et(_, (p) => r(p), () => r()), A(h, _);
    };
    ue(u, (h) => {
      s() ? h(c) : h(f, !1);
    });
  }
  return A(t, l), H(a);
}
K(r2, { ref: {}, class: {}, child: {} }, [], [], { mode: "open" });
function n2(t) {
  return typeof t == "function";
}
function Vi(t) {
  return t !== null && typeof t == "object";
}
const s2 = ["string", "number", "bigint", "boolean"];
function Vc(t) {
  return t == null || s2.includes(typeof t) ? !0 : Array.isArray(t) ? t.every((e) => Vc(e)) : typeof t == "object" ? Object.getPrototypeOf(t) === Object.prototype : !1;
}
const _o = /* @__PURE__ */ Symbol("box"), ou = /* @__PURE__ */ Symbol("is-writable");
function z(t, e) {
  const r = /* @__PURE__ */ O(t);
  return e ? {
    [_o]: !0,
    [ou]: !0,
    get current() {
      return d(r);
    },
    set current(n) {
      e(n);
    }
  } : {
    [_o]: !0,
    get current() {
      return t();
    }
  };
}
function Li(t) {
  return Vi(t) && _o in t;
}
function ef(t) {
  return Li(t) && ou in t;
}
function e0(t) {
  return Li(t) ? t : n2(t) ? z(t) : Jr(t);
}
function o2(t) {
  return Object.entries(t).reduce(
    (e, [r, n]) => Li(n) ? (ef(n) ? Object.defineProperty(e, r, {
      get() {
        return n.current;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(s) {
        n.current = s;
      }
    }) : Object.defineProperty(e, r, {
      get() {
        return n.current;
      }
    }), e) : Object.assign(e, { [r]: n }),
    {}
  );
}
function i2(t) {
  return ef(t) ? {
    [_o]: !0,
    get current() {
      return t.current;
    }
  } : t;
}
function Jr(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    [_o]: !0,
    [ou]: !0,
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
function Gs(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    [_o]: !0,
    [ou]: !0,
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
Gs.from = e0;
Gs.with = z;
Gs.flatten = o2;
Gs.readonly = i2;
Gs.isBox = Li;
Gs.isWritableBox = ef;
function t0(...t) {
  return function(e) {
    for (const r of t)
      if (r) {
        if (e.defaultPrevented)
          return;
        typeof r == "function" ? r.call(this, e) : r.current?.call(this, e);
      }
  };
}
var pm = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, a2 = /\n/g, l2 = /^\s*/, u2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, c2 = /^:\s*/, d2 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, f2 = /^[;\s]*/, h2 = /^\s+|\s+$/g, g2 = `
`, mm = "/", vm = "*", xs = "", p2 = "comment", m2 = "declaration";
function v2(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var r = 1, n = 1;
  function s(b) {
    var p = b.match(a2);
    p && (r += p.length);
    var g = b.lastIndexOf(g2);
    n = ~g ? b.length - g : n + b.length;
  }
  function o() {
    var b = { line: r, column: n };
    return function(p) {
      return p.position = new i(b), u(), p;
    };
  }
  function i(b) {
    this.start = b, this.end = { line: r, column: n }, this.source = e.source;
  }
  i.prototype.content = t;
  function a(b) {
    var p = new Error(
      e.source + ":" + r + ":" + n + ": " + b
    );
    if (p.reason = b, p.filename = e.source, p.line = r, p.column = n, p.source = t, !e.silent) throw p;
  }
  function l(b) {
    var p = b.exec(t);
    if (p) {
      var g = p[0];
      return s(g), t = t.slice(g.length), p;
    }
  }
  function u() {
    l(l2);
  }
  function c(b) {
    var p;
    for (b = b || []; p = f(); )
      p !== !1 && b.push(p);
    return b;
  }
  function f() {
    var b = o();
    if (!(mm != t.charAt(0) || vm != t.charAt(1))) {
      for (var p = 2; xs != t.charAt(p) && (vm != t.charAt(p) || mm != t.charAt(p + 1)); )
        ++p;
      if (p += 2, xs === t.charAt(p - 1))
        return a("End of comment missing");
      var g = t.slice(2, p - 2);
      return n += 2, s(g), t = t.slice(p), n += 2, b({
        type: p2,
        comment: g
      });
    }
  }
  function h() {
    var b = o(), p = l(u2);
    if (p) {
      if (f(), !l(c2)) return a("property missing ':'");
      var g = l(d2), y = b({
        type: m2,
        property: ym(p[0].replace(pm, xs)),
        value: g ? ym(g[0].replace(pm, xs)) : xs
      });
      return l(f2), y;
    }
  }
  function _() {
    var b = [];
    c(b);
    for (var p; p = h(); )
      p !== !1 && (b.push(p), c(b));
    return b;
  }
  return u(), _();
}
function ym(t) {
  return t ? t.replace(h2, xs) : xs;
}
function y2(t, e) {
  let r = null;
  if (!t || typeof t != "string")
    return r;
  const n = v2(t), s = typeof e == "function";
  return n.forEach((o) => {
    if (o.type !== "declaration")
      return;
    const { property: i, value: a } = o;
    s ? e(i, a, o) : a && (r = r || {}, r[i] = a);
  }), r;
}
const b2 = /\d/, _2 = ["-", "_", "/", "."];
function w2(t = "") {
  if (!b2.test(t))
    return t !== t.toLowerCase();
}
function S2(t) {
  const e = [];
  let r = "", n, s;
  for (const o of t) {
    const i = _2.includes(o);
    if (i === !0) {
      e.push(r), r = "", n = void 0;
      continue;
    }
    const a = w2(o);
    if (s === !1) {
      if (n === !1 && a === !0) {
        e.push(r), r = o, n = a;
        continue;
      }
      if (n === !0 && a === !1 && r.length > 1) {
        const l = r.at(-1);
        e.push(r.slice(0, Math.max(0, r.length - 1))), r = l + o, n = a;
        continue;
      }
    }
    r += o, n = a, s = i;
  }
  return e.push(r), e;
}
function r0(t) {
  return t ? S2(t).map((e) => P2(e)).join("") : "";
}
function x2(t) {
  return O2(r0(t || ""));
}
function P2(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
function O2(t) {
  return t ? t[0].toLowerCase() + t.slice(1) : "";
}
function li(t) {
  if (!t)
    return {};
  const e = {};
  function r(n, s) {
    if (n.startsWith("-moz-") || n.startsWith("-webkit-") || n.startsWith("-ms-") || n.startsWith("-o-")) {
      e[r0(n)] = s;
      return;
    }
    if (n.startsWith("--")) {
      e[n] = s;
      return;
    }
    e[x2(n)] = s;
  }
  return y2(t, r), e;
}
function Es(...t) {
  return (...e) => {
    for (const r of t)
      typeof r == "function" && r(...e);
  };
}
function C2(t, e) {
  const r = RegExp(t, "g");
  return (n) => {
    if (typeof n != "string")
      throw new TypeError(`expected an argument of type string, but got ${typeof n}`);
    return n.match(r) ? n.replace(r, e) : n;
  };
}
const k2 = C2(/[A-Z]/, (t) => `-${t.toLowerCase()}`);
function $2(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw new TypeError(`expected an argument of type object, but got ${typeof t}`);
  return Object.keys(t).map((e) => `${k2(e)}: ${t[e]};`).join(`
`);
}
function iu(t = {}) {
  return $2(t).replace(`
`, " ");
}
const A2 = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
], E2 = new Set(A2);
function T2(t) {
  return E2.has(t);
}
function Ce(...t) {
  const e = { ...t[0] };
  for (let r = 1; r < t.length; r++) {
    const n = t[r];
    if (n) {
      for (const s of Object.keys(n)) {
        const o = e[s], i = n[s], a = typeof o == "function", l = typeof i == "function";
        if (a && T2(s)) {
          const u = o, c = i;
          e[s] = t0(u, c);
        } else if (a && l)
          e[s] = Es(o, i);
        else if (s === "class") {
          const u = Vc(o), c = Vc(i);
          u && c ? e[s] = io(o, i) : u ? e[s] = io(o) : c && (e[s] = io(i));
        } else if (s === "style") {
          const u = typeof o == "object", c = typeof i == "object", f = typeof o == "string", h = typeof i == "string";
          if (u && c)
            e[s] = { ...o, ...i };
          else if (u && h) {
            const _ = li(i);
            e[s] = { ...o, ..._ };
          } else if (f && c) {
            const _ = li(o);
            e[s] = { ..._, ...i };
          } else if (f && h) {
            const _ = li(o), b = li(i);
            e[s] = { ..._, ...b };
          } else u ? e[s] = o : c ? e[s] = i : f ? e[s] = o : h && (e[s] = i);
        } else
          e[s] = i !== void 0 ? i : o;
      }
      for (const s of Object.getOwnPropertySymbols(n)) {
        const o = e[s], i = n[s];
        e[s] = i !== void 0 ? i : o;
      }
    }
  }
  return typeof e.style == "object" && (e.style = iu(e.style).replaceAll(`
`, " ")), e.hidden === !1 && (e.hidden = void 0, delete e.hidden), e.disabled === !1 && (e.disabled = void 0, delete e.disabled), e;
}
const n0 = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
}, s0 = iu(n0), o0 = typeof window < "u" ? window : void 0;
function D2(t) {
  let e = t.activeElement;
  for (; e?.shadowRoot; ) {
    const r = e.shadowRoot.activeElement;
    if (r === e)
      break;
    e = r;
  }
  return e;
}
class M2 {
  #e;
  #t;
  constructor(e = {}) {
    const { window: r = o0, document: n = r?.document } = e;
    r !== void 0 && (this.#e = n, this.#t = cd((s) => {
      const o = Ye(r, "focusin", s), i = Ye(r, "focusout", s);
      return () => {
        o(), i();
      };
    }));
  }
  get current() {
    return this.#t?.(), this.#e ? D2(this.#e) : null;
  }
}
new M2();
function I2(t) {
  return typeof t == "function";
}
class ht {
  #e;
  #t;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(e) {
    this.#e = e, this.#t = Symbol(e);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#t;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return nP(this.#t);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const e = Ms(this.#t);
    if (e === void 0)
      throw new Error(`Context "${this.#e}" not found`);
    return e;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(e) {
    const r = Ms(this.#t);
    return r === void 0 ? e : r;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(e) {
    return Oo(this.#t, e);
  }
}
function N2(t, e) {
  switch (t) {
    case "post":
      Xe(e);
      break;
    case "pre":
      ko(e);
      break;
  }
}
function i0(t, e, r, n = {}) {
  const { lazy: s = !1 } = n;
  let o = !s, i = Array.isArray(t) ? [] : void 0;
  N2(e, () => {
    const a = Array.isArray(t) ? t.map((u) => u()) : t();
    if (!o) {
      o = !0, i = a;
      return;
    }
    const l = ot(() => r(a, i));
    return i = a, l;
  });
}
function Fe(t, e, r) {
  i0(t, "post", e, r);
}
function F2(t, e, r) {
  i0(t, "pre", e, r);
}
Fe.pre = F2;
function bm(t) {
  return I2(t) ? t() : t;
}
class R2 {
  // no need to use `$state` here since we are using createSubscriber
  #e = { width: 0, height: 0 };
  #t = !1;
  #r;
  #n;
  #s;
  // we use a derived here to extract the width so that if the width doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #o = /* @__PURE__ */ O(() => (d(this.#a)?.(), this.getSize().width));
  // we use a derived here to extract the height so that if the height doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #i = /* @__PURE__ */ O(() => (d(this.#a)?.(), this.getSize().height));
  // we need to use a derived here because the class will be created before the node is bound to the ref
  #a = /* @__PURE__ */ O(() => {
    const e = bm(this.#n);
    if (e)
      return cd((r) => {
        if (!this.#s) return;
        const n = new this.#s.ResizeObserver((s) => {
          this.#t = !0;
          for (const o of s) {
            const i = this.#r.box === "content-box" ? o.contentBoxSize : o.borderBoxSize, a = Array.isArray(i) ? i : [i];
            this.#e.width = a.reduce((l, u) => Math.max(l, u.inlineSize), 0), this.#e.height = a.reduce((l, u) => Math.max(l, u.blockSize), 0);
          }
          r();
        });
        return n.observe(e), () => {
          this.#t = !1, n.disconnect();
        };
      });
  });
  constructor(e, r = { box: "border-box" }) {
    this.#s = r.window ?? o0, this.#r = r, this.#n = e, this.#e = { width: 0, height: 0 };
  }
  calculateSize() {
    const e = bm(this.#n);
    if (!e || !this.#s)
      return;
    const r = e.offsetWidth, n = e.offsetHeight;
    if (this.#r.box === "border-box")
      return { width: r, height: n };
    const s = this.#s.getComputedStyle(e), o = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight), i = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom), a = parseFloat(s.borderLeftWidth) + parseFloat(s.borderRightWidth), l = parseFloat(s.borderTopWidth) + parseFloat(s.borderBottomWidth), u = r - o - a, c = n - i - l;
    return { width: u, height: c };
  }
  getSize() {
    return this.#t ? this.#e : this.calculateSize() ?? this.#e;
  }
  get current() {
    return d(this.#a)?.(), this.getSize();
  }
  get width() {
    return d(this.#o);
  }
  get height() {
    return d(this.#i);
  }
}
class V2 {
  #e = () => {
  };
  #t = /* @__PURE__ */ O(() => this.#e());
  constructor(e, r) {
    let n;
    r !== void 0 && (n = r), this.#e = () => {
      try {
        return n;
      } finally {
        n = e();
      }
    };
  }
  get current() {
    return d(this.#t);
  }
}
function Ys(t) {
  Xe(() => () => {
    t();
  });
}
function tf(t) {
  Xe(() => ot(() => t()));
}
function rf(t, e) {
  return setTimeout(e, t);
}
function Jt(t) {
  Vl().then(t);
}
const L2 = 1, j2 = 9, B2 = 11;
function Lc(t) {
  return Vi(t) && t.nodeType === L2 && typeof t.nodeName == "string";
}
function a0(t) {
  return Vi(t) && t.nodeType === j2;
}
function z2(t) {
  return Vi(t) && t.constructor?.name === "VisualViewport";
}
function q2(t) {
  return Vi(t) && t.nodeType !== void 0;
}
function l0(t) {
  return q2(t) && t.nodeType === B2 && "host" in t;
}
function U2(t, e) {
  if (!t || !e || !Lc(t) || !Lc(e))
    return !1;
  const r = e.getRootNode?.();
  if (t === e || t.contains(e))
    return !0;
  if (r && l0(r)) {
    let n = e;
    for (; n; ) {
      if (t === n)
        return !0;
      n = n.parentNode || n.host;
    }
  }
  return !1;
}
function nf(t) {
  return a0(t) ? t : z2(t) ? t.document : t?.ownerDocument ?? document;
}
function u0(t) {
  return l0(t) ? u0(t.host) : a0(t) ? t.defaultView ?? window : Lc(t) ? t.ownerDocument?.defaultView ?? window : window;
}
function K2(t) {
  let e = t.activeElement;
  for (; e?.shadowRoot; ) {
    const r = e.shadowRoot.activeElement;
    if (r === e)
      break;
    e = r;
  }
  return e;
}
class Fn {
  element;
  #e = /* @__PURE__ */ O(() => this.element.current ? this.element.current.getRootNode() ?? document : document);
  get root() {
    return d(this.#e);
  }
  set root(e) {
    q(this.#e, e);
  }
  constructor(e) {
    typeof e == "function" ? this.element = z(e) : this.element = e;
  }
  getDocument = () => nf(this.root);
  getWindow = () => this.getDocument().defaultView ?? window;
  getActiveElement = () => K2(this.root);
  isActiveElement = (e) => e === this.getActiveElement();
  getElementById(e) {
    return this.root.getElementById(e);
  }
  querySelector = (e) => this.root ? this.root.querySelector(e) : null;
  querySelectorAll = (e) => this.root ? this.root.querySelectorAll(e) : [];
  setTimeout = (e, r) => this.getWindow().setTimeout(e, r);
  clearTimeout = (e) => this.getWindow().clearTimeout(e);
}
function Te(t, e) {
  return {
    [ey()]: (r) => Li(t) ? (t.current = r, ot(() => e?.(r)), () => {
      "isConnected" in r && r.isConnected || (t.current = null, e?.(null));
    }) : (t(r), ot(() => e?.(r)), () => {
      "isConnected" in r && r.isConnected || (t(null), e?.(null));
    })
  };
}
function at(t) {
  return t ? "true" : "false";
}
function sf(t) {
  return t ? "true" : void 0;
}
function Re(t) {
  return t ? "" : void 0;
}
function _i(t) {
  return t ? !0 : void 0;
}
function ji(t) {
  return t ? "open" : "closed";
}
function W2(t) {
  return t ? "checked" : "unchecked";
}
function au(t, e) {
  return e ? "mixed" : t ? "true" : "false";
}
class H2 {
  #e;
  #t;
  attrs;
  constructor(e) {
    this.#e = e.getVariant ? e.getVariant() : null, this.#t = this.#e ? `data-${this.#e}-` : `data-${e.component}-`, this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(e.parts.map((r) => [r, this.getAttr(r)]));
  }
  getAttr(e, r) {
    return r ? `data-${r}-${e}` : `${this.#t}${e}`;
  }
  selector(e, r) {
    return `[${this.getAttr(e, r)}]`;
  }
}
function nr(t) {
  const e = new H2(t);
  return {
    ...e.attrs,
    selector: e.selector,
    getAttr: e.getAttr
  };
}
const dr = "ArrowDown", ds = "ArrowLeft", fs = "ArrowRight", Qt = "ArrowUp", Ro = "End", Br = "Enter", G2 = "Escape", Vo = "Home", c0 = "PageDown", d0 = "PageUp", xr = " ", _m = "Tab", Y2 = "p", X2 = "n", J2 = "j", Z2 = "k", Q2 = "h", eT = "l";
function tT(t) {
  return window.getComputedStyle(t).getPropertyValue("direction");
}
function rT(t = "ltr", e = "horizontal") {
  return {
    horizontal: t === "rtl" ? ds : fs,
    vertical: dr
  }[e];
}
function nT(t = "ltr", e = "horizontal") {
  return {
    horizontal: t === "rtl" ? fs : ds,
    vertical: Qt
  }[e];
}
function sT(t = "ltr", e = "horizontal") {
  return ["ltr", "rtl"].includes(t) || (t = "ltr"), ["horizontal", "vertical"].includes(e) || (e = "horizontal"), {
    nextKey: rT(t, e),
    prevKey: nT(t, e)
  };
}
const Bi = typeof document < "u", jc = oT();
function oT() {
  return Bi && window?.navigator?.userAgent && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function Cn(t) {
  return t instanceof HTMLElement;
}
function di(t) {
  return t instanceof Element;
}
function of(t) {
  return t instanceof Element || t instanceof SVGElement;
}
function cl(t) {
  return t.pointerType === "touch";
}
function iT(t) {
  return t !== null;
}
class f0 {
  #e;
  #t = Gs(null);
  constructor(e) {
    this.#e = e;
  }
  getCandidateNodes() {
    return this.#e.rootNode.current ? this.#e.candidateSelector ? Array.from(this.#e.rootNode.current.querySelectorAll(this.#e.candidateSelector)) : this.#e.candidateAttr ? Array.from(this.#e.rootNode.current.querySelectorAll(`[${this.#e.candidateAttr}]:not([data-disabled])`)) : [] : [];
  }
  focusFirstCandidate() {
    const e = this.getCandidateNodes();
    e.length && e[0]?.focus();
  }
  handleKeydown(e, r, n = !1) {
    const s = this.#e.rootNode.current;
    if (!s || !e)
      return;
    const o = this.getCandidateNodes();
    if (!o.length)
      return;
    const i = o.indexOf(e), a = tT(s), { nextKey: l, prevKey: u } = sT(a, this.#e.orientation.current), c = this.#e.loop.current, f = {
      [l]: i + 1,
      [u]: i - 1,
      [Vo]: 0,
      [Ro]: o.length - 1
    };
    if (n) {
      const b = l === dr ? fs : dr, p = u === Qt ? ds : Qt;
      f[b] = i + 1, f[p] = i - 1;
    }
    let h = f[r.key];
    if (h === void 0)
      return;
    r.preventDefault(), h < 0 && c ? h = o.length - 1 : h === o.length && c && (h = 0);
    const _ = o[h];
    if (_)
      return _.focus(), this.#t.current = _.id, this.#e.onCandidateFocus?.(_), _;
  }
  getTabIndex(e) {
    const r = this.getCandidateNodes(), n = this.#t.current !== null;
    return e && !n && r[0] === e ? (this.#t.current = e.id, 0) : e?.id === this.#t.current ? 0 : -1;
  }
  setCurrentTabStopId(e) {
    this.#t.current = e;
  }
  focusCurrentTabStop() {
    const e = this.#t.current;
    if (!e)
      return;
    const r = this.#e.rootNode.current?.querySelector(`#${e}`);
    !r || !Cn(r) || r.focus();
  }
}
class aT {
  #e;
  #t = null;
  constructor(e) {
    this.#e = e, Ys(() => this.#r());
  }
  #r() {
    this.#t && (window.cancelAnimationFrame(this.#t), this.#t = null);
  }
  run(e) {
    this.#r();
    const r = this.#e.ref.current;
    if (r) {
      if (typeof r.getAnimations != "function") {
        this.#n(e);
        return;
      }
      this.#t = window.requestAnimationFrame(() => {
        const n = r.getAnimations();
        if (n.length === 0) {
          this.#n(e);
          return;
        }
        Promise.allSettled(n.map((s) => s.finished)).then(() => {
          this.#n(e);
        });
      });
    }
  }
  #n(e) {
    const r = () => {
      e();
    };
    this.#e.afterTick ? Jt(r) : r();
  }
}
class wi {
  #e;
  #t;
  #r;
  #n = /* @__PURE__ */ xe(!1);
  constructor(e) {
    this.#e = e, q(this.#n, e.open.current, !0), this.#t = e.enabled ?? !0, this.#r = new aT({ ref: this.#e.ref, afterTick: this.#e.open }), Fe(() => this.#e.open.current, (r) => {
      r && q(this.#n, !0), this.#t && this.#r.run(() => {
        r === this.#e.open.current && (this.#e.open.current || q(this.#n, !1), this.#e.onComplete?.());
      });
    });
  }
  get shouldRender() {
    return d(this.#n);
  }
}
function _e() {
}
function me(t, e) {
  return `bits-${t}`;
}
const lT = nr({
  component: "dialog",
  parts: [
    "content",
    "trigger",
    "overlay",
    "title",
    "description",
    "close",
    "cancel",
    "action"
  ]
}), Qn = new ht("Dialog.Root | AlertDialog.Root");
class af {
  static create(e) {
    const r = Qn.getOr(null);
    return Qn.set(new af(e, r));
  }
  opts;
  #e = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#e);
  }
  set triggerNode(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#t);
  }
  set contentNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get overlayNode() {
    return d(this.#r);
  }
  set overlayNode(e) {
    q(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ xe(null);
  get descriptionNode() {
    return d(this.#n);
  }
  set descriptionNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(void 0);
  get contentId() {
    return d(this.#s);
  }
  set contentId(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(void 0);
  get titleId() {
    return d(this.#o);
  }
  set titleId(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(void 0);
  get triggerId() {
    return d(this.#i);
  }
  set triggerId(e) {
    q(this.#i, e, !0);
  }
  #a = /* @__PURE__ */ xe(void 0);
  get descriptionId() {
    return d(this.#a);
  }
  set descriptionId(e) {
    q(this.#a, e, !0);
  }
  #u = /* @__PURE__ */ xe(null);
  get cancelNode() {
    return d(this.#u);
  }
  set cancelNode(e) {
    q(this.#u, e, !0);
  }
  #l = /* @__PURE__ */ xe(0);
  get nestedOpenCount() {
    return d(this.#l);
  }
  set nestedOpenCount(e) {
    q(this.#l, e, !0);
  }
  depth;
  parent;
  contentPresence;
  overlayPresence;
  constructor(e, r) {
    this.opts = e, this.parent = r, this.depth = r ? r.depth + 1 : 0, this.handleOpen = this.handleOpen.bind(this), this.handleClose = this.handleClose.bind(this), this.contentPresence = new wi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      enabled: !0,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), this.overlayPresence = new wi({
      ref: z(() => this.overlayNode),
      open: this.opts.open,
      enabled: !0
    }), Fe(
      () => this.opts.open.current,
      (n) => {
        this.parent && (n ? this.parent.incrementNested() : this.parent.decrementNested());
      },
      { lazy: !0 }
    ), Ys(() => {
      this.opts.open.current && this.parent?.decrementNested();
    });
  }
  handleOpen() {
    this.opts.open.current || (this.opts.open.current = !0);
  }
  handleClose() {
    this.opts.open.current && (this.opts.open.current = !1);
  }
  getBitsAttr = (e) => lT.getAttr(e, this.opts.variant.current);
  incrementNested() {
    this.nestedOpenCount++, this.parent?.incrementNested();
  }
  decrementNested() {
    this.nestedOpenCount !== 0 && (this.nestedOpenCount--, this.parent?.decrementNested());
  }
  #c = /* @__PURE__ */ O(() => ({ "data-state": ji(this.opts.open.current) }));
  get sharedProps() {
    return d(this.#c);
  }
  set sharedProps(e) {
    q(this.#c, e);
  }
}
class lf {
  static create(e) {
    return new lf(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => {
      this.root.triggerNode = n, this.root.triggerId = n?.id;
    }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || e.button > 0 || this.root.handleOpen();
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === xr || e.key === Br) && (e.preventDefault(), this.root.handleOpen());
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-haspopup": "dialog",
    "aria-expanded": at(this.root.opts.open.current),
    "aria-controls": this.root.contentId,
    [this.root.getBitsAttr("trigger")]: "",
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    disabled: this.opts.disabled.current ? !0 : void 0,
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class uf {
  static create(e) {
    return new uf(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || e.button > 0 || this.root.handleClose();
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === xr || e.key === Br) && (e.preventDefault(), this.root.handleClose());
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr(this.opts.variant.current)]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    disabled: this.opts.disabled.current ? !0 : void 0,
    tabindex: 0,
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class cf {
  static create(e) {
    return new cf(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.root.titleId = this.opts.id.current, this.attachment = Te(this.opts.ref), Fe.pre(() => this.opts.id.current, (n) => {
      this.root.titleId = n;
    });
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "heading",
    "aria-level": this.opts.level.current,
    [this.root.getBitsAttr("title")]: "",
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class df {
  static create(e) {
    return new df(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.root.descriptionId = this.opts.id.current, this.attachment = Te(this.opts.ref, (n) => {
      this.root.descriptionNode = n;
    }), Fe.pre(() => this.opts.id.current, (n) => {
      this.root.descriptionId = n;
    });
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr("description")]: "",
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class ff {
  static create(e) {
    return new ff(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => {
      this.root.contentNode = n, this.root.contentId = n?.id;
    });
  }
  #e = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: this.root.opts.variant.current === "alert-dialog" ? "alertdialog" : "dialog",
    "aria-modal": "true",
    "aria-describedby": this.root.descriptionId,
    "aria-labelledby": this.root.titleId,
    [this.root.getBitsAttr("content")]: "",
    style: {
      pointerEvents: "auto",
      outline: this.root.opts.variant.current === "alert-dialog" ? "none" : void 0,
      "--bits-dialog-depth": this.root.depth,
      "--bits-dialog-nested-count": this.root.nestedOpenCount,
      contain: "layout style paint"
    },
    tabindex: this.root.opts.variant.current === "alert-dialog" ? -1 : void 0,
    "data-nested-open": Re(this.root.nestedOpenCount > 0),
    "data-nested": Re(this.root.parent !== null),
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
}
class hf {
  static create(e) {
    return new hf(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.overlayNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr("overlay")]: "",
    style: {
      pointerEvents: "auto",
      "--bits-dialog-depth": this.root.depth,
      "--bits-dialog-nested-count": this.root.nestedOpenCount
    },
    "data-nested-open": Re(this.root.nestedOpenCount > 0),
    "data-nested": Re(this.root.parent !== null),
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  get shouldRender() {
    return this.root.overlayPresence.shouldRender;
  }
}
var uT = /* @__PURE__ */ ne("<div><!></div>");
function h0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "level", 7, 2), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "level"
  ]);
  const u = cf.create({
    id: z(() => n()),
    level: z(() => a()),
    ref: z(() => s(), (g) => s(g))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get child() {
      return o();
    },
    set child(g) {
      o(g), m();
    },
    get children() {
      return i();
    },
    set children(g) {
      i(g), m();
    },
    get level() {
      return a();
    },
    set level(g = 2) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, o, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = uT();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => i() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      o() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(h0, { id: {}, ref: {}, child: {}, children: {}, level: {} }, [], [], { mode: "open" });
function g0(t, e) {
  W(e, !0);
  const r = v(e, "children", 7);
  var n = {
    get children() {
      return r();
    },
    set children(i) {
      r(i), m();
    }
  }, s = M(), o = D(s);
  return Ll(o, r, (i) => {
    var a = M(), l = D(a);
    te(l, () => r() ?? he), A(i, a);
  }), A(t, s), H(n);
}
K(g0, { children: {} }, [], [], { mode: "open" });
const cT = new ht("BitsConfig");
function dT() {
  const t = new fT(null, {});
  return cT.getOr(t).opts;
}
class fT {
  opts;
  constructor(e, r) {
    const n = hT(e, r);
    this.opts = {
      defaultPortalTo: n((s) => s.defaultPortalTo),
      defaultLocale: n((s) => s.defaultLocale)
    };
  }
}
function hT(t, e) {
  return (r) => z(() => {
    const s = r(e)?.current;
    if (s !== void 0)
      return s;
    if (t !== null)
      return r(t.opts)?.current;
  });
}
function p0(t, e) {
  return (r) => {
    const n = dT();
    return z(() => {
      const s = r();
      if (s !== void 0)
        return s;
      const o = t(n).current;
      return o !== void 0 ? o : e;
    });
  };
}
const m0 = p0((t) => t.defaultLocale, "en"), gT = p0((t) => t.defaultPortalTo, "body");
function lu(t, e) {
  W(e, !0);
  let r = v(e, "to", 7), n = v(e, "children", 7), s = v(e, "disabled", 7);
  const o = gT(() => r()), i = sP();
  let a = /* @__PURE__ */ O(l);
  function l() {
    if (!Bi || s()) return null;
    let p = null;
    return typeof o.current == "string" ? p = document.querySelector(o.current) : p = o.current, p;
  }
  let u;
  function c() {
    u && (Qv(u), u = null);
  }
  Fe([() => d(a), () => s()], ([p, g]) => {
    if (!p || g) {
      c();
      return;
    }
    return u = vd(g0, { target: p, props: { children: n() }, context: i }), () => {
      c();
    };
  });
  var f = {
    get to() {
      return r();
    },
    set to(p) {
      r(p), m();
    },
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get disabled() {
      return s();
    },
    set disabled(p) {
      s(p), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (p) => {
      var g = M(), y = D(g);
      te(y, () => n() ?? he), A(p, g);
    };
    ue(_, (p) => {
      s() && p(b);
    });
  }
  return A(t, h), H(f);
}
K(lu, { to: {}, children: {}, disabled: {} }, [], [], { mode: "open" });
function wm(t, e = 500) {
  let r = null;
  const n = (...s) => {
    r !== null && clearTimeout(r), r = setTimeout(() => {
      t(...s);
    }, e);
  };
  return n.destroy = () => {
    r !== null && (clearTimeout(r), r = null);
  }, n;
}
function v0(t, e) {
  return t === e || t.contains(e);
}
function y0(t) {
  return t?.ownerDocument ?? document;
}
function pT(t) {
  if (!t)
    return null;
  for (const e of t.childNodes)
    if (e.nodeType !== Node.COMMENT_NODE)
      return e;
  return null;
}
function mT(t, e) {
  const { clientX: r, clientY: n } = t, s = e.getBoundingClientRect();
  return r < s.left || r > s.right || n < s.top || n > s.bottom;
}
var b0 = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"], dl = /* @__PURE__ */ b0.join(","), _0 = typeof Element > "u", Vs = _0 ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, fl = !_0 && Element.prototype.getRootNode ? function(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
} : function(t) {
  return t?.ownerDocument;
}, hl = function(e, r) {
  var n;
  r === void 0 && (r = !0);
  var s = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "inert"), o = s === "" || s === "true", i = o || r && e && // closest does not exist on shadow roots, so we fall back to a manual
  // lookup upward, in case it is not defined.
  (typeof e.closest == "function" ? e.closest("[inert]") : hl(e.parentNode));
  return i;
}, vT = function(e) {
  var r, n = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "contenteditable");
  return n === "" || n === "true";
}, w0 = function(e, r, n) {
  if (hl(e))
    return [];
  var s = Array.prototype.slice.apply(e.querySelectorAll(dl));
  return r && Vs.call(e, dl) && s.unshift(e), s = s.filter(n), s;
}, gl = function(e, r, n) {
  for (var s = [], o = Array.from(e); o.length; ) {
    var i = o.shift();
    if (!hl(i, !1))
      if (i.tagName === "SLOT") {
        var a = i.assignedElements(), l = a.length ? a : i.children, u = gl(l, !0, n);
        n.flatten ? s.push.apply(s, u) : s.push({
          scopeParent: i,
          candidates: u
        });
      } else {
        var c = Vs.call(i, dl);
        c && n.filter(i) && (r || !e.includes(i)) && s.push(i);
        var f = i.shadowRoot || // check for an undisclosed shadow
        typeof n.getShadowRoot == "function" && n.getShadowRoot(i), h = !hl(f, !1) && (!n.shadowRootFilter || n.shadowRootFilter(i));
        if (f && h) {
          var _ = gl(f === !0 ? i.children : f.children, !0, n);
          n.flatten ? s.push.apply(s, _) : s.push({
            scopeParent: i,
            candidates: _
          });
        } else
          o.unshift.apply(o, i.children);
      }
  }
  return s;
}, S0 = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, x0 = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || vT(e)) && !S0(e) ? 0 : e.tabIndex;
}, yT = function(e, r) {
  var n = x0(e);
  return n < 0 && r && !S0(e) ? 0 : n;
}, bT = function(e, r) {
  return e.tabIndex === r.tabIndex ? e.documentOrder - r.documentOrder : e.tabIndex - r.tabIndex;
}, P0 = function(e) {
  return e.tagName === "INPUT";
}, _T = function(e) {
  return P0(e) && e.type === "hidden";
}, wT = function(e) {
  var r = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return r;
}, ST = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (e[n].checked && e[n].form === r)
      return e[n];
}, xT = function(e) {
  if (!e.name)
    return !0;
  var r = e.form || fl(e), n = function(a) {
    return r.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, s;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    s = n(window.CSS.escape(e.name));
  else
    try {
      s = n(e.name);
    } catch (i) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", i.message), !1;
    }
  var o = ST(s, e.form);
  return !o || o === e;
}, PT = function(e) {
  return P0(e) && e.type === "radio";
}, OT = function(e) {
  return PT(e) && !xT(e);
}, CT = function(e) {
  var r, n = e && fl(e), s = (r = n) === null || r === void 0 ? void 0 : r.host, o = !1;
  if (n && n !== e) {
    var i, a, l;
    for (o = !!((i = s) !== null && i !== void 0 && (a = i.ownerDocument) !== null && a !== void 0 && a.contains(s) || e != null && (l = e.ownerDocument) !== null && l !== void 0 && l.contains(e)); !o && s; ) {
      var u, c, f;
      n = fl(s), s = (u = n) === null || u === void 0 ? void 0 : u.host, o = !!((c = s) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(s));
    }
  }
  return o;
}, Sm = function(e) {
  var r = e.getBoundingClientRect(), n = r.width, s = r.height;
  return n === 0 && s === 0;
}, kT = function(e, r) {
  var n = r.displayCheck, s = r.getShadowRoot;
  if (n === "full-native" && "checkVisibility" in e) {
    var o = e.checkVisibility({
      // Checking opacity might be desirable for some use cases, but natively,
      // opacity zero elements _are_ focusable and tabbable.
      checkOpacity: !1,
      opacityProperty: !1,
      contentVisibilityAuto: !0,
      visibilityProperty: !0,
      // This is an alias for `visibilityProperty`. Contemporary browsers
      // support both. However, this alias has wider browser support (Chrome
      // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
      // we include it anyway.
      checkVisibilityCSS: !0
    });
    return !o;
  }
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var i = Vs.call(e, "details>summary:first-of-type"), a = i ? e.parentElement : e;
  if (Vs.call(a, "details:not([open]) *"))
    return !0;
  if (!n || n === "full" || // full-native can run this branch when it falls through in case
  // Element#checkVisibility is unsupported
  n === "full-native" || n === "legacy-full") {
    if (typeof s == "function") {
      for (var l = e; e; ) {
        var u = e.parentElement, c = fl(e);
        if (u && !u.shadowRoot && s(u) === !0)
          return Sm(e);
        e.assignedSlot ? e = e.assignedSlot : !u && c !== e.ownerDocument ? e = c.host : e = u;
      }
      e = l;
    }
    if (CT(e))
      return !e.getClientRects().length;
    if (n !== "legacy-full")
      return !0;
  } else if (n === "non-zero-area")
    return Sm(e);
  return !1;
}, $T = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var r = e.parentElement; r; ) {
      if (r.tagName === "FIELDSET" && r.disabled) {
        for (var n = 0; n < r.children.length; n++) {
          var s = r.children.item(n);
          if (s.tagName === "LEGEND")
            return Vs.call(r, "fieldset[disabled] *") ? !0 : !s.contains(e);
        }
        return !0;
      }
      r = r.parentElement;
    }
  return !1;
}, pl = function(e, r) {
  return !(r.disabled || _T(r) || kT(r, e) || // For a details element with a summary, the summary element gets the focus
  wT(r) || $T(r));
}, Bc = function(e, r) {
  return !(OT(r) || x0(r) < 0 || !pl(e, r));
}, AT = function(e) {
  var r = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(r) || r >= 0);
}, O0 = function(e) {
  var r = [], n = [];
  return e.forEach(function(s, o) {
    var i = !!s.scopeParent, a = i ? s.scopeParent : s, l = yT(a, i), u = i ? O0(s.candidates) : a;
    l === 0 ? i ? r.push.apply(r, u) : r.push(a) : n.push({
      documentOrder: o,
      tabIndex: l,
      item: s,
      isScope: i,
      content: u
    });
  }), n.sort(bT).reduce(function(s, o) {
    return o.isScope ? s.push.apply(s, o.content) : s.push(o.content), s;
  }, []).concat(r);
}, ET = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = gl([e], r.includeContainer, {
    filter: Bc.bind(null, r),
    flatten: !1,
    getShadowRoot: r.getShadowRoot,
    shadowRootFilter: AT
  }) : n = w0(e, r.includeContainer, Bc.bind(null, r)), O0(n);
}, TT = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = gl([e], r.includeContainer, {
    filter: pl.bind(null, r),
    flatten: !0,
    getShadowRoot: r.getShadowRoot
  }) : n = w0(e, r.includeContainer, pl.bind(null, r)), n;
}, DT = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return Vs.call(e, dl) === !1 ? !1 : Bc(r, e);
}, MT = /* @__PURE__ */ b0.concat("iframe:not([inert]):not([inert] *)").join(","), IT = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return Vs.call(e, MT) === !1 ? !1 : pl(r, e);
};
function NT(t, e) {
  const r = [];
  for (let n = 0; n < t.length; n += e)
    r.push(t.slice(n, n + e));
  return r;
}
function Ha(t, e) {
  return t >= 0 && t < e.length;
}
function FT(t, e, r = !0) {
  if (!(t.length === 0 || e < 0 || e >= t.length))
    return t.length === 1 && e === 0 ? t[0] : e === t.length - 1 ? r ? t[0] : void 0 : t[e + 1];
}
function RT(t, e, r = !0) {
  if (!(t.length === 0 || e < 0 || e >= t.length))
    return t.length === 1 && e === 0 ? t[0] : e === 0 ? r ? t[t.length - 1] : void 0 : t[e - 1];
}
function VT(t, e, r, n = !0) {
  if (t.length === 0 || e < 0 || e >= t.length)
    return;
  let s = e + r;
  return n ? s = (s % t.length + t.length) % t.length : s = Math.max(0, Math.min(s, t.length - 1)), t[s];
}
function LT(t, e, r, n = !0) {
  if (t.length === 0 || e < 0 || e >= t.length)
    return;
  let s = e - r;
  return n ? s = (s % t.length + t.length) % t.length : s = Math.max(0, Math.min(s, t.length - 1)), t[s];
}
function gf(t, e, r) {
  const n = e.toLowerCase();
  if (n.endsWith(" ")) {
    const f = n.slice(0, -1);
    if (t.filter((p) => p.toLowerCase().startsWith(f)).length <= 1)
      return gf(t, f, r);
    const _ = r?.toLowerCase();
    if (_ && _.startsWith(f) && _.charAt(f.length) === " " && e.trim() === f)
      return r;
    const b = t.filter((p) => p.toLowerCase().startsWith(n));
    if (b.length > 0) {
      const p = r ? t.indexOf(r) : -1;
      return xm(b, Math.max(p, 0)).find((S) => S !== r) || r;
    }
  }
  const o = e.length > 1 && Array.from(e).every((f) => f === e[0]) ? e[0] : e, i = o.toLowerCase(), a = r ? t.indexOf(r) : -1;
  let l = xm(t, Math.max(a, 0));
  o.length === 1 && (l = l.filter((f) => f !== r));
  const c = l.find((f) => f?.toLowerCase().startsWith(i));
  return c !== r ? c : void 0;
}
function xm(t, e) {
  return t.map((r, n) => t[(e + n) % t.length]);
}
const jT = { afterMs: 1e4, onChange: _e };
function C0(t, e) {
  const { afterMs: r, onChange: n, getWindow: s } = { ...jT, ...e };
  let o = null, i = /* @__PURE__ */ xe(Pt(t));
  function a() {
    return s().setTimeout(
      () => {
        q(i, t, !0), n?.(t);
      },
      r
    );
  }
  return Xe(() => () => {
    o && s().clearTimeout(o);
  }), z(() => d(i), (l) => {
    q(i, l, !0), n?.(l), o && s().clearTimeout(o), o = a();
  });
}
class BT {
  #e;
  #t;
  #r = /* @__PURE__ */ O(() => this.#e.onMatch ? this.#e.onMatch : (e) => e.focus());
  #n = /* @__PURE__ */ O(() => this.#e.getCurrentItem ? this.#e.getCurrentItem : this.#e.getActiveElement);
  constructor(e) {
    this.#e = e, this.#t = C0("", { afterMs: 1e3, getWindow: e.getWindow }), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(e, r) {
    if (!r.length) return;
    this.#t.current = this.#t.current + e;
    const n = d(this.#n)(), s = r.find((l) => l === n)?.textContent?.trim() ?? "", o = r.map((l) => l.textContent?.trim() ?? ""), i = gf(o, this.#t.current, s), a = r.find((l) => l.textContent?.trim() === i);
    return a && d(this.#r)(a), a;
  }
  resetTypeahead() {
    this.#t.current = "";
  }
  get search() {
    return this.#t.current;
  }
}
const zT = "data-context-menu-trigger", qT = "data-context-menu-content";
nr({
  component: "menu",
  parts: [
    "trigger",
    "content",
    "sub-trigger",
    "item",
    "group",
    "group-heading",
    "checkbox-group",
    "checkbox-item",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "arrow"
  ]
});
globalThis.bitsDismissableLayers ??= /* @__PURE__ */ new Map();
class pf {
  static create(e) {
    return new pf(e);
  }
  opts;
  #e;
  #t;
  #r = { pointerdown: !1 };
  #n = !1;
  #s = !1;
  #o = void 0;
  #i;
  #a = _e;
  constructor(e) {
    this.opts = e, this.#t = e.interactOutsideBehavior, this.#e = e.onInteractOutside, this.#i = e.onFocusOutside, Xe(() => {
      this.#o = y0(this.opts.ref.current);
    });
    let r = _e;
    const n = () => {
      this.#h(), globalThis.bitsDismissableLayers.delete(this), this.#d.destroy(), r();
    };
    Fe([() => this.opts.enabled.current, () => this.opts.ref.current], () => {
      if (!(!this.opts.enabled.current || !this.opts.ref.current))
        return rf(1, () => {
          this.opts.ref.current && (globalThis.bitsDismissableLayers.set(this, this.#t), r(), r = this.#l());
        }), n;
    }), Ys(() => {
      this.#h.destroy(), globalThis.bitsDismissableLayers.delete(this), this.#d.destroy(), this.#a(), r();
    });
  }
  #u = (e) => {
    e.defaultPrevented || this.opts.ref.current && Jt(() => {
      !this.opts.ref.current || this.#f(e.target) || e.target && !this.#s && this.#i.current?.(e);
    });
  };
  #l() {
    return Es(
      /**
       * CAPTURE INTERACTION START
       * mark interaction-start event as intercepted.
       * mark responsible layer during interaction start
       * to avoid checking if is responsible layer during interaction end
       * when a new floating element may have been opened.
       */
      Ye(this.#o, "pointerdown", Es(this.#g, this.#p), { capture: !0 }),
      /**
       * BUBBLE INTERACTION START
       * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
       * to avoid prematurely checking if other events were intercepted.
       */
      Ye(this.#o, "pointerdown", Es(this.#m, this.#d)),
      /**
       * HANDLE FOCUS OUTSIDE
       */
      Ye(this.#o, "focusin", this.#u)
    );
  }
  #c = (e) => {
    let r = e;
    r.defaultPrevented && (r = Pm(e)), this.#e.current(e);
  };
  #d = wm(
    (e) => {
      if (!this.opts.ref.current) {
        this.#a();
        return;
      }
      const r = this.opts.isValidEvent.current(e, this.opts.ref.current) || WT(e, this.opts.ref.current);
      if (!this.#n || this.#b() || !r) {
        this.#a();
        return;
      }
      let n = e;
      if (n.defaultPrevented && (n = Pm(n)), this.#t.current !== "close" && this.#t.current !== "defer-otherwise-close") {
        this.#a();
        return;
      }
      e.pointerType === "touch" ? (this.#a(), this.#a = Ye(this.#o, "click", this.#c, { once: !0 })) : this.#e.current(n);
    },
    10
  );
  #g = (e) => {
    this.#r[e.type] = !0;
  };
  #m = (e) => {
    this.#r[e.type] = !1;
  };
  #p = () => {
    this.opts.ref.current && (this.#n = KT(this.opts.ref.current));
  };
  #f = (e) => this.opts.ref.current ? v0(this.opts.ref.current, e) : !1;
  #h = wm(
    () => {
      for (const e in this.#r)
        this.#r[e] = !1;
      this.#n = !1;
    },
    20
  );
  #b() {
    return Object.values(this.#r).some(Boolean);
  }
  #y = () => {
    this.#s = !0;
  };
  #v = () => {
    this.#s = !1;
  };
  props = {
    onfocuscapture: this.#y,
    onblurcapture: this.#v
  };
}
function UT(t = [...globalThis.bitsDismissableLayers]) {
  return t.findLast(([e, { current: r }]) => r === "close" || r === "ignore");
}
function KT(t) {
  const e = [...globalThis.bitsDismissableLayers], r = UT(e);
  if (r) return r[0].opts.ref.current === t;
  const [n] = e[0];
  return n.opts.ref.current === t;
}
function WT(t, e) {
  const r = t.target;
  if (!of(r)) return !1;
  const n = !!r.closest(`[${zT}]`);
  if ("button" in t && t.button > 0 && !n) return !1;
  if ("button" in t && t.button === 0 && n) return !0;
  const s = !!e.closest(`[${qT}]`);
  return n && s ? !1 : y0(r).documentElement.contains(r) && !v0(e, r) && mT(t, e);
}
function Pm(t) {
  const e = t.currentTarget, r = t.target;
  let n;
  t instanceof PointerEvent ? n = new PointerEvent(t.type, t) : n = new PointerEvent("pointerdown", t);
  let s = !1;
  return new Proxy(n, {
    get: (i, a) => a === "currentTarget" ? e : a === "target" ? r : a === "preventDefault" ? () => {
      s = !0, typeof i.preventDefault == "function" && i.preventDefault();
    } : a === "defaultPrevented" ? s : a in i ? i[a] : t[a]
  });
}
function mf(t, e) {
  W(e, !0);
  let r = v(e, "interactOutsideBehavior", 7, "close"), n = v(e, "onInteractOutside", 7, _e), s = v(e, "onFocusOutside", 7, _e), o = v(e, "id", 7), i = v(e, "children", 7), a = v(e, "enabled", 7), l = v(e, "isValidEvent", 7, () => !1), u = v(e, "ref", 7);
  const c = pf.create({
    id: z(() => o()),
    interactOutsideBehavior: z(() => r()),
    onInteractOutside: z(() => n()),
    enabled: z(() => a()),
    onFocusOutside: z(() => s()),
    isValidEvent: z(() => l()),
    ref: u()
  });
  var f = {
    get interactOutsideBehavior() {
      return r();
    },
    set interactOutsideBehavior(b = "close") {
      r(b), m();
    },
    get onInteractOutside() {
      return n();
    },
    set onInteractOutside(b = _e) {
      n(b), m();
    },
    get onFocusOutside() {
      return s();
    },
    set onFocusOutside(b = _e) {
      s(b), m();
    },
    get id() {
      return o();
    },
    set id(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get enabled() {
      return a();
    },
    set enabled(b) {
      a(b), m();
    },
    get isValidEvent() {
      return l();
    },
    set isValidEvent(b = () => !1) {
      l(b), m();
    },
    get ref() {
      return u();
    },
    set ref(b) {
      u(b), m();
    }
  }, h = M(), _ = D(h);
  return te(_, () => i() ?? he, () => ({ props: c.props })), A(t, h), H(f);
}
K(
  mf,
  {
    interactOutsideBehavior: {},
    onInteractOutside: {},
    onFocusOutside: {},
    id: {},
    children: {},
    enabled: {},
    isValidEvent: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsEscapeLayers ??= /* @__PURE__ */ new Map();
class vf {
  static create(e) {
    return new vf(e);
  }
  opts;
  domContext;
  constructor(e) {
    this.opts = e, this.domContext = new Fn(this.opts.ref);
    let r = _e;
    Fe(() => e.enabled.current, (n) => (n && (globalThis.bitsEscapeLayers.set(this, e.escapeKeydownBehavior), r = this.#e()), () => {
      r(), globalThis.bitsEscapeLayers.delete(this);
    }));
  }
  #e = () => Ye(this.domContext.getDocument(), "keydown", this.#t, { passive: !1 });
  #t = (e) => {
    if (e.key !== G2 || !HT(this)) return;
    const r = new KeyboardEvent(e.type, e);
    e.preventDefault();
    const n = this.opts.escapeKeydownBehavior.current;
    n !== "close" && n !== "defer-otherwise-close" || this.opts.onEscapeKeydown.current(r);
  };
}
function HT(t) {
  const e = [...globalThis.bitsEscapeLayers], r = e.findLast(([s, { current: o }]) => o === "close" || o === "ignore");
  if (r) return r[0] === t;
  const [n] = e[0];
  return n === t;
}
function yf(t, e) {
  W(e, !0);
  let r = v(e, "escapeKeydownBehavior", 7, "close"), n = v(e, "onEscapeKeydown", 7, _e), s = v(e, "children", 7), o = v(e, "enabled", 7), i = v(e, "ref", 7);
  vf.create({
    escapeKeydownBehavior: z(() => r()),
    onEscapeKeydown: z(() => n()),
    enabled: z(() => o()),
    ref: i()
  });
  var a = {
    get escapeKeydownBehavior() {
      return r();
    },
    set escapeKeydownBehavior(c = "close") {
      r(c), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(c = _e) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get enabled() {
      return o();
    },
    set enabled(c) {
      o(c), m();
    },
    get ref() {
      return i();
    },
    set ref(c) {
      i(c), m();
    }
  }, l = M(), u = D(l);
  return te(u, () => s() ?? he), A(t, l), H(a);
}
K(
  yf,
  {
    escapeKeydownBehavior: {},
    onEscapeKeydown: {},
    children: {},
    enabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
class bf {
  static instance;
  #e = Jr([]);
  #t = /* @__PURE__ */ new WeakMap();
  #r = /* @__PURE__ */ new WeakMap();
  static getInstance() {
    return this.instance || (this.instance = new bf()), this.instance;
  }
  register(e) {
    const r = this.getActive();
    r && r !== e && r.pause();
    const n = document.activeElement;
    n && n !== document.body && this.#r.set(e, n), this.#e.current = this.#e.current.filter((s) => s !== e), this.#e.current.unshift(e);
  }
  unregister(e) {
    this.#e.current = this.#e.current.filter((n) => n !== e);
    const r = this.getActive();
    r && r.resume();
  }
  getActive() {
    return this.#e.current[0];
  }
  setFocusMemory(e, r) {
    this.#t.set(e, r);
  }
  getFocusMemory(e) {
    return this.#t.get(e);
  }
  isActiveScope(e) {
    return this.getActive() === e;
  }
  setPreFocusMemory(e, r) {
    this.#r.set(e, r);
  }
  getPreFocusMemory(e) {
    return this.#r.get(e);
  }
  clearPreFocusMemory(e) {
    this.#r.delete(e);
  }
}
class _f {
  #e = !1;
  #t = null;
  #r = bf.getInstance();
  #n = [];
  #s;
  constructor(e) {
    this.#s = e;
  }
  get paused() {
    return this.#e;
  }
  pause() {
    this.#e = !0;
  }
  resume() {
    this.#e = !1;
  }
  #o() {
    for (const e of this.#n)
      e();
    this.#n = [];
  }
  mount(e) {
    this.#t && this.unmount(), this.#t = e, this.#r.register(this), this.#u(), this.#i();
  }
  unmount() {
    this.#t && (this.#o(), this.#a(), this.#r.unregister(this), this.#r.clearPreFocusMemory(this), this.#t = null);
  }
  #i() {
    if (!this.#t) return;
    const e = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: !1, cancelable: !0 });
    this.#s.onOpenAutoFocus.current(e), e.defaultPrevented || requestAnimationFrame(() => {
      if (!this.#t) return;
      const r = this.#c();
      r ? (r.focus(), this.#r.setFocusMemory(this, r)) : this.#t.focus();
    });
  }
  #a() {
    const e = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: !1, cancelable: !0 });
    if (this.#s.onCloseAutoFocus.current?.(e), !e.defaultPrevented) {
      const r = this.#r.getPreFocusMemory(this);
      if (r && document.contains(r))
        try {
          r.focus();
        } catch {
          document.body.focus();
        }
    }
  }
  #u() {
    if (!this.#t || !this.#s.trap.current) return;
    const e = this.#t, r = e.ownerDocument, n = (i) => {
      if (this.#e || !this.#r.isActiveScope(this)) return;
      const a = i.target;
      if (!a) return;
      if (e.contains(a))
        this.#r.setFocusMemory(this, a);
      else {
        const u = this.#r.getFocusMemory(this);
        if (u && e.contains(u) && IT(u))
          i.preventDefault(), u.focus();
        else {
          const c = this.#c(), f = this.#d()[0];
          (c || f || e).focus();
        }
      }
    }, s = (i) => {
      if (!this.#s.loop || this.#e || i.key !== "Tab" || !this.#r.isActiveScope(this)) return;
      const a = this.#l();
      if (a.length === 0) return;
      const l = a[0], u = a[a.length - 1];
      !i.shiftKey && r.activeElement === u ? (i.preventDefault(), l.focus()) : i.shiftKey && r.activeElement === l && (i.preventDefault(), u.focus());
    };
    this.#n.push(Ye(r, "focusin", n, { capture: !0 }), Ye(e, "keydown", s));
    const o = new MutationObserver(() => {
      const i = this.#r.getFocusMemory(this);
      if (i && !e.contains(i)) {
        const a = this.#c(), l = this.#d()[0], u = a || l;
        u ? (u.focus(), this.#r.setFocusMemory(this, u)) : e.focus();
      }
    });
    o.observe(e, { childList: !0, subtree: !0 }), this.#n.push(() => o.disconnect());
  }
  #l() {
    return this.#t ? ET(this.#t, { includeContainer: !1, getShadowRoot: !0 }) : [];
  }
  #c() {
    return this.#l()[0] || null;
  }
  #d() {
    return this.#t ? TT(this.#t, { includeContainer: !1, getShadowRoot: !0 }) : [];
  }
  static use(e) {
    let r = null;
    return Fe([() => e.ref.current, () => e.enabled.current], ([n, s]) => {
      n && s ? (r || (r = new _f(e)), r.mount(n)) : r && (r.unmount(), r = null);
    }), Ys(() => {
      r?.unmount();
    }), {
      get props() {
        return { tabindex: -1 };
      }
    };
  }
}
function wf(t, e) {
  W(e, !0);
  let r = v(e, "enabled", 7, !1), n = v(e, "trapFocus", 7, !1), s = v(e, "loop", 7, !1), o = v(e, "onCloseAutoFocus", 7, _e), i = v(e, "onOpenAutoFocus", 7, _e), a = v(e, "focusScope", 7), l = v(e, "ref", 7);
  const u = _f.use({
    enabled: z(() => r()),
    trap: z(() => n()),
    loop: s(),
    onCloseAutoFocus: z(() => o()),
    onOpenAutoFocus: z(() => i()),
    ref: l()
  });
  var c = {
    get enabled() {
      return r();
    },
    set enabled(_ = !1) {
      r(_), m();
    },
    get trapFocus() {
      return n();
    },
    set trapFocus(_ = !1) {
      n(_), m();
    },
    get loop() {
      return s();
    },
    set loop(_ = !1) {
      s(_), m();
    },
    get onCloseAutoFocus() {
      return o();
    },
    set onCloseAutoFocus(_ = _e) {
      o(_), m();
    },
    get onOpenAutoFocus() {
      return i();
    },
    set onOpenAutoFocus(_ = _e) {
      i(_), m();
    },
    get focusScope() {
      return a();
    },
    set focusScope(_) {
      a(_), m();
    },
    get ref() {
      return l();
    },
    set ref(_) {
      l(_), m();
    }
  }, f = M(), h = D(f);
  return te(h, () => a() ?? he, () => ({ props: u.props })), A(t, f), H(c);
}
K(
  wf,
  {
    enabled: {},
    trapFocus: {},
    loop: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    focusScope: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsTextSelectionLayers ??= /* @__PURE__ */ new Map();
class Sf {
  static create(e) {
    return new Sf(e);
  }
  opts;
  domContext;
  #e = _e;
  constructor(e) {
    this.opts = e, this.domContext = new Fn(e.ref);
    let r = _e;
    Fe(() => this.opts.enabled.current, (n) => (n && (globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled), r(), r = this.#t()), () => {
      r(), this.#n(), globalThis.bitsTextSelectionLayers.delete(this);
    }));
  }
  #t() {
    return Es(Ye(this.domContext.getDocument(), "pointerdown", this.#r), Ye(this.domContext.getDocument(), "pointerup", t0(this.#n, this.opts.onPointerUp.current)));
  }
  #r = (e) => {
    const r = this.opts.ref.current, n = e.target;
    !Cn(r) || !Cn(n) || !this.opts.enabled.current || !YT(this) || !U2(r, n) || (this.opts.onPointerDown.current(e), !e.defaultPrevented && (this.#e = GT(r, this.domContext.getDocument().body)));
  };
  #n = () => {
    this.#e(), this.#e = _e;
  };
}
const Om = (t) => t.style.userSelect || t.style.webkitUserSelect;
function GT(t, e) {
  const r = Om(e), n = Om(t);
  return Na(e, "none"), Na(t, "text"), () => {
    Na(e, r), Na(t, n);
  };
}
function Na(t, e) {
  t.style.userSelect = e, t.style.webkitUserSelect = e;
}
function YT(t) {
  const e = [...globalThis.bitsTextSelectionLayers];
  if (!e.length) return !1;
  const r = e.at(-1);
  return r ? r[0] === t : !1;
}
function xf(t, e) {
  W(e, !0);
  let r = v(e, "preventOverflowTextSelection", 7, !0), n = v(e, "onPointerDown", 7, _e), s = v(e, "onPointerUp", 7, _e), o = v(e, "id", 7), i = v(e, "children", 7), a = v(e, "enabled", 7), l = v(e, "ref", 7);
  Sf.create({
    id: z(() => o()),
    onPointerDown: z(() => n()),
    onPointerUp: z(() => s()),
    enabled: z(() => a() && r()),
    ref: l()
  });
  var u = {
    get preventOverflowTextSelection() {
      return r();
    },
    set preventOverflowTextSelection(h = !0) {
      r(h), m();
    },
    get onPointerDown() {
      return n();
    },
    set onPointerDown(h = _e) {
      n(h), m();
    },
    get onPointerUp() {
      return s();
    },
    set onPointerUp(h = _e) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h) {
      o(h), m();
    },
    get children() {
      return i();
    },
    set children(h) {
      i(h), m();
    },
    get enabled() {
      return a();
    },
    set enabled(h) {
      a(h), m();
    },
    get ref() {
      return l();
    },
    set ref(h) {
      l(h), m();
    }
  }, c = M(), f = D(c);
  return te(f, () => i() ?? he), A(t, c), H(u);
}
K(
  xf,
  {
    preventOverflowTextSelection: {},
    onPointerDown: {},
    onPointerUp: {},
    id: {},
    children: {},
    enabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsIdCounter ??= { current: 0 };
function En(t = "bits") {
  return globalThis.bitsIdCounter.current++, `${t}-${globalThis.bitsIdCounter.current}`;
}
class XT {
  #e;
  #t = 0;
  #r = /* @__PURE__ */ xe();
  #n;
  constructor(e) {
    this.#e = e;
  }
  #s() {
    this.#t -= 1, this.#n && this.#t <= 0 && (this.#n(), q(this.#r, void 0), this.#n = void 0);
  }
  get(...e) {
    return this.#t += 1, d(this.#r) === void 0 && (this.#n = Iv(() => {
      q(this.#r, this.#e(...e), !0);
    })), Xe(() => () => {
      this.#s();
    }), d(this.#r);
  }
}
const Ga = new $d();
let Fa = /* @__PURE__ */ xe(null), Yu = null, ti = null, ri = !1;
const Cm = z(() => {
  for (const t of Ga.values())
    if (t) return !0;
  return !1;
});
let Xu = null;
const JT = new XT(() => {
  function t() {
    document.body.setAttribute("style", d(Fa) ?? ""), document.body.style.removeProperty("--scrollbar-width"), jc && Yu?.(), q(Fa, null);
  }
  function e() {
    ti !== null && (window.clearTimeout(ti), ti = null);
  }
  function r(s, o) {
    e(), ri = !0, Xu = Date.now();
    const i = Xu, a = () => {
      ti = null, Xu === i && (k0(Ga) ? ri = !1 : (ri = !1, o()));
    }, l = s === null ? 24 : s;
    ti = window.setTimeout(a, l);
  }
  function n() {
    d(Fa) === null && Ga.size === 0 && !ri && q(Fa, document.body.getAttribute("style"), !0);
  }
  return Fe(() => Cm.current, () => {
    if (!Cm.current) return;
    n(), ri = !1;
    const s = getComputedStyle(document.documentElement), o = getComputedStyle(document.body), i = s.scrollbarGutter?.includes("stable") || o.scrollbarGutter?.includes("stable"), a = window.innerWidth - document.documentElement.clientWidth, u = {
      padding: Number.parseInt(o.paddingRight ?? "0", 10) + a,
      margin: Number.parseInt(o.marginRight ?? "0", 10)
    };
    a > 0 && !i && (document.body.style.paddingRight = `${u.padding}px`, document.body.style.marginRight = `${u.margin}px`, document.body.style.setProperty("--scrollbar-width", `${a}px`)), document.body.style.overflow = "hidden", jc && (Yu = Ye(
      document,
      "touchmove",
      (c) => {
        c.target === document.documentElement && (c.touches.length > 1 || c.preventDefault());
      },
      { passive: !1 }
    )), Jt(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }), Ys(() => () => {
    Yu?.();
  }), {
    get lockMap() {
      return Ga;
    },
    resetBodyStyle: t,
    scheduleCleanupIfNoNewLocks: r,
    cancelPendingCleanup: e,
    ensureInitialStyleCaptured: n
  };
});
class ZT {
  #e = En();
  #t;
  #r = () => null;
  #n;
  locked;
  constructor(e, r = () => null) {
    this.#t = e, this.#r = r, this.#n = JT.get(), this.#n && (this.#n.cancelPendingCleanup(), this.#n.ensureInitialStyleCaptured(), this.#n.lockMap.set(this.#e, this.#t ?? !1), this.locked = z(() => this.#n.lockMap.get(this.#e) ?? !1, (n) => this.#n.lockMap.set(this.#e, n)), Ys(() => {
      if (this.#n.lockMap.delete(this.#e), k0(this.#n.lockMap)) return;
      const n = this.#r();
      this.#n.scheduleCleanupIfNoNewLocks(n, () => {
        this.#n.resetBodyStyle();
      });
    }));
  }
}
function k0(t) {
  for (const [e, r] of t)
    if (r) return !0;
  return !1;
}
function Si(t, e) {
  W(e, !0);
  let r = v(e, "preventScroll", 7, !0), n = v(e, "restoreScrollDelay", 7, null);
  r() && new ZT(r(), () => n());
  var s = {
    get preventScroll() {
      return r();
    },
    set preventScroll(o = !0) {
      r(o), m();
    },
    get restoreScrollDelay() {
      return n();
    },
    set restoreScrollDelay(o = null) {
      n(o), m();
    }
  };
  return H(s);
}
K(Si, { preventScroll: {}, restoreScrollDelay: {} }, [], [], { mode: "open" });
var QT = /* @__PURE__ */ ne("<div><!></div>");
function $0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "forceMount", 7, !1), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "ref", 15, null), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "forceMount",
    "child",
    "children",
    "ref"
  ]);
  const u = hf.create({
    id: z(() => n()),
    ref: z(() => a(), (p) => a(p))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get forceMount() {
      return s();
    },
    set forceMount(p = !1) {
      s(p), m();
    },
    get child() {
      return o();
    },
    set child(p) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    },
    get ref() {
      return a();
    },
    set ref(p = null) {
      a(p), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (p) => {
      var g = M(), y = D(g);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          {
            let k = /* @__PURE__ */ O(() => ({
              props: Ce(d(c)),
              ...u.snippetProps
            }));
            te(C, o, () => d(k));
          }
          A(P, w);
        }, x = (P) => {
          var w = QT();
          ve(w, (k) => ({ ...k }), [() => Ce(d(c))]);
          var C = ge(w);
          te(C, () => i() ?? he, () => u.snippetProps), de(w), A(P, w);
        };
        ue(y, (P) => {
          o() ? P(S) : P(x, !1);
        });
      }
      A(p, g);
    };
    ue(_, (p) => {
      (u.shouldRender || s()) && p(b);
    });
  }
  return A(t, h), H(f);
}
K($0, { id: {}, forceMount: {}, child: {}, children: {}, ref: {} }, [], [], { mode: "open" });
var eD = /* @__PURE__ */ ne("<button><!></button>");
function A0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = v(e, "disabled", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child",
    "disabled"
  ]);
  const u = lf.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g)),
    disabled: z(() => !!a())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    },
    get disabled() {
      return a();
    },
    set disabled(g = !1) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, i, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = eD();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => o() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      i() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(A0, { id: {}, ref: {}, children: {}, child: {}, disabled: {} }, [], [], { mode: "open" });
var tD = /* @__PURE__ */ ne("<div><!></div>");
function E0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "ref"
  ]);
  const l = df.create({
    id: z(() => n()),
    ref: z(() => i(), (p) => i(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    },
    get child() {
      return o();
    },
    set child(p) {
      o(p), m();
    },
    get ref() {
      return i();
    },
    set ref(p = null) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, o, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = tD();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => s() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      o() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(E0, { id: {}, children: {}, child: {}, ref: {} }, [], [], { mode: "open" });
function Ju(t, e) {
  return t - e * Math.floor(t / e);
}
const T0 = 1721426;
function Ra(t, e, r, n) {
  e = Pf(t, e);
  let s = e - 1, o = -2;
  return r <= 2 ? o = 0 : Ya(e) && (o = -1), T0 - 1 + 365 * s + Math.floor(s / 4) - Math.floor(s / 100) + Math.floor(s / 400) + Math.floor((367 * r - 362) / 12 + o + n);
}
function Ya(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function Pf(t, e) {
  return t === "BC" ? 1 - e : e;
}
function rD(t) {
  let e = "AD";
  return t <= 0 && (e = "BC", t = 1 - t), [
    e,
    t
  ];
}
const nD = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class wo {
  fromJulianDay(e) {
    let r = e, n = r - T0, s = Math.floor(n / 146097), o = Ju(n, 146097), i = Math.floor(o / 36524), a = Ju(o, 36524), l = Math.floor(a / 1461), u = Ju(a, 1461), c = Math.floor(u / 365), f = s * 400 + i * 100 + l * 4 + c + (i !== 4 && c !== 4 ? 1 : 0), [h, _] = rD(f), b = r - Ra(h, _, 1, 1), p = 2;
    r < Ra(h, _, 3, 1) ? p = 0 : Ya(_) && (p = 1);
    let g = Math.floor(((b + p) * 12 + 373) / 367), y = r - Ra(h, _, g, 1) + 1;
    return new rs(h, _, g, y);
  }
  toJulianDay(e) {
    return Ra(e.era, e.year, e.month, e.day);
  }
  getDaysInMonth(e) {
    return nD[Ya(e.year) ? "leapyear" : "standard"][e.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(e) {
    return 12;
  }
  getDaysInYear(e) {
    return Ya(e.year) ? 366 : 365;
  }
  getMaximumMonthsInYear() {
    return 12;
  }
  getMaximumDaysInMonth() {
    return 31;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(e) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(e) {
    return e.era === "BC";
  }
  balanceDate(e) {
    e.year <= 0 && (e.era = e.era === "BC" ? "AD" : "BC", e.year = 1 - e.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const sD = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function _t(t, e) {
  return e = fr(e, t.calendar), t.era === e.era && t.year === e.year && t.month === e.month && t.day === e.day;
}
function Lo(t, e) {
  return e = fr(e, t.calendar), t = zc(t), e = zc(e), t.era === e.era && t.year === e.year && t.month === e.month;
}
function D0(t, e) {
  return M0(t.calendar, e.calendar) && Lo(t, e);
}
function M0(t, e) {
  var r, n, s, o;
  return (o = (s = (r = t.isEqual) === null || r === void 0 ? void 0 : r.call(t, e)) !== null && s !== void 0 ? s : (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && o !== void 0 ? o : t.identifier === e.identifier;
}
function I0(t, e) {
  return _t(t, iD(e));
}
function N0(t, e, r) {
  let n = t.calendar.toJulianDay(t), s = cD(e), o = Math.ceil(n + 1 - s) % 7;
  return o < 0 && (o += 7), o;
}
function oD(t) {
  return Zr(Date.now(), t);
}
function iD(t) {
  return hD(oD(t));
}
function F0(t, e) {
  return t.calendar.toJulianDay(t) - e.calendar.toJulianDay(e);
}
function aD(t, e) {
  return km(t) - km(e);
}
function km(t) {
  return t.hour * 36e5 + t.minute * 6e4 + t.second * 1e3 + t.millisecond;
}
let Zu = null;
function ft() {
  return Zu == null && (Zu = new Intl.DateTimeFormat().resolvedOptions().timeZone), Zu;
}
function zc(t) {
  return t.subtract({
    days: t.day - 1
  });
}
function lD(t) {
  return t.add({
    days: t.calendar.getDaysInMonth(t) - t.day
  });
}
const $m = /* @__PURE__ */ new Map(), Qu = /* @__PURE__ */ new Map();
function uD(t) {
  if (Intl.Locale) {
    let r = $m.get(t);
    return r || (r = new Intl.Locale(t).maximize().region, r && $m.set(t, r)), r;
  }
  let e = t.split("-")[1];
  return e === "u" ? void 0 : e;
}
function cD(t) {
  let e = Qu.get(t);
  if (!e) {
    if (Intl.Locale) {
      let n = new Intl.Locale(t);
      if ("getWeekInfo" in n && (e = n.getWeekInfo(), e))
        return Qu.set(t, e), e.firstDay;
    }
    let r = uD(t);
    if (t.includes("-fw-")) {
      let n = t.split("-fw-")[1].split("-")[0];
      n === "mon" ? e = {
        firstDay: 1
      } : n === "tue" ? e = {
        firstDay: 2
      } : n === "wed" ? e = {
        firstDay: 3
      } : n === "thu" ? e = {
        firstDay: 4
      } : n === "fri" ? e = {
        firstDay: 5
      } : n === "sat" ? e = {
        firstDay: 6
      } : e = {
        firstDay: 0
      };
    } else t.includes("-ca-iso8601") ? e = {
      firstDay: 1
    } : e = {
      firstDay: r && sD[r] || 0
    };
    Qu.set(t, e);
  }
  return e.firstDay;
}
function es(t) {
  t = fr(t, new wo());
  let e = Pf(t.era, t.year);
  return R0(e, t.month, t.day, t.hour, t.minute, t.second, t.millisecond);
}
function R0(t, e, r, n, s, o, i) {
  let a = /* @__PURE__ */ new Date();
  return a.setUTCHours(n, s, o, i), a.setUTCFullYear(t, e - 1, r), a.getTime();
}
function xi(t, e) {
  if (e === "UTC") return 0;
  if (t > 0 && e === ft()) return new Date(t).getTimezoneOffset() * -6e4;
  let { year: r, month: n, day: s, hour: o, minute: i, second: a } = V0(t, e);
  return R0(r, n, s, o, i, a, 0) - Math.floor(t / 1e3) * 1e3;
}
const Am = /* @__PURE__ */ new Map();
function V0(t, e) {
  let r = Am.get(e);
  r || (r = new Intl.DateTimeFormat("en-US", {
    timeZone: e,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), Am.set(e, r));
  let n = r.formatToParts(new Date(t)), s = {};
  for (let o of n) o.type !== "literal" && (s[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: s.era === "BC" || s.era === "B" ? -s.year + 1 : +s.year,
    month: +s.month,
    day: +s.day,
    hour: s.hour === "24" ? 0 : +s.hour,
    minute: +s.minute,
    second: +s.second
  };
}
const ml = 864e5;
function dD(t, e) {
  let r = es(t), n = r - xi(r - ml, e), s = r - xi(r + ml, e);
  return L0(t, e, n, s);
}
function L0(t, e, r, n) {
  return (r === n ? [
    r
  ] : [
    r,
    n
  ]).filter((o) => fD(t, e, o));
}
function fD(t, e, r) {
  let n = V0(r, e);
  return t.year === n.year && t.month === n.month && t.day === n.day && t.hour === n.hour && t.minute === n.minute && t.second === n.second;
}
function Gr(t, e, r = "compatible") {
  let n = ts(t);
  if (e === "UTC") return es(n);
  if (e === ft() && r === "compatible") {
    n = fr(n, new wo());
    let l = /* @__PURE__ */ new Date(), u = Pf(n.era, n.year);
    return l.setFullYear(u, n.month - 1, n.day), l.setHours(n.hour, n.minute, n.second, n.millisecond), l.getTime();
  }
  let s = es(n), o = xi(s - ml, e), i = xi(s + ml, e), a = L0(n, e, s - o, s - i);
  if (a.length === 1) return a[0];
  if (a.length > 1) switch (r) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return a[0];
    case "later":
      return a[a.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (r) {
    case "earlier":
      return Math.min(s - o, s - i);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(s - o, s - i);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function j0(t, e, r = "compatible") {
  return new Date(Gr(t, e, r));
}
function Zr(t, e) {
  let r = xi(t, e), n = new Date(t + r), s = n.getUTCFullYear(), o = n.getUTCMonth() + 1, i = n.getUTCDate(), a = n.getUTCHours(), l = n.getUTCMinutes(), u = n.getUTCSeconds(), c = n.getUTCMilliseconds();
  return new on(s < 1 ? "BC" : "AD", s < 1 ? -s + 1 : s, o, i, e, r, a, l, u, c);
}
function hD(t) {
  return new rs(t.calendar, t.era, t.year, t.month, t.day);
}
function ts(t, e) {
  let r = 0, n = 0, s = 0, o = 0;
  if ("timeZone" in t) ({ hour: r, minute: n, second: s, millisecond: o } = t);
  else if ("hour" in t && !e) return t;
  return e && ({ hour: r, minute: n, second: s, millisecond: o } = e), new Tn(t.calendar, t.era, t.year, t.month, t.day, r, n, s, o);
}
function fr(t, e) {
  if (M0(t.calendar, e)) return t;
  let r = e.fromJulianDay(t.calendar.toJulianDay(t)), n = t.copy();
  return n.calendar = e, n.era = r.era, n.year = r.year, n.month = r.month, n.day = r.day, Ls(n), n;
}
function gD(t, e, r) {
  if (t instanceof on)
    return t.timeZone === e ? t : mD(t, e);
  let n = Gr(t, e, r);
  return Zr(n, e);
}
function pD(t) {
  let e = es(t) - t.offset;
  return new Date(e);
}
function mD(t, e) {
  let r = es(t) - t.offset;
  return fr(Zr(r, e), t.calendar);
}
const ni = 36e5;
function uu(t, e) {
  let r = t.copy(), n = "hour" in r ? _D(r, e) : 0;
  qc(r, e.years || 0), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, t), r.month += e.months || 0, Uc(r), B0(r), r.day += (e.weeks || 0) * 7, r.day += e.days || 0, r.day += n, vD(r), r.calendar.balanceDate && r.calendar.balanceDate(r), r.year < 1 && (r.year = 1, r.month = 1, r.day = 1);
  let s = r.calendar.getYearsInEra(r);
  if (r.year > s) {
    var o, i;
    let l = (o = (i = r.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(i, r);
    r.year = s, r.month = l ? 1 : r.calendar.getMonthsInYear(r), r.day = l ? 1 : r.calendar.getDaysInMonth(r);
  }
  r.month < 1 && (r.month = 1, r.day = 1);
  let a = r.calendar.getMonthsInYear(r);
  return r.month > a && (r.month = a, r.day = r.calendar.getDaysInMonth(r)), r.day = Math.max(1, Math.min(r.calendar.getDaysInMonth(r), r.day)), r;
}
function qc(t, e) {
  var r, n;
  !((r = (n = t.calendar).isInverseEra) === null || r === void 0) && r.call(n, t) && (e = -e), t.year += e;
}
function Uc(t) {
  for (; t.month < 1; )
    qc(t, -1), t.month += t.calendar.getMonthsInYear(t);
  let e = 0;
  for (; t.month > (e = t.calendar.getMonthsInYear(t)); )
    t.month -= e, qc(t, 1);
}
function vD(t) {
  for (; t.day < 1; )
    t.month--, Uc(t), t.day += t.calendar.getDaysInMonth(t);
  for (; t.day > t.calendar.getDaysInMonth(t); )
    t.day -= t.calendar.getDaysInMonth(t), t.month++, Uc(t);
}
function B0(t) {
  t.month = Math.max(1, Math.min(t.calendar.getMonthsInYear(t), t.month)), t.day = Math.max(1, Math.min(t.calendar.getDaysInMonth(t), t.day));
}
function Ls(t) {
  t.calendar.constrainDate && t.calendar.constrainDate(t), t.year = Math.max(1, Math.min(t.calendar.getYearsInEra(t), t.year)), B0(t);
}
function z0(t) {
  let e = {};
  for (let r in t) typeof t[r] == "number" && (e[r] = -t[r]);
  return e;
}
function q0(t, e) {
  return uu(t, z0(e));
}
function Of(t, e) {
  let r = t.copy();
  return e.era != null && (r.era = e.era), e.year != null && (r.year = e.year), e.month != null && (r.month = e.month), e.day != null && (r.day = e.day), Ls(r), r;
}
function vl(t, e) {
  let r = t.copy();
  return e.hour != null && (r.hour = e.hour), e.minute != null && (r.minute = e.minute), e.second != null && (r.second = e.second), e.millisecond != null && (r.millisecond = e.millisecond), bD(r), r;
}
function yD(t) {
  t.second += Math.floor(t.millisecond / 1e3), t.millisecond = Va(t.millisecond, 1e3), t.minute += Math.floor(t.second / 60), t.second = Va(t.second, 60), t.hour += Math.floor(t.minute / 60), t.minute = Va(t.minute, 60);
  let e = Math.floor(t.hour / 24);
  return t.hour = Va(t.hour, 24), e;
}
function bD(t) {
  t.millisecond = Math.max(0, Math.min(t.millisecond, 1e3)), t.second = Math.max(0, Math.min(t.second, 59)), t.minute = Math.max(0, Math.min(t.minute, 59)), t.hour = Math.max(0, Math.min(t.hour, 23));
}
function Va(t, e) {
  let r = t % e;
  return r < 0 && (r += e), r;
}
function _D(t, e) {
  return t.hour += e.hours || 0, t.minute += e.minutes || 0, t.second += e.seconds || 0, t.millisecond += e.milliseconds || 0, yD(t);
}
function Cf(t, e, r, n) {
  let s = t.copy();
  switch (e) {
    case "era": {
      let a = t.calendar.getEras(), l = a.indexOf(t.era);
      if (l < 0) throw new Error("Invalid era: " + t.era);
      l = wn(l, r, 0, a.length - 1, n?.round), s.era = a[l], Ls(s);
      break;
    }
    case "year":
      var o, i;
      !((o = (i = s.calendar).isInverseEra) === null || o === void 0) && o.call(i, s) && (r = -r), s.year = wn(t.year, r, -1 / 0, 9999, n?.round), s.year === -1 / 0 && (s.year = 1), s.calendar.balanceYearMonth && s.calendar.balanceYearMonth(s, t);
      break;
    case "month":
      s.month = wn(t.month, r, 1, t.calendar.getMonthsInYear(t), n?.round);
      break;
    case "day":
      s.day = wn(t.day, r, 1, t.calendar.getDaysInMonth(t), n?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return t.calendar.balanceDate && t.calendar.balanceDate(s), Ls(s), s;
}
function U0(t, e, r, n) {
  let s = t.copy();
  switch (e) {
    case "hour": {
      let o = t.hour, i = 0, a = 23;
      if (n?.hourCycle === 12) {
        let l = o >= 12;
        i = l ? 12 : 0, a = l ? 23 : 11;
      }
      s.hour = wn(o, r, i, a, n?.round);
      break;
    }
    case "minute":
      s.minute = wn(t.minute, r, 0, 59, n?.round);
      break;
    case "second":
      s.second = wn(t.second, r, 0, 59, n?.round);
      break;
    case "millisecond":
      s.millisecond = wn(t.millisecond, r, 0, 999, n?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return s;
}
function wn(t, e, r, n, s = !1) {
  if (s) {
    t += Math.sign(e), t < r && (t = n);
    let o = Math.abs(e);
    e > 0 ? t = Math.ceil(t / o) * o : t = Math.floor(t / o) * o, t > n && (t = r);
  } else
    t += e, t < r ? t = n - (r - t - 1) : t > n && (t = r + (t - n - 1));
  return t;
}
function K0(t, e) {
  let r;
  if (e.years != null && e.years !== 0 || e.months != null && e.months !== 0 || e.weeks != null && e.weeks !== 0 || e.days != null && e.days !== 0) {
    let s = uu(ts(t), {
      years: e.years,
      months: e.months,
      weeks: e.weeks,
      days: e.days
    });
    r = Gr(s, t.timeZone);
  } else
    r = es(t) - t.offset;
  r += e.milliseconds || 0, r += (e.seconds || 0) * 1e3, r += (e.minutes || 0) * 6e4, r += (e.hours || 0) * 36e5;
  let n = Zr(r, t.timeZone);
  return fr(n, t.calendar);
}
function wD(t, e) {
  return K0(t, z0(e));
}
function SD(t, e, r, n) {
  switch (e) {
    case "hour": {
      let s = 0, o = 23;
      if (n?.hourCycle === 12) {
        let b = t.hour >= 12;
        s = b ? 12 : 0, o = b ? 23 : 11;
      }
      let i = ts(t), a = fr(vl(i, {
        hour: s
      }), new wo()), l = [
        Gr(a, t.timeZone, "earlier"),
        Gr(a, t.timeZone, "later")
      ].filter((b) => Zr(b, t.timeZone).day === a.day)[0], u = fr(vl(i, {
        hour: o
      }), new wo()), c = [
        Gr(u, t.timeZone, "earlier"),
        Gr(u, t.timeZone, "later")
      ].filter((b) => Zr(b, t.timeZone).day === u.day).pop(), f = es(t) - t.offset, h = Math.floor(f / ni), _ = f % ni;
      return f = wn(h, r, Math.floor(l / ni), Math.floor(c / ni), n?.round) * ni + _, fr(Zr(f, t.timeZone), t.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return U0(t, e, r, n);
    case "era":
    case "year":
    case "month":
    case "day": {
      let s = Cf(ts(t), e, r, n), o = Gr(s, t.timeZone);
      return fr(Zr(o, t.timeZone), t.calendar);
    }
    default:
      throw new Error("Unsupported field " + e);
  }
}
function xD(t, e, r) {
  let n = ts(t), s = vl(Of(n, e), e);
  if (s.compare(n) === 0) return t;
  let o = Gr(s, t.timeZone, r);
  return fr(Zr(o, t.timeZone), t.calendar);
}
const PD = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})$/, OD = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/, CD = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?(?::?(\d{2}))?)?\[(.*?)\]$/, W0 = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
function Pi(t) {
  let e = t.match(PD);
  if (!e)
    throw W0.test(t) ? new Error(`Invalid ISO 8601 date string: ${t}. Use parseAbsolute() instead.`) : new Error("Invalid ISO 8601 date string: " + t);
  let r = new rs(mt(e[1], 0, 9999), mt(e[2], 1, 12), 1);
  return r.day = mt(e[3], 1, r.calendar.getDaysInMonth(r)), r;
}
function H0(t) {
  let e = t.match(OD);
  if (!e)
    throw W0.test(t) ? new Error(`Invalid ISO 8601 date time string: ${t}. Use parseAbsolute() instead.`) : new Error("Invalid ISO 8601 date time string: " + t);
  let r = mt(e[1], -9999, 9999), n = r < 1 ? "BC" : "AD", s = new Tn(n, r < 1 ? -r + 1 : r, mt(e[2], 1, 12), 1, e[4] ? mt(e[4], 0, 23) : 0, e[5] ? mt(e[5], 0, 59) : 0, e[6] ? mt(e[6], 0, 59) : 0, e[7] ? mt(e[7], 0, 1 / 0) * 1e3 : 0);
  return s.day = mt(e[3], 0, s.calendar.getDaysInMonth(s)), s;
}
function G0(t, e) {
  let r = t.match(CD);
  if (!r) throw new Error("Invalid ISO 8601 date time string: " + t);
  let n = mt(r[1], -9999, 9999), s = n < 1 ? "BC" : "AD", o = new on(s, n < 1 ? -n + 1 : n, mt(r[2], 1, 12), 1, r[11], 0, r[4] ? mt(r[4], 0, 23) : 0, r[5] ? mt(r[5], 0, 59) : 0, r[6] ? mt(r[6], 0, 59) : 0, r[7] ? mt(r[7], 0, 1 / 0) * 1e3 : 0);
  o.day = mt(r[3], 0, o.calendar.getDaysInMonth(o));
  let i = ts(o), a;
  if (r[8]) {
    let c = mt(r[8], -23, 23);
    var l, u;
    if (o.offset = Math.sign(c) * (Math.abs(c) * 36e5 + mt((l = r[9]) !== null && l !== void 0 ? l : "0", 0, 59) * 6e4 + mt((u = r[10]) !== null && u !== void 0 ? u : "0", 0, 59) * 1e3), a = es(o) - o.offset, !dD(i, o.timeZone).includes(a)) throw new Error(`Offset ${X0(o.offset)} is invalid for ${kf(o)} in ${o.timeZone}`);
  } else
    a = Gr(ts(i), o.timeZone, e);
  return Zr(a, o.timeZone);
}
function mt(t, e, r) {
  let n = Number(t);
  if (n < e || n > r) throw new RangeError(`Value out of range: ${e} <= ${n} <= ${r}`);
  return n;
}
function kD(t) {
  return `${String(t.hour).padStart(2, "0")}:${String(t.minute).padStart(2, "0")}:${String(t.second).padStart(2, "0")}${t.millisecond ? String(t.millisecond / 1e3).slice(1) : ""}`;
}
function Y0(t) {
  let e = fr(t, new wo()), r;
  return e.era === "BC" ? r = e.year === 1 ? "0000" : "-" + String(Math.abs(1 - e.year)).padStart(6, "00") : r = String(e.year).padStart(4, "0"), `${r}-${String(e.month).padStart(2, "0")}-${String(e.day).padStart(2, "0")}`;
}
function kf(t) {
  return `${Y0(t)}T${kD(t)}`;
}
function X0(t) {
  let e = Math.sign(t) < 0 ? "-" : "+";
  t = Math.abs(t);
  let r = Math.floor(t / 36e5), n = Math.floor(t % 36e5 / 6e4), s = Math.floor(t % 36e5 % 6e4 / 1e3), o = `${e}${String(r).padStart(2, "0")}:${String(n).padStart(2, "0")}`;
  return s !== 0 && (o += `:${String(s).padStart(2, "0")}`), o;
}
function $D(t) {
  return `${kf(t)}${X0(t.offset)}[${t.timeZone}]`;
}
function AD(t, e) {
  if (e.has(t))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function $f(t, e, r) {
  AD(t, e), e.set(t, r);
}
function Af(t) {
  let e = typeof t[0] == "object" ? t.shift() : new wo(), r;
  if (typeof t[0] == "string") r = t.shift();
  else {
    let i = e.getEras();
    r = i[i.length - 1];
  }
  let n = t.shift(), s = t.shift(), o = t.shift();
  return [
    e,
    r,
    n,
    s,
    o
  ];
}
var ED = /* @__PURE__ */ new WeakMap();
class rs {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new rs(this.calendar, this.era, this.year, this.month, this.day) : new rs(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(e) {
    return uu(this, e);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(e) {
    return q0(this, e);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return Of(this, e);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    return Cf(this, e, r, n);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(e) {
    return j0(this, e);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Y0(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return F0(this, e);
  }
  constructor(...e) {
    $f(this, ED, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = Af(e);
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, Ls(this);
  }
}
var TD = /* @__PURE__ */ new WeakMap();
class Tn {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Tn(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Tn(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(e) {
    return uu(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return q0(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return Of(vl(this, e), e);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    switch (e) {
      case "era":
      case "year":
      case "month":
      case "day":
        return Cf(this, e, r, n);
      default:
        return U0(this, e, r, n);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(e, r) {
    return j0(this, e, r);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return kf(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    let r = F0(this, e);
    return r === 0 ? aD(this, ts(e)) : r;
  }
  constructor(...e) {
    $f(this, TD, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = Af(e);
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, Ls(this);
  }
}
var DD = /* @__PURE__ */ new WeakMap();
class on {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new on(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new on(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(e) {
    return K0(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return wD(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e, r) {
    return xD(this, e, r);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    return SD(this, e, r, n);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return pD(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return $D(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return this.toDate().getTime() - gD(e, this.timeZone).toDate().getTime();
  }
  constructor(...e) {
    $f(this, DD, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = Af(e), a = e.shift(), l = e.shift();
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, this.timeZone = a, this.offset = l, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, Ls(this);
  }
}
let ec = /* @__PURE__ */ new Map();
class jt {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(e) {
    return this.formatter.format(e);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(e) {
    return this.formatter.formatToParts(e);
  }
  /** Formats a date range as a string. */
  formatRange(e, r) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(e, r);
    if (r < e) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(e)} â€“ ${this.formatter.format(r)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(e, r) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(e, r);
    if (r < e) throw new RangeError("End date must be >= start date");
    let n = this.formatter.formatToParts(e), s = this.formatter.formatToParts(r);
    return [
      ...n.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " â€“ ",
        source: "shared"
      },
      ...s.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let e = this.formatter.resolvedOptions();
    return ND() && (this.resolvedHourCycle || (this.resolvedHourCycle = FD(e.locale, this.options)), e.hourCycle = this.resolvedHourCycle, e.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), e.calendar === "ethiopic-amete-alem" && (e.calendar = "ethioaa"), e;
  }
  constructor(e, r = {}) {
    this.formatter = J0(e, r), this.options = r;
  }
}
const MD = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function J0(t, e = {}) {
  if (typeof e.hour12 == "boolean" && ID()) {
    e = {
      ...e
    };
    let s = MD[String(e.hour12)][t.split("-")[0]], o = e.hour12 ? "h12" : "h23";
    e.hourCycle = s ?? o, delete e.hour12;
  }
  let r = t + (e ? Object.entries(e).sort((s, o) => s[0] < o[0] ? -1 : 1).join() : "");
  if (ec.has(r)) return ec.get(r);
  let n = new Intl.DateTimeFormat(t, e);
  return ec.set(r, n), n;
}
let tc = null;
function ID() {
  return tc == null && (tc = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), tc;
}
let rc = null;
function ND() {
  return rc == null && (rc = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), rc;
}
function FD(t, e) {
  if (!e.timeStyle && !e.hour) return;
  t = t.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), t += (t.includes("-u-") ? "" : "-u") + "-nu-latn";
  let r = J0(t, {
    ...e,
    timeZone: void 0
    // use local timezone
  }), n = parseInt(r.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), s = parseInt(r.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (n === 0 && s === 23) return "h23";
  if (n === 24 && s === 23) return "h24";
  if (n === 0 && s === 11) return "h11";
  if (n === 12 && s === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function RD(t) {
  if (!Bi || !t)
    return null;
  let e = t.querySelector("[data-bits-announcer]");
  const r = (s) => {
    const o = t.createElement("div");
    return o.role = "log", o.ariaLive = s, o.setAttribute("aria-relevant", "additions"), o;
  };
  if (!Cn(e)) {
    const s = t.createElement("div");
    s.style.cssText = s0, s.setAttribute("data-bits-announcer", ""), s.appendChild(r("assertive")), s.appendChild(r("polite")), e = s, t.body.insertBefore(e, t.body.firstChild);
  }
  return {
    getLog: (s) => {
      if (!Cn(e))
        return null;
      const o = e.querySelector(`[aria-live="${s}"]`);
      return Cn(o) ? o : null;
    }
  };
}
function yl(t) {
  const e = RD(t);
  function r(n, s = "assertive", o = 7500) {
    if (!e || !Bi || !t)
      return;
    const i = e.getLog(s), a = t.createElement("div");
    return typeof n == "number" ? n = n.toString() : n === null ? n = "Empty" : n = n.trim(), a.innerText = n, s === "assertive" ? i?.replaceChildren(a) : i?.appendChild(a), setTimeout(() => {
      a.remove();
    }, o);
  }
  return {
    announce: r
  };
}
const VD = {
  defaultValue: void 0,
  granularity: "day"
};
function Z0(t) {
  const e = { ...VD, ...t }, { defaultValue: r, granularity: n, minValue: s, maxValue: o } = e;
  if (Array.isArray(r) && r.length)
    return r[r.length - 1];
  if (r && !Array.isArray(r))
    return r;
  {
    let i = /* @__PURE__ */ new Date();
    s && i < s.toDate(ft()) ? i = s.toDate(ft()) : o && i > o.toDate(ft()) && (i = o.toDate(ft()));
    const a = i.getFullYear(), l = i.getMonth() + 1, u = i.getDate();
    return ["hour", "minute", "second"].includes(n ?? "day") ? new Tn(a, l, u, 0, 0, 0) : new rs(a, l, u);
  }
}
function Q0(t, e) {
  let r;
  return e instanceof on ? r = G0(t) : e instanceof Tn ? r = H0(t) : r = Pi(t), r.calendar !== e.calendar ? fr(r, e.calendar) : r;
}
function _r(t, e = ft()) {
  return t instanceof on ? t.toDate() : t.toDate(e);
}
function ew(t) {
  if (t instanceof rs)
    return "date";
  if (t instanceof Tn)
    return "datetime";
  if (t instanceof on)
    return "zoneddatetime";
  throw new Error("Unknown date type");
}
function LD(t, e) {
  switch (e) {
    case "date":
      return Pi(t);
    case "datetime":
      return H0(t);
    case "zoneddatetime":
      return G0(t);
    default:
      throw new Error(`Unknown date type: ${e}`);
  }
}
function jD(t) {
  return t instanceof Tn;
}
function tw(t) {
  return t instanceof on;
}
function Kc(t) {
  return jD(t) || tw(t);
}
function BD(t) {
  if (t instanceof Date) {
    const e = t.getFullYear(), r = t.getMonth() + 1;
    return new Date(e, r, 0).getDate();
  } else
    return t.set({ day: 100 }).day;
}
function Bt(t, e) {
  return t.compare(e) < 0;
}
function rw(t, e) {
  return t.compare(e) > 0;
}
function zD(t, e) {
  return t.compare(e) <= 0;
}
function qD(t, e) {
  return t.compare(e) >= 0;
}
function nw(t, e, r) {
  return qD(t, e) && zD(t, r);
}
function Em(t, e, r) {
  const n = N0(t, r);
  return e > n ? t.subtract({ days: n + 7 - e }) : e === n ? t : t.subtract({ days: n - e });
}
function Tm(t, e, r) {
  const n = N0(t, r), s = e === 0 ? 6 : e - 1;
  return n === s ? t : n > s ? t.add({ days: 7 - n + s }) : t.add({ days: s - n });
}
function UD(t, e, r, n) {
  if (r === void 0 && n === void 0)
    return !0;
  let s = t.add({ days: 1 });
  if (n?.(s) || r?.(s))
    return !1;
  const o = e;
  for (; s.compare(o) < 0; )
    if (s = s.add({ days: 1 }), n?.(s) || r?.(s))
      return !1;
  return !0;
}
const KD = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function sw(t) {
  let e = t.initialLocale;
  function r(_) {
    e = _;
  }
  function n() {
    return e;
  }
  function s(_, b) {
    return new jt(e, b).format(_);
  }
  function o(_, b = !0) {
    return Kc(_) && b ? s(_r(_), {
      dateStyle: "long",
      timeStyle: "long"
    }) : s(_r(_), {
      dateStyle: "long"
    });
  }
  function i(_) {
    if (typeof t.monthFormat.current != "function" && typeof t.yearFormat.current != "function")
      return new jt(e, {
        month: t.monthFormat.current,
        year: t.yearFormat.current
      }).format(_);
    const b = typeof t.monthFormat.current == "function" ? t.monthFormat.current(_.getMonth() + 1) : new jt(e, { month: t.monthFormat.current }).format(_), p = typeof t.yearFormat.current == "function" ? t.yearFormat.current(_.getFullYear()) : new jt(e, { year: t.yearFormat.current }).format(_);
    return `${b} ${p}`;
  }
  function a(_) {
    return new jt(e, { month: "long" }).format(_);
  }
  function l(_) {
    return new jt(e, { year: "numeric" }).format(_);
  }
  function u(_, b) {
    return tw(_) ? new jt(e, {
      ...b,
      timeZone: _.timeZone
    }).formatToParts(_r(_)) : new jt(e, b).formatToParts(_r(_));
  }
  function c(_, b = "narrow") {
    return new jt(e, { weekday: b }).format(_);
  }
  function f(_, b = void 0) {
    return new jt(e, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: b === 24 ? "h23" : void 0
    }).formatToParts(_).find((y) => y.type === "dayPeriod")?.value === "PM" ? "PM" : "AM";
  }
  function h(_, b, p = {}) {
    const g = { ...KD, ...p }, S = u(_, g).find((x) => x.type === b);
    return S ? S.value : "";
  }
  return {
    setLocale: r,
    getLocale: n,
    fullMonth: a,
    fullYear: l,
    fullMonthAndYear: i,
    toParts: u,
    custom: s,
    part: h,
    dayPeriod: f,
    selectedDate: o,
    dayOfWeek: c
  };
}
function WD(t) {
  return !(!Cn(t) || !t.hasAttribute("data-bits-day"));
}
function Dm(t, e) {
  const r = [];
  let n = t.add({ days: 1 });
  const s = e;
  for (; n.compare(s) < 0; )
    r.push(n), n = n.add({ days: 1 });
  return r;
}
function nc(t) {
  const { dateObj: e, weekStartsOn: r, fixedWeeks: n, locale: s } = t, o = BD(e), i = Array.from({ length: o }, (g, y) => e.set({ day: y + 1 })), a = zc(e), l = lD(e), u = r !== void 0 ? Em(a, r, "en-US") : Em(a, 0, s), c = r !== void 0 ? Tm(l, r, "en-US") : Tm(l, 0, s), f = Dm(u.subtract({ days: 1 }), a), h = Dm(l, c.add({ days: 1 })), _ = f.length + i.length + h.length;
  if (n && _ < 42) {
    const g = 42 - _;
    let y = h[h.length - 1];
    y || (y = e.add({ months: 1 }).set({ day: 1 }));
    let S = g;
    h.length === 0 && (S = g - 1, h.push(y));
    const x = Array.from({ length: S }, (P, w) => {
      const C = w + 1;
      return y.add({ days: C });
    });
    h.push(...x);
  }
  const b = f.concat(i, h), p = NT(b, 7);
  return { value: e, dates: b, weeks: p };
}
function jo(t) {
  const { numberOfMonths: e, dateObj: r, ...n } = t, s = [];
  if (!e || e === 1)
    return s.push(nc({ ...n, dateObj: r })), s;
  s.push(nc({ ...n, dateObj: r }));
  for (let o = 1; o < e; o++) {
    const i = r.add({ months: o });
    s.push(nc({ ...n, dateObj: i }));
  }
  return s;
}
function sc(t) {
  return t ? Array.from(t.querySelectorAll("[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])")).filter((r) => Cn(r)) : [];
}
function Mm(t, e) {
  const r = t.getAttribute("data-value");
  r && (e.current = Q0(r, e.current));
}
function ow({
  node: t,
  add: e,
  placeholder: r,
  calendarNode: n,
  isPrevButtonDisabled: s,
  isNextButtonDisabled: o,
  months: i,
  numberOfMonths: a
}) {
  const l = sc(n);
  if (!l.length) return;
  const c = l.indexOf(t) + e;
  if (Ha(c, l)) {
    const f = l[c];
    return Mm(f, r), f.focus();
  }
  if (c < 0) {
    if (s) return;
    const f = i[0]?.value;
    if (!f) return;
    r.current = f.subtract({ months: a }), Jt(() => {
      const h = sc(n);
      if (!h.length) return;
      const _ = h.length - Math.abs(c);
      if (Ha(_, h)) {
        const b = h[_];
        return Mm(b, r), b.focus();
      }
    });
  }
  if (c >= l.length) {
    if (o) return;
    const f = i[0]?.value;
    if (!f) return;
    r.current = f.add({ months: a }), Jt(() => {
      const h = sc(n);
      if (!h.length) return;
      const _ = c - l.length;
      if (Ha(_, h))
        return h[_].focus();
    });
  }
}
const Im = [
  dr,
  Qt,
  ds,
  fs
], Nm = [Br, xr];
function iw({ event: t, handleCellClick: e, shiftFocus: r, placeholderValue: n }) {
  const s = t.target;
  if (!WD(s) || !Im.includes(t.key) && !Nm.includes(t.key)) return;
  t.preventDefault();
  const o = {
    [dr]: 7,
    [Qt]: -7,
    [ds]: -1,
    [fs]: 1
  };
  if (Im.includes(t.key)) {
    const i = o[t.key];
    i !== void 0 && r(s, i);
  }
  if (Nm.includes(t.key)) {
    const i = s.getAttribute("data-value");
    if (!i) return;
    e(t, Q0(i, n));
  }
}
function aw({
  months: t,
  setMonths: e,
  numberOfMonths: r,
  pagedNavigation: n,
  weekStartsOn: s,
  locale: o,
  fixedWeeks: i,
  setPlaceholder: a
}) {
  const l = t[0]?.value;
  if (l)
    if (n)
      a(l.add({ months: r }));
    else {
      const u = l.add({ months: 1 }), c = jo({
        dateObj: u,
        weekStartsOn: s,
        locale: o,
        fixedWeeks: i,
        numberOfMonths: r
      });
      a(u), e(c);
    }
}
function lw({
  months: t,
  setMonths: e,
  numberOfMonths: r,
  pagedNavigation: n,
  weekStartsOn: s,
  locale: o,
  fixedWeeks: i,
  setPlaceholder: a
}) {
  const l = t[0]?.value;
  if (l)
    if (n)
      a(l.subtract({ months: r }));
    else {
      const u = l.subtract({ months: 1 }), c = jo({
        dateObj: u,
        weekStartsOn: s,
        locale: o,
        fixedWeeks: i,
        numberOfMonths: r
      });
      a(u), e(c);
    }
}
function uw({ months: t, formatter: e, weekdayFormat: r }) {
  if (!t.length) return [];
  const s = t[0].weeks[0];
  return s ? s.map((o) => e.dayOfWeek(_r(o), r)) : [];
}
function cw(t) {
  Xe(() => {
    const e = t.weekStartsOn.current, r = t.locale.current, n = t.fixedWeeks.current, s = t.numberOfMonths.current;
    ot(() => {
      const o = t.placeholder.current;
      if (!o) return;
      const i = { weekStartsOn: e, locale: r, fixedWeeks: n, numberOfMonths: s };
      t.setMonths(jo({ ...i, dateObj: o }));
    });
  });
}
function HD({ calendarNode: t, label: e, accessibleHeadingId: r }) {
  const n = nf(t), s = n.createElement("div");
  s.style.cssText = iu({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const o = n.createElement("div");
  return o.textContent = e, o.id = r, o.role = "heading", o.ariaLevel = "2", t.insertBefore(s, t.firstChild), s.appendChild(o), () => {
    const i = n.getElementById(r);
    i && (s.parentElement?.removeChild(s), i.remove());
  };
}
function dw({
  placeholder: t,
  getVisibleMonths: e,
  weekStartsOn: r,
  locale: n,
  fixedWeeks: s,
  numberOfMonths: o,
  setMonths: i
}) {
  Xe(() => {
    t.current, ot(() => {
      if (e().some((l) => Lo(l, t.current)))
        return;
      const a = {
        weekStartsOn: r.current,
        locale: n.current,
        fixedWeeks: s.current,
        numberOfMonths: o.current
      };
      i(jo({ ...a, dateObj: t.current }));
    });
  });
}
function fw({ maxValue: t, months: e, disabled: r }) {
  if (!t || !e.length) return !1;
  if (r) return !0;
  const n = e[e.length - 1]?.value;
  if (!n) return !1;
  const s = n.add({ months: 1 }).set({ day: 1 });
  return rw(s, t);
}
function hw({ minValue: t, months: e, disabled: r }) {
  if (!t || !e.length) return !1;
  if (r) return !0;
  const n = e[0]?.value;
  if (!n) return !1;
  const s = n.subtract({ months: 1 }).set({ day: 35 });
  return Bt(s, t);
}
function gw({ months: t, locale: e, formatter: r }) {
  if (!t.length) return "";
  if (e !== r.getLocale() && r.setLocale(e), t.length === 1) {
    const c = _r(t[0].value);
    return `${r.fullMonthAndYear(c)}`;
  }
  const n = _r(t[0].value), s = _r(t[t.length - 1].value), o = r.fullMonth(n), i = r.fullMonth(s), a = r.fullYear(n), l = r.fullYear(s);
  return a === l ? `${o} - ${i} ${l}` : `${o} ${a} - ${i} ${l}`;
}
function pw({ fullCalendarLabel: t, id: e, isInvalid: r, disabled: n, readonly: s }) {
  return {
    id: e,
    role: "application",
    "aria-label": t,
    "data-invalid": Re(r),
    "data-disabled": Re(n),
    "data-readonly": Re(s)
  };
}
function GD(t) {
  if (!Bi) return;
  const e = Array.from(t.querySelectorAll("[data-bits-day]:not([aria-disabled=true])"));
  if (e.length === 0) return;
  const r = e[0], n = r?.getAttribute("data-value"), s = r?.getAttribute("data-type");
  if (!(!n || !s))
    return LD(n, s);
}
function mw({
  ref: t,
  placeholder: e,
  defaultPlaceholder: r,
  minValue: n,
  maxValue: s,
  isDateDisabled: o
}) {
  function i(a) {
    return !!(o.current(a) || n.current && Bt(a, n.current) || s.current && Bt(s.current, a));
  }
  Fe(() => t.current, () => {
    t.current && e.current && _t(e.current, r) && i(r) && (e.current = GD(t.current) ?? r);
  });
}
function YD(t, e) {
  return !t || !e ? t : Kc(t) && Kc(e) ? t.set({
    hour: e.hour,
    minute: e.minute,
    millisecond: e.millisecond,
    second: e.second
  }) : t;
}
const vw = nr({
  component: "calendar",
  parts: [
    "root",
    "grid",
    "cell",
    "next-button",
    "prev-button",
    "day",
    "grid-body",
    "grid-head",
    "grid-row",
    "head-cell",
    "header",
    "heading",
    "month-select",
    "year-select"
  ]
});
function yw(t) {
  const e = (/* @__PURE__ */ new Date()).getFullYear(), r = Math.max(t.placeholderYear, e);
  let n, s;
  if (t.minValue)
    n = t.minValue.year;
  else {
    const i = r - 100;
    n = t.placeholderYear < i ? t.placeholderYear - 10 : i;
  }
  t.maxValue ? s = t.maxValue.year : s = r + 10, n > s && (n = s);
  const o = s - n + 1;
  return Array.from({ length: o }, (i, a) => n + a);
}
const Ut = new ht("Calendar.Root | RangeCalender.Root");
class Ef {
  static create(e) {
    return Ut.set(new Ef(e));
  }
  opts;
  #e = /* @__PURE__ */ O(() => this.months.map((e) => e.value));
  get visibleMonths() {
    return d(this.#e);
  }
  set visibleMonths(e) {
    q(this.#e, e);
  }
  formatter;
  accessibleHeadingId = En();
  domContext;
  attachment;
  #t = /* @__PURE__ */ xe(Pt([]));
  get months() {
    return d(this.#t);
  }
  set months(e) {
    q(this.#t, e, !0);
  }
  announcer;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.domContext = new Fn(e.ref), this.announcer = yl(null), this.formatter = sw({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    }), this.setMonths = this.setMonths.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.prevYear = this.prevYear.bind(this), this.nextYear = this.nextYear.bind(this), this.setYear = this.setYear.bind(this), this.setMonth = this.setMonth.bind(this), this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this), this.isDateDisabled = this.isDateDisabled.bind(this), this.isDateSelected = this.isDateSelected.bind(this), this.shiftFocus = this.shiftFocus.bind(this), this.handleCellClick = this.handleCellClick.bind(this), this.handleMultipleUpdate = this.handleMultipleUpdate.bind(this), this.handleSingleUpdate = this.handleSingleUpdate.bind(this), this.onkeydown = this.onkeydown.bind(this), this.getBitsAttr = this.getBitsAttr.bind(this), $o(() => {
      this.announcer = yl(this.domContext.getDocument());
    }), this.months = jo({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    }), this.#o(), this.#i(), this.#a(), dw({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: (r) => this.months = r
    }), cw({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    }), Fe(() => this.fullCalendarLabel, (r) => {
      const n = this.domContext.getElementById(this.accessibleHeadingId);
      n && (n.textContent = r);
    }), Fe(() => this.opts.value.current, () => {
      const r = this.opts.value.current;
      if (Array.isArray(r) && r.length) {
        const n = r[r.length - 1];
        n && this.opts.placeholder.current !== n && (this.opts.placeholder.current = n);
      } else !Array.isArray(r) && r && this.opts.placeholder.current !== r && (this.opts.placeholder.current = r);
    }), mw({
      placeholder: e.placeholder,
      defaultPlaceholder: e.defaultPlaceholder,
      isDateDisabled: e.isDateDisabled,
      maxValue: e.maxValue,
      minValue: e.minValue,
      ref: e.ref
    });
  }
  setMonths(e) {
    this.months = e;
  }
  #r = /* @__PURE__ */ O(
    /**
     * This derived state holds an array of localized day names for the current
     * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,
     * updating its content when the option changes. Using this state to render the
     * calendar's days of the week is strongly recommended, as it guarantees that
     * the days are correctly formatted for the current locale and calendar view.
     */
    () => uw({
      months: this.months,
      formatter: this.formatter,
      weekdayFormat: this.opts.weekdayFormat.current
    })
  );
  get weekdays() {
    return d(this.#r);
  }
  set weekdays(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ot(() => this.opts.placeholder.current.year));
  get initialPlaceholderYear() {
    return d(this.#n);
  }
  set initialPlaceholderYear(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => yw({
    minValue: this.opts.minValue.current,
    maxValue: this.opts.maxValue.current,
    placeholderYear: this.initialPlaceholderYear
  }));
  get defaultYears() {
    return d(this.#s);
  }
  set defaultYears(e) {
    q(this.#s, e);
  }
  #o() {
    Xe(() => {
      if (ot(() => this.opts.initialFocus.current)) {
        const r = this.opts.ref.current?.querySelector("[data-focused]");
        r && r.focus();
      }
    });
  }
  #i() {
    Xe(() => this.opts.ref.current ? HD({
      calendarNode: this.opts.ref.current,
      label: this.fullCalendarLabel,
      accessibleHeadingId: this.accessibleHeadingId
    }) : void 0);
  }
  #a() {
    ko(() => {
      this.formatter.getLocale() !== this.opts.locale.current && this.formatter.setLocale(this.opts.locale.current);
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    aw({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    lw({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year: e });
  }
  setMonth(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month: e });
  }
  #u = /* @__PURE__ */ O(() => fw({
    maxValue: this.opts.maxValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isNextButtonDisabled() {
    return d(this.#u);
  }
  set isNextButtonDisabled(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => hw({
    minValue: this.opts.minValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isPrevButtonDisabled() {
    return d(this.#l);
  }
  set isPrevButtonDisabled(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => {
    const e = this.opts.value.current, r = this.opts.isDateDisabled.current, n = this.opts.isDateUnavailable.current;
    if (Array.isArray(e)) {
      if (!e.length) return !1;
      for (const s of e)
        if (r(s) || n(s)) return !0;
    } else {
      if (!e) return !1;
      if (r(e) || n(e)) return !0;
    }
    return !1;
  });
  get isInvalid() {
    return d(this.#c);
  }
  set isInvalid(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => (this.opts.monthFormat.current, this.opts.yearFormat.current, gw({
    months: this.months,
    formatter: this.formatter,
    locale: this.opts.locale.current
  })));
  get headingValue() {
    return d(this.#d);
  }
  set headingValue(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => `${this.opts.calendarLabel.current} ${this.headingValue}`);
  get fullCalendarLabel() {
    return d(this.#g);
  }
  set fullCalendarLabel(e) {
    q(this.#g, e);
  }
  isOutsideVisibleMonths(e) {
    return !this.visibleMonths.some((r) => Lo(e, r));
  }
  isDateDisabled(e) {
    if (this.opts.isDateDisabled.current(e) || this.opts.disabled.current) return !0;
    const r = this.opts.minValue.current, n = this.opts.maxValue.current;
    return !!(r && Bt(e, r) || n && Bt(n, e));
  }
  isDateSelected(e) {
    const r = this.opts.value.current;
    return Array.isArray(r) ? r.some((n) => _t(n, e)) : r ? _t(r, e) : !1;
  }
  shiftFocus(e, r) {
    return ow({
      node: e,
      add: r,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #m(e) {
    if (this.opts.type.current !== "multiple" || !this.opts.maxDays.current) return !0;
    const r = e.length;
    return !(this.opts.maxDays.current && r > this.opts.maxDays.current);
  }
  handleCellClick(e, r) {
    if (this.opts.readonly.current || this.opts.isDateDisabled.current?.(r) || this.opts.isDateUnavailable.current?.(r))
      return;
    const n = this.opts.value.current;
    if (this.opts.type.current === "multiple")
      (Array.isArray(n) || n === void 0) && (this.opts.value.current = this.handleMultipleUpdate(n, r));
    else if (!Array.isArray(n)) {
      const o = this.handleSingleUpdate(n, r);
      o ? this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(o, !1)}`, "polite") : this.announcer.announce("Selected date is now empty.", "polite", 5e3), this.opts.value.current = YD(o, n), o !== void 0 && this.opts.onDateSelect?.current?.();
    }
  }
  handleMultipleUpdate(e, r) {
    if (!e) {
      const o = [r];
      return this.#m(o) ? o : [r];
    }
    if (!Array.isArray(e))
      return;
    const n = e.findIndex((o) => _t(o, r)), s = this.opts.preventDeselect.current;
    if (n === -1) {
      const o = [...e, r];
      return this.#m(o) ? o : [r];
    } else {
      if (s)
        return e;
      {
        const o = e.filter((i) => !_t(i, r));
        if (!o.length) {
          this.opts.placeholder.current = r;
          return;
        }
        return o;
      }
    }
  }
  handleSingleUpdate(e, r) {
    if (!e) return r;
    if (!this.opts.preventDeselect.current && _t(e, r)) {
      this.opts.placeholder.current = r;
      return;
    }
    return r;
  }
  onkeydown(e) {
    iw({
      event: e,
      handleCellClick: this.handleCellClick,
      shiftFocus: this.shiftFocus,
      placeholderValue: this.opts.placeholder.current
    });
  }
  #p = /* @__PURE__ */ O(() => ({ months: this.months, weekdays: this.weekdays }));
  get snippetProps() {
    return d(this.#p);
  }
  set snippetProps(e) {
    q(this.#p, e);
  }
  getBitsAttr = (e) => vw.getAttr(e);
  #f = /* @__PURE__ */ O(() => ({
    ...pw({
      fullCalendarLabel: this.fullCalendarLabel,
      id: this.opts.id.current,
      isInvalid: this.isInvalid,
      disabled: this.opts.disabled.current,
      readonly: this.opts.readonly.current
    }),
    [this.getBitsAttr("root")]: "",
    //
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#f);
  }
  set props(e) {
    q(this.#f, e);
  }
}
class Tf {
  static create(e) {
    return new Tf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-hidden": sf(!0),
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("heading")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
const bw = new ht("Calendar.Cell | RangeCalendar.Cell");
class Df {
  static create(e) {
    return bw.set(new Df(e, Ut.get()));
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => _r(this.opts.date.current));
  get cellDate() {
    return d(this.#e);
  }
  set cellDate(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.root.opts.isDateUnavailable.current(this.opts.date.current));
  get isUnavailable() {
    return d(this.#t);
  }
  set isUnavailable(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => I0(this.opts.date.current, ft()));
  get isDateToday() {
    return d(this.#r);
  }
  set isDateToday(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => !Lo(this.opts.date.current, this.opts.month.current));
  get isOutsideMonth() {
    return d(this.#n);
  }
  set isOutsideMonth(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.root.isOutsideVisibleMonths(this.opts.date.current));
  get isOutsideVisibleMonths() {
    return d(this.#s);
  }
  set isOutsideVisibleMonths(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current);
  get isDisabled() {
    return d(this.#o);
  }
  set isDisabled(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => _t(this.opts.date.current, this.root.opts.placeholder.current));
  get isFocusedDate() {
    return d(this.#i);
  }
  set isFocusedDate(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => this.root.isDateSelected(this.opts.date.current));
  get isSelectedDate() {
    return d(this.#a);
  }
  set isSelectedDate(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => this.root.formatter.custom(this.cellDate, {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  }));
  get labelText() {
    return d(this.#u);
  }
  set labelText(e) {
    q(this.#u, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #l = /* @__PURE__ */ O(() => ({
    disabled: this.isDisabled,
    unavailable: this.isUnavailable,
    selected: this.isSelectedDate,
    day: `${this.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#l);
  }
  set snippetProps(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable);
  get ariaDisabled() {
    return d(this.#c);
  }
  set ariaDisabled(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => ({
    "data-unavailable": Re(this.isUnavailable),
    "data-today": this.isDateToday ? "" : void 0,
    "data-outside-month": this.isOutsideMonth ? "" : void 0,
    "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
    "data-focused": this.isFocusedDate ? "" : void 0,
    "data-selected": Re(this.isSelectedDate),
    "data-value": this.opts.date.current.toString(),
    "data-type": ew(this.opts.date.current),
    "data-disabled": Re(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
  }));
  get sharedDataAttrs() {
    return d(this.#d);
  }
  set sharedDataAttrs(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "gridcell",
    "aria-selected": at(this.isSelectedDate),
    "aria-disabled": at(this.ariaDisabled),
    ...this.sharedDataAttrs,
    [this.root.getBitsAttr("cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#g);
  }
  set props(e) {
    q(this.#g, e);
  }
}
class Mf {
  static create(e) {
    return new Mf(e, bw.get());
  }
  opts;
  cell;
  attachment;
  constructor(e, r) {
    this.opts = e, this.cell = r, this.onclick = this.onclick.bind(this), this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1);
  onclick(e) {
    this.cell.isDisabled || this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  #t = /* @__PURE__ */ O(() => ({
    disabled: this.cell.isDisabled,
    unavailable: this.cell.isUnavailable,
    selected: this.cell.isSelectedDate,
    day: `${this.cell.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#t);
  }
  set snippetProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    "aria-label": this.cell.labelText,
    "aria-disabled": at(this.cell.ariaDisabled),
    ...this.cell.sharedDataAttrs,
    tabindex: d(this.#e),
    [this.cell.root.getBitsAttr("day")]: "",
    "data-bits-day": "",
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
class If {
  static create(e) {
    return new If(e, Ut.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => this.root.isNextButtonDisabled);
  get isDisabled() {
    return d(this.#e);
  }
  set isDisabled(e) {
    q(this.#e, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onclick = this.onclick.bind(this), this.attachment = Te(this.opts.ref);
  }
  onclick(e) {
    this.isDisabled || this.root.nextPage();
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    type: "button",
    "aria-label": "Next",
    "aria-disabled": at(this.isDisabled),
    "data-disabled": Re(this.isDisabled),
    disabled: this.isDisabled,
    [this.root.getBitsAttr("next-button")]: "",
    //
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Nf {
  static create(e) {
    return new Nf(e, Ut.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => this.root.isPrevButtonDisabled);
  get isDisabled() {
    return d(this.#e);
  }
  set isDisabled(e) {
    q(this.#e, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onclick = this.onclick.bind(this), this.attachment = Te(this.opts.ref);
  }
  onclick(e) {
    this.isDisabled || this.root.prevPage();
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    type: "button",
    "aria-label": "Previous",
    "aria-disabled": at(this.isDisabled),
    "data-disabled": Re(this.isDisabled),
    disabled: this.isDisabled,
    [this.root.getBitsAttr("prev-button")]: "",
    //
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Ff {
  static create(e) {
    return new Ff(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    tabindex: -1,
    role: "grid",
    "aria-readonly": at(this.root.opts.readonly.current),
    "aria-disabled": at(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    "data-disabled": Re(this.root.opts.disabled.current),
    [this.root.getBitsAttr("grid")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Rf {
  static create(e) {
    return new Rf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-body")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Vf {
  static create(e) {
    return new Vf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-head")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Lf {
  static create(e) {
    return new Lf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-row")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class jf {
  static create(e) {
    return new jf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("head-cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Bf {
  static create(e) {
    return new Bf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("header")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class zf {
  static create(e) {
    return new zf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onchange = this.onchange.bind(this), this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => {
    this.root.opts.locale.current;
    const e = this.opts.months.current, r = this.opts.monthFormat.current, n = [];
    for (const s of e) {
      const o = this.root.opts.placeholder.current.set({ month: s });
      let i;
      typeof r == "function" ? i = r(s) : i = this.root.formatter.custom(_r(o), { month: r }), n.push({ value: s, label: i });
    }
    return n;
  });
  get monthItems() {
    return d(this.#e);
  }
  set monthItems(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.root.opts.placeholder.current.month);
  get currentMonth() {
    return d(this.#t);
  }
  set currentMonth(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.opts.disabled.current || this.opts.disabled.current);
  get isDisabled() {
    return d(this.#r);
  }
  set isDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ({
    monthItems: this.monthItems,
    selectedMonthItem: this.monthItems.find((e) => e.value === this.currentMonth)
  }));
  get snippetProps() {
    return d(this.#n);
  }
  set snippetProps(e) {
    q(this.#n, e);
  }
  onchange(e) {
    if (this.isDisabled) return;
    const r = e.target, n = parseInt(r.value, 10);
    isNaN(n) || (this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ month: n }));
  }
  #s = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    value: this.currentMonth,
    disabled: this.isDisabled,
    "data-disabled": Re(this.isDisabled),
    [this.root.getBitsAttr("month-select")]: "",
    //
    onchange: this.onchange,
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class qf {
  static create(e) {
    return new qf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onchange = this.onchange.bind(this), this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => this.opts.years.current && this.opts.years.current.length ? this.opts.years.current : this.root.defaultYears);
  get years() {
    return d(this.#e);
  }
  set years(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => {
    this.root.opts.locale.current;
    const e = this.opts.yearFormat.current, r = [];
    for (const n of this.years) {
      const s = this.root.opts.placeholder.current.set({ year: n });
      let o;
      typeof e == "function" ? o = e(n) : o = this.root.formatter.custom(_r(s), { year: e }), r.push({ value: n, label: o });
    }
    return r;
  });
  get yearItems() {
    return d(this.#t);
  }
  set yearItems(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.opts.placeholder.current.year);
  get currentYear() {
    return d(this.#r);
  }
  set currentYear(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.root.opts.disabled.current || this.opts.disabled.current);
  get isDisabled() {
    return d(this.#n);
  }
  set isDisabled(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => ({
    yearItems: this.yearItems,
    selectedYearItem: this.yearItems.find((e) => e.value === this.currentYear)
  }));
  get snippetProps() {
    return d(this.#s);
  }
  set snippetProps(e) {
    q(this.#s, e);
  }
  onchange(e) {
    if (this.isDisabled) return;
    const r = e.target, n = parseInt(r.value, 10);
    isNaN(n) || (this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ year: n }));
  }
  #o = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    value: this.currentYear,
    disabled: this.isDisabled,
    "data-disabled": Re(this.isDisabled),
    [this.root.getBitsAttr("year-select")]: "",
    //
    onchange: this.onchange,
    ...this.attachment
  }));
  get props() {
    return d(this.#o);
  }
  set props(e) {
    q(this.#o, e);
  }
}
var XD = /* @__PURE__ */ ne("<div><!></div>");
function _w(t, e) {
  W(e, !0);
  let r = v(e, "child", 7), n = v(e, "children", 7), s = v(e, "id", 23, En), o = v(e, "ref", 15, null), i = v(e, "value", 15), a = v(e, "onValueChange", 7, _e), l = v(e, "placeholder", 15), u = v(e, "onPlaceholderChange", 7, _e), c = v(e, "weekdayFormat", 7, "narrow"), f = v(e, "weekStartsOn", 7), h = v(e, "pagedNavigation", 7, !1), _ = v(e, "isDateDisabled", 7, () => !1), b = v(e, "isDateUnavailable", 7, () => !1), p = v(e, "fixedWeeks", 7, !1), g = v(e, "numberOfMonths", 7, 1), y = v(e, "locale", 7), S = v(e, "calendarLabel", 7, "Event"), x = v(e, "disabled", 7, !1), P = v(e, "readonly", 7, !1), w = v(e, "minValue", 7, void 0), C = v(e, "maxValue", 7, void 0), k = v(e, "preventDeselect", 7, !1), $ = v(e, "type", 7), T = v(e, "disableDaysOutsideMonth", 7, !0), E = v(e, "initialFocus", 7, !1), I = v(e, "maxDays", 7), F = v(e, "monthFormat", 7, "long"), U = v(e, "yearFormat", 7, "numeric"), B = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "type",
    "disableDaysOutsideMonth",
    "initialFocus",
    "maxDays",
    "monthFormat",
    "yearFormat"
  ]);
  const R = Z0({
    defaultValue: i(),
    minValue: w(),
    maxValue: C()
  });
  function Z() {
    l() === void 0 && l(R);
  }
  Z(), Fe.pre(() => l(), () => {
    Z();
  });
  function Y() {
    i() === void 0 && i($() === "single" ? void 0 : []);
  }
  Y(), Fe.pre(() => i(), () => {
    Y();
  });
  const X = Ef.create({
    id: z(() => s()),
    ref: z(() => o(), (V) => o(V)),
    weekdayFormat: z(() => c()),
    weekStartsOn: z(() => f()),
    pagedNavigation: z(() => h()),
    isDateDisabled: z(() => _()),
    isDateUnavailable: z(() => b()),
    fixedWeeks: z(() => p()),
    numberOfMonths: z(() => g()),
    locale: m0(() => y()),
    calendarLabel: z(() => S()),
    readonly: z(() => P()),
    disabled: z(() => x()),
    minValue: z(() => w()),
    maxValue: z(() => C()),
    disableDaysOutsideMonth: z(() => T()),
    initialFocus: z(() => E()),
    maxDays: z(() => I()),
    placeholder: z(() => l(), (V) => {
      l(V), u()(V);
    }),
    preventDeselect: z(() => k()),
    value: z(() => i(), (V) => {
      i(V), a()(V);
    }),
    type: z(() => $()),
    monthFormat: z(() => F()),
    yearFormat: z(() => U()),
    defaultPlaceholder: R
  }), ae = /* @__PURE__ */ O(() => Ce(B, X.props));
  var J = {
    get child() {
      return r();
    },
    set child(V) {
      r(V), m();
    },
    get children() {
      return n();
    },
    set children(V) {
      n(V), m();
    },
    get id() {
      return s();
    },
    set id(V = En()) {
      s(V), m();
    },
    get ref() {
      return o();
    },
    set ref(V = null) {
      o(V), m();
    },
    get value() {
      return i();
    },
    set value(V) {
      i(V), m();
    },
    get onValueChange() {
      return a();
    },
    set onValueChange(V = _e) {
      a(V), m();
    },
    get placeholder() {
      return l();
    },
    set placeholder(V) {
      l(V), m();
    },
    get onPlaceholderChange() {
      return u();
    },
    set onPlaceholderChange(V = _e) {
      u(V), m();
    },
    get weekdayFormat() {
      return c();
    },
    set weekdayFormat(V = "narrow") {
      c(V), m();
    },
    get weekStartsOn() {
      return f();
    },
    set weekStartsOn(V) {
      f(V), m();
    },
    get pagedNavigation() {
      return h();
    },
    set pagedNavigation(V = !1) {
      h(V), m();
    },
    get isDateDisabled() {
      return _();
    },
    set isDateDisabled(V = () => !1) {
      _(V), m();
    },
    get isDateUnavailable() {
      return b();
    },
    set isDateUnavailable(V = () => !1) {
      b(V), m();
    },
    get fixedWeeks() {
      return p();
    },
    set fixedWeeks(V = !1) {
      p(V), m();
    },
    get numberOfMonths() {
      return g();
    },
    set numberOfMonths(V = 1) {
      g(V), m();
    },
    get locale() {
      return y();
    },
    set locale(V) {
      y(V), m();
    },
    get calendarLabel() {
      return S();
    },
    set calendarLabel(V = "Event") {
      S(V), m();
    },
    get disabled() {
      return x();
    },
    set disabled(V = !1) {
      x(V), m();
    },
    get readonly() {
      return P();
    },
    set readonly(V = !1) {
      P(V), m();
    },
    get minValue() {
      return w();
    },
    set minValue(V = void 0) {
      w(V), m();
    },
    get maxValue() {
      return C();
    },
    set maxValue(V = void 0) {
      C(V), m();
    },
    get preventDeselect() {
      return k();
    },
    set preventDeselect(V = !1) {
      k(V), m();
    },
    get type() {
      return $();
    },
    set type(V) {
      $(V), m();
    },
    get disableDaysOutsideMonth() {
      return T();
    },
    set disableDaysOutsideMonth(V = !0) {
      T(V), m();
    },
    get initialFocus() {
      return E();
    },
    set initialFocus(V = !1) {
      E(V), m();
    },
    get maxDays() {
      return I();
    },
    set maxDays(V) {
      I(V), m();
    },
    get monthFormat() {
      return F();
    },
    set monthFormat(V = "long") {
      F(V), m();
    },
    get yearFormat() {
      return U();
    },
    set yearFormat(V = "numeric") {
      U(V), m();
    }
  }, j = M(), ee = D(j);
  {
    var L = (V) => {
      var G = M(), fe = D(G);
      {
        let se = /* @__PURE__ */ O(() => ({ props: d(ae), ...X.snippetProps }));
        te(fe, r, () => d(se));
      }
      A(V, G);
    }, N = (V) => {
      var G = XD();
      ve(G, () => ({ ...d(ae) }));
      var fe = ge(G);
      te(fe, () => n() ?? he, () => X.snippetProps), de(G), A(V, G);
    };
    ue(ee, (V) => {
      r() ? V(L) : V(N, !1);
    });
  }
  return A(t, j), H(J);
}
K(
  _w,
  {
    child: {},
    children: {},
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    placeholder: {},
    onPlaceholderChange: {},
    weekdayFormat: {},
    weekStartsOn: {},
    pagedNavigation: {},
    isDateDisabled: {},
    isDateUnavailable: {},
    fixedWeeks: {},
    numberOfMonths: {},
    locale: {},
    calendarLabel: {},
    disabled: {},
    readonly: {},
    minValue: {},
    maxValue: {},
    preventDeselect: {},
    type: {},
    disableDaysOutsideMonth: {},
    initialFocus: {},
    maxDays: {},
    monthFormat: {},
    yearFormat: {}
  },
  [],
  [],
  { mode: "open" }
);
var JD = /* @__PURE__ */ ne("<div><!></div>");
function ww(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Mf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      {
        let S = /* @__PURE__ */ O(() => ({ props: d(u), ...l.snippetProps }));
        te(y, s, () => d(S));
      }
      A(p, g);
    }, b = (p) => {
      var g = JD();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, () => n() ?? he, () => l.snippetProps), A(P, w);
        }, x = (P) => {
          var w = tt();
          ke(() => Ie(w, l.cell.opts.date.current.day)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(ww, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var ZD = /* @__PURE__ */ ne("<table><!></table>");
function Uf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Ff.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = ZD();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Uf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var QD = /* @__PURE__ */ ne("<tbody><!></tbody>");
function Kf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Rf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = QD();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Kf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var eM = /* @__PURE__ */ ne("<td><!></td>");
function Sw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "date", 7), l = v(e, "month", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "date",
    "month"
  ]);
  const c = Df.create({
    id: z(() => i()),
    ref: z(() => o(), (y) => o(y)),
    date: z(() => a()),
    month: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var h = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get ref() {
      return o();
    },
    set ref(y = null) {
      o(y), m();
    },
    get id() {
      return i();
    },
    set id(y = me(r)) {
      i(y), m();
    },
    get date() {
      return a();
    },
    set date(y) {
      a(y), m();
    },
    get month() {
      return l();
    },
    set month(y) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({ props: d(f), ...c.snippetProps }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, g = (y) => {
      var S = eM();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => n() ?? he, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(p) : y(g, !1);
    });
  }
  return A(t, _), H(h);
}
K(
  Sw,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    date: {},
    month: {}
  },
  [],
  [],
  { mode: "open" }
);
var tM = /* @__PURE__ */ ne("<thead><!></thead>");
function Wf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Vf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = tM();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Wf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var rM = /* @__PURE__ */ ne("<th><!></th>");
function Hf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = jf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = rM();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Hf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var nM = /* @__PURE__ */ ne("<tr><!></tr>");
function Gf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Lf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = nM();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Gf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var sM = /* @__PURE__ */ ne("<header><!></header>");
function Yf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Bf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = sM();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Yf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var oM = /* @__PURE__ */ ne("<div><!></div>");
function Xf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Tf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({
        props: d(u),
        headingValue: l.root.headingValue
      })), A(p, g);
    }, b = (p) => {
      var g = oM();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, () => n() ?? he, () => ({ headingValue: l.root.headingValue })), A(P, w);
        }, x = (P) => {
          var w = tt();
          ke(() => Ie(w, l.root.headingValue)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Xf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var iM = /* @__PURE__ */ ne("<option> </option>"), aM = /* @__PURE__ */ ne("<!>", 1), lM = /* @__PURE__ */ ne("<select><!></select>");
function Jf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "months", 23, () => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), l = v(e, "monthFormat", 7, "long"), u = v(e, "disabled", 7, !1), c = v(e, "aria-label", 7, "Select a month"), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "months",
    "monthFormat",
    "disabled",
    "aria-label"
  ]);
  const h = zf.create({
    id: z(() => i()),
    ref: z(() => o(), (x) => o(x)),
    months: z(() => a()),
    monthFormat: z(() => l()),
    disabled: z(() => !!u())
  }), _ = /* @__PURE__ */ O(() => Ce(f, h.props, { "aria-label": c() }));
  var b = {
    get children() {
      return n();
    },
    set children(x) {
      n(x), m();
    },
    get child() {
      return s();
    },
    set child(x) {
      s(x), m();
    },
    get ref() {
      return o();
    },
    set ref(x = null) {
      o(x), m();
    },
    get id() {
      return i();
    },
    set id(x = me(r)) {
      i(x), m();
    },
    get months() {
      return a();
    },
    set months(x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) {
      a(x), m();
    },
    get monthFormat() {
      return l();
    },
    set monthFormat(x = "long") {
      l(x), m();
    },
    get disabled() {
      return u();
    },
    set disabled(x = !1) {
      u(x), m();
    },
    get "aria-label"() {
      return c();
    },
    set "aria-label"(x = "Select a month") {
      c(x), m();
    }
  }, p = M(), g = D(p);
  {
    var y = (x) => {
      var P = M(), w = D(P);
      {
        let C = /* @__PURE__ */ O(() => ({ props: d(_), ...h.snippetProps }));
        te(w, s, () => d(C));
      }
      A(x, P);
    }, S = (x) => {
      var P = lM();
      ve(P, () => ({ ...d(_) })), iy(P, () => {
        var w = ge(P), C = aM(), k = D(C);
        {
          var $ = (E) => {
            var I = M(), F = D(I);
            te(F, () => n() ?? he, () => h.snippetProps), A(E, I);
          }, T = (E) => {
            var I = M(), F = D(I);
            st(F, 17, () => h.monthItems, (U) => U.value, (U, B) => {
              var R = iM(), Z = ge(R, !0);
              de(R);
              var Y = {};
              ke(() => {
                Us(R, d(B).value === h.currentMonth), Ie(Z, d(B).label), Y !== (Y = d(B).value) && (R.value = (R.__value = d(B).value) ?? "");
              }), A(U, R);
            }), A(E, I);
          };
          ue(k, (E) => {
            n() ? E($) : E(T, !1);
          });
        }
        A(w, C);
      }), A(x, P);
    };
    ue(g, (x) => {
      s() ? x(y) : x(S, !1);
    });
  }
  return A(t, p), H(b);
}
K(
  Jf,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    months: {},
    monthFormat: {},
    disabled: {},
    "aria-label": {}
  },
  [],
  [],
  { mode: "open" }
);
var uM = /* @__PURE__ */ ne("<button><!></button>");
function Zf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "tabindex", 7, 0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const u = If.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { tabindex: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    },
    get tabindex() {
      return a();
    },
    set tabindex(g = 0) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = uM();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      s() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(Zf, { children: {}, child: {}, id: {}, ref: {}, tabindex: {} }, [], [], { mode: "open" });
var cM = /* @__PURE__ */ ne("<button><!></button>");
function Qf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "tabindex", 7, 0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const u = Nf.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { tabindex: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    },
    get tabindex() {
      return a();
    },
    set tabindex(g = 0) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = cM();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      s() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(Qf, { children: {}, child: {}, id: {}, ref: {}, tabindex: {} }, [], [], { mode: "open" });
var dM = /* @__PURE__ */ ne("<option> </option>"), fM = /* @__PURE__ */ ne("<!>", 1), hM = /* @__PURE__ */ ne("<select><!></select>");
function eh(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "years", 7), l = v(e, "yearFormat", 7, "numeric"), u = v(e, "disabled", 7, !1), c = v(e, "aria-label", 7, "Select a year"), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "years",
    "yearFormat",
    "disabled",
    "aria-label"
  ]);
  const h = qf.create({
    id: z(() => i()),
    ref: z(() => o(), (x) => o(x)),
    years: z(() => a()),
    yearFormat: z(() => l()),
    disabled: z(() => !!u())
  }), _ = /* @__PURE__ */ O(() => Ce(f, h.props, { "aria-label": c() }));
  var b = {
    get children() {
      return n();
    },
    set children(x) {
      n(x), m();
    },
    get child() {
      return s();
    },
    set child(x) {
      s(x), m();
    },
    get ref() {
      return o();
    },
    set ref(x = null) {
      o(x), m();
    },
    get id() {
      return i();
    },
    set id(x = me(r)) {
      i(x), m();
    },
    get years() {
      return a();
    },
    set years(x) {
      a(x), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(x = "numeric") {
      l(x), m();
    },
    get disabled() {
      return u();
    },
    set disabled(x = !1) {
      u(x), m();
    },
    get "aria-label"() {
      return c();
    },
    set "aria-label"(x = "Select a year") {
      c(x), m();
    }
  }, p = M(), g = D(p);
  {
    var y = (x) => {
      var P = M(), w = D(P);
      {
        let C = /* @__PURE__ */ O(() => ({ props: d(_), ...h.snippetProps }));
        te(w, s, () => d(C));
      }
      A(x, P);
    }, S = (x) => {
      var P = hM();
      ve(P, () => ({ ...d(_) })), iy(P, () => {
        var w = ge(P), C = fM(), k = D(C);
        {
          var $ = (E) => {
            var I = M(), F = D(I);
            te(F, () => n() ?? he, () => h.snippetProps), A(E, I);
          }, T = (E) => {
            var I = M(), F = D(I);
            st(F, 17, () => h.yearItems, (U) => U.value, (U, B) => {
              var R = dM(), Z = ge(R, !0);
              de(R);
              var Y = {};
              ke(() => {
                Us(R, d(B).value === h.currentYear), Ie(Z, d(B).label), Y !== (Y = d(B).value) && (R.value = (R.__value = d(B).value) ?? "");
              }), A(U, R);
            }), A(E, I);
          };
          ue(k, (E) => {
            n() ? E($) : E(T, !1);
          });
        }
        A(w, C);
      }), A(x, P);
    };
    ue(g, (x) => {
      s() ? x(y) : x(S, !1);
    });
  }
  return A(t, p), H(b);
}
K(
  eh,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    years: {},
    yearFormat: {},
    disabled: {},
    "aria-label": {}
  },
  [],
  [],
  { mode: "open" }
);
const gM = nr({
  component: "checkbox",
  parts: ["root", "group", "group-label", "input"]
}), pM = new ht("Checkbox.Group"), xw = new ht("Checkbox.Root");
class th {
  static create(e, r = null) {
    return xw.set(new th(e, r));
  }
  opts;
  group;
  #e = /* @__PURE__ */ O(() => this.group && this.group.opts.name.current ? this.group.opts.name.current : this.opts.name.current);
  get trueName() {
    return d(this.#e);
  }
  set trueName(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.group && this.group.opts.required.current ? !0 : this.opts.required.current);
  get trueRequired() {
    return d(this.#t);
  }
  set trueRequired(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.group && this.group.opts.disabled.current ? !0 : this.opts.disabled.current);
  get trueDisabled() {
    return d(this.#r);
  }
  set trueDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.group && this.group.opts.readonly.current ? !0 : this.opts.readonly.current);
  get trueReadonly() {
    return d(this.#n);
  }
  set trueReadonly(e) {
    q(this.#n, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(this.opts.ref), this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this), Fe.pre(
      [
        () => Po(this.group?.opts.value.current),
        () => this.opts.value.current
      ],
      ([n, s]) => {
        !n || !s || (this.opts.checked.current = n.includes(s));
      }
    ), Fe.pre(() => this.opts.checked.current, (n) => {
      this.group && (n ? this.group?.addValue(this.opts.value.current) : this.group?.removeValue(this.opts.value.current));
    });
  }
  onkeydown(e) {
    if (!(this.trueDisabled || this.trueReadonly)) {
      if (e.key === Br) {
        e.preventDefault(), this.opts.type.current === "submit" && e.currentTarget.closest("form")?.requestSubmit();
        return;
      }
      e.key === xr && (e.preventDefault(), this.#s());
    }
  }
  #s() {
    this.opts.indeterminate.current ? (this.opts.indeterminate.current = !1, this.opts.checked.current = !0) : this.opts.checked.current = !this.opts.checked.current;
  }
  onclick(e) {
    if (!(this.trueDisabled || this.trueReadonly)) {
      if (this.opts.type.current === "submit") {
        this.#s();
        return;
      }
      e.preventDefault(), this.#s();
    }
  }
  #o = /* @__PURE__ */ O(() => ({
    checked: this.opts.checked.current,
    indeterminate: this.opts.indeterminate.current
  }));
  get snippetProps() {
    return d(this.#o);
  }
  set snippetProps(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "checkbox",
    type: this.opts.type.current,
    disabled: this.trueDisabled,
    "aria-checked": au(this.opts.checked.current, this.opts.indeterminate.current),
    "aria-required": at(this.trueRequired),
    "aria-readonly": at(this.trueReadonly),
    "data-disabled": Re(this.trueDisabled),
    "data-readonly": Re(this.trueReadonly),
    "data-state": mM(this.opts.checked.current, this.opts.indeterminate.current),
    [gM.root]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#i);
  }
  set props(e) {
    q(this.#i, e);
  }
}
class rh {
  static create() {
    return new rh(xw.get());
  }
  root;
  #e = /* @__PURE__ */ O(() => this.root.group ? !!(this.root.opts.value.current !== void 0 && this.root.group.opts.value.current.includes(this.root.opts.value.current)) : this.root.opts.checked.current);
  get trueChecked() {
    return d(this.#e);
  }
  set trueChecked(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => !!this.root.trueName);
  get shouldRender() {
    return d(this.#t);
  }
  set shouldRender(e) {
    q(this.#t, e);
  }
  constructor(e) {
    this.root = e, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    Cn(this.root.opts.ref.current) && this.root.opts.ref.current.focus();
  }
  #r = /* @__PURE__ */ O(() => ({
    type: "checkbox",
    checked: this.root.opts.checked.current === !0,
    disabled: this.root.trueDisabled,
    required: this.root.trueRequired,
    name: this.root.trueName,
    value: this.root.opts.value.current,
    readonly: this.root.trueReadonly,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
function mM(t, e) {
  return e ? "indeterminate" : t ? "checked" : "unchecked";
}
var vM = /* @__PURE__ */ ne("<input/>"), yM = /* @__PURE__ */ ne("<input/>");
function zi(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  const s = /* @__PURE__ */ O(() => Ce(n, {
    "aria-hidden": "true",
    tabindex: -1,
    style: s0
  }));
  var o = {
    get value() {
      return r();
    },
    set value(c) {
      r(c), m();
    }
  }, i = M(), a = D(i);
  {
    var l = (c) => {
      var f = vM();
      ve(f, () => ({ ...d(s), value: r() }), void 0, void 0, void 0, void 0, !0), A(c, f);
    }, u = (c) => {
      var f = yM();
      ve(f, () => ({ ...d(s) }), void 0, void 0, void 0, void 0, !0), go(f, r), A(c, f);
    };
    ue(a, (c) => {
      d(s).type === "checkbox" ? c(l) : c(u, !1);
    });
  }
  return A(t, i), H(o);
}
K(zi, { value: {} }, [], [], { mode: "open" });
function Pw(t, e) {
  W(e, !1);
  const r = rh.create();
  bd();
  var n = M(), s = D(n);
  {
    var o = (i) => {
      zi(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), H();
}
K(Pw, {}, [], [], { mode: "open" });
var bM = /* @__PURE__ */ ne("<button><!></button>"), _M = /* @__PURE__ */ ne("<!> <!>", 1);
function Ow(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "checked", 15, !1), s = v(e, "ref", 15, null), o = v(e, "onCheckedChange", 7), i = v(e, "children", 7), a = v(e, "disabled", 7, !1), l = v(e, "required", 7, !1), u = v(e, "name", 7, void 0), c = v(e, "value", 7, "on"), f = v(e, "id", 23, () => me(r)), h = v(e, "indeterminate", 15, !1), _ = v(e, "onIndeterminateChange", 7), b = v(e, "child", 7), p = v(e, "type", 7, "button"), g = v(e, "readonly", 7), y = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "checked",
    "ref",
    "onCheckedChange",
    "children",
    "disabled",
    "required",
    "name",
    "value",
    "id",
    "indeterminate",
    "onIndeterminateChange",
    "child",
    "type",
    "readonly"
  ]);
  const S = pM.getOr(null);
  S && c() && (S.opts.value.current.includes(c()) ? n(!0) : n(!1)), Fe.pre(() => c(), () => {
    S && c() && (S.opts.value.current.includes(c()) ? n(!0) : n(!1));
  });
  const x = th.create(
    {
      checked: z(() => n(), (I) => {
        n(I), o()?.(I);
      }),
      disabled: z(() => a() ?? !1),
      required: z(() => l()),
      name: z(() => u()),
      value: z(() => c()),
      id: z(() => f()),
      ref: z(() => s(), (I) => s(I)),
      indeterminate: z(() => h(), (I) => {
        h(I), _()?.(I);
      }),
      type: z(() => p()),
      readonly: z(() => !!g())
    },
    S
  ), P = /* @__PURE__ */ O(() => Ce({ ...y }, x.props));
  var w = {
    get checked() {
      return n();
    },
    set checked(I = !1) {
      n(I), m();
    },
    get ref() {
      return s();
    },
    set ref(I = null) {
      s(I), m();
    },
    get onCheckedChange() {
      return o();
    },
    set onCheckedChange(I) {
      o(I), m();
    },
    get children() {
      return i();
    },
    set children(I) {
      i(I), m();
    },
    get disabled() {
      return a();
    },
    set disabled(I = !1) {
      a(I), m();
    },
    get required() {
      return l();
    },
    set required(I = !1) {
      l(I), m();
    },
    get name() {
      return u();
    },
    set name(I = void 0) {
      u(I), m();
    },
    get value() {
      return c();
    },
    set value(I = "on") {
      c(I), m();
    },
    get id() {
      return f();
    },
    set id(I = me(r)) {
      f(I), m();
    },
    get indeterminate() {
      return h();
    },
    set indeterminate(I = !1) {
      h(I), m();
    },
    get onIndeterminateChange() {
      return _();
    },
    set onIndeterminateChange(I) {
      _(I), m();
    },
    get child() {
      return b();
    },
    set child(I) {
      b(I), m();
    },
    get type() {
      return p();
    },
    set type(I = "button") {
      p(I), m();
    },
    get readonly() {
      return g();
    },
    set readonly(I) {
      g(I), m();
    }
  }, C = _M(), k = D(C);
  {
    var $ = (I) => {
      var F = M(), U = D(F);
      {
        let B = /* @__PURE__ */ O(() => ({ props: d(P), ...x.snippetProps }));
        te(U, b, () => d(B));
      }
      A(I, F);
    }, T = (I) => {
      var F = bM();
      ve(F, () => ({ ...d(P) }));
      var U = ge(F);
      te(U, () => i() ?? he, () => x.snippetProps), de(F), A(I, F);
    };
    ue(k, (I) => {
      b() ? I($) : I(T, !1);
    });
  }
  var E = be(k, 2);
  return Pw(E, {}), A(t, C), H(w);
}
K(
  Ow,
  {
    checked: {},
    ref: {},
    onCheckedChange: {},
    children: {},
    disabled: {},
    required: {},
    name: {},
    value: {},
    id: {},
    indeterminate: {},
    onIndeterminateChange: {},
    child: {},
    type: {},
    readonly: {}
  },
  [],
  [],
  { mode: "open" }
);
const wM = ["top", "right", "bottom", "left"], ns = Math.min, cr = Math.max, bl = Math.round, La = Math.floor, rn = (t) => ({
  x: t,
  y: t
}), SM = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, xM = {
  start: "end",
  end: "start"
};
function Wc(t, e, r) {
  return cr(t, ns(e, r));
}
function Dn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Mn(t) {
  return t.split("-")[0];
}
function Bo(t) {
  return t.split("-")[1];
}
function nh(t) {
  return t === "x" ? "y" : "x";
}
function sh(t) {
  return t === "y" ? "height" : "width";
}
const PM = /* @__PURE__ */ new Set(["top", "bottom"]);
function Qr(t) {
  return PM.has(Mn(t)) ? "y" : "x";
}
function oh(t) {
  return nh(Qr(t));
}
function OM(t, e, r) {
  r === void 0 && (r = !1);
  const n = Bo(t), s = oh(t), o = sh(s);
  let i = s === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (i = _l(i)), [i, _l(i)];
}
function CM(t) {
  const e = _l(t);
  return [Hc(t), e, Hc(e)];
}
function Hc(t) {
  return t.replace(/start|end/g, (e) => xM[e]);
}
const Fm = ["left", "right"], Rm = ["right", "left"], kM = ["top", "bottom"], $M = ["bottom", "top"];
function AM(t, e, r) {
  switch (t) {
    case "top":
    case "bottom":
      return r ? e ? Rm : Fm : e ? Fm : Rm;
    case "left":
    case "right":
      return e ? kM : $M;
    default:
      return [];
  }
}
function EM(t, e, r, n) {
  const s = Bo(t);
  let o = AM(Mn(t), r === "start", n);
  return s && (o = o.map((i) => i + "-" + s), e && (o = o.concat(o.map(Hc)))), o;
}
function _l(t) {
  return t.replace(/left|right|bottom|top/g, (e) => SM[e]);
}
function TM(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Cw(t) {
  return typeof t != "number" ? TM(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function wl(t) {
  const {
    x: e,
    y: r,
    width: n,
    height: s
  } = t;
  return {
    width: n,
    height: s,
    top: r,
    left: e,
    right: e + n,
    bottom: r + s,
    x: e,
    y: r
  };
}
function Vm(t, e, r) {
  let {
    reference: n,
    floating: s
  } = t;
  const o = Qr(e), i = oh(e), a = sh(i), l = Mn(e), u = o === "y", c = n.x + n.width / 2 - s.width / 2, f = n.y + n.height / 2 - s.height / 2, h = n[a] / 2 - s[a] / 2;
  let _;
  switch (l) {
    case "top":
      _ = {
        x: c,
        y: n.y - s.height
      };
      break;
    case "bottom":
      _ = {
        x: c,
        y: n.y + n.height
      };
      break;
    case "right":
      _ = {
        x: n.x + n.width,
        y: f
      };
      break;
    case "left":
      _ = {
        x: n.x - s.width,
        y: f
      };
      break;
    default:
      _ = {
        x: n.x,
        y: n.y
      };
  }
  switch (Bo(e)) {
    case "start":
      _[i] -= h * (r && u ? -1 : 1);
      break;
    case "end":
      _[i] += h * (r && u ? -1 : 1);
      break;
  }
  return _;
}
async function DM(t, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: n,
    y: s,
    platform: o,
    rects: i,
    elements: a,
    strategy: l
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: h = !1,
    padding: _ = 0
  } = Dn(e, t), b = Cw(_), g = a[h ? f === "floating" ? "reference" : "floating" : f], y = wl(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(g))) == null || r ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), S = f === "floating" ? {
    x: n,
    y: s,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), P = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = wl(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: S,
    offsetParent: x,
    strategy: l
  }) : S);
  return {
    top: (y.top - w.top + b.top) / P.y,
    bottom: (w.bottom - y.bottom + b.bottom) / P.y,
    left: (y.left - w.left + b.left) / P.x,
    right: (w.right - y.right + b.right) / P.x
  };
}
const MM = async (t, e, r) => {
  const {
    placement: n = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: i
  } = r, a = o.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(e));
  let u = await i.getElementRects({
    reference: t,
    floating: e,
    strategy: s
  }), {
    x: c,
    y: f
  } = Vm(u, n, l), h = n, _ = {}, b = 0;
  for (let g = 0; g < a.length; g++) {
    var p;
    const {
      name: y,
      fn: S
    } = a[g], {
      x,
      y: P,
      data: w,
      reset: C
    } = await S({
      x: c,
      y: f,
      initialPlacement: n,
      placement: h,
      strategy: s,
      middlewareData: _,
      rects: u,
      platform: {
        ...i,
        detectOverflow: (p = i.detectOverflow) != null ? p : DM
      },
      elements: {
        reference: t,
        floating: e
      }
    });
    c = x ?? c, f = P ?? f, _ = {
      ..._,
      [y]: {
        ..._[y],
        ...w
      }
    }, C && b <= 50 && (b++, typeof C == "object" && (C.placement && (h = C.placement), C.rects && (u = C.rects === !0 ? await i.getElementRects({
      reference: t,
      floating: e,
      strategy: s
    }) : C.rects), {
      x: c,
      y: f
    } = Vm(u, h, l)), g = -1);
  }
  return {
    x: c,
    y: f,
    placement: h,
    strategy: s,
    middlewareData: _
  };
}, IM = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: r,
      y: n,
      placement: s,
      rects: o,
      platform: i,
      elements: a,
      middlewareData: l
    } = e, {
      element: u,
      padding: c = 0
    } = Dn(t, e) || {};
    if (u == null)
      return {};
    const f = Cw(c), h = {
      x: r,
      y: n
    }, _ = oh(s), b = sh(_), p = await i.getDimensions(u), g = _ === "y", y = g ? "top" : "left", S = g ? "bottom" : "right", x = g ? "clientHeight" : "clientWidth", P = o.reference[b] + o.reference[_] - h[_] - o.floating[b], w = h[_] - o.reference[_], C = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u));
    let k = C ? C[x] : 0;
    (!k || !await (i.isElement == null ? void 0 : i.isElement(C))) && (k = a.floating[x] || o.floating[b]);
    const $ = P / 2 - w / 2, T = k / 2 - p[b] / 2 - 1, E = ns(f[y], T), I = ns(f[S], T), F = E, U = k - p[b] - I, B = k / 2 - p[b] / 2 + $, R = Wc(F, B, U), Z = !l.arrow && Bo(s) != null && B !== R && o.reference[b] / 2 - (B < F ? E : I) - p[b] / 2 < 0, Y = Z ? B < F ? B - F : B - U : 0;
    return {
      [_]: h[_] + Y,
      data: {
        [_]: R,
        centerOffset: B - R - Y,
        ...Z && {
          alignmentOffset: Y
        }
      },
      reset: Z
    };
  }
}), NM = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var r, n;
      const {
        placement: s,
        middlewareData: o,
        rects: i,
        initialPlacement: a,
        platform: l,
        elements: u
      } = e, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: h,
        fallbackStrategy: _ = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: p = !0,
        ...g
      } = Dn(t, e);
      if ((r = o.arrow) != null && r.alignmentOffset)
        return {};
      const y = Mn(s), S = Qr(a), x = Mn(a) === a, P = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), w = h || (x || !p ? [_l(a)] : CM(a)), C = b !== "none";
      !h && C && w.push(...EM(a, p, b, P));
      const k = [a, ...w], $ = await l.detectOverflow(e, g), T = [];
      let E = ((n = o.flip) == null ? void 0 : n.overflows) || [];
      if (c && T.push($[y]), f) {
        const B = OM(s, i, P);
        T.push($[B[0]], $[B[1]]);
      }
      if (E = [...E, {
        placement: s,
        overflows: T
      }], !T.every((B) => B <= 0)) {
        var I, F;
        const B = (((I = o.flip) == null ? void 0 : I.index) || 0) + 1, R = k[B];
        if (R && (!(f === "alignment" ? S !== Qr(R) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        E.every((X) => Qr(X.placement) === S ? X.overflows[0] > 0 : !0)))
          return {
            data: {
              index: B,
              overflows: E
            },
            reset: {
              placement: R
            }
          };
        let Z = (F = E.filter((Y) => Y.overflows[0] <= 0).sort((Y, X) => Y.overflows[1] - X.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!Z)
          switch (_) {
            case "bestFit": {
              var U;
              const Y = (U = E.filter((X) => {
                if (C) {
                  const ae = Qr(X.placement);
                  return ae === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ae === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((ae) => ae > 0).reduce((ae, J) => ae + J, 0)]).sort((X, ae) => X[1] - ae[1])[0]) == null ? void 0 : U[0];
              Y && (Z = Y);
              break;
            }
            case "initialPlacement":
              Z = a;
              break;
          }
        if (s !== Z)
          return {
            reset: {
              placement: Z
            }
          };
      }
      return {};
    }
  };
};
function Lm(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function jm(t) {
  return wM.some((e) => t[e] >= 0);
}
const FM = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: r,
        platform: n
      } = e, {
        strategy: s = "referenceHidden",
        ...o
      } = Dn(t, e);
      switch (s) {
        case "referenceHidden": {
          const i = await n.detectOverflow(e, {
            ...o,
            elementContext: "reference"
          }), a = Lm(i, r.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: jm(a)
            }
          };
        }
        case "escaped": {
          const i = await n.detectOverflow(e, {
            ...o,
            altBoundary: !0
          }), a = Lm(i, r.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: jm(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, kw = /* @__PURE__ */ new Set(["left", "top"]);
async function RM(t, e) {
  const {
    placement: r,
    platform: n,
    elements: s
  } = t, o = await (n.isRTL == null ? void 0 : n.isRTL(s.floating)), i = Mn(r), a = Bo(r), l = Qr(r) === "y", u = kw.has(i) ? -1 : 1, c = o && l ? -1 : 1, f = Dn(e, t);
  let {
    mainAxis: h,
    crossAxis: _,
    alignmentAxis: b
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return a && typeof b == "number" && (_ = a === "end" ? b * -1 : b), l ? {
    x: _ * c,
    y: h * u
  } : {
    x: h * u,
    y: _ * c
  };
}
const VM = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var r, n;
      const {
        x: s,
        y: o,
        placement: i,
        middlewareData: a
      } = e, l = await RM(e, t);
      return i === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: s + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: i
        }
      };
    }
  };
}, LM = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: r,
        y: n,
        placement: s,
        platform: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: a = !1,
        limiter: l = {
          fn: (y) => {
            let {
              x: S,
              y: x
            } = y;
            return {
              x: S,
              y: x
            };
          }
        },
        ...u
      } = Dn(t, e), c = {
        x: r,
        y: n
      }, f = await o.detectOverflow(e, u), h = Qr(Mn(s)), _ = nh(h);
      let b = c[_], p = c[h];
      if (i) {
        const y = _ === "y" ? "top" : "left", S = _ === "y" ? "bottom" : "right", x = b + f[y], P = b - f[S];
        b = Wc(x, b, P);
      }
      if (a) {
        const y = h === "y" ? "top" : "left", S = h === "y" ? "bottom" : "right", x = p + f[y], P = p - f[S];
        p = Wc(x, p, P);
      }
      const g = l.fn({
        ...e,
        [_]: b,
        [h]: p
      });
      return {
        ...g,
        data: {
          x: g.x - r,
          y: g.y - n,
          enabled: {
            [_]: i,
            [h]: a
          }
        }
      };
    }
  };
}, jM = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: r,
        y: n,
        placement: s,
        rects: o,
        middlewareData: i
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: u = !0
      } = Dn(t, e), c = {
        x: r,
        y: n
      }, f = Qr(s), h = nh(f);
      let _ = c[h], b = c[f];
      const p = Dn(a, e), g = typeof p == "number" ? {
        mainAxis: p,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...p
      };
      if (l) {
        const x = h === "y" ? "height" : "width", P = o.reference[h] - o.floating[x] + g.mainAxis, w = o.reference[h] + o.reference[x] - g.mainAxis;
        _ < P ? _ = P : _ > w && (_ = w);
      }
      if (u) {
        var y, S;
        const x = h === "y" ? "width" : "height", P = kw.has(Mn(s)), w = o.reference[f] - o.floating[x] + (P && ((y = i.offset) == null ? void 0 : y[f]) || 0) + (P ? 0 : g.crossAxis), C = o.reference[f] + o.reference[x] + (P ? 0 : ((S = i.offset) == null ? void 0 : S[f]) || 0) - (P ? g.crossAxis : 0);
        b < w ? b = w : b > C && (b = C);
      }
      return {
        [h]: _,
        [f]: b
      };
    }
  };
}, BM = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var r, n;
      const {
        placement: s,
        rects: o,
        platform: i,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...u
      } = Dn(t, e), c = await i.detectOverflow(e, u), f = Mn(s), h = Bo(s), _ = Qr(s) === "y", {
        width: b,
        height: p
      } = o.floating;
      let g, y;
      f === "top" || f === "bottom" ? (g = f, y = h === (await (i.isRTL == null ? void 0 : i.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (y = f, g = h === "end" ? "top" : "bottom");
      const S = p - c.top - c.bottom, x = b - c.left - c.right, P = ns(p - c[g], S), w = ns(b - c[y], x), C = !e.middlewareData.shift;
      let k = P, $ = w;
      if ((r = e.middlewareData.shift) != null && r.enabled.x && ($ = x), (n = e.middlewareData.shift) != null && n.enabled.y && (k = S), C && !h) {
        const E = cr(c.left, 0), I = cr(c.right, 0), F = cr(c.top, 0), U = cr(c.bottom, 0);
        _ ? $ = b - 2 * (E !== 0 || I !== 0 ? E + I : cr(c.left, c.right)) : k = p - 2 * (F !== 0 || U !== 0 ? F + U : cr(c.top, c.bottom));
      }
      await l({
        ...e,
        availableWidth: $,
        availableHeight: k
      });
      const T = await i.getDimensions(a.floating);
      return b !== T.width || p !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function cu() {
  return typeof window < "u";
}
function zo(t) {
  return $w(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function gr(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function dn(t) {
  var e;
  return (e = ($w(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function $w(t) {
  return cu() ? t instanceof Node || t instanceof gr(t).Node : !1;
}
function zr(t) {
  return cu() ? t instanceof Element || t instanceof gr(t).Element : !1;
}
function an(t) {
  return cu() ? t instanceof HTMLElement || t instanceof gr(t).HTMLElement : !1;
}
function Bm(t) {
  return !cu() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof gr(t).ShadowRoot;
}
const zM = /* @__PURE__ */ new Set(["inline", "contents"]);
function qi(t) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: n,
    display: s
  } = qr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !zM.has(s);
}
const qM = /* @__PURE__ */ new Set(["table", "td", "th"]);
function UM(t) {
  return qM.has(zo(t));
}
const KM = [":popover-open", ":modal"];
function du(t) {
  return KM.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const WM = ["transform", "translate", "scale", "rotate", "perspective"], HM = ["transform", "translate", "scale", "rotate", "perspective", "filter"], GM = ["paint", "layout", "strict", "content"];
function ih(t) {
  const e = ah(), r = zr(t) ? qr(t) : t;
  return WM.some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || HM.some((n) => (r.willChange || "").includes(n)) || GM.some((n) => (r.contain || "").includes(n));
}
function YM(t) {
  let e = ss(t);
  for (; an(e) && !So(e); ) {
    if (ih(e))
      return e;
    if (du(e))
      return null;
    e = ss(e);
  }
  return null;
}
function ah() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const XM = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function So(t) {
  return XM.has(zo(t));
}
function qr(t) {
  return gr(t).getComputedStyle(t);
}
function fu(t) {
  return zr(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function ss(t) {
  if (zo(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Bm(t) && t.host || // Fallback.
    dn(t)
  );
  return Bm(e) ? e.host : e;
}
function Aw(t) {
  const e = ss(t);
  return So(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : an(e) && qi(e) ? e : Aw(e);
}
function Oi(t, e, r) {
  var n;
  e === void 0 && (e = []), r === void 0 && (r = !0);
  const s = Aw(t), o = s === ((n = t.ownerDocument) == null ? void 0 : n.body), i = gr(s);
  if (o) {
    const a = Gc(i);
    return e.concat(i, i.visualViewport || [], qi(s) ? s : [], a && r ? Oi(a) : []);
  }
  return e.concat(s, Oi(s, [], r));
}
function Gc(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function Ew(t) {
  const e = qr(t);
  let r = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const s = an(t), o = s ? t.offsetWidth : r, i = s ? t.offsetHeight : n, a = bl(r) !== o || bl(n) !== i;
  return a && (r = o, n = i), {
    width: r,
    height: n,
    $: a
  };
}
function lh(t) {
  return zr(t) ? t : t.contextElement;
}
function ao(t) {
  const e = lh(t);
  if (!an(e))
    return rn(1);
  const r = e.getBoundingClientRect(), {
    width: n,
    height: s,
    $: o
  } = Ew(e);
  let i = (o ? bl(r.width) : r.width) / n, a = (o ? bl(r.height) : r.height) / s;
  return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: i,
    y: a
  };
}
const JM = /* @__PURE__ */ rn(0);
function Tw(t) {
  const e = gr(t);
  return !ah() || !e.visualViewport ? JM : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ZM(t, e, r) {
  return e === void 0 && (e = !1), !r || e && r !== gr(t) ? !1 : e;
}
function js(t, e, r, n) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  const s = t.getBoundingClientRect(), o = lh(t);
  let i = rn(1);
  e && (n ? zr(n) && (i = ao(n)) : i = ao(t));
  const a = ZM(o, r, n) ? Tw(o) : rn(0);
  let l = (s.left + a.x) / i.x, u = (s.top + a.y) / i.y, c = s.width / i.x, f = s.height / i.y;
  if (o) {
    const h = gr(o), _ = n && zr(n) ? gr(n) : n;
    let b = h, p = Gc(b);
    for (; p && n && _ !== b; ) {
      const g = ao(p), y = p.getBoundingClientRect(), S = qr(p), x = y.left + (p.clientLeft + parseFloat(S.paddingLeft)) * g.x, P = y.top + (p.clientTop + parseFloat(S.paddingTop)) * g.y;
      l *= g.x, u *= g.y, c *= g.x, f *= g.y, l += x, u += P, b = gr(p), p = Gc(b);
    }
  }
  return wl({
    width: c,
    height: f,
    x: l,
    y: u
  });
}
function hu(t, e) {
  const r = fu(t).scrollLeft;
  return e ? e.left + r : js(dn(t)).left + r;
}
function Dw(t, e) {
  const r = t.getBoundingClientRect(), n = r.left + e.scrollLeft - hu(t, r), s = r.top + e.scrollTop;
  return {
    x: n,
    y: s
  };
}
function QM(t) {
  let {
    elements: e,
    rect: r,
    offsetParent: n,
    strategy: s
  } = t;
  const o = s === "fixed", i = dn(n), a = e ? du(e.floating) : !1;
  if (n === i || a && o)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = rn(1);
  const c = rn(0), f = an(n);
  if ((f || !f && !o) && ((zo(n) !== "body" || qi(i)) && (l = fu(n)), an(n))) {
    const _ = js(n);
    u = ao(n), c.x = _.x + n.clientLeft, c.y = _.y + n.clientTop;
  }
  const h = i && !f && !o ? Dw(i, l) : rn(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + h.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + h.y
  };
}
function eI(t) {
  return Array.from(t.getClientRects());
}
function tI(t) {
  const e = dn(t), r = fu(t), n = t.ownerDocument.body, s = cr(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), o = cr(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let i = -r.scrollLeft + hu(t);
  const a = -r.scrollTop;
  return qr(n).direction === "rtl" && (i += cr(e.clientWidth, n.clientWidth) - s), {
    width: s,
    height: o,
    x: i,
    y: a
  };
}
const zm = 25;
function rI(t, e) {
  const r = gr(t), n = dn(t), s = r.visualViewport;
  let o = n.clientWidth, i = n.clientHeight, a = 0, l = 0;
  if (s) {
    o = s.width, i = s.height;
    const c = ah();
    (!c || c && e === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  const u = hu(n);
  if (u <= 0) {
    const c = n.ownerDocument, f = c.body, h = getComputedStyle(f), _ = c.compatMode === "CSS1Compat" && parseFloat(h.marginLeft) + parseFloat(h.marginRight) || 0, b = Math.abs(n.clientWidth - f.clientWidth - _);
    b <= zm && (o -= b);
  } else u <= zm && (o += u);
  return {
    width: o,
    height: i,
    x: a,
    y: l
  };
}
const nI = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function sI(t, e) {
  const r = js(t, !0, e === "fixed"), n = r.top + t.clientTop, s = r.left + t.clientLeft, o = an(t) ? ao(t) : rn(1), i = t.clientWidth * o.x, a = t.clientHeight * o.y, l = s * o.x, u = n * o.y;
  return {
    width: i,
    height: a,
    x: l,
    y: u
  };
}
function qm(t, e, r) {
  let n;
  if (e === "viewport")
    n = rI(t, r);
  else if (e === "document")
    n = tI(dn(t));
  else if (zr(e))
    n = sI(e, r);
  else {
    const s = Tw(t);
    n = {
      x: e.x - s.x,
      y: e.y - s.y,
      width: e.width,
      height: e.height
    };
  }
  return wl(n);
}
function Mw(t, e) {
  const r = ss(t);
  return r === e || !zr(r) || So(r) ? !1 : qr(r).position === "fixed" || Mw(r, e);
}
function oI(t, e) {
  const r = e.get(t);
  if (r)
    return r;
  let n = Oi(t, [], !1).filter((a) => zr(a) && zo(a) !== "body"), s = null;
  const o = qr(t).position === "fixed";
  let i = o ? ss(t) : t;
  for (; zr(i) && !So(i); ) {
    const a = qr(i), l = ih(i);
    !l && a.position === "fixed" && (s = null), (o ? !l && !s : !l && a.position === "static" && !!s && nI.has(s.position) || qi(i) && !l && Mw(t, i)) ? n = n.filter((c) => c !== i) : s = a, i = ss(i);
  }
  return e.set(t, n), n;
}
function iI(t) {
  let {
    element: e,
    boundary: r,
    rootBoundary: n,
    strategy: s
  } = t;
  const i = [...r === "clippingAncestors" ? du(e) ? [] : oI(e, this._c) : [].concat(r), n], a = i[0], l = i.reduce((u, c) => {
    const f = qm(e, c, s);
    return u.top = cr(f.top, u.top), u.right = ns(f.right, u.right), u.bottom = ns(f.bottom, u.bottom), u.left = cr(f.left, u.left), u;
  }, qm(e, a, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function aI(t) {
  const {
    width: e,
    height: r
  } = Ew(t);
  return {
    width: e,
    height: r
  };
}
function lI(t, e, r) {
  const n = an(e), s = dn(e), o = r === "fixed", i = js(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = rn(0);
  function u() {
    l.x = hu(s);
  }
  if (n || !n && !o)
    if ((zo(e) !== "body" || qi(s)) && (a = fu(e)), n) {
      const _ = js(e, !0, o, e);
      l.x = _.x + e.clientLeft, l.y = _.y + e.clientTop;
    } else s && u();
  o && !n && s && u();
  const c = s && !n && !o ? Dw(s, a) : rn(0), f = i.left + a.scrollLeft - l.x - c.x, h = i.top + a.scrollTop - l.y - c.y;
  return {
    x: f,
    y: h,
    width: i.width,
    height: i.height
  };
}
function oc(t) {
  return qr(t).position === "static";
}
function Um(t, e) {
  if (!an(t) || qr(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let r = t.offsetParent;
  return dn(t) === r && (r = r.ownerDocument.body), r;
}
function Iw(t, e) {
  const r = gr(t);
  if (du(t))
    return r;
  if (!an(t)) {
    let s = ss(t);
    for (; s && !So(s); ) {
      if (zr(s) && !oc(s))
        return s;
      s = ss(s);
    }
    return r;
  }
  let n = Um(t, e);
  for (; n && UM(n) && oc(n); )
    n = Um(n, e);
  return n && So(n) && oc(n) && !ih(n) ? r : n || YM(t) || r;
}
const uI = async function(t) {
  const e = this.getOffsetParent || Iw, r = this.getDimensions, n = await r(t.floating);
  return {
    reference: lI(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function cI(t) {
  return qr(t).direction === "rtl";
}
const dI = {
  convertOffsetParentRelativeRectToViewportRelativeRect: QM,
  getDocumentElement: dn,
  getClippingRect: iI,
  getOffsetParent: Iw,
  getElementRects: uI,
  getClientRects: eI,
  getDimensions: aI,
  getScale: ao,
  isElement: zr,
  isRTL: cI
};
function Nw(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function fI(t, e) {
  let r = null, n;
  const s = dn(t);
  function o() {
    var a;
    clearTimeout(n), (a = r) == null || a.disconnect(), r = null;
  }
  function i(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const u = t.getBoundingClientRect(), {
      left: c,
      top: f,
      width: h,
      height: _
    } = u;
    if (a || e(), !h || !_)
      return;
    const b = La(f), p = La(s.clientWidth - (c + h)), g = La(s.clientHeight - (f + _)), y = La(c), x = {
      rootMargin: -b + "px " + -p + "px " + -g + "px " + -y + "px",
      threshold: cr(0, ns(1, l)) || 1
    };
    let P = !0;
    function w(C) {
      const k = C[0].intersectionRatio;
      if (k !== l) {
        if (!P)
          return i();
        k ? i(!1, k) : n = setTimeout(() => {
          i(!1, 1e-7);
        }, 1e3);
      }
      k === 1 && !Nw(u, t.getBoundingClientRect()) && i(), P = !1;
    }
    try {
      r = new IntersectionObserver(w, {
        ...x,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(w, x);
    }
    r.observe(t);
  }
  return i(!0), o;
}
function hI(t, e, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, u = lh(t), c = s || o ? [...u ? Oi(u) : [], ...Oi(e)] : [];
  c.forEach((y) => {
    s && y.addEventListener("scroll", r, {
      passive: !0
    }), o && y.addEventListener("resize", r);
  });
  const f = u && a ? fI(u, r) : null;
  let h = -1, _ = null;
  i && (_ = new ResizeObserver((y) => {
    let [S] = y;
    S && S.target === u && _ && (_.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var x;
      (x = _) == null || x.observe(e);
    })), r();
  }), u && !l && _.observe(u), _.observe(e));
  let b, p = l ? js(t) : null;
  l && g();
  function g() {
    const y = js(t);
    p && !Nw(p, y) && r(), p = y, b = requestAnimationFrame(g);
  }
  return r(), () => {
    var y;
    c.forEach((S) => {
      s && S.removeEventListener("scroll", r), o && S.removeEventListener("resize", r);
    }), f?.(), (y = _) == null || y.disconnect(), _ = null, l && cancelAnimationFrame(b);
  };
}
const gI = VM, pI = LM, mI = NM, vI = BM, yI = FM, bI = IM, _I = jM, wI = (t, e, r) => {
  const n = /* @__PURE__ */ new Map(), s = {
    platform: dI,
    ...r
  }, o = {
    ...s.platform,
    _c: n
  };
  return MM(t, e, {
    ...s,
    platform: o
  });
};
function Ss(t) {
  return typeof t == "function" ? t() : t;
}
function Fw(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Km(t, e) {
  const r = Fw(t);
  return Math.round(e * r) / r;
}
function Yc(t) {
  return {
    [`--bits-${t}-content-transform-origin`]: "var(--bits-floating-transform-origin)",
    [`--bits-${t}-content-available-width`]: "var(--bits-floating-available-width)",
    [`--bits-${t}-content-available-height`]: "var(--bits-floating-available-height)",
    [`--bits-${t}-anchor-width`]: "var(--bits-floating-anchor-width)",
    [`--bits-${t}-anchor-height`]: "var(--bits-floating-anchor-height)"
  };
}
function SI(t) {
  const e = t.whileElementsMounted, r = /* @__PURE__ */ O(() => Ss(t.open) ?? !0), n = /* @__PURE__ */ O(() => Ss(t.middleware)), s = /* @__PURE__ */ O(() => Ss(t.transform) ?? !0), o = /* @__PURE__ */ O(() => Ss(t.placement) ?? "bottom"), i = /* @__PURE__ */ O(() => Ss(t.strategy) ?? "absolute"), a = /* @__PURE__ */ O(() => Ss(t.sideOffset) ?? 0), l = /* @__PURE__ */ O(() => Ss(t.alignOffset) ?? 0), u = t.reference;
  let c = /* @__PURE__ */ xe(0), f = /* @__PURE__ */ xe(0);
  const h = Jr(null);
  let _ = /* @__PURE__ */ xe(Pt(d(i))), b = /* @__PURE__ */ xe(Pt(d(o))), p = /* @__PURE__ */ xe(Pt({})), g = /* @__PURE__ */ xe(!1);
  const y = /* @__PURE__ */ O(() => {
    const k = h.current ? Km(h.current, d(c)) : d(c), $ = h.current ? Km(h.current, d(f)) : d(f);
    return d(s) ? {
      position: d(_),
      left: "0",
      top: "0",
      transform: `translate(${k}px, ${$}px)`,
      ...h.current && Fw(h.current) >= 1.5 && { willChange: "transform" }
    } : {
      position: d(_),
      left: `${k}px`,
      top: `${$}px`
    };
  });
  let S;
  function x() {
    u.current === null || h.current === null || wI(u.current, h.current, {
      middleware: d(n),
      placement: d(o),
      strategy: d(i)
    }).then((k) => {
      if (!d(r) && d(c) !== 0 && d(f) !== 0) {
        const $ = Math.max(Math.abs(d(a)), Math.abs(d(l)), 15);
        if (k.x <= $ && k.y <= $) return;
      }
      q(c, k.x, !0), q(f, k.y, !0), q(_, k.strategy, !0), q(b, k.placement, !0), q(p, k.middlewareData, !0), q(g, !0);
    });
  }
  function P() {
    typeof S == "function" && (S(), S = void 0);
  }
  function w() {
    if (P(), e === void 0) {
      x();
      return;
    }
    u.current === null || h.current === null || (S = e(u.current, h.current, x));
  }
  function C() {
    d(r) || q(g, !1);
  }
  return Xe(x), Xe(w), Xe(C), Xe(() => P), {
    floating: h,
    reference: u,
    get strategy() {
      return d(_);
    },
    get placement() {
      return d(b);
    },
    get middlewareData() {
      return d(p);
    },
    get isPositioned() {
      return d(g);
    },
    get floatingStyles() {
      return d(y);
    },
    get update() {
      return x;
    }
  };
}
const xI = { top: "bottom", right: "left", bottom: "top", left: "right" }, uh = new ht("Floating.Root"), Wm = new ht("Floating.Content"), ch = new ht("Floating.Root");
class Sl {
  static create(e = !1) {
    return e ? ch.set(new Sl()) : uh.set(new Sl());
  }
  anchorNode = Jr(null);
  customAnchorNode = Jr(null);
  triggerNode = Jr(null);
  constructor() {
    Xe(() => {
      this.customAnchorNode.current ? typeof this.customAnchorNode.current == "string" ? this.anchorNode.current = document.querySelector(this.customAnchorNode.current) : this.anchorNode.current = this.customAnchorNode.current : this.anchorNode.current = this.triggerNode.current;
    });
  }
}
class xl {
  static create(e, r = !1) {
    return r ? Wm.set(new xl(e, ch.get())) : Wm.set(new xl(e, uh.get()));
  }
  opts;
  root;
  // nodes
  contentRef = Jr(null);
  wrapperRef = Jr(null);
  arrowRef = Jr(null);
  contentAttachment = Te(this.contentRef);
  wrapperAttachment = Te(this.wrapperRef);
  arrowAttachment = Te(this.arrowRef);
  // ids
  arrowId = Jr(En());
  #e = /* @__PURE__ */ O(() => {
    if (typeof this.opts.style == "string") return li(this.opts.style);
    if (!this.opts.style) return {};
  });
  #t = void 0;
  #r = new R2(() => this.arrowRef.current ?? void 0);
  #n = /* @__PURE__ */ O(() => this.#r?.width ?? 0);
  #s = /* @__PURE__ */ O(() => this.#r?.height ?? 0);
  #o = /* @__PURE__ */ O(() => this.opts.side?.current + (this.opts.align.current !== "center" ? `-${this.opts.align.current}` : ""));
  #i = /* @__PURE__ */ O(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current]);
  #a = /* @__PURE__ */ O(() => d(this.#i).length > 0);
  get hasExplicitBoundaries() {
    return d(this.#a);
  }
  set hasExplicitBoundaries(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => ({
    padding: this.opts.collisionPadding.current,
    boundary: d(this.#i).filter(iT),
    altBoundary: this.hasExplicitBoundaries
  }));
  get detectOverflowOptions() {
    return d(this.#u);
  }
  set detectOverflowOptions(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ xe(void 0);
  #c = /* @__PURE__ */ xe(void 0);
  #d = /* @__PURE__ */ xe(void 0);
  #g = /* @__PURE__ */ xe(void 0);
  #m = /* @__PURE__ */ O(() => [
    gI({
      mainAxis: this.opts.sideOffset.current + d(this.#s),
      alignmentAxis: this.opts.alignOffset.current
    }),
    this.opts.avoidCollisions.current && pI({
      mainAxis: !0,
      crossAxis: !1,
      limiter: this.opts.sticky.current === "partial" ? _I() : void 0,
      ...this.detectOverflowOptions
    }),
    this.opts.avoidCollisions.current && mI({ ...this.detectOverflowOptions }),
    vI({
      ...this.detectOverflowOptions,
      apply: ({ rects: e, availableWidth: r, availableHeight: n }) => {
        const { width: s, height: o } = e.reference;
        q(this.#l, r, !0), q(this.#c, n, !0), q(this.#d, s, !0), q(this.#g, o, !0);
      }
    }),
    this.arrowRef.current && bI({
      element: this.arrowRef.current,
      padding: this.opts.arrowPadding.current
    }),
    PI({
      arrowWidth: d(this.#n),
      arrowHeight: d(this.#s)
    }),
    this.opts.hideWhenDetached.current && yI({ strategy: "referenceHidden", ...this.detectOverflowOptions })
  ].filter(Boolean));
  get middleware() {
    return d(this.#m);
  }
  set middleware(e) {
    q(this.#m, e);
  }
  floating;
  #p = /* @__PURE__ */ O(() => OI(this.floating.placement));
  get placedSide() {
    return d(this.#p);
  }
  set placedSide(e) {
    q(this.#p, e);
  }
  #f = /* @__PURE__ */ O(() => CI(this.floating.placement));
  get placedAlign() {
    return d(this.#f);
  }
  set placedAlign(e) {
    q(this.#f, e);
  }
  #h = /* @__PURE__ */ O(() => this.floating.middlewareData.arrow?.x ?? 0);
  get arrowX() {
    return d(this.#h);
  }
  set arrowX(e) {
    q(this.#h, e);
  }
  #b = /* @__PURE__ */ O(() => this.floating.middlewareData.arrow?.y ?? 0);
  get arrowY() {
    return d(this.#b);
  }
  set arrowY(e) {
    q(this.#b, e);
  }
  #y = /* @__PURE__ */ O(() => this.floating.middlewareData.arrow?.centerOffset !== 0);
  get cannotCenterArrow() {
    return d(this.#y);
  }
  set cannotCenterArrow(e) {
    q(this.#y, e);
  }
  #v = /* @__PURE__ */ xe();
  get contentZIndex() {
    return d(this.#v);
  }
  set contentZIndex(e) {
    q(this.#v, e, !0);
  }
  #S = /* @__PURE__ */ O(() => xI[this.placedSide]);
  get arrowBaseSide() {
    return d(this.#S);
  }
  set arrowBaseSide(e) {
    q(this.#S, e);
  }
  #w = /* @__PURE__ */ O(() => ({
    id: this.opts.wrapperId.current,
    "data-bits-floating-content-wrapper": "",
    style: {
      ...this.floating.floatingStyles,
      transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: this.contentZIndex,
      "--bits-floating-transform-origin": `${this.floating.middlewareData.transformOrigin?.x} ${this.floating.middlewareData.transformOrigin?.y}`,
      "--bits-floating-available-width": `${d(this.#l)}px`,
      "--bits-floating-available-height": `${d(this.#c)}px`,
      "--bits-floating-anchor-width": `${d(this.#d)}px`,
      "--bits-floating-anchor-height": `${d(this.#g)}px`,
      ...this.floating.middlewareData.hide?.referenceHidden && { visibility: "hidden", "pointer-events": "none" },
      ...d(this.#e)
    },
    dir: this.opts.dir.current,
    ...this.wrapperAttachment
  }));
  get wrapperProps() {
    return d(this.#w);
  }
  set wrapperProps(e) {
    q(this.#w, e);
  }
  #x = /* @__PURE__ */ O(() => ({
    "data-side": this.placedSide,
    "data-align": this.placedAlign,
    style: iu({ ...d(this.#e) }),
    ...this.contentAttachment
  }));
  get props() {
    return d(this.#x);
  }
  set props(e) {
    q(this.#x, e);
  }
  #_ = /* @__PURE__ */ O(() => ({
    position: "absolute",
    left: this.arrowX ? `${this.arrowX}px` : void 0,
    top: this.arrowY ? `${this.arrowY}px` : void 0,
    [this.arrowBaseSide]: 0,
    "transform-origin": { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[this.placedSide],
    transform: {
      top: "translateY(100%)",
      right: "translateY(50%) rotate(90deg) translateX(-50%)",
      bottom: "rotate(180deg)",
      left: "translateY(50%) rotate(-90deg) translateX(50%)"
    }[this.placedSide],
    visibility: this.cannotCenterArrow ? "hidden" : void 0
  }));
  get arrowStyle() {
    return d(this.#_);
  }
  set arrowStyle(e) {
    q(this.#_, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, e.customAnchor && (this.root.customAnchorNode.current = e.customAnchor.current), Fe(() => e.customAnchor.current, (n) => {
      this.root.customAnchorNode.current = n;
    }), this.floating = SI({
      strategy: () => this.opts.strategy.current,
      placement: () => d(this.#o),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...n) => hI(...n, {
        animationFrame: this.#t?.current === "always"
      }),
      open: () => this.opts.enabled.current,
      sideOffset: () => this.opts.sideOffset.current,
      alignOffset: () => this.opts.alignOffset.current
    }), Xe(() => {
      this.floating.isPositioned && this.opts.onPlaced?.current();
    }), Fe(() => this.contentRef.current, (n) => {
      if (!n) return;
      const s = u0(n);
      this.contentZIndex = s.getComputedStyle(n).zIndex;
    }), Xe(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
}
class Pl {
  static create(e, r = !1) {
    return r ? new Pl(e, ch.get()) : new Pl(e, uh.get());
  }
  opts;
  root;
  constructor(e, r) {
    this.opts = e, this.root = r, e.virtualEl && e.virtualEl.current ? r.triggerNode = e0(e.virtualEl.current) : r.triggerNode = e.ref;
  }
}
function PI(t) {
  return {
    name: "transformOrigin",
    options: t,
    fn(e) {
      const { placement: r, rects: n, middlewareData: s } = e, i = s.arrow?.centerOffset !== 0, a = i ? 0 : t.arrowWidth, l = i ? 0 : t.arrowHeight, [u, c] = dh(r), f = { start: "0%", center: "50%", end: "100%" }[c], h = (s.arrow?.x ?? 0) + a / 2, _ = (s.arrow?.y ?? 0) + l / 2;
      let b = "", p = "";
      return u === "bottom" ? (b = i ? f : `${h}px`, p = `${-l}px`) : u === "top" ? (b = i ? f : `${h}px`, p = `${n.floating.height + l}px`) : u === "right" ? (b = `${-l}px`, p = i ? f : `${_}px`) : u === "left" && (b = `${n.floating.width + l}px`, p = i ? f : `${_}px`), { data: { x: b, y: p } };
    }
  };
}
function dh(t) {
  const [e, r = "center"] = t.split("-");
  return [e, r];
}
function OI(t) {
  return dh(t)[0];
}
function CI(t) {
  return dh(t)[1];
}
function fh(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "tooltip", 7, !1);
  Sl.create(n());
  var s = {
    get children() {
      return r();
    },
    set children(a) {
      r(a), m();
    },
    get tooltip() {
      return n();
    },
    set tooltip(a = !1) {
      n(a), m();
    }
  }, o = M(), i = D(o);
  return te(i, () => r() ?? he), A(t, o), H(s);
}
K(fh, { children: {}, tooltip: {} }, [], [], { mode: "open" });
class kI {
  #e;
  #t = /* @__PURE__ */ O(() => this.#e.candidateValues());
  #r;
  constructor(e) {
    this.#e = e, this.#r = C0("", { afterMs: 1e3, getWindow: this.#e.getWindow }), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(e) {
    if (!this.#e.enabled() || !d(this.#t).length) return;
    this.#r.current = this.#r.current + e;
    const r = this.#e.getCurrentItem(), n = d(this.#t).find((a) => a === r) ?? "", s = d(this.#t).map((a) => a ?? ""), o = gf(s, this.#r.current, n), i = d(this.#t).find((a) => a === o);
    return i && this.#e.onMatch(i), i;
  }
  resetTypeahead() {
    this.#r.current = "";
  }
}
const $I = [dr, d0, Vo], AI = [Qt, c0, Ro], EI = [...$I, ...AI], TI = nr({
  component: "select",
  parts: [
    "trigger",
    "content",
    "item",
    "viewport",
    "scroll-up-button",
    "scroll-down-button",
    "group",
    "group-label",
    "separator",
    "arrow",
    "input",
    "content-wrapper",
    "item-text",
    "value"
  ]
}), qo = new ht("Select.Root | Combobox.Root"), Rw = new ht("Select.Group | Combobox.Group"), gu = new ht("Select.Content | Combobox.Content");
class Vw {
  opts;
  #e = /* @__PURE__ */ xe(!1);
  get touchedInput() {
    return d(this.#e);
  }
  set touchedInput(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(null);
  get inputNode() {
    return d(this.#t);
  }
  set inputNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#r);
  }
  set contentNode(e) {
    q(this.#r, e, !0);
  }
  contentPresence;
  #n = /* @__PURE__ */ xe(null);
  get viewportNode() {
    return d(this.#n);
  }
  set viewportNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#s);
  }
  set triggerNode(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe("");
  get valueId() {
    return d(this.#o);
  }
  set valueId(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(null);
  get highlightedNode() {
    return d(this.#i);
  }
  set highlightedNode(e) {
    q(this.#i, e, !0);
  }
  #a = /* @__PURE__ */ O(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-value") : null);
  get highlightedValue() {
    return d(this.#a);
  }
  set highlightedValue(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => {
    if (this.highlightedNode)
      return this.highlightedNode.id;
  });
  get highlightedId() {
    return d(this.#u);
  }
  set highlightedId(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-label") : null);
  get highlightedLabel() {
    return d(this.#l);
  }
  set highlightedLabel(e) {
    q(this.#l, e);
  }
  isUsingKeyboard = !1;
  isCombobox = !1;
  domContext = new Fn(() => null);
  constructor(e) {
    this.opts = e, this.isCombobox = e.isCombobox, this.contentPresence = new wi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), ko(() => {
      this.opts.open.current || this.setHighlightedNode(null);
    });
  }
  setHighlightedNode(e, r = !1) {
    this.highlightedNode = e, e && (this.isUsingKeyboard || r) && e.scrollIntoView({ block: this.opts.scrollAlignment.current });
  }
  getCandidateNodes() {
    const e = this.contentNode;
    return e ? Array.from(e.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`)) : [];
  }
  setHighlightedToFirstCandidate(e = !1) {
    this.setHighlightedNode(null);
    let r = this.getCandidateNodes();
    if (r.length) {
      if (this.viewportNode) {
        const n = this.viewportNode.getBoundingClientRect();
        r = r.filter((s) => {
          if (!this.viewportNode) return !1;
          const o = s.getBoundingClientRect();
          return o.right < n.right && o.left > n.left && o.bottom < n.bottom && o.top > n.top;
        });
      }
      this.setHighlightedNode(r[0], e);
    }
  }
  getNodeByValue(e) {
    return this.getCandidateNodes().find((n) => n.dataset.value === e) ?? null;
  }
  setOpen(e) {
    this.opts.open.current = e;
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleOpen() {
    this.setOpen(!0);
  }
  handleClose() {
    this.setHighlightedNode(null), this.setOpen(!1);
  }
  toggleMenu() {
    this.toggleOpen();
  }
  getBitsAttr = (e) => TI.getAttr(e, this.isCombobox ? "combobox" : void 0);
}
class DI extends Vw {
  opts;
  isMulti = !1;
  #e = /* @__PURE__ */ O(() => this.opts.value.current !== "");
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.opts.items.current.length ? this.opts.items.current.find((e) => e.value === this.opts.value.current)?.label ?? "" : "");
  get currentLabel() {
    return d(this.#t);
  }
  set currentLabel(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.opts.items.current.length ? this.opts.items.current.filter((r) => !r.disabled).map((r) => r.label) : []);
  get candidateLabels() {
    return d(this.#r);
  }
  set candidateLabels(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => !(this.isMulti || this.opts.items.current.length === 0));
  get dataTypeaheadEnabled() {
    return d(this.#n);
  }
  set dataTypeaheadEnabled(e) {
    q(this.#n, e);
  }
  constructor(e) {
    super(e), this.opts = e, Xe(() => {
      !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null);
    }), Fe(() => this.opts.open.current, () => {
      this.opts.open.current && this.setInitialHighlightedNode();
    });
  }
  includesItem(e) {
    return this.opts.value.current === e;
  }
  toggleItem(e, r = e) {
    const n = this.includesItem(e) ? "" : e;
    this.opts.value.current = n, n !== "" && (this.opts.inputValue.current = r);
  }
  setInitialHighlightedNode() {
    Jt(() => {
      if (!(this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode))) {
        if (this.opts.value.current !== "") {
          const e = this.getNodeByValue(this.opts.value.current);
          if (e) {
            this.setHighlightedNode(e, !0);
            return;
          }
        }
        this.setHighlightedToFirstCandidate(!0);
      }
    });
  }
}
class MI extends Vw {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ O(() => this.opts.value.current.length > 0);
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e, Xe(() => {
      !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null);
    }), Fe(() => this.opts.open.current, () => {
      this.opts.open.current && this.setInitialHighlightedNode();
    });
  }
  includesItem(e) {
    return this.opts.value.current.includes(e);
  }
  toggleItem(e, r = e) {
    this.includesItem(e) ? this.opts.value.current = this.opts.value.current.filter((n) => n !== e) : this.opts.value.current = [...this.opts.value.current, e], this.opts.inputValue.current = r;
  }
  setInitialHighlightedNode() {
    Jt(() => {
      if (this.domContext && !(this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode))) {
        if (this.opts.value.current.length && this.opts.value.current[0] !== "") {
          const e = this.getNodeByValue(this.opts.value.current[0]);
          if (e) {
            this.setHighlightedNode(e, !0);
            return;
          }
        }
        this.setHighlightedToFirstCandidate(!0);
      }
    });
  }
}
class II {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new DI(n) : new MI(n);
    return qo.set(s);
  }
}
class hh {
  static create(e) {
    return new hh(e, qo.get());
  }
  opts;
  root;
  attachment;
  #e;
  #t;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref, (n) => this.root.triggerNode = n), this.root.domContext = new Fn(e.ref), this.#e = new BT({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (n) => {
        this.root.setHighlightedNode(n);
      },
      getActiveElement: () => this.root.domContext.getActiveElement(),
      getWindow: () => this.root.domContext.getWindow()
    }), this.#t = new kI({
      getCurrentItem: () => this.root.isMulti ? "" : this.root.currentLabel,
      onMatch: (n) => {
        if (this.root.isMulti || !this.root.opts.items.current) return;
        const s = this.root.opts.items.current.find((o) => o.label === n);
        s && (this.root.opts.value.current = s.value);
      },
      enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled,
      candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels,
      getWindow: () => this.root.domContext.getWindow()
    }), this.onkeydown = this.onkeydown.bind(this), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onclick = this.onclick.bind(this);
  }
  #r() {
    this.root.opts.open.current = !0, this.#t.resetTypeahead(), this.#e.resetTypeahead();
  }
  #n(e) {
    this.#r();
  }
  /**
   * Logic used to handle keyboard selection/deselection.
   *
   * If it returns true, it means the item was selected and whatever is calling
   * this function should return early
   *
   */
  #s() {
    const e = this.root.highlightedValue === this.root.opts.value.current;
    return !this.root.opts.allowDeselect.current && e && !this.root.isMulti ? (this.root.handleClose(), !0) : (this.root.highlightedValue !== null && this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0), !this.root.isMulti && !e ? (this.root.handleClose(), !0) : !1);
  }
  onkeydown(e) {
    if (this.root.isUsingKeyboard = !0, (e.key === Qt || e.key === dr) && e.preventDefault(), !this.root.opts.open.current) {
      if (e.key === Br || e.key === xr || e.key === dr || e.key === Qt)
        e.preventDefault(), this.root.handleOpen();
      else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
        this.#t.handleTypeaheadSearch(e.key);
        return;
      }
      if (this.root.hasValue) return;
      const i = this.root.getCandidateNodes();
      if (!i.length) return;
      if (e.key === dr) {
        const a = i[0];
        this.root.setHighlightedNode(a);
      } else if (e.key === Qt) {
        const a = i[i.length - 1];
        this.root.setHighlightedNode(a);
      }
      return;
    }
    if (e.key === _m) {
      this.root.handleClose();
      return;
    }
    if ((e.key === Br || // if we're currently "typing ahead", we don't want to select the item
    // just yet as the item the user is trying to get to may have a space in it,
    // so we defer handling the close for this case until further down
    e.key === xr && this.#e.search === "") && !e.isComposing && (e.preventDefault(), this.#s()))
      return;
    if (e.key === Qt && e.altKey && this.root.handleClose(), EI.includes(e.key)) {
      e.preventDefault();
      const i = this.root.getCandidateNodes(), a = this.root.highlightedNode, l = a ? i.indexOf(a) : -1, u = this.root.opts.loop.current;
      let c;
      if (e.key === dr ? c = FT(i, l, u) : e.key === Qt ? c = RT(i, l, u) : e.key === c0 ? c = VT(i, l, 10, u) : e.key === d0 ? c = LT(i, l, 10, u) : e.key === Vo ? c = i[0] : e.key === Ro && (c = i[i.length - 1]), !c) return;
      this.root.setHighlightedNode(c);
      return;
    }
    const r = e.ctrlKey || e.altKey || e.metaKey, n = e.key.length === 1, s = e.key === xr, o = this.root.getCandidateNodes();
    if (e.key !== _m) {
      if (!r && (n || s)) {
        !this.#e.handleTypeaheadSearch(e.key, o) && s && (e.preventDefault(), this.#s());
        return;
      }
      this.root.highlightedNode || this.root.setHighlightedToFirstCandidate();
    }
  }
  onclick(e) {
    e.currentTarget.focus();
  }
  onpointerdown(e) {
    if (this.root.opts.disabled.current) return;
    if (e.pointerType === "touch") return e.preventDefault();
    const r = e.target;
    r?.hasPointerCapture(e.pointerId) && r?.releasePointerCapture(e.pointerId), e.button === 0 && e.ctrlKey === !1 && (this.root.opts.open.current === !1 ? this.#n(e) : this.root.handleClose());
  }
  onpointerup(e) {
    this.root.opts.disabled.current || (e.preventDefault(), e.pointerType === "touch" && (this.root.opts.open.current === !1 ? this.#n(e) : this.root.handleClose()));
  }
  #o = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    disabled: this.root.opts.disabled.current ? !0 : void 0,
    "aria-haspopup": "listbox",
    "aria-expanded": at(this.root.opts.open.current),
    "aria-activedescendant": this.root.highlightedId,
    "data-state": ji(this.root.opts.open.current),
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-placeholder": this.root.hasValue ? void 0 : "",
    [this.root.getBitsAttr("trigger")]: "",
    onpointerdown: this.onpointerdown,
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    onpointerup: this.onpointerup,
    ...this.attachment
  }));
  get props() {
    return d(this.#o);
  }
  set props(e) {
    q(this.#o, e);
  }
}
class gh {
  static create(e) {
    return gu.set(new gh(e, qo.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ xe(!1);
  get isPositioned() {
    return d(this.#e);
  }
  set isPositioned(e) {
    q(this.#e, e, !0);
  }
  domContext;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref, (n) => this.root.contentNode = n), this.domContext = new Fn(this.opts.ref), this.root.domContext === null && (this.root.domContext = this.domContext), Ys(() => {
      this.root.contentNode = null, this.isPositioned = !1;
    }), Fe(() => this.root.opts.open.current, () => {
      this.root.opts.open.current || (this.isPositioned = !1);
    }), this.onpointermove = this.onpointermove.bind(this);
  }
  onpointermove(e) {
    this.root.isUsingKeyboard = !1;
  }
  #t = /* @__PURE__ */ O(() => Yc(this.root.isCombobox ? "combobox" : "select"));
  onInteractOutside = (e) => {
    if (e.target === this.root.triggerNode || e.target === this.root.inputNode) {
      e.preventDefault();
      return;
    }
    this.opts.onInteractOutside.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  #r = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#r);
  }
  set snippetProps(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "listbox",
    "aria-multiselectable": this.root.isMulti ? "true" : void 0,
    "data-state": ji(this.root.opts.open.current),
    [this.root.getBitsAttr("content")]: "",
    style: {
      display: "flex",
      flexDirection: "column",
      outline: "none",
      boxSizing: "border-box",
      pointerEvents: "auto",
      ...d(this.#t)
    },
    onpointermove: this.onpointermove,
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onOpenAutoFocus: this.onOpenAutoFocus,
    onCloseAutoFocus: this.onCloseAutoFocus,
    trapFocus: !1,
    loop: !1,
    onPlaced: () => {
      this.root.opts.open.current && (this.isPositioned = !0);
    }
  };
}
class ph {
  static create(e) {
    return new ph(e, qo.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root.includesItem(this.opts.value.current));
  get isSelected() {
    return d(this.#e);
  }
  set isSelected(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.root.highlightedValue === this.opts.value.current);
  get isHighlighted() {
    return d(this.#t);
  }
  set isHighlighted(e) {
    q(this.#t, e);
  }
  prevHighlighted = new V2(() => this.isHighlighted);
  #r = /* @__PURE__ */ xe(!1);
  get mounted() {
    return d(this.#r);
  }
  set mounted(e) {
    q(this.#r, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref), Fe([() => this.isHighlighted, () => this.prevHighlighted.current], () => {
      this.isHighlighted ? this.opts.onHighlight.current() : this.prevHighlighted.current && this.opts.onUnhighlight.current();
    }), Fe(() => this.mounted, () => {
      this.mounted && this.root.setInitialHighlightedNode();
    }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onpointermove = this.onpointermove.bind(this);
  }
  handleSelect() {
    if (this.opts.disabled.current) return;
    const e = this.opts.value.current === this.root.opts.value.current;
    if (!this.root.opts.allowDeselect.current && e && !this.root.isMulti) {
      this.root.handleClose();
      return;
    }
    this.root.toggleItem(this.opts.value.current, this.opts.label.current), !this.root.isMulti && !e && this.root.handleClose();
  }
  #n = /* @__PURE__ */ O(() => ({ selected: this.isSelected, highlighted: this.isHighlighted }));
  get snippetProps() {
    return d(this.#n);
  }
  set snippetProps(e) {
    q(this.#n, e);
  }
  onpointerdown(e) {
    e.preventDefault();
  }
  /**
   * Using `pointerup` instead of `click` allows power users to pointerdown
   * the trigger, then release pointerup on an item to select it vs having to do
   * multiple clicks.
   */
  onpointerup(e) {
    if (!(e.defaultPrevented || !this.opts.ref.current)) {
      if (e.pointerType === "touch" && !jc) {
        Ye(
          this.opts.ref.current,
          "click",
          () => {
            this.handleSelect(), this.root.setHighlightedNode(this.opts.ref.current);
          },
          { once: !0 }
        );
        return;
      }
      e.preventDefault(), this.handleSelect(), e.pointerType === "touch" && this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  onpointermove(e) {
    e.pointerType !== "touch" && this.root.highlightedNode !== this.opts.ref.current && this.root.setHighlightedNode(this.opts.ref.current);
  }
  #s = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "option",
    "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0,
    "data-value": this.opts.value.current,
    "data-disabled": Re(this.opts.disabled.current),
    "data-highlighted": this.root.highlightedValue === this.opts.value.current && !this.opts.disabled.current ? "" : void 0,
    "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0,
    "data-label": this.opts.label.current,
    [this.root.getBitsAttr("item")]: "",
    onpointermove: this.onpointermove,
    onpointerdown: this.onpointerdown,
    onpointerup: this.onpointerup,
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class mh {
  static create(e) {
    return Rw.set(new mh(e, qo.get()));
  }
  opts;
  root;
  #e = /* @__PURE__ */ xe(null);
  get labelNode() {
    return d(this.#e);
  }
  set labelNode(e) {
    q(this.#e, e, !0);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "group",
    [this.root.getBitsAttr("group")]: "",
    "aria-labelledby": this.labelNode?.id ?? void 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class vh {
  static create(e) {
    return new vh(e, Rw.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(e.ref, (n) => this.group.labelNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.group.root.getBitsAttr("group-label")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class yh {
  static create(e) {
    return new yh(e, qo.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => this.root.opts.name.current !== "");
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    e.preventDefault(), this.root.isCombobox ? this.root.inputNode?.focus() : this.root.triggerNode?.focus();
  }
  #t = /* @__PURE__ */ O(() => ({
    disabled: _i(this.root.opts.disabled.current),
    required: _i(this.root.opts.required.current),
    name: this.root.opts.name.current,
    value: this.opts.value.current,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class bh {
  static create(e) {
    return new bh(e, gu.get());
  }
  opts;
  content;
  root;
  attachment;
  #e = /* @__PURE__ */ xe(0);
  get prevScrollTop() {
    return d(this.#e);
  }
  set prevScrollTop(e) {
    q(this.#e, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.content = r, this.root = r.root, this.attachment = Te(e.ref, (n) => {
      this.root.viewportNode = n;
    });
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "presentation",
    [this.root.getBitsAttr("viewport")]: "",
    style: {
      // we use position: 'relative' here on the `viewport` so that when we call
      // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
      // (independent of the scrollUpButton).
      position: "relative",
      flex: 1,
      overflow: "auto"
    },
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Lw {
  opts;
  content;
  root;
  attachment;
  autoScrollTimer = null;
  userScrollTimer = -1;
  isUserScrolling = !1;
  onAutoScroll = _e;
  #e = /* @__PURE__ */ xe(!1);
  get mounted() {
    return d(this.#e);
  }
  set mounted(e) {
    q(this.#e, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.content = r, this.root = r.root, this.attachment = Te(e.ref), Fe([() => this.mounted], () => {
      if (!this.mounted) {
        this.isUserScrolling = !1;
        return;
      }
      this.isUserScrolling;
    }), Xe(() => {
      this.mounted || this.clearAutoScrollInterval();
    }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointermove = this.onpointermove.bind(this), this.onpointerleave = this.onpointerleave.bind(this);
  }
  handleUserScroll() {
    this.content.domContext.clearTimeout(this.userScrollTimer), this.isUserScrolling = !0, this.userScrollTimer = this.content.domContext.setTimeout(
      () => {
        this.isUserScrolling = !1;
      },
      200
    );
  }
  clearAutoScrollInterval() {
    this.autoScrollTimer !== null && (this.content.domContext.clearTimeout(this.autoScrollTimer), this.autoScrollTimer = null);
  }
  onpointerdown(e) {
    if (this.autoScrollTimer !== null) return;
    const r = (n) => {
      this.onAutoScroll(), this.autoScrollTimer = this.content.domContext.setTimeout(() => r(n + 1), this.opts.delay.current(n));
    };
    this.autoScrollTimer = this.content.domContext.setTimeout(() => r(1), this.opts.delay.current(0));
  }
  onpointermove(e) {
    this.onpointerdown(e);
  }
  onpointerleave(e) {
    this.clearAutoScrollInterval();
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-hidden": sf(!0),
    style: { flexShrink: 0 },
    onpointerdown: this.onpointerdown,
    onpointermove: this.onpointermove,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class _h {
  static create(e) {
    return new _h(new Lw(e, gu.get()));
  }
  scrollButtonState;
  content;
  root;
  #e = /* @__PURE__ */ xe(!1);
  get canScrollDown() {
    return d(this.#e);
  }
  set canScrollDown(e) {
    q(this.#e, e, !0);
  }
  scrollIntoViewTimer = null;
  constructor(e) {
    this.scrollButtonState = e, this.content = e.content, this.root = e.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, Fe(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!(!this.root.viewportNode || !this.content.isPositioned))
          return this.handleScroll(!0), Ye(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    ), Fe(
      [
        () => this.root.opts.inputValue.current,
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        !this.root.viewportNode || !this.content.isPositioned || this.handleScroll(!0);
      }
    ), Fe(() => this.scrollButtonState.mounted, () => {
      this.scrollButtonState.mounted && (this.scrollIntoViewTimer && clearTimeout(this.scrollIntoViewTimer), this.scrollIntoViewTimer = rf(5, () => {
        this.root.highlightedNode?.scrollIntoView({ block: this.root.opts.scrollAlignment.current });
      }));
    });
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (e = !1) => {
    if (e || this.scrollButtonState.handleUserScroll(), !this.root.viewportNode) return;
    const r = this.root.viewportNode.scrollHeight - this.root.viewportNode.clientHeight, n = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
    this.canScrollDown = Math.ceil(this.root.viewportNode.scrollTop) < r - n;
  };
  handleAutoScroll = () => {
    const e = this.root.viewportNode, r = this.root.highlightedNode;
    !e || !r || (e.scrollTop = e.scrollTop + r.offsetHeight);
  };
  #t = /* @__PURE__ */ O(() => ({
    ...this.scrollButtonState.props,
    [this.root.getBitsAttr("scroll-down-button")]: ""
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class wh {
  static create(e) {
    return new wh(new Lw(e, gu.get()));
  }
  scrollButtonState;
  content;
  root;
  #e = /* @__PURE__ */ xe(!1);
  get canScrollUp() {
    return d(this.#e);
  }
  set canScrollUp(e) {
    q(this.#e, e, !0);
  }
  constructor(e) {
    this.scrollButtonState = e, this.content = e.content, this.root = e.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, Fe(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!(!this.root.viewportNode || !this.content.isPositioned))
          return this.handleScroll(!0), Ye(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    );
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (e = !1) => {
    if (e || this.scrollButtonState.handleUserScroll(), !this.root.viewportNode) return;
    const r = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
    this.canScrollUp = this.root.viewportNode.scrollTop - r > 0.1;
  };
  handleAutoScroll = () => {
    !this.root.viewportNode || !this.root.highlightedNode || (this.root.viewportNode.scrollTop = this.root.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight);
  };
  #t = /* @__PURE__ */ O(() => ({
    ...this.scrollButtonState.props,
    [this.root.getBitsAttr("scroll-up-button")]: ""
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function Xa(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "autocomplete", 7);
  const s = yh.create({ value: z(() => r()) });
  var o = {
    get value() {
      return r();
    },
    set value(u) {
      r(u), m();
    },
    get autocomplete() {
      return n();
    },
    set autocomplete(u) {
      n(u), m();
    }
  }, i = M(), a = D(i);
  {
    var l = (u) => {
      zi(u, ce(() => s.props, {
        get autocomplete() {
          return n();
        },
        get value() {
          return r();
        },
        set value(c) {
          r(c);
        }
      }));
    };
    ue(a, (u) => {
      s.shouldRender && u(l);
    });
  }
  return A(t, i), H(o);
}
K(Xa, { value: {}, autocomplete: {} }, [], [], { mode: "open" });
function Sh(t, e) {
  W(e, !0);
  let r = v(e, "id", 7), n = v(e, "children", 7), s = v(e, "virtualEl", 7), o = v(e, "ref", 7), i = v(e, "tooltip", 7, !1);
  Pl.create(
    {
      id: z(() => r()),
      virtualEl: z(() => s()),
      ref: o()
    },
    i()
  );
  var a = {
    get id() {
      return r();
    },
    set id(c) {
      r(c), m();
    },
    get children() {
      return n();
    },
    set children(c) {
      n(c), m();
    },
    get virtualEl() {
      return s();
    },
    set virtualEl(c) {
      s(c), m();
    },
    get ref() {
      return o();
    },
    set ref(c) {
      o(c), m();
    },
    get tooltip() {
      return i();
    },
    set tooltip(c = !1) {
      i(c), m();
    }
  }, l = M(), u = D(l);
  return te(u, () => n() ?? he), A(t, l), H(a);
}
K(Sh, { id: {}, children: {}, virtualEl: {}, ref: {}, tooltip: {} }, [], [], { mode: "open" });
function jw(t, e) {
  W(e, !0);
  let r = v(e, "content", 7), n = v(e, "side", 7, "bottom"), s = v(e, "sideOffset", 7, 0), o = v(e, "align", 7, "center"), i = v(e, "alignOffset", 7, 0), a = v(e, "id", 7), l = v(e, "arrowPadding", 7, 0), u = v(e, "avoidCollisions", 7, !0), c = v(e, "collisionBoundary", 23, () => []), f = v(e, "collisionPadding", 7, 0), h = v(e, "hideWhenDetached", 7, !1), _ = v(e, "onPlaced", 7, () => {
  }), b = v(e, "sticky", 7, "partial"), p = v(e, "updatePositionStrategy", 7, "optimized"), g = v(e, "strategy", 7, "fixed"), y = v(e, "dir", 7, "ltr"), S = v(e, "style", 23, () => ({})), x = v(e, "wrapperId", 23, En), P = v(e, "customAnchor", 7, null), w = v(e, "enabled", 7), C = v(e, "tooltip", 7, !1);
  const k = xl.create(
    {
      side: z(() => n()),
      sideOffset: z(() => s()),
      align: z(() => o()),
      alignOffset: z(() => i()),
      id: z(() => a()),
      arrowPadding: z(() => l()),
      avoidCollisions: z(() => u()),
      collisionBoundary: z(() => c()),
      collisionPadding: z(() => f()),
      hideWhenDetached: z(() => h()),
      onPlaced: z(() => _()),
      sticky: z(() => b()),
      updatePositionStrategy: z(() => p()),
      strategy: z(() => g()),
      dir: z(() => y()),
      style: z(() => S()),
      enabled: z(() => w()),
      wrapperId: z(() => x()),
      customAnchor: z(() => P())
    },
    C()
  ), $ = /* @__PURE__ */ O(() => Ce(k.wrapperProps, { style: { pointerEvents: "auto" } }));
  var T = {
    get content() {
      return r();
    },
    set content(F) {
      r(F), m();
    },
    get side() {
      return n();
    },
    set side(F = "bottom") {
      n(F), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(F = 0) {
      s(F), m();
    },
    get align() {
      return o();
    },
    set align(F = "center") {
      o(F), m();
    },
    get alignOffset() {
      return i();
    },
    set alignOffset(F = 0) {
      i(F), m();
    },
    get id() {
      return a();
    },
    set id(F) {
      a(F), m();
    },
    get arrowPadding() {
      return l();
    },
    set arrowPadding(F = 0) {
      l(F), m();
    },
    get avoidCollisions() {
      return u();
    },
    set avoidCollisions(F = !0) {
      u(F), m();
    },
    get collisionBoundary() {
      return c();
    },
    set collisionBoundary(F = []) {
      c(F), m();
    },
    get collisionPadding() {
      return f();
    },
    set collisionPadding(F = 0) {
      f(F), m();
    },
    get hideWhenDetached() {
      return h();
    },
    set hideWhenDetached(F = !1) {
      h(F), m();
    },
    get onPlaced() {
      return _();
    },
    set onPlaced(F = () => {
    }) {
      _(F), m();
    },
    get sticky() {
      return b();
    },
    set sticky(F = "partial") {
      b(F), m();
    },
    get updatePositionStrategy() {
      return p();
    },
    set updatePositionStrategy(F = "optimized") {
      p(F), m();
    },
    get strategy() {
      return g();
    },
    set strategy(F = "fixed") {
      g(F), m();
    },
    get dir() {
      return y();
    },
    set dir(F = "ltr") {
      y(F), m();
    },
    get style() {
      return S();
    },
    set style(F = {}) {
      S(F), m();
    },
    get wrapperId() {
      return x();
    },
    set wrapperId(F = En()) {
      x(F), m();
    },
    get customAnchor() {
      return P();
    },
    set customAnchor(F = null) {
      P(F), m();
    },
    get enabled() {
      return w();
    },
    set enabled(F) {
      w(F), m();
    },
    get tooltip() {
      return C();
    },
    set tooltip(F = !1) {
      C(F), m();
    }
  }, E = M(), I = D(E);
  return te(I, () => r() ?? he, () => ({ props: k.props, wrapperProps: d($) })), A(t, E), H(T);
}
K(
  jw,
  {
    content: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    id: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    hideWhenDetached: {},
    onPlaced: {},
    sticky: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    style: {},
    wrapperId: {},
    customAnchor: {},
    enabled: {},
    tooltip: {}
  },
  [],
  [],
  { mode: "open" }
);
function Bw(t, e) {
  W(e, !0);
  let r = v(e, "content", 7), n = v(e, "onPlaced", 7);
  $o(() => {
    n()?.();
  });
  var s = {
    get content() {
      return r();
    },
    set content(a) {
      r(a), m();
    },
    get onPlaced() {
      return n();
    },
    set onPlaced(a) {
      n(a), m();
    }
  }, o = M(), i = D(o);
  return te(i, () => r() ?? he, () => ({ props: {}, wrapperProps: {} })), A(t, o), H(s);
}
K(Bw, { content: {}, onPlaced: {} }, [], [], { mode: "open" });
const NI = nr({ component: "separator", parts: ["root"] });
class xh {
  static create(e) {
    return new xh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: this.opts.decorative.current ? "none" : "separator",
    "aria-orientation": this.opts.orientation.current,
    "aria-hidden": sf(this.opts.decorative.current),
    "data-orientation": this.opts.orientation.current,
    [NI.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var FI = /* @__PURE__ */ ne("<div><!></div>");
function zw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "decorative", 7, !1), l = v(e, "orientation", 7, "horizontal"), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "decorative",
    "orientation"
  ]);
  const c = xh.create({
    ref: z(() => s(), (y) => s(y)),
    id: z(() => n()),
    decorative: z(() => a()),
    orientation: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var h = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get ref() {
      return s();
    },
    set ref(y = null) {
      s(y), m();
    },
    get child() {
      return o();
    },
    set child(y) {
      o(y), m();
    },
    get children() {
      return i();
    },
    set children(y) {
      i(y), m();
    },
    get decorative() {
      return a();
    },
    set decorative(y = !1) {
      a(y), m();
    },
    get orientation() {
      return l();
    },
    set orientation(y = "horizontal") {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      te(x, o, () => ({ props: d(f) })), A(y, S);
    }, g = (y) => {
      var S = FI();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => i() ?? he), de(S), A(y, S);
    };
    ue(b, (y) => {
      o() ? y(p) : y(g, !1);
    });
  }
  return A(t, _), H(h);
}
K(
  zw,
  {
    id: {},
    ref: {},
    child: {},
    children: {},
    decorative: {},
    orientation: {}
  },
  [],
  [],
  { mode: "open" }
);
function qw(t, e) {
  W(e, !0);
  let r = v(e, "content", 7), n = v(e, "isStatic", 7, !1), s = v(e, "onPlaced", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "content",
    "isStatic",
    "onPlaced"
  ]);
  var i = {
    get content() {
      return r();
    },
    set content(f) {
      r(f), m();
    },
    get isStatic() {
      return n();
    },
    set isStatic(f = !1) {
      n(f), m();
    },
    get onPlaced() {
      return s();
    },
    set onPlaced(f) {
      s(f), m();
    }
  }, a = M(), l = D(a);
  {
    var u = (f) => {
      Bw(f, {
        get content() {
          return r();
        },
        get onPlaced() {
          return s();
        }
      });
    }, c = (f) => {
      jw(f, ce(
        {
          get content() {
            return r();
          },
          get onPlaced() {
            return s();
          }
        },
        () => o
      ));
    };
    ue(l, (f) => {
      n() ? f(u) : f(c, !1);
    });
  }
  return A(t, a), H(i);
}
K(qw, { content: {}, isStatic: {}, onPlaced: {} }, [], [], { mode: "open" });
var RI = /* @__PURE__ */ ne("<!> <!>", 1);
function Ph(t, e) {
  W(e, !0);
  let r = v(e, "popper", 7), n = v(e, "onEscapeKeydown", 7), s = v(e, "escapeKeydownBehavior", 7), o = v(e, "preventOverflowTextSelection", 7), i = v(e, "id", 7), a = v(e, "onPointerDown", 7), l = v(e, "onPointerUp", 7), u = v(e, "side", 7), c = v(e, "sideOffset", 7), f = v(e, "align", 7), h = v(e, "alignOffset", 7), _ = v(e, "arrowPadding", 7), b = v(e, "avoidCollisions", 7), p = v(e, "collisionBoundary", 7), g = v(e, "collisionPadding", 7), y = v(e, "sticky", 7), S = v(e, "hideWhenDetached", 7), x = v(e, "updatePositionStrategy", 7), P = v(e, "strategy", 7), w = v(e, "dir", 7), C = v(e, "preventScroll", 7), k = v(e, "wrapperId", 7), $ = v(e, "style", 7), T = v(e, "onPlaced", 7), E = v(e, "onInteractOutside", 7), I = v(e, "onCloseAutoFocus", 7), F = v(e, "onOpenAutoFocus", 7), U = v(e, "onFocusOutside", 7), B = v(e, "interactOutsideBehavior", 7, "close"), R = v(e, "loop", 7), Z = v(e, "trapFocus", 7, !0), Y = v(e, "isValidEvent", 7, () => !1), X = v(e, "customAnchor", 7, null), ae = v(e, "isStatic", 7, !1), J = v(e, "enabled", 7), j = v(e, "ref", 7), ee = v(e, "tooltip", 7, !1), L = v(e, "contentPointerEvents", 7, "auto"), N = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled",
    "ref",
    "tooltip",
    "contentPointerEvents"
  ]);
  var V = {
    get popper() {
      return r();
    },
    set popper(G) {
      r(G), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(G) {
      n(G), m();
    },
    get escapeKeydownBehavior() {
      return s();
    },
    set escapeKeydownBehavior(G) {
      s(G), m();
    },
    get preventOverflowTextSelection() {
      return o();
    },
    set preventOverflowTextSelection(G) {
      o(G), m();
    },
    get id() {
      return i();
    },
    set id(G) {
      i(G), m();
    },
    get onPointerDown() {
      return a();
    },
    set onPointerDown(G) {
      a(G), m();
    },
    get onPointerUp() {
      return l();
    },
    set onPointerUp(G) {
      l(G), m();
    },
    get side() {
      return u();
    },
    set side(G) {
      u(G), m();
    },
    get sideOffset() {
      return c();
    },
    set sideOffset(G) {
      c(G), m();
    },
    get align() {
      return f();
    },
    set align(G) {
      f(G), m();
    },
    get alignOffset() {
      return h();
    },
    set alignOffset(G) {
      h(G), m();
    },
    get arrowPadding() {
      return _();
    },
    set arrowPadding(G) {
      _(G), m();
    },
    get avoidCollisions() {
      return b();
    },
    set avoidCollisions(G) {
      b(G), m();
    },
    get collisionBoundary() {
      return p();
    },
    set collisionBoundary(G) {
      p(G), m();
    },
    get collisionPadding() {
      return g();
    },
    set collisionPadding(G) {
      g(G), m();
    },
    get sticky() {
      return y();
    },
    set sticky(G) {
      y(G), m();
    },
    get hideWhenDetached() {
      return S();
    },
    set hideWhenDetached(G) {
      S(G), m();
    },
    get updatePositionStrategy() {
      return x();
    },
    set updatePositionStrategy(G) {
      x(G), m();
    },
    get strategy() {
      return P();
    },
    set strategy(G) {
      P(G), m();
    },
    get dir() {
      return w();
    },
    set dir(G) {
      w(G), m();
    },
    get preventScroll() {
      return C();
    },
    set preventScroll(G) {
      C(G), m();
    },
    get wrapperId() {
      return k();
    },
    set wrapperId(G) {
      k(G), m();
    },
    get style() {
      return $();
    },
    set style(G) {
      $(G), m();
    },
    get onPlaced() {
      return T();
    },
    set onPlaced(G) {
      T(G), m();
    },
    get onInteractOutside() {
      return E();
    },
    set onInteractOutside(G) {
      E(G), m();
    },
    get onCloseAutoFocus() {
      return I();
    },
    set onCloseAutoFocus(G) {
      I(G), m();
    },
    get onOpenAutoFocus() {
      return F();
    },
    set onOpenAutoFocus(G) {
      F(G), m();
    },
    get onFocusOutside() {
      return U();
    },
    set onFocusOutside(G) {
      U(G), m();
    },
    get interactOutsideBehavior() {
      return B();
    },
    set interactOutsideBehavior(G = "close") {
      B(G), m();
    },
    get loop() {
      return R();
    },
    set loop(G) {
      R(G), m();
    },
    get trapFocus() {
      return Z();
    },
    set trapFocus(G = !0) {
      Z(G), m();
    },
    get isValidEvent() {
      return Y();
    },
    set isValidEvent(G = () => !1) {
      Y(G), m();
    },
    get customAnchor() {
      return X();
    },
    set customAnchor(G = null) {
      X(G), m();
    },
    get isStatic() {
      return ae();
    },
    set isStatic(G = !1) {
      ae(G), m();
    },
    get enabled() {
      return J();
    },
    set enabled(G) {
      J(G), m();
    },
    get ref() {
      return j();
    },
    set ref(G) {
      j(G), m();
    },
    get tooltip() {
      return ee();
    },
    set tooltip(G = !1) {
      ee(G), m();
    },
    get contentPointerEvents() {
      return L();
    },
    set contentPointerEvents(G = "auto") {
      L(G), m();
    }
  };
  return qw(t, {
    get isStatic() {
      return ae();
    },
    get id() {
      return i();
    },
    get side() {
      return u();
    },
    get sideOffset() {
      return c();
    },
    get align() {
      return f();
    },
    get alignOffset() {
      return h();
    },
    get arrowPadding() {
      return _();
    },
    get avoidCollisions() {
      return b();
    },
    get collisionBoundary() {
      return p();
    },
    get collisionPadding() {
      return g();
    },
    get sticky() {
      return y();
    },
    get hideWhenDetached() {
      return S();
    },
    get updatePositionStrategy() {
      return x();
    },
    get strategy() {
      return P();
    },
    get dir() {
      return w();
    },
    get wrapperId() {
      return k();
    },
    get style() {
      return $();
    },
    get onPlaced() {
      return T();
    },
    get customAnchor() {
      return X();
    },
    get enabled() {
      return J();
    },
    get tooltip() {
      return ee();
    },
    content: (fe, se) => {
      let we = () => se?.().props, le = () => se?.().wrapperProps;
      var re = RI(), oe = D(re);
      {
        var pe = (Oe) => {
          Si(Oe, {
            get preventScroll() {
              return C();
            }
          });
        }, ye = (Oe) => {
          var Ve = M(), Ke = D(Ve);
          {
            var Le = (je) => {
              Si(je, {
                get preventScroll() {
                  return C();
                }
              });
            };
            ue(
              Ke,
              (je) => {
                e.forceMount || je(Le);
              },
              !0
            );
          }
          A(Oe, Ve);
        };
        ue(oe, (Oe) => {
          e.forceMount && J() ? Oe(pe) : Oe(ye, !1);
        });
      }
      var Pe = be(oe, 2);
      wf(Pe, {
        get onOpenAutoFocus() {
          return F();
        },
        get onCloseAutoFocus() {
          return I();
        },
        get loop() {
          return R();
        },
        get enabled() {
          return J();
        },
        get trapFocus() {
          return Z();
        },
        get forceMount() {
          return e.forceMount;
        },
        get ref() {
          return j();
        },
        focusScope: (Ve, Ke) => {
          let Le = () => Ke?.().props;
          yf(Ve, {
            get onEscapeKeydown() {
              return n();
            },
            get escapeKeydownBehavior() {
              return s();
            },
            get enabled() {
              return J();
            },
            get ref() {
              return j();
            },
            children: (je, We) => {
              mf(je, {
                get id() {
                  return i();
                },
                get onInteractOutside() {
                  return E();
                },
                get onFocusOutside() {
                  return U();
                },
                get interactOutsideBehavior() {
                  return B();
                },
                get isValidEvent() {
                  return Y();
                },
                get enabled() {
                  return J();
                },
                get ref() {
                  return j();
                },
                children: (Ze, $t) => {
                  let lt = () => $t?.().props;
                  xf(Ze, {
                    get id() {
                      return i();
                    },
                    get preventOverflowTextSelection() {
                      return o();
                    },
                    get onPointerDown() {
                      return a();
                    },
                    get onPointerUp() {
                      return l();
                    },
                    get enabled() {
                      return J();
                    },
                    get ref() {
                      return j();
                    },
                    children: (ct, pt) => {
                      var Kt = M(), yt = D(Kt);
                      {
                        let Vt = /* @__PURE__ */ O(() => ({
                          props: Ce(N, we(), lt(), Le(), { style: { pointerEvents: L() } }),
                          wrapperProps: le()
                        }));
                        te(yt, () => r() ?? he, () => d(Vt));
                      }
                      A(ct, Kt);
                    },
                    $$slots: { default: !0 }
                  });
                },
                $$slots: { default: !0 }
              });
            },
            $$slots: { default: !0 }
          });
        },
        $$slots: { focusScope: !0 }
      }), A(fe, re);
    },
    $$slots: { content: !0 }
  }), H(V);
}
K(
  Ph,
  {
    popper: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    enabled: {},
    ref: {},
    tooltip: {},
    contentPointerEvents: {}
  },
  [],
  [],
  { mode: "open" }
);
function Oh(t, e) {
  W(e, !0);
  let r = v(e, "popper", 7), n = v(e, "open", 7), s = v(e, "onEscapeKeydown", 7), o = v(e, "escapeKeydownBehavior", 7), i = v(e, "preventOverflowTextSelection", 7), a = v(e, "id", 7), l = v(e, "onPointerDown", 7), u = v(e, "onPointerUp", 7), c = v(e, "side", 7), f = v(e, "sideOffset", 7), h = v(e, "align", 7), _ = v(e, "alignOffset", 7), b = v(e, "arrowPadding", 7), p = v(e, "avoidCollisions", 7), g = v(e, "collisionBoundary", 7), y = v(e, "collisionPadding", 7), S = v(e, "sticky", 7), x = v(e, "hideWhenDetached", 7), P = v(e, "updatePositionStrategy", 7), w = v(e, "strategy", 7), C = v(e, "dir", 7), k = v(e, "preventScroll", 7), $ = v(e, "wrapperId", 7), T = v(e, "style", 7), E = v(e, "onPlaced", 7), I = v(e, "onInteractOutside", 7), F = v(e, "onCloseAutoFocus", 7), U = v(e, "onOpenAutoFocus", 7), B = v(e, "onFocusOutside", 7), R = v(e, "interactOutsideBehavior", 7, "close"), Z = v(e, "loop", 7), Y = v(e, "trapFocus", 7, !0), X = v(e, "isValidEvent", 7, () => !1), ae = v(e, "customAnchor", 7, null), J = v(e, "isStatic", 7, !1), j = v(e, "ref", 7), ee = v(e, "shouldRender", 7), L = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "open",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "ref",
    "shouldRender"
  ]);
  var N = {
    get popper() {
      return r();
    },
    set popper(se) {
      r(se), m();
    },
    get open() {
      return n();
    },
    set open(se) {
      n(se), m();
    },
    get onEscapeKeydown() {
      return s();
    },
    set onEscapeKeydown(se) {
      s(se), m();
    },
    get escapeKeydownBehavior() {
      return o();
    },
    set escapeKeydownBehavior(se) {
      o(se), m();
    },
    get preventOverflowTextSelection() {
      return i();
    },
    set preventOverflowTextSelection(se) {
      i(se), m();
    },
    get id() {
      return a();
    },
    set id(se) {
      a(se), m();
    },
    get onPointerDown() {
      return l();
    },
    set onPointerDown(se) {
      l(se), m();
    },
    get onPointerUp() {
      return u();
    },
    set onPointerUp(se) {
      u(se), m();
    },
    get side() {
      return c();
    },
    set side(se) {
      c(se), m();
    },
    get sideOffset() {
      return f();
    },
    set sideOffset(se) {
      f(se), m();
    },
    get align() {
      return h();
    },
    set align(se) {
      h(se), m();
    },
    get alignOffset() {
      return _();
    },
    set alignOffset(se) {
      _(se), m();
    },
    get arrowPadding() {
      return b();
    },
    set arrowPadding(se) {
      b(se), m();
    },
    get avoidCollisions() {
      return p();
    },
    set avoidCollisions(se) {
      p(se), m();
    },
    get collisionBoundary() {
      return g();
    },
    set collisionBoundary(se) {
      g(se), m();
    },
    get collisionPadding() {
      return y();
    },
    set collisionPadding(se) {
      y(se), m();
    },
    get sticky() {
      return S();
    },
    set sticky(se) {
      S(se), m();
    },
    get hideWhenDetached() {
      return x();
    },
    set hideWhenDetached(se) {
      x(se), m();
    },
    get updatePositionStrategy() {
      return P();
    },
    set updatePositionStrategy(se) {
      P(se), m();
    },
    get strategy() {
      return w();
    },
    set strategy(se) {
      w(se), m();
    },
    get dir() {
      return C();
    },
    set dir(se) {
      C(se), m();
    },
    get preventScroll() {
      return k();
    },
    set preventScroll(se) {
      k(se), m();
    },
    get wrapperId() {
      return $();
    },
    set wrapperId(se) {
      $(se), m();
    },
    get style() {
      return T();
    },
    set style(se) {
      T(se), m();
    },
    get onPlaced() {
      return E();
    },
    set onPlaced(se) {
      E(se), m();
    },
    get onInteractOutside() {
      return I();
    },
    set onInteractOutside(se) {
      I(se), m();
    },
    get onCloseAutoFocus() {
      return F();
    },
    set onCloseAutoFocus(se) {
      F(se), m();
    },
    get onOpenAutoFocus() {
      return U();
    },
    set onOpenAutoFocus(se) {
      U(se), m();
    },
    get onFocusOutside() {
      return B();
    },
    set onFocusOutside(se) {
      B(se), m();
    },
    get interactOutsideBehavior() {
      return R();
    },
    set interactOutsideBehavior(se = "close") {
      R(se), m();
    },
    get loop() {
      return Z();
    },
    set loop(se) {
      Z(se), m();
    },
    get trapFocus() {
      return Y();
    },
    set trapFocus(se = !0) {
      Y(se), m();
    },
    get isValidEvent() {
      return X();
    },
    set isValidEvent(se = () => !1) {
      X(se), m();
    },
    get customAnchor() {
      return ae();
    },
    set customAnchor(se = null) {
      ae(se), m();
    },
    get isStatic() {
      return J();
    },
    set isStatic(se = !1) {
      J(se), m();
    },
    get ref() {
      return j();
    },
    set ref(se) {
      j(se), m();
    },
    get shouldRender() {
      return ee();
    },
    set shouldRender(se) {
      ee(se), m();
    }
  }, V = M(), G = D(V);
  {
    var fe = (se) => {
      Ph(se, ce(
        {
          get popper() {
            return r();
          },
          get onEscapeKeydown() {
            return s();
          },
          get escapeKeydownBehavior() {
            return o();
          },
          get preventOverflowTextSelection() {
            return i();
          },
          get id() {
            return a();
          },
          get onPointerDown() {
            return l();
          },
          get onPointerUp() {
            return u();
          },
          get side() {
            return c();
          },
          get sideOffset() {
            return f();
          },
          get align() {
            return h();
          },
          get alignOffset() {
            return _();
          },
          get arrowPadding() {
            return b();
          },
          get avoidCollisions() {
            return p();
          },
          get collisionBoundary() {
            return g();
          },
          get collisionPadding() {
            return y();
          },
          get sticky() {
            return S();
          },
          get hideWhenDetached() {
            return x();
          },
          get updatePositionStrategy() {
            return P();
          },
          get strategy() {
            return w();
          },
          get dir() {
            return C();
          },
          get preventScroll() {
            return k();
          },
          get wrapperId() {
            return $();
          },
          get style() {
            return T();
          },
          get onPlaced() {
            return E();
          },
          get customAnchor() {
            return ae();
          },
          get isStatic() {
            return J();
          },
          get enabled() {
            return n();
          },
          get onInteractOutside() {
            return I();
          },
          get onCloseAutoFocus() {
            return F();
          },
          get onOpenAutoFocus() {
            return U();
          },
          get interactOutsideBehavior() {
            return R();
          },
          get loop() {
            return Z();
          },
          get trapFocus() {
            return Y();
          },
          get isValidEvent() {
            return X();
          },
          get onFocusOutside() {
            return B();
          },
          forceMount: !1,
          get ref() {
            return j();
          }
        },
        () => L
      ));
    };
    ue(G, (se) => {
      ee() && se(fe);
    });
  }
  return A(t, V), H(N);
}
K(
  Oh,
  {
    popper: {},
    open: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    ref: {},
    shouldRender: {}
  },
  [],
  [],
  { mode: "open" }
);
function Ch(t, e) {
  W(e, !0);
  let r = v(e, "popper", 7), n = v(e, "onEscapeKeydown", 7), s = v(e, "escapeKeydownBehavior", 7), o = v(e, "preventOverflowTextSelection", 7), i = v(e, "id", 7), a = v(e, "onPointerDown", 7), l = v(e, "onPointerUp", 7), u = v(e, "side", 7), c = v(e, "sideOffset", 7), f = v(e, "align", 7), h = v(e, "alignOffset", 7), _ = v(e, "arrowPadding", 7), b = v(e, "avoidCollisions", 7), p = v(e, "collisionBoundary", 7), g = v(e, "collisionPadding", 7), y = v(e, "sticky", 7), S = v(e, "hideWhenDetached", 7), x = v(e, "updatePositionStrategy", 7), P = v(e, "strategy", 7), w = v(e, "dir", 7), C = v(e, "preventScroll", 7), k = v(e, "wrapperId", 7), $ = v(e, "style", 7), T = v(e, "onPlaced", 7), E = v(e, "onInteractOutside", 7), I = v(e, "onCloseAutoFocus", 7), F = v(e, "onOpenAutoFocus", 7), U = v(e, "onFocusOutside", 7), B = v(e, "interactOutsideBehavior", 7, "close"), R = v(e, "loop", 7), Z = v(e, "trapFocus", 7, !0), Y = v(e, "isValidEvent", 7, () => !1), X = v(e, "customAnchor", 7, null), ae = v(e, "isStatic", 7, !1), J = v(e, "enabled", 7), j = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled"
  ]);
  var ee = {
    get popper() {
      return r();
    },
    set popper(L) {
      r(L), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(L) {
      n(L), m();
    },
    get escapeKeydownBehavior() {
      return s();
    },
    set escapeKeydownBehavior(L) {
      s(L), m();
    },
    get preventOverflowTextSelection() {
      return o();
    },
    set preventOverflowTextSelection(L) {
      o(L), m();
    },
    get id() {
      return i();
    },
    set id(L) {
      i(L), m();
    },
    get onPointerDown() {
      return a();
    },
    set onPointerDown(L) {
      a(L), m();
    },
    get onPointerUp() {
      return l();
    },
    set onPointerUp(L) {
      l(L), m();
    },
    get side() {
      return u();
    },
    set side(L) {
      u(L), m();
    },
    get sideOffset() {
      return c();
    },
    set sideOffset(L) {
      c(L), m();
    },
    get align() {
      return f();
    },
    set align(L) {
      f(L), m();
    },
    get alignOffset() {
      return h();
    },
    set alignOffset(L) {
      h(L), m();
    },
    get arrowPadding() {
      return _();
    },
    set arrowPadding(L) {
      _(L), m();
    },
    get avoidCollisions() {
      return b();
    },
    set avoidCollisions(L) {
      b(L), m();
    },
    get collisionBoundary() {
      return p();
    },
    set collisionBoundary(L) {
      p(L), m();
    },
    get collisionPadding() {
      return g();
    },
    set collisionPadding(L) {
      g(L), m();
    },
    get sticky() {
      return y();
    },
    set sticky(L) {
      y(L), m();
    },
    get hideWhenDetached() {
      return S();
    },
    set hideWhenDetached(L) {
      S(L), m();
    },
    get updatePositionStrategy() {
      return x();
    },
    set updatePositionStrategy(L) {
      x(L), m();
    },
    get strategy() {
      return P();
    },
    set strategy(L) {
      P(L), m();
    },
    get dir() {
      return w();
    },
    set dir(L) {
      w(L), m();
    },
    get preventScroll() {
      return C();
    },
    set preventScroll(L) {
      C(L), m();
    },
    get wrapperId() {
      return k();
    },
    set wrapperId(L) {
      k(L), m();
    },
    get style() {
      return $();
    },
    set style(L) {
      $(L), m();
    },
    get onPlaced() {
      return T();
    },
    set onPlaced(L) {
      T(L), m();
    },
    get onInteractOutside() {
      return E();
    },
    set onInteractOutside(L) {
      E(L), m();
    },
    get onCloseAutoFocus() {
      return I();
    },
    set onCloseAutoFocus(L) {
      I(L), m();
    },
    get onOpenAutoFocus() {
      return F();
    },
    set onOpenAutoFocus(L) {
      F(L), m();
    },
    get onFocusOutside() {
      return U();
    },
    set onFocusOutside(L) {
      U(L), m();
    },
    get interactOutsideBehavior() {
      return B();
    },
    set interactOutsideBehavior(L = "close") {
      B(L), m();
    },
    get loop() {
      return R();
    },
    set loop(L) {
      R(L), m();
    },
    get trapFocus() {
      return Z();
    },
    set trapFocus(L = !0) {
      Z(L), m();
    },
    get isValidEvent() {
      return Y();
    },
    set isValidEvent(L = () => !1) {
      Y(L), m();
    },
    get customAnchor() {
      return X();
    },
    set customAnchor(L = null) {
      X(L), m();
    },
    get isStatic() {
      return ae();
    },
    set isStatic(L = !1) {
      ae(L), m();
    },
    get enabled() {
      return J();
    },
    set enabled(L) {
      J(L), m();
    }
  };
  return Ph(t, ce(
    {
      get popper() {
        return r();
      },
      get onEscapeKeydown() {
        return n();
      },
      get escapeKeydownBehavior() {
        return s();
      },
      get preventOverflowTextSelection() {
        return o();
      },
      get id() {
        return i();
      },
      get onPointerDown() {
        return a();
      },
      get onPointerUp() {
        return l();
      },
      get side() {
        return u();
      },
      get sideOffset() {
        return c();
      },
      get align() {
        return f();
      },
      get alignOffset() {
        return h();
      },
      get arrowPadding() {
        return _();
      },
      get avoidCollisions() {
        return b();
      },
      get collisionBoundary() {
        return p();
      },
      get collisionPadding() {
        return g();
      },
      get sticky() {
        return y();
      },
      get hideWhenDetached() {
        return S();
      },
      get updatePositionStrategy() {
        return x();
      },
      get strategy() {
        return P();
      },
      get dir() {
        return w();
      },
      get preventScroll() {
        return C();
      },
      get wrapperId() {
        return k();
      },
      get style() {
        return $();
      },
      get onPlaced() {
        return T();
      },
      get customAnchor() {
        return X();
      },
      get isStatic() {
        return ae();
      },
      get enabled() {
        return J();
      },
      get onInteractOutside() {
        return E();
      },
      get onCloseAutoFocus() {
        return I();
      },
      get onOpenAutoFocus() {
        return F();
      },
      get interactOutsideBehavior() {
        return B();
      },
      get loop() {
        return R();
      },
      get trapFocus() {
        return Z();
      },
      get isValidEvent() {
        return Y();
      },
      get onFocusOutside() {
        return U();
      }
    },
    () => j,
    { forceMount: !0 }
  )), H(ee);
}
K(
  Ch,
  {
    popper: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    enabled: {}
  },
  [],
  [],
  { mode: "open" }
);
var VI = /* @__PURE__ */ ne("<div><div><!></div></div>"), LI = /* @__PURE__ */ ne("<div><div><!></div></div>");
function Uw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "forceMount", 7, !1), i = v(e, "side", 7, "bottom"), a = v(e, "onInteractOutside", 7, _e), l = v(e, "onEscapeKeydown", 7, _e), u = v(e, "children", 7), c = v(e, "child", 7), f = v(e, "preventScroll", 7, !1), h = v(e, "style", 7), _ = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "forceMount",
    "side",
    "onInteractOutside",
    "onEscapeKeydown",
    "children",
    "child",
    "preventScroll",
    "style"
  ]);
  const b = gh.create({
    id: z(() => n()),
    ref: z(() => s(), (w) => s(w)),
    onInteractOutside: z(() => a()),
    onEscapeKeydown: z(() => l())
  }), p = /* @__PURE__ */ O(() => Ce(_, b.props));
  var g = {
    get id() {
      return n();
    },
    set id(w = me(r)) {
      n(w), m();
    },
    get ref() {
      return s();
    },
    set ref(w = null) {
      s(w), m();
    },
    get forceMount() {
      return o();
    },
    set forceMount(w = !1) {
      o(w), m();
    },
    get side() {
      return i();
    },
    set side(w = "bottom") {
      i(w), m();
    },
    get onInteractOutside() {
      return a();
    },
    set onInteractOutside(w = _e) {
      a(w), m();
    },
    get onEscapeKeydown() {
      return l();
    },
    set onEscapeKeydown(w = _e) {
      l(w), m();
    },
    get children() {
      return u();
    },
    set children(w) {
      u(w), m();
    },
    get child() {
      return c();
    },
    set child(w) {
      c(w), m();
    },
    get preventScroll() {
      return f();
    },
    set preventScroll(w = !1) {
      f(w), m();
    },
    get style() {
      return h();
    },
    set style(w) {
      h(w), m();
    }
  }, y = M(), S = D(y);
  {
    var x = (w) => {
      Ch(w, ce(() => d(p), () => b.popperProps, {
        get ref() {
          return b.opts.ref;
        },
        get side() {
          return i();
        },
        get enabled() {
          return b.root.opts.open.current;
        },
        get id() {
          return n();
        },
        get preventScroll() {
          return f();
        },
        forceMount: !0,
        get shouldRender() {
          return b.shouldRender;
        },
        popper: (k, $) => {
          let T = () => $?.().props, E = () => $?.().wrapperProps;
          const I = /* @__PURE__ */ O(() => Ce(T(), { style: b.props.style }, { style: h() }));
          var F = M(), U = D(F);
          {
            var B = (Z) => {
              var Y = M(), X = D(Y);
              {
                let ae = /* @__PURE__ */ O(() => ({
                  props: d(I),
                  wrapperProps: E(),
                  ...b.snippetProps
                }));
                te(X, c, () => d(ae));
              }
              A(Z, Y);
            }, R = (Z) => {
              var Y = VI();
              ve(Y, () => ({ ...E() }));
              var X = ge(Y);
              ve(X, () => ({ ...d(I) }));
              var ae = ge(X);
              te(ae, () => u() ?? he), de(X), de(Y), A(Z, Y);
            };
            ue(U, (Z) => {
              c() ? Z(B) : Z(R, !1);
            });
          }
          A(k, F);
        },
        $$slots: { popper: !0 }
      }));
    }, P = (w) => {
      var C = M(), k = D(C);
      {
        var $ = (T) => {
          Oh(T, ce(() => d(p), () => b.popperProps, {
            get ref() {
              return b.opts.ref;
            },
            get side() {
              return i();
            },
            get open() {
              return b.root.opts.open.current;
            },
            get id() {
              return n();
            },
            get preventScroll() {
              return f();
            },
            forceMount: !1,
            get shouldRender() {
              return b.shouldRender;
            },
            popper: (I, F) => {
              let U = () => F?.().props, B = () => F?.().wrapperProps;
              const R = /* @__PURE__ */ O(() => Ce(U(), { style: b.props.style }, { style: h() }));
              var Z = M(), Y = D(Z);
              {
                var X = (J) => {
                  var j = M(), ee = D(j);
                  {
                    let L = /* @__PURE__ */ O(() => ({
                      props: d(R),
                      wrapperProps: B(),
                      ...b.snippetProps
                    }));
                    te(ee, c, () => d(L));
                  }
                  A(J, j);
                }, ae = (J) => {
                  var j = LI();
                  ve(j, () => ({ ...B() }));
                  var ee = ge(j);
                  ve(ee, () => ({ ...d(R) }));
                  var L = ge(ee);
                  te(L, () => u() ?? he), de(ee), de(j), A(J, j);
                };
                ue(Y, (J) => {
                  c() ? J(X) : J(ae, !1);
                });
              }
              A(I, Z);
            },
            $$slots: { popper: !0 }
          }));
        };
        ue(
          k,
          (T) => {
            o() || T($);
          },
          !0
        );
      }
      A(w, C);
    };
    ue(S, (w) => {
      o() ? w(x) : w(P, !1);
    });
  }
  return A(t, y), H(g);
}
K(
  Uw,
  {
    id: {},
    ref: {},
    forceMount: {},
    side: {},
    onInteractOutside: {},
    onEscapeKeydown: {},
    children: {},
    child: {},
    preventScroll: {},
    style: {}
  },
  [],
  [],
  { mode: "open" }
);
function pu(t, e) {
  W(e, !0);
  let r = v(e, "mounted", 15, !1), n = v(e, "onMountedChange", 7, _e);
  tf(() => (r(!0), n()(!0), () => {
    r(!1), n()(!1);
  }));
  var s = {
    get mounted() {
      return r();
    },
    set mounted(o = !1) {
      r(o), m();
    },
    get onMountedChange() {
      return n();
    },
    set onMountedChange(o = _e) {
      n(o), m();
    }
  };
  return H(s);
}
K(pu, { mounted: {}, onMountedChange: {} }, [], [], { mode: "open" });
var jI = /* @__PURE__ */ ne("<div><!></div>"), BI = /* @__PURE__ */ ne("<!> <!>", 1);
function Kw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7), i = v(e, "label", 23, o), a = v(e, "disabled", 7, !1), l = v(e, "children", 7), u = v(e, "child", 7), c = v(e, "onHighlight", 7, _e), f = v(e, "onUnhighlight", 7, _e), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "label",
    "disabled",
    "children",
    "child",
    "onHighlight",
    "onUnhighlight"
  ]);
  const _ = ph.create({
    id: z(() => n()),
    ref: z(() => s(), (w) => s(w)),
    value: z(() => o()),
    disabled: z(() => a()),
    label: z(() => i()),
    onHighlight: z(() => c()),
    onUnhighlight: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(h, _.props));
  var p = {
    get id() {
      return n();
    },
    set id(w = me(r)) {
      n(w), m();
    },
    get ref() {
      return s();
    },
    set ref(w = null) {
      s(w), m();
    },
    get value() {
      return o();
    },
    set value(w) {
      o(w), m();
    },
    get label() {
      return i();
    },
    set label(w = o) {
      i(w), m();
    },
    get disabled() {
      return a();
    },
    set disabled(w = !1) {
      a(w), m();
    },
    get children() {
      return l();
    },
    set children(w) {
      l(w), m();
    },
    get child() {
      return u();
    },
    set child(w) {
      u(w), m();
    },
    get onHighlight() {
      return c();
    },
    set onHighlight(w = _e) {
      c(w), m();
    },
    get onUnhighlight() {
      return f();
    },
    set onUnhighlight(w = _e) {
      f(w), m();
    }
  }, g = BI(), y = D(g);
  {
    var S = (w) => {
      var C = M(), k = D(C);
      {
        let $ = /* @__PURE__ */ O(() => ({ props: d(b), ..._.snippetProps }));
        te(k, u, () => d($));
      }
      A(w, C);
    }, x = (w) => {
      var C = jI();
      ve(C, () => ({ ...d(b) }));
      var k = ge(C);
      te(k, () => l() ?? he, () => _.snippetProps), de(C), A(w, C);
    };
    ue(y, (w) => {
      u() ? w(S) : w(x, !1);
    });
  }
  var P = be(y, 2);
  return pu(P, {
    get mounted() {
      return _.mounted;
    },
    set mounted(w) {
      _.mounted = w;
    }
  }), A(t, g), H(p);
}
K(
  Kw,
  {
    id: {},
    ref: {},
    value: {},
    label: {},
    disabled: {},
    children: {},
    child: {},
    onHighlight: {},
    onUnhighlight: {}
  },
  [],
  [],
  { mode: "open" }
);
var zI = /* @__PURE__ */ ne("<div><!></div>");
function Ww(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = mh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, i, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = zI();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => o() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Ww, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var qI = /* @__PURE__ */ ne("<div><!></div>");
function Hw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children"
  ]);
  const l = vh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get child() {
      return o();
    },
    set child(p) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, o, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = qI();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => i() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      o() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Hw, { id: {}, ref: {}, child: {}, children: {} }, [], [], { mode: "open" });
var UI = /* @__PURE__ */ ne("<div><!></div>");
const KI = {
  hash: "svelte-18zq11a",
  code: `
	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */[data-select-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport]::-webkit-scrollbar {display:none !important;}[data-select-viewport]::-webkit-scrollbar {display:none !important;}`
};
function Gw(t, e) {
  const r = De();
  W(e, !0), WP(t, KI);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = bh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, i, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = UI();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => o() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Gw, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var WI = /* @__PURE__ */ ne("<div><!></div>"), HI = /* @__PURE__ */ ne("<!> <!>", 1);
function Yw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "delay", 7, () => 50), i = v(e, "child", 7), a = v(e, "children", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const u = _h.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    delay: z(() => o())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get delay() {
      return o();
    },
    set delay(p = () => 50) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    },
    get children() {
      return a();
    },
    set children(p) {
      a(p), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (p) => {
      var g = HI(), y = D(g);
      pu(y, {
        get mounted() {
          return u.scrollButtonState.mounted;
        },
        set mounted(w) {
          u.scrollButtonState.mounted = w;
        }
      });
      var S = be(y, 2);
      {
        var x = (w) => {
          var C = M(), k = D(C);
          te(k, i, () => ({ props: l })), A(w, C);
        }, P = (w) => {
          var C = WI();
          ve(C, () => ({ ...d(c) }));
          var k = ge(C);
          te(k, () => a() ?? he), de(C), A(w, C);
        };
        ue(S, (w) => {
          i() ? w(x) : w(P, !1);
        });
      }
      A(p, g);
    };
    ue(_, (p) => {
      u.canScrollDown && p(b);
    });
  }
  return A(t, h), H(f);
}
K(Yw, { id: {}, ref: {}, delay: {}, child: {}, children: {} }, [], [], { mode: "open" });
var GI = /* @__PURE__ */ ne("<div><!></div>"), YI = /* @__PURE__ */ ne("<!> <!>", 1);
function Xw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "delay", 7, () => 50), i = v(e, "child", 7), a = v(e, "children", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const u = wh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    delay: z(() => o())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get delay() {
      return o();
    },
    set delay(p = () => 50) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    },
    get children() {
      return a();
    },
    set children(p) {
      a(p), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (p) => {
      var g = YI(), y = D(g);
      pu(y, {
        get mounted() {
          return u.scrollButtonState.mounted;
        },
        set mounted(w) {
          u.scrollButtonState.mounted = w;
        }
      });
      var S = be(y, 2);
      {
        var x = (w) => {
          var C = M(), k = D(C);
          te(k, i, () => ({ props: l })), A(w, C);
        }, P = (w) => {
          var C = GI();
          ve(C, () => ({ ...d(c) }));
          var k = ge(C);
          te(k, () => a() ?? he), de(C), A(w, C);
        };
        ue(S, (w) => {
          i() ? w(x) : w(P, !1);
        });
      }
      A(p, g);
    };
    ue(_, (p) => {
      u.canScrollUp && p(b);
    });
  }
  return A(t, h), H(f);
}
K(Xw, { id: {}, ref: {}, delay: {}, child: {}, children: {} }, [], [], { mode: "open" });
function XI(t, e) {
  let r = t.nextElementSibling;
  for (; r; ) {
    if (r.matches(e))
      return r;
    r = r.nextElementSibling;
  }
}
function JI(t, e) {
  let r = t.previousElementSibling;
  for (; r; ) {
    if (r.matches(e))
      return r;
    r = r.previousElementSibling;
  }
}
function Jw(t) {
  if (typeof CSS < "u" && typeof CSS.escape == "function")
    return CSS.escape(t);
  const e = t.length;
  let r = -1, n, s = "";
  const o = t.charCodeAt(0);
  if (e === 1 && o === 45)
    return "\\" + t;
  for (; ++r < e; ) {
    if (n = t.charCodeAt(r), n === 0) {
      s += "ï¿½";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is U+007F
      n >= 1 && n <= 31 || n === 127 || // If the character is the first character and is in the range [0-9] (U+0030 to U+0039)
      r === 0 && n >= 48 && n <= 57 || // If the character is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D)
      r === 1 && n >= 48 && n <= 57 && o === 45
    ) {
      s += "\\" + n.toString(16) + " ";
      continue;
    }
    if (n >= 128 || n === 45 || n === 95 || n >= 48 && n <= 57 || n >= 65 && n <= 90 || n >= 97 && n <= 122) {
      s += t.charAt(r);
      continue;
    }
    s += "\\" + t.charAt(r);
  }
  return s;
}
const Ps = "data-value", Rt = nr({
  component: "command",
  parts: [
    "root",
    "list",
    "input",
    "separator",
    "loading",
    "empty",
    "group",
    "group-items",
    "group-heading",
    "item",
    "viewport",
    "input-label"
  ]
}), to = Rt.selector("group"), ic = Rt.selector("group-items"), Hm = Rt.selector("group-heading"), Zw = Rt.selector("item"), ac = `${Rt.selector("item")}:not([aria-disabled="true"])`, hs = new ht("Command.Root"), ZI = new ht("Command.List"), Ci = new ht("Command.Group"), Gm = {
  search: "",
  value: "",
  filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() }
};
class kh {
  static create(e) {
    return hs.set(new kh(e));
  }
  opts;
  attachment;
  #e = !1;
  #t = !0;
  sortAfterTick = !1;
  sortAndFilterAfterTick = !1;
  allItems = /* @__PURE__ */ new Set();
  allGroups = /* @__PURE__ */ new Map();
  allIds = /* @__PURE__ */ new Map();
  #r = (
    // attempt to prevent the harsh delay when user is typing fast
    /* @__PURE__ */ xe(0)
  );
  get key() {
    return d(this.#r);
  }
  set key(e) {
    q(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ xe(null);
  get viewportNode() {
    return d(this.#n);
  }
  set viewportNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(null);
  get inputNode() {
    return d(this.#s);
  }
  set inputNode(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(null);
  get labelNode() {
    return d(this.#o);
  }
  set labelNode(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(Gm);
  get commandState() {
    return d(this.#i);
  }
  set commandState(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ xe(Pt(Gm));
  get _commandState() {
    return d(this.#a);
  }
  set _commandState(e) {
    q(this.#a, e, !0);
  }
  #u() {
    return Po(this._commandState);
  }
  #l() {
    this.#e || (this.#e = !0, Jt(() => {
      this.#e = !1;
      const e = this.#u();
      !Object.is(this.commandState, e) && (this.commandState = e, this.opts.onStateChange?.current?.(e));
    }));
  }
  setState(e, r, n) {
    Object.is(this._commandState[e], r) || (this._commandState[e] = r, e === "search" ? (this.#p(), this.#d()) : e === "value" && (n || this.#h()), this.#l());
  }
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref);
    const r = { ...this._commandState, value: this.opts.value.current ?? "" };
    this._commandState = r, this.commandState = r, this.onkeydown = this.onkeydown.bind(this);
  }
  /**
   * Calculates score for an item based on search text and keywords.
   * Higher score = better match.
   *
   * @param value - Item's display text
   * @param keywords - Optional keywords to boost scoring
   * @returns Score from 0-1, where 0 = no match
   */
  #c(e, r) {
    const n = this.opts.filter.current ?? Jc;
    return e ? n(e, this._commandState.search, r) : 0;
  }
  /**
   * Sorts items and groups based on search scores.
   * Groups are sorted by their highest scoring item.
   * When no search active, selects first item.
   */
  #d() {
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      !this._commandState.value || !this.#t ? this.#g() : this.#t && this._commandState.value && this.#m();
      return;
    }
    const e = this._commandState.filtered.items, r = [];
    for (const i of this._commandState.filtered.groups) {
      const a = this.allGroups.get(i);
      let l = 0;
      if (!a) {
        r.push([i, l]);
        continue;
      }
      for (const u of a) {
        const c = e.get(u);
        l = Math.max(c ?? 0, l);
      }
      r.push([i, l]);
    }
    const n = this.viewportNode, s = this.getValidItems().sort((i, a) => {
      const l = i.getAttribute("data-value"), u = a.getAttribute("data-value"), c = e.get(l) ?? 0;
      return (e.get(u) ?? 0) - c;
    });
    for (const i of s) {
      const a = i.closest(ic);
      if (a) {
        const l = i.parentElement === a ? i : i.closest(`${ic} > *`);
        l && a.appendChild(l);
      } else {
        const l = i.parentElement === n ? i : i.closest(`${ic} > *`);
        l && n?.appendChild(l);
      }
    }
    const o = r.sort((i, a) => a[1] - i[1]);
    for (const i of o) {
      const a = n?.querySelector(`${to}[${Ps}="${Jw(i[0])}"]`);
      a?.parentElement?.appendChild(a);
    }
    this.#g();
  }
  /**
   * Sets current value and triggers re-render if cleared.
   *
   * @param value - New value to set
   */
  setValue(e, r) {
    e !== this.opts.value.current && e === "" && Jt(() => {
      this.key++;
    }), this.setState("value", e, r), this.opts.value.current = e;
  }
  /**
   * Selects first non-disabled item on next tick.
   */
  #g() {
    Jt(() => {
      const r = this.getValidItems().find((s) => s.getAttribute("aria-disabled") !== "true")?.getAttribute(Ps), n = this.#t && this.opts.disableInitialScroll.current;
      this.setValue(r ?? "", n), this.#t = !1;
    });
  }
  /**
   * Scrolls the initial value into view if it exists and is not the first item.
   * Called during initial mount when a value is provided.
   */
  #m() {
    Jt(() => {
      this.opts.disableInitialScroll.current || this.#h(), this.#t = !1;
    });
  }
  /**
   * Updates filtered items/groups based on search.
   * Recalculates scores and filtered count.
   */
  #p() {
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      this._commandState.filtered.count = this.allItems.size;
      return;
    }
    this._commandState.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (const r of this.allItems) {
      const n = this.allIds.get(r)?.value ?? "", s = this.allIds.get(r)?.keywords ?? [], o = this.#c(n, s);
      this._commandState.filtered.items.set(r, o), o > 0 && e++;
    }
    for (const [r, n] of this.allGroups)
      for (const s of n) {
        const o = this._commandState.filtered.items.get(s);
        if (o && o > 0) {
          this._commandState.filtered.groups.add(r);
          break;
        }
      }
    this._commandState.filtered.count = e;
  }
  /**
   * Gets all non-disabled, visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getValidItems() {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(ac)).filter((n) => !!n) : [];
  }
  /**
   * Gets all visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getVisibleItems() {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Zw)).filter((n) => !!n) : [];
  }
  /** Returns all visible items in a matrix structure
   *
   * @remarks Returns empty if the command isn't configured as a grid
   *
   * @returns
   */
  get itemsGrid() {
    if (!this.isGrid) return [];
    const e = this.opts.columns.current ?? 1, r = this.getVisibleItems(), n = [[]];
    let s = r[0]?.getAttribute("data-group"), o = 0, i = 0;
    for (let a = 0; a < r.length; a++) {
      const l = r[a], u = l?.getAttribute("data-group");
      s !== u ? (s = u, o = 1, i++, n.push([{ index: a, firstRowOfGroup: !0, ref: l }])) : (o++, o > e && (i++, o = 1, n.push([])), n[i]?.push({
        index: a,
        firstRowOfGroup: n[i]?.[0]?.firstRowOfGroup ?? a === 0,
        ref: l
      }));
    }
    return n;
  }
  /**
   * Gets currently selected command item.
   *
   * @returns Selected element or undefined
   */
  #f() {
    const e = this.opts.ref.current;
    if (!e) return;
    const r = e.querySelector(`${ac}[data-selected]`);
    if (r)
      return r;
  }
  /**
   * Scrolls selected item into view.
   * Special handling for first items in groups.
   */
  #h() {
    Jt(() => {
      const e = this.#f();
      if (!e) return;
      const r = e.parentElement?.parentElement;
      if (r) {
        if (this.isGrid) {
          const n = this.#b(e);
          if (e.scrollIntoView({ block: "nearest" }), n) {
            e?.closest(to)?.querySelector(Hm)?.scrollIntoView({ block: "nearest" });
            return;
          }
        } else {
          const n = pT(r);
          if (n && n.dataset?.value === e.dataset?.value) {
            e?.closest(to)?.querySelector(Hm)?.scrollIntoView({ block: "nearest" });
            return;
          }
        }
        e.scrollIntoView({ block: "nearest" });
      }
    });
  }
  #b(e) {
    const r = this.itemsGrid;
    if (r.length === 0) return !1;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s !== void 0)
        for (let o = 0; o < s.length; o++) {
          const i = s[o];
          if (!(i === void 0 || i.ref !== e))
            return i.firstRowOfGroup;
        }
    }
    return !1;
  }
  /**
   * Sets selection to item at specified index in valid items array.
   * If index is out of bounds, does nothing.
   *
   * @param index - Zero-based index of item to select
   * @remarks
   * Uses `getValidItems()` to get selectable items, filtering out disabled/hidden ones.
   * Access valid items directly via `getValidItems()` to check bounds before calling.
   *
   * @example
   * // get valid items length for bounds check
   * const items = getValidItems()
   * if (index < items.length) {
   *   updateSelectedToIndex(index)
   * }
   */
  updateSelectedToIndex(e) {
    const r = this.getValidItems()[e];
    r && this.setValue(r.getAttribute(Ps) ?? "");
  }
  /**
   * Updates selected item by moving up/down relative to current selection.
   * Handles wrapping when loop option is enabled.
   *
   * @param change - Direction to move: 1 for next item, -1 for previous item
   * @remarks
   * The loop behavior wraps:
   * - From last item to first when moving next
   * - From first item to last when moving previous
   *
   * Uses `getValidItems()` to get all selectable items, which filters out disabled/hidden items.
   * You can call `getValidItems()` directly to get the current valid items array.
   *
   * @example
   * // select next item
   * updateSelectedByItem(1)
   *
   * // get all valid items
   * const items = getValidItems()
   */
  updateSelectedByItem(e) {
    const r = this.#f(), n = this.getValidItems(), s = n.findIndex((i) => i === r);
    let o = n[s + e];
    this.opts.loop.current && (o = s + e < 0 ? n[n.length - 1] : s + e === n.length ? n[0] : n[s + e]), o && this.setValue(o.getAttribute(Ps) ?? "");
  }
  /**
   * Moves selection to the first valid item in the next/previous group.
   * If no group is found, falls back to selecting the next/previous item globally.
   *
   * @param change - Direction to move: 1 for next group, -1 for previous group
   * @example
   * // move to first item in next group
   * updateSelectedByGroup(1)
   *
   * // move to first item in previous group
   * updateSelectedByGroup(-1)
   */
  updateSelectedByGroup(e) {
    let n = this.#f()?.closest(to), s;
    for (; n && !s; )
      n = e > 0 ? XI(n, to) : JI(n, to), s = n?.querySelector(ac);
    s ? this.setValue(s.getAttribute(Ps) ?? "") : this.updateSelectedByItem(e);
  }
  /**
   * Maps item id to display value and search keywords.
   * Returns cleanup function to remove mapping.
   *
   * @param id - Unique item identifier
   * @param value - Display text
   * @param keywords - Optional search boost terms
   * @returns Cleanup function
   */
  registerValue(e, r) {
    return e && e === this.allIds.get(e)?.value || this.allIds.set(e, { value: e, keywords: r }), this._commandState.filtered.items.set(e, this.#c(e, r)), this.sortAfterTick || (this.sortAfterTick = !0, Jt(() => {
      this.#d(), this.sortAfterTick = !1;
    })), () => {
      this.allIds.delete(e);
    };
  }
  /**
   * Registers item in command list and its group.
   * Handles filtering, sorting and selection updates.
   *
   * @param id - Item identifier
   * @param groupId - Optional group to add item to
   * @returns Cleanup function that handles selection
   */
  registerItem(e, r) {
    return this.allItems.add(e), r && (this.allGroups.has(r) ? this.allGroups.get(r).add(e) : this.allGroups.set(r, /* @__PURE__ */ new Set([e]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Jt(() => {
      this.#p(), this.#d(), this.sortAndFilterAfterTick = !1;
    })), this.#l(), () => {
      const n = this.#f();
      this.allItems.delete(e), this.commandState.filtered.items.delete(e), this.#p(), n?.getAttribute("id") === e && this.#g(), this.#l();
    };
  }
  /**
   * Creates empty group if not exists.
   *
   * @param id - Group identifier
   * @returns Cleanup function
   */
  registerGroup(e) {
    return this.allGroups.has(e) || this.allGroups.set(e, /* @__PURE__ */ new Set()), () => {
      this.allIds.delete(e), this.allGroups.delete(e);
    };
  }
  get isGrid() {
    return this.opts.columns.current !== null;
  }
  /**
   * Selects last valid item.
   */
  #y() {
    return this.updateSelectedToIndex(this.getValidItems().length - 1);
  }
  /**
   * Handles next item selection:
   * - Meta: Jump to last
   * - Alt: Next group
   * - Default: Next item
   *
   * @param e - Keyboard event
   */
  #v(e) {
    e.preventDefault(), e.metaKey ? this.#y() : e.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1);
  }
  #S(e) {
    this.opts.columns.current !== null && (e.preventDefault(), e.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(this.#x(e)));
  }
  #w(e, r) {
    if (r.length === 0) return null;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s !== void 0)
        for (let o = 0; o < s.length; o++) {
          const i = s[o];
          if (!(i === void 0 || i.ref !== e))
            return { columnIndex: o, rowIndex: n };
        }
    }
    return null;
  }
  #x(e) {
    const r = this.itemsGrid, n = this.#f();
    if (!n) return 0;
    const s = this.#w(n, r);
    if (!s) return 0;
    let o = null;
    const i = e.altKey ? 1 : 0;
    if (e.altKey && s.rowIndex === r.length - 2 && !this.opts.loop.current)
      o = this.#_({
        start: r.length - 1,
        end: r.length,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    else if (s.rowIndex === r.length - 1) {
      if (!this.opts.loop.current) return 0;
      o = this.#_({
        start: 0 + i,
        end: s.rowIndex,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    } else
      o = this.#_({
        start: s.rowIndex + 1 + i,
        end: r.length,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }), o === null && this.opts.loop.current && (o = this.#_({
        start: 0,
        end: s.rowIndex,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }));
    return this.#C(n, o);
  }
  /** Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   *
   * @param param0
   * @returns
   */
  #_({ start: e, end: r, grid: n, expectedColumnIndex: s }) {
    let o = null;
    for (let i = e; i < r; i++) {
      const a = n[i];
      if (o = a[s]?.ref ?? null, o !== null && ja(o)) {
        o = null;
        continue;
      }
      if (o === null)
        for (let l = a.length - 1; l >= 0; l--) {
          const u = a[a.length - 1];
          if (!(u === void 0 || ja(u.ref))) {
            o = u.ref;
            break;
          }
        }
      break;
    }
    return o;
  }
  #C(e, r) {
    if (r === null) return 0;
    const n = this.getValidItems(), s = n.findIndex((i) => i === e);
    return n.findIndex((i) => i === r) - s;
  }
  #k(e) {
    this.opts.columns.current !== null && (e.preventDefault(), e.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(this.#A(e)));
  }
  #A(e) {
    const r = this.itemsGrid, n = this.#f();
    if (n === void 0) return 0;
    const s = this.#w(n, r);
    if (s === null) return 0;
    let o = null;
    const i = e.altKey ? 1 : 0;
    if (e.altKey && s.rowIndex === 1 && this.opts.loop.current === !1)
      o = this.#P({
        start: 0,
        end: 0,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    else if (s.rowIndex === 0) {
      if (this.opts.loop.current === !1) return 0;
      o = this.#P({
        start: r.length - 1 - i,
        end: s.rowIndex + 1,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    } else
      o = this.#P({
        start: s.rowIndex - 1 - i,
        end: 0,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }), o === null && this.opts.loop.current && (o = this.#P({
        start: r.length - 1,
        end: s.rowIndex + 1,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }));
    return this.#C(n, o);
  }
  /**
   * Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   */
  #P({ start: e, end: r, grid: n, expectedColumnIndex: s }) {
    let o = null;
    for (let i = e; i >= r; i--) {
      const a = n[i];
      if (a !== void 0) {
        if (o = a[s]?.ref ?? null, o !== null && ja(o)) {
          o = null;
          continue;
        }
        if (o === null)
          for (let l = a.length - 1; l >= 0; l--) {
            const u = a[a.length - 1];
            if (!(u === void 0 || ja(u.ref))) {
              o = u.ref;
              break;
            }
          }
        break;
      }
    }
    return o;
  }
  /**
   * Handles previous item selection:
   * - Meta: Jump to first
   * - Alt: Previous group
   * - Default: Previous item
   *
   * @param e - Keyboard event
   */
  #O(e) {
    e.preventDefault(), e.metaKey ? this.updateSelectedToIndex(0) : e.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1);
  }
  onkeydown(e) {
    const r = this.opts.vimBindings.current && e.ctrlKey;
    switch (e.key) {
      case X2:
      case J2: {
        r && (this.isGrid ? this.#S(e) : this.#v(e));
        break;
      }
      case eT: {
        r && this.isGrid && this.#v(e);
        break;
      }
      case dr:
        this.isGrid ? this.#S(e) : this.#v(e);
        break;
      case fs:
        if (!this.isGrid) break;
        this.#v(e);
        break;
      case Y2:
      case Z2: {
        r && (this.isGrid ? this.#k(e) : this.#O(e));
        break;
      }
      case Q2: {
        r && this.isGrid && this.#O(e);
        break;
      }
      case Qt:
        this.isGrid ? this.#k(e) : this.#O(e);
        break;
      case ds:
        if (!this.isGrid) break;
        this.#O(e);
        break;
      case Vo:
        e.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case Ro:
        e.preventDefault(), this.#y();
        break;
      case Br:
        if (!e.isComposing && e.keyCode !== 229) {
          e.preventDefault();
          const n = this.#f();
          n && n?.click();
        }
    }
  }
  #$ = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "application",
    [Rt.root]: "",
    tabindex: -1,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#$);
  }
  set props(e) {
    q(this.#$, e);
  }
}
function ja(t) {
  return t.getAttribute("aria-disabled") === "true";
}
class $h {
  static create(e) {
    return new $h(e, hs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root._commandState.filtered.count === 0 && this.#t === !1 || this.opts.forceMount.current);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  #t = !0;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), ko(() => {
      this.#t = !1;
    });
  }
  #r = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "presentation",
    [Rt.empty]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
class Ah {
  static create(e) {
    return Ci.set(new Ah(e, hs.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue));
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ xe(null);
  get headingNode() {
    return d(this.#t);
  }
  set headingNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe("");
  get trueValue() {
    return d(this.#r);
  }
  set trueValue(e) {
    q(this.#r, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.trueValue = e.value.current ?? e.id.current, Fe(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Xe(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)));
  }
  #n = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "presentation",
    hidden: this.shouldRender ? void 0 : !0,
    "data-value": this.trueValue,
    [Rt.group]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
}
class Eh {
  static create(e) {
    return new Eh(e, Ci.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(this.opts.ref, (n) => this.group.headingNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [Rt["group-heading"]]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Th {
  static create(e) {
    return new Th(e, Ci.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "group",
    [Rt["group-items"]]: "",
    "aria-labelledby": this.group.headingNode?.id ?? void 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Dh {
  static create(e) {
    return new Dh(e, hs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => {
    const e = this.root.viewportNode?.querySelector(`${Zw}[${Ps}="${Jw(this.root.opts.value.current)}"]`);
    if (e != null)
      return e.getAttribute("id") ?? void 0;
  });
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.inputNode = n), Fe(() => this.opts.ref.current, () => {
      const n = this.opts.ref.current;
      n && this.opts.autofocus.current && rf(10, () => n.focus());
    }), Fe(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current);
    });
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    type: "text",
    [Rt.input]: "",
    autocomplete: "off",
    autocorrect: "off",
    spellcheck: !1,
    "aria-autocomplete": "list",
    role: "combobox",
    "aria-expanded": at(!0),
    "aria-controls": this.root.viewportNode?.id ?? void 0,
    "aria-labelledby": this.root.labelNode?.id ?? void 0,
    "aria-activedescendant": d(this.#e),
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class mu {
  static create(e) {
    const r = Ci.getOr(null);
    return new mu({ ...e, group: r }, hs.get());
  }
  opts;
  root;
  attachment;
  #e = null;
  #t = /* @__PURE__ */ O(() => this.opts.forceMount.current || this.#e?.opts.forceMount.current === !0);
  #r = /* @__PURE__ */ O(() => {
    if (this.opts.ref.current, d(this.#t) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search)
      return !0;
    const e = this.root.commandState.filtered.items.get(this.trueValue);
    return e === void 0 ? !1 : e > 0;
  });
  get shouldRender() {
    return d(this.#r);
  }
  set shouldRender(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.root.opts.value.current === this.trueValue && this.trueValue !== "");
  get isSelected() {
    return d(this.#n);
  }
  set isSelected(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ xe("");
  get trueValue() {
    return d(this.#s);
  }
  set trueValue(e) {
    q(this.#s, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.#e = Ci.getOr(null), this.trueValue = e.value.current, this.attachment = Te(this.opts.ref), Fe(
      [
        () => this.trueValue,
        () => this.#e?.trueValue,
        () => this.opts.forceMount.current
      ],
      () => {
        if (!(this.opts.forceMount.current || !this.trueValue))
          return this.root.registerItem(this.trueValue, this.#e?.trueValue);
      }
    ), Fe([() => this.opts.value.current, () => this.opts.ref.current], () => {
      this.opts.value.current ? this.trueValue = this.opts.value.current : this.opts.ref.current?.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, e.keywords.current.map((n) => n.trim())), this.opts.ref.current?.setAttribute(Ps, this.trueValue));
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this);
  }
  #o() {
    this.opts.disabled.current || (this.#i(), this.opts.onSelect?.current());
  }
  #i() {
    this.opts.disabled.current || this.root.setValue(this.trueValue, !0);
  }
  onpointermove(e) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || this.#i();
  }
  onclick(e) {
    this.opts.disabled.current || this.#o();
  }
  #a = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-disabled": at(this.opts.disabled.current),
    "aria-selected": at(this.isSelected),
    "data-disabled": Re(this.opts.disabled.current),
    "data-selected": Re(this.isSelected),
    "data-value": this.trueValue,
    "data-group": this.#e?.trueValue,
    [Rt.item]: "",
    role: "option",
    onpointermove: this.onpointermove,
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
class Mh {
  static create(e) {
    return new Mh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "progressbar",
    "aria-valuenow": this.opts.progress.current,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-label": "Loading...",
    [Rt.loading]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Ih {
  static create(e) {
    return new Ih(e, hs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => !this.root._commandState.search || this.opts.forceMount.current);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    // role="separator" cannot belong to a role="listbox"
    "aria-hidden": "true",
    [Rt.separator]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Nh {
  static create(e) {
    return ZI.set(new Nh(e, hs.get()));
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "listbox",
    "aria-label": this.opts.ariaLabel.current,
    [Rt.list]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Fh {
  static create(e) {
    return new Fh(e, hs.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.labelNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [Rt["input-label"]]: "",
    for: this.opts.for?.current,
    style: n0,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var QI = /* @__PURE__ */ ne("<label><!></label>");
function Qw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children"
  ]);
  const a = Fh.create({
    id: z(() => n()),
    ref: z(() => s(), (h) => s(h))
  }), l = /* @__PURE__ */ O(() => Ce(i, a.props));
  var u = {
    get id() {
      return n();
    },
    set id(h = me(r)) {
      n(h), m();
    },
    get ref() {
      return s();
    },
    set ref(h = null) {
      s(h), m();
    },
    get children() {
      return o();
    },
    set children(h) {
      o(h), m();
    }
  }, c = QI();
  ve(c, () => ({ ...d(l) }));
  var f = ge(c);
  return te(f, () => o() ?? he), de(c), A(t, c), H(u);
}
K(Qw, { id: {}, ref: {}, children: {} }, [], [], { mode: "open" });
var eN = /* @__PURE__ */ ne("<!> <!>", 1), tN = /* @__PURE__ */ ne("<div><!> <!></div>");
function e1(t, e) {
  const r = De();
  W(e, !0);
  const n = (R) => {
    Qw(R, {
      children: (Z, Y) => {
        vt();
        var X = tt();
        ke(() => Ie(X, h())), A(Z, X);
      },
      $$slots: { default: !0 }
    });
  };
  let s = v(e, "id", 23, () => me(r)), o = v(e, "ref", 15, null), i = v(e, "value", 15, ""), a = v(e, "onValueChange", 7, _e), l = v(e, "onStateChange", 7, _e), u = v(e, "loop", 7, !1), c = v(e, "shouldFilter", 7, !0), f = v(e, "filter", 7, Jc), h = v(e, "label", 7, ""), _ = v(e, "vimBindings", 7, !0), b = v(e, "disablePointerSelection", 7, !1), p = v(e, "disableInitialScroll", 7, !1), g = v(e, "columns", 7, null), y = v(e, "children", 7), S = v(e, "child", 7), x = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "onValueChange",
    "onStateChange",
    "loop",
    "shouldFilter",
    "filter",
    "label",
    "vimBindings",
    "disablePointerSelection",
    "disableInitialScroll",
    "columns",
    "children",
    "child"
  ]);
  const P = kh.create({
    id: z(() => s()),
    ref: z(() => o(), (R) => o(R)),
    filter: z(() => f()),
    shouldFilter: z(() => c()),
    loop: z(() => u()),
    value: z(() => i(), (R) => {
      i() !== R && (i(R), a()(R));
    }),
    vimBindings: z(() => _()),
    disablePointerSelection: z(() => b()),
    disableInitialScroll: z(() => p()),
    onStateChange: z(() => l()),
    columns: z(() => g())
  }), w = (R) => P.updateSelectedToIndex(R), C = (R) => P.updateSelectedByGroup(R), k = (R) => P.updateSelectedByItem(R), $ = () => P.getValidItems(), T = /* @__PURE__ */ O(() => Ce(x, P.props));
  var E = {
    updateSelectedToIndex: w,
    updateSelectedByGroup: C,
    updateSelectedByItem: k,
    getValidItems: $,
    get id() {
      return s();
    },
    set id(R = me(r)) {
      s(R), m();
    },
    get ref() {
      return o();
    },
    set ref(R = null) {
      o(R), m();
    },
    get value() {
      return i();
    },
    set value(R = "") {
      i(R), m();
    },
    get onValueChange() {
      return a();
    },
    set onValueChange(R = _e) {
      a(R), m();
    },
    get onStateChange() {
      return l();
    },
    set onStateChange(R = _e) {
      l(R), m();
    },
    get loop() {
      return u();
    },
    set loop(R = !1) {
      u(R), m();
    },
    get shouldFilter() {
      return c();
    },
    set shouldFilter(R = !0) {
      c(R), m();
    },
    get filter() {
      return f();
    },
    set filter(R = Jc) {
      f(R), m();
    },
    get label() {
      return h();
    },
    set label(R = "") {
      h(R), m();
    },
    get vimBindings() {
      return _();
    },
    set vimBindings(R = !0) {
      _(R), m();
    },
    get disablePointerSelection() {
      return b();
    },
    set disablePointerSelection(R = !1) {
      b(R), m();
    },
    get disableInitialScroll() {
      return p();
    },
    set disableInitialScroll(R = !1) {
      p(R), m();
    },
    get columns() {
      return g();
    },
    set columns(R = null) {
      g(R), m();
    },
    get children() {
      return y();
    },
    set children(R) {
      y(R), m();
    },
    get child() {
      return S();
    },
    set child(R) {
      S(R), m();
    }
  }, I = M(), F = D(I);
  {
    var U = (R) => {
      var Z = eN(), Y = D(Z);
      n(Y);
      var X = be(Y, 2);
      te(X, S, () => ({ props: d(T) })), A(R, Z);
    }, B = (R) => {
      var Z = tN();
      ve(Z, () => ({ ...d(T) }));
      var Y = ge(Z);
      n(Y);
      var X = be(Y, 2);
      te(X, () => y() ?? he), de(Z), A(R, Z);
    };
    ue(F, (R) => {
      S() ? R(U) : R(B, !1);
    });
  }
  return A(t, I), H(E);
}
K(
  e1,
  {
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    onStateChange: {},
    loop: {},
    shouldFilter: {},
    filter: {},
    label: {},
    vimBindings: {},
    disablePointerSelection: {},
    disableInitialScroll: {},
    columns: {},
    children: {},
    child: {}
  },
  [],
  [
    "updateSelectedToIndex",
    "updateSelectedByGroup",
    "updateSelectedByItem",
    "getValidItems"
  ],
  { mode: "open" }
);
var rN = /* @__PURE__ */ ne("<div><!></div>");
function t1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = v(e, "forceMount", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child",
    "forceMount"
  ]);
  const u = $h.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    forceMount: z(() => a())
  }), c = /* @__PURE__ */ O(() => Ce(u.props, l));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(p = !1) {
      a(p), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (p) => {
      var g = M(), y = D(g);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, i, () => ({ props: d(c) })), A(P, w);
        }, x = (P) => {
          var w = rN();
          ve(w, () => ({ ...d(c) }));
          var C = ge(w);
          te(C, () => o() ?? he), de(w), A(P, w);
        };
        ue(y, (P) => {
          i() ? P(S) : P(x, !1);
        });
      }
      A(p, g);
    };
    ue(_, (p) => {
      u.shouldRender && p(b);
    });
  }
  return A(t, h), H(f);
}
K(t1, { id: {}, ref: {}, children: {}, child: {}, forceMount: {} }, [], [], { mode: "open" });
var nN = /* @__PURE__ */ ne("<div><!></div>");
function r1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "forceMount", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "forceMount",
    "children",
    "child"
  ]);
  const c = Ah.create({
    id: z(() => n()),
    ref: z(() => s(), (y) => s(y)),
    forceMount: z(() => i()),
    value: z(() => o())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var h = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get ref() {
      return s();
    },
    set ref(y = null) {
      s(y), m();
    },
    get value() {
      return o();
    },
    set value(y = "") {
      o(y), m();
    },
    get forceMount() {
      return i();
    },
    set forceMount(y = !1) {
      i(y), m();
    },
    get children() {
      return a();
    },
    set children(y) {
      a(y), m();
    },
    get child() {
      return l();
    },
    set child(y) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      te(x, l, () => ({ props: d(f) })), A(y, S);
    }, g = (y) => {
      var S = nN();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => a() ?? he), de(S), A(y, S);
    };
    ue(b, (y) => {
      l() ? y(p) : y(g, !1);
    });
  }
  return A(t, _), H(h);
}
K(
  r1,
  {
    id: {},
    ref: {},
    value: {},
    forceMount: {},
    children: {},
    child: {}
  },
  [],
  [],
  { mode: "open" }
);
var sN = /* @__PURE__ */ ne("<div><!></div>");
function n1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = Eh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, i, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = sN();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => o() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(n1, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var oN = /* @__PURE__ */ ne("<div><!></div>"), iN = /* @__PURE__ */ ne('<div style="display: contents;"><!></div>');
function s1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = Th.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = iN(), h = ge(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, i, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = oN();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => o() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return de(f), A(t, f), H(c);
}
K(s1, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var aN = /* @__PURE__ */ ne("<input/>");
function o1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "value", 15, ""), s = v(e, "autofocus", 7, !1), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "value",
    "autofocus",
    "id",
    "ref",
    "child"
  ]);
  const u = Dh.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g)),
    value: z(() => n(), (g) => {
      n(g);
    }),
    autofocus: z(() => s() ?? !1)
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get value() {
      return n();
    },
    set value(g = "") {
      n(g), m();
    },
    get autofocus() {
      return s();
    },
    set autofocus(g = !1) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    },
    get child() {
      return a();
    },
    set child(g) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, a, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = aN();
      ve(y, () => ({ ...d(c) }), void 0, void 0, void 0, void 0, !0), go(y, n), A(g, y);
    };
    ue(_, (g) => {
      a() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(o1, { value: {}, autofocus: {}, id: {}, ref: {}, child: {} }, [], [], { mode: "open" });
var lN = /* @__PURE__ */ ne("<div><!></div>"), uN = /* @__PURE__ */ ne('<div style="display: contents;" data-item-wrapper=""><!></div>');
function i1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "disabled", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = v(e, "onSelect", 7, _e), c = v(e, "forceMount", 7, !1), f = v(e, "keywords", 23, () => []), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const _ = mu.create({
    id: z(() => n()),
    ref: z(() => s(), (S) => s(S)),
    value: z(() => o()),
    disabled: z(() => i()),
    onSelect: z(() => u()),
    forceMount: z(() => c()),
    keywords: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(h, _.props));
  var p = {
    get id() {
      return n();
    },
    set id(S = me(r)) {
      n(S), m();
    },
    get ref() {
      return s();
    },
    set ref(S = null) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S = "") {
      o(S), m();
    },
    get disabled() {
      return i();
    },
    set disabled(S = !1) {
      i(S), m();
    },
    get children() {
      return a();
    },
    set children(S) {
      a(S), m();
    },
    get child() {
      return l();
    },
    set child(S) {
      l(S), m();
    },
    get onSelect() {
      return u();
    },
    set onSelect(S = _e) {
      u(S), m();
    },
    get forceMount() {
      return c();
    },
    set forceMount(S = !1) {
      c(S), m();
    },
    get keywords() {
      return f();
    },
    set keywords(S = []) {
      f(S), m();
    }
  }, g = M(), y = D(g);
  return Ll(y, () => _.root.key, (S) => {
    var x = uN(), P = ge(x);
    {
      var w = (C) => {
        var k = M(), $ = D(k);
        {
          var T = (I) => {
            var F = M(), U = D(F);
            te(U, l, () => ({ props: d(b) })), A(I, F);
          }, E = (I) => {
            var F = lN();
            ve(F, () => ({ ...d(b) }));
            var U = ge(F);
            te(U, () => a() ?? he), de(F), A(I, F);
          };
          ue($, (I) => {
            l() ? I(T) : I(E, !1);
          });
        }
        A(C, k);
      };
      ue(P, (C) => {
        _.shouldRender && C(w);
      });
    }
    de(x), ke(() => An(x, "data-value", _.trueValue)), A(S, x);
  }), A(t, g), H(p);
}
K(
  i1,
  {
    id: {},
    ref: {},
    value: {},
    disabled: {},
    children: {},
    child: {},
    onSelect: {},
    forceMount: {},
    keywords: {}
  },
  [],
  [],
  { mode: "open" }
);
var cN = /* @__PURE__ */ ne("<a><!></a>"), dN = /* @__PURE__ */ ne('<div style="display: contents;"><!></div>');
function a1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "disabled", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = v(e, "onSelect", 7, _e), c = v(e, "forceMount", 7, !1), f = v(e, "keywords", 23, () => []), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const _ = mu.create({
    id: z(() => n()),
    ref: z(() => s(), (S) => s(S)),
    value: z(() => o()),
    disabled: z(() => i()),
    onSelect: z(() => u()),
    forceMount: z(() => c()),
    keywords: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(h, _.props));
  var p = {
    get id() {
      return n();
    },
    set id(S = me(r)) {
      n(S), m();
    },
    get ref() {
      return s();
    },
    set ref(S = null) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S = "") {
      o(S), m();
    },
    get disabled() {
      return i();
    },
    set disabled(S = !1) {
      i(S), m();
    },
    get children() {
      return a();
    },
    set children(S) {
      a(S), m();
    },
    get child() {
      return l();
    },
    set child(S) {
      l(S), m();
    },
    get onSelect() {
      return u();
    },
    set onSelect(S = _e) {
      u(S), m();
    },
    get forceMount() {
      return c();
    },
    set forceMount(S = !1) {
      c(S), m();
    },
    get keywords() {
      return f();
    },
    set keywords(S = []) {
      f(S), m();
    }
  }, g = M(), y = D(g);
  return Ll(y, () => _.root.key, (S) => {
    var x = dN(), P = ge(x);
    {
      var w = (C) => {
        var k = M(), $ = D(k);
        {
          var T = (I) => {
            var F = M(), U = D(F);
            te(U, l, () => ({ props: d(b) })), A(I, F);
          }, E = (I) => {
            var F = cN();
            ve(F, () => ({ ...d(b) }));
            var U = ge(F);
            te(U, () => a() ?? he), de(F), A(I, F);
          };
          ue($, (I) => {
            l() ? I(T) : I(E, !1);
          });
        }
        A(C, k);
      };
      ue(P, (C) => {
        _.shouldRender && C(w);
      });
    }
    de(x), A(S, x);
  }), A(t, g), H(p);
}
K(
  a1,
  {
    id: {},
    ref: {},
    value: {},
    disabled: {},
    children: {},
    child: {},
    onSelect: {},
    forceMount: {},
    keywords: {}
  },
  [],
  [],
  { mode: "open" }
);
var fN = /* @__PURE__ */ ne("<div><!></div>");
function l1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "aria-label", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "aria-label"
  ]);
  const u = Nh.create({
    id: z(() => n()),
    ref: z(() => s(), (b) => s(b)),
    ariaLabel: z(() => a() ?? "Suggestions...")
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(b = me(r)) {
      n(b), m();
    },
    get ref() {
      return s();
    },
    set ref(b = null) {
      s(b), m();
    },
    get child() {
      return o();
    },
    set child(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get "aria-label"() {
      return a();
    },
    set "aria-label"(b) {
      a(b), m();
    }
  }, h = M(), _ = D(h);
  return Ll(_, () => u.root._commandState.search === "", (b) => {
    var p = M(), g = D(p);
    {
      var y = (x) => {
        var P = M(), w = D(P);
        te(w, o, () => ({ props: d(c) })), A(x, P);
      }, S = (x) => {
        var P = fN();
        ve(P, () => ({ ...d(c) }));
        var w = ge(P);
        te(w, () => i() ?? he), de(P), A(x, P);
      };
      ue(g, (x) => {
        o() ? x(y) : x(S, !1);
      });
    }
    A(b, p);
  }), A(t, h), H(f);
}
K(l1, { id: {}, ref: {}, child: {}, children: {}, "aria-label": {} }, [], [], { mode: "open" });
var hN = /* @__PURE__ */ ne("<div><!></div>");
function u1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "progress", 7, 0), s = v(e, "id", 23, () => me(r)), o = v(e, "ref", 15, null), i = v(e, "children", 7), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "progress",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const u = Mh.create({
    id: z(() => s()),
    ref: z(() => o(), (g) => o(g)),
    progress: z(() => n())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get progress() {
      return n();
    },
    set progress(g = 0) {
      n(g), m();
    },
    get id() {
      return s();
    },
    set id(g = me(r)) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get children() {
      return i();
    },
    set children(g) {
      i(g), m();
    },
    get child() {
      return a();
    },
    set child(g) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, a, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = hN();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => i() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      a() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(u1, { progress: {}, id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var gN = /* @__PURE__ */ ne("<div><!></div>");
function c1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "forceMount", 7, !1), i = v(e, "children", 7), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "forceMount",
    "children",
    "child"
  ]);
  const u = Ih.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    forceMount: z(() => o())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get forceMount() {
      return o();
    },
    set forceMount(p = !1) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    },
    get child() {
      return a();
    },
    set child(p) {
      a(p), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (p) => {
      var g = M(), y = D(g);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, a, () => ({ props: d(c) })), A(P, w);
        }, x = (P) => {
          var w = gN();
          ve(w, () => ({ ...d(c) }));
          var C = ge(w);
          te(C, () => i() ?? he), de(w), A(P, w);
        };
        ue(y, (P) => {
          a() ? P(S) : P(x, !1);
        });
      }
      A(p, g);
    };
    ue(_, (p) => {
      u.shouldRender && p(b);
    });
  }
  return A(t, h), H(f);
}
K(c1, { id: {}, ref: {}, forceMount: {}, children: {}, child: {} }, [], [], { mode: "open" });
const Ym = 1, pN = 0.9, mN = 0.8, vN = 0.17, lc = 0.1, uc = 0.999, yN = 0.9999, bN = 0.99, _N = /[\\/_+.#"@[({&]/, wN = /[\\/_+.#"@[({&]/g, SN = /[\s-]/, d1 = /[\s-]/g;
function Xc(t, e, r, n, s, o, i) {
  if (o === e.length)
    return s === t.length ? Ym : bN;
  const a = `${s},${o}`;
  if (i[a] !== void 0)
    return i[a];
  const l = n.charAt(o);
  let u = r.indexOf(l, s), c = 0, f, h, _, b;
  for (; u >= 0; )
    f = Xc(t, e, r, n, u + 1, o + 1, i), f > c && (u === s ? f *= Ym : _N.test(t.charAt(u - 1)) ? (f *= mN, _ = t.slice(s, u - 1).match(wN), _ && s > 0 && (f *= uc ** _.length)) : SN.test(t.charAt(u - 1)) ? (f *= pN, b = t.slice(s, u - 1).match(d1), b && s > 0 && (f *= uc ** b.length)) : (f *= vN, s > 0 && (f *= uc ** (u - s))), t.charAt(u) !== e.charAt(o) && (f *= yN)), (f < lc && r.charAt(u - 1) === n.charAt(o + 1) || n.charAt(o + 1) === n.charAt(o) && r.charAt(u - 1) !== n.charAt(o)) && (h = Xc(t, e, r, n, u + 1, o + 2, i), h * lc > f && (f = h * lc)), f > c && (c = f), u = r.indexOf(l, u + 1);
  return i[a] = c, c;
}
function Xm(t) {
  return t.toLowerCase().replace(d1, " ");
}
function Jc(t, e, r) {
  return t = r && r.length > 0 ? `${`${t} ${r?.join(" ")}`}` : t, Xc(t, e, Xm(t), Xm(e), 0, 0, {});
}
function Jm(t, e) {
  const [r, n] = t;
  let s = !1;
  const o = e.length;
  for (let i = 0, a = o - 1; i < o; a = i++) {
    const [l, u] = e[i] ?? [0, 0], [c, f] = e[a] ?? [0, 0];
    u >= n != f >= n && r <= (c - l) * (n - u) / (f - u) + l && (s = !s);
  }
  return s;
}
function Zm(t, e) {
  return t[0] >= e.left && t[0] <= e.right && t[1] >= e.top && t[1] <= e.bottom;
}
function xN(t, e) {
  const r = t.left + t.width / 2, n = t.top + t.height / 2, s = e.left + e.width / 2, o = e.top + e.height / 2, i = s - r, a = o - n;
  return Math.abs(i) > Math.abs(a) ? i > 0 ? "right" : "left" : a > 0 ? "bottom" : "top";
}
class PN {
  #e;
  #t;
  // tracks the cursor position when leaving trigger or content
  #r = null;
  // tracks what we're moving toward: "content" when leaving trigger, "trigger" when leaving content
  #n = null;
  constructor(e) {
    this.#e = e, this.#t = e.buffer ?? 1, Fe([e.triggerNode, e.contentNode, e.enabled], ([r, n, s]) => {
      if (!r || !n || !s) {
        this.#r = null, this.#n = null;
        return;
      }
      const o = nf(r), i = (f) => {
        this.#s(f, r, n);
      }, a = (f) => {
        const h = f.relatedTarget;
        di(h) && n.contains(h) || (this.#r = [f.clientX, f.clientY], this.#n = "content");
      }, l = () => {
        this.#r = null, this.#n = null;
      }, u = () => {
        this.#r = null, this.#n = null;
      }, c = (f) => {
        const h = f.relatedTarget;
        di(h) && r.contains(h) || (this.#r = [f.clientX, f.clientY], this.#n = "trigger");
      };
      return [
        Ye(o, "pointermove", i),
        Ye(r, "pointerleave", a),
        Ye(r, "pointerenter", l),
        Ye(n, "pointerenter", u),
        Ye(n, "pointerleave", c)
      ].reduce(
        (f, h) => () => {
          f(), h();
        },
        () => {
        }
      );
    });
  }
  #s(e, r, n) {
    if (!this.#r || !this.#n) return;
    const s = [e.clientX, e.clientY], o = r.getBoundingClientRect(), i = n.getBoundingClientRect();
    if (this.#n === "content" && Zm(s, i)) {
      this.#r = null, this.#n = null;
      return;
    }
    if (this.#n === "trigger" && Zm(s, o)) {
      this.#r = null, this.#n = null;
      return;
    }
    const a = xN(o, i), l = this.#o(o, i, a);
    if (l && Jm(s, l))
      return;
    const u = this.#n === "content" ? i : o, c = this.#i(this.#r, u, a, this.#n);
    Jm(s, c) || (this.#r = null, this.#n = null, this.#e.onPointerExit());
  }
  /**
   * Creates a rectangular corridor between trigger and content
   * This prevents closing when cursor is in the gap between them
   */
  #o(e, r, n) {
    const s = this.#t;
    switch (n) {
      case "top":
        return [
          [
            Math.min(e.left, r.left) - s,
            e.top
          ],
          [
            Math.min(e.left, r.left) - s,
            r.bottom
          ],
          [
            Math.max(e.right, r.right) + s,
            r.bottom
          ],
          [
            Math.max(e.right, r.right) + s,
            e.top
          ]
        ];
      case "bottom":
        return [
          [
            Math.min(e.left, r.left) - s,
            e.bottom
          ],
          [
            Math.min(e.left, r.left) - s,
            r.top
          ],
          [
            Math.max(e.right, r.right) + s,
            r.top
          ],
          [
            Math.max(e.right, r.right) + s,
            e.bottom
          ]
        ];
      case "left":
        return [
          [
            e.left,
            Math.min(e.top, r.top) - s
          ],
          [
            r.right,
            Math.min(e.top, r.top) - s
          ],
          [
            r.right,
            Math.max(e.bottom, r.bottom) + s
          ],
          [
            e.left,
            Math.max(e.bottom, r.bottom) + s
          ]
        ];
      case "right":
        return [
          [
            e.right,
            Math.min(e.top, r.top) - s
          ],
          [
            r.left,
            Math.min(e.top, r.top) - s
          ],
          [
            r.left,
            Math.max(e.bottom, r.bottom) + s
          ],
          [
            e.right,
            Math.max(e.bottom, r.bottom) + s
          ]
        ];
    }
  }
  /**
   * Creates a triangular/trapezoidal safe zone from the exit point to the target
   */
  #i(e, r, n, s) {
    const o = this.#t * 4, [i, a] = e;
    switch (s === "trigger" ? this.#a(n) : n) {
      case "top":
        return [
          [i - o, a + o],
          [i + o, a + o],
          [r.right + o, r.bottom],
          [r.right + o, r.top],
          [r.left - o, r.top],
          [r.left - o, r.bottom]
        ];
      case "bottom":
        return [
          [i - o, a - o],
          [i + o, a - o],
          [r.right + o, r.top],
          [r.right + o, r.bottom],
          [r.left - o, r.bottom],
          [r.left - o, r.top]
        ];
      case "left":
        return [
          [i + o, a - o],
          [i + o, a + o],
          [r.right, r.bottom + o],
          [r.left, r.bottom + o],
          [r.left, r.top - o],
          [r.right, r.top - o]
        ];
      case "right":
        return [
          [i - o, a - o],
          [i - o, a + o],
          [r.left, r.bottom + o],
          [r.right, r.bottom + o],
          [r.right, r.top - o],
          [r.left, r.top - o]
        ];
    }
  }
  #a(e) {
    switch (e) {
      case "top":
        return "bottom";
      case "bottom":
        return "top";
      case "left":
        return "right";
      case "right":
        return "left";
    }
  }
}
const Ol = nr({
  component: "popover",
  parts: ["root", "trigger", "content", "close", "overlay"]
}), vu = new ht("Popover.Root");
class Rh {
  static create(e) {
    return vu.set(new Rh(e));
  }
  opts;
  #e = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#e);
  }
  set contentNode(e) {
    q(this.#e, e, !0);
  }
  contentPresence;
  #t = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#t);
  }
  set triggerNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get overlayNode() {
    return d(this.#r);
  }
  set overlayNode(e) {
    q(this.#r, e, !0);
  }
  overlayPresence;
  #n = /* @__PURE__ */ xe(!1);
  get openedViaHover() {
    return d(this.#n);
  }
  set openedViaHover(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(!1);
  get hasInteractedWithContent() {
    return d(this.#s);
  }
  set hasInteractedWithContent(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(!1);
  get hoverCooldown() {
    return d(this.#o);
  }
  set hoverCooldown(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(0);
  get closeDelay() {
    return d(this.#i);
  }
  set closeDelay(e) {
    q(this.#i, e, !0);
  }
  #a = null;
  #u = null;
  constructor(e) {
    this.opts = e, this.contentPresence = new wi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), this.overlayPresence = new wi({ ref: z(() => this.overlayNode), open: this.opts.open }), Fe(() => this.opts.open.current, (r) => {
      r || (this.openedViaHover = !1, this.hasInteractedWithContent = !1, this.#l());
    });
  }
  setDomContext(e) {
    this.#u = e;
  }
  #l() {
    this.#a !== null && this.#u && (this.#u.clearTimeout(this.#a), this.#a = null);
  }
  toggleOpen() {
    this.#l(), this.opts.open.current = !this.opts.open.current;
  }
  handleClose() {
    this.#l(), this.opts.open.current && (this.opts.open.current = !1);
  }
  handleHoverOpen() {
    this.#l(), !this.opts.open.current && (this.openedViaHover = !0, this.opts.open.current = !0);
  }
  handleHoverClose() {
    this.opts.open.current && this.openedViaHover && !this.hasInteractedWithContent && (this.opts.open.current = !1);
  }
  handleDelayedHoverClose() {
    this.opts.open.current && (!this.openedViaHover || this.hasInteractedWithContent || (this.#l(), this.closeDelay <= 0 ? this.opts.open.current = !1 : this.#u && (this.#a = this.#u.setTimeout(
      () => {
        this.openedViaHover && !this.hasInteractedWithContent && (this.opts.open.current = !1), this.#a = null;
      },
      this.closeDelay
    ))));
  }
  cancelDelayedClose() {
    this.#l();
  }
  markInteraction() {
    this.hasInteractedWithContent = !0, this.#l();
  }
}
class Vh {
  static create(e) {
    return new Vh(e, vu.get());
  }
  opts;
  root;
  attachment;
  domContext;
  #e = null;
  #t = null;
  #r = /* @__PURE__ */ xe(!1);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.triggerNode = n), this.domContext = new Fn(e.ref), this.root.setDomContext(this.domContext), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this), Fe(() => this.opts.closeDelay.current, (n) => {
      this.root.closeDelay = n;
    });
  }
  #n() {
    this.#e !== null && (this.domContext.clearTimeout(this.#e), this.#e = null);
  }
  #s() {
    this.#t !== null && (this.domContext.clearTimeout(this.#t), this.#t = null);
  }
  #o() {
    this.#n(), this.#s();
  }
  onpointerenter(e) {
    if (this.opts.disabled.current || !this.opts.openOnHover.current || cl(e) || (q(this.#r, !0), this.#s(), this.root.cancelDelayedClose(), this.root.opts.open.current || this.root.hoverCooldown)) return;
    const r = this.opts.openDelay.current;
    r <= 0 ? this.root.handleHoverOpen() : this.#e = this.domContext.setTimeout(
      () => {
        this.root.handleHoverOpen(), this.#e = null;
      },
      r
    );
  }
  onpointerleave(e) {
    this.opts.disabled.current || this.opts.openOnHover.current && (cl(e) || (q(this.#r, !1), this.#n(), this.root.hoverCooldown = !1));
  }
  onclick(e) {
    if (!this.opts.disabled.current && e.button === 0) {
      if (this.#o(), d(this.#r) && this.root.opts.open.current && this.root.openedViaHover) {
        this.root.openedViaHover = !1, this.root.hasInteractedWithContent = !0;
        return;
      }
      d(this.#r) && this.opts.openOnHover.current && this.root.opts.open.current && (this.root.hoverCooldown = !0), this.root.hoverCooldown && !this.root.opts.open.current && (this.root.hoverCooldown = !1), this.root.toggleOpen();
    }
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === Br || e.key === xr) && (e.preventDefault(), this.#o(), this.root.toggleOpen());
  }
  #i() {
    if (this.root.opts.open.current && this.root.contentNode?.id)
      return this.root.contentNode?.id;
  }
  #a = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-haspopup": "dialog",
    "aria-expanded": at(this.root.opts.open.current),
    "data-state": ji(this.root.opts.open.current),
    "aria-controls": this.#i(),
    [Ol.trigger]: "",
    disabled: this.opts.disabled.current,
    //
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    onpointerenter: this.onpointerenter,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
class Lh {
  static create(e) {
    return new Lh(e, vu.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.contentNode = n), this.onpointerdown = this.onpointerdown.bind(this), this.onfocusin = this.onfocusin.bind(this), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this), new PN({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.root.contentNode,
      enabled: () => this.root.opts.open.current && this.root.openedViaHover && !this.root.hasInteractedWithContent,
      onPointerExit: () => {
        this.root.handleDelayedHoverClose();
      }
    });
  }
  onpointerdown(e) {
    this.root.markInteraction();
  }
  onfocusin(e) {
    const r = e.target;
    di(r) && DT(r) && this.root.markInteraction();
  }
  onpointerenter(e) {
    cl(e) || this.root.cancelDelayedClose();
  }
  onpointerleave(e) {
    cl(e);
  }
  onInteractOutside = (e) => {
    if (this.opts.onInteractOutside.current(e), e.defaultPrevented || !di(e.target)) return;
    const r = e.target.closest(Ol.selector("trigger"));
    if (!(r && r === this.root.triggerNode)) {
      if (this.opts.customAnchor.current) {
        if (di(this.opts.customAnchor.current)) {
          if (this.opts.customAnchor.current.contains(e.target)) return;
        } else if (typeof this.opts.customAnchor.current == "string") {
          const n = document.querySelector(this.opts.customAnchor.current);
          if (n && n.contains(e.target)) return;
        }
      }
      this.root.handleClose();
    }
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get shouldTrapFocus() {
    return !(this.root.openedViaHover && !this.root.hasInteractedWithContent);
  }
  #e = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    tabindex: -1,
    "data-state": ji(this.root.opts.open.current),
    [Ol.content]: "",
    style: { pointerEvents: "auto", contain: "layout style paint" },
    onpointerdown: this.onpointerdown,
    onfocusin: this.onfocusin,
    onpointerenter: this.onpointerenter,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown
  };
}
class jh {
  static create(e) {
    return new jh(e, vu.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.root.handleClose();
  }
  onkeydown(e) {
    (e.key === Br || e.key === xr) && (e.preventDefault(), this.root.handleClose());
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    type: "button",
    [Ol.close]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var ON = /* @__PURE__ */ ne("<div><div><!></div></div>"), CN = /* @__PURE__ */ ne("<div><div><!></div></div>");
function f1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "forceMount", 7, !1), l = v(e, "onOpenAutoFocus", 7, _e), u = v(e, "onCloseAutoFocus", 7, _e), c = v(e, "onEscapeKeydown", 7, _e), f = v(e, "onInteractOutside", 7, _e), h = v(e, "trapFocus", 7, !0), _ = v(e, "preventScroll", 7, !1), b = v(e, "customAnchor", 7, null), p = v(e, "style", 7), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id",
    "forceMount",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "customAnchor",
    "style"
  ]);
  const y = Lh.create({
    id: z(() => i()),
    ref: z(() => o(), (E) => o(E)),
    onInteractOutside: z(() => f()),
    onEscapeKeydown: z(() => c()),
    customAnchor: z(() => b())
  }), S = /* @__PURE__ */ O(() => Ce(g, y.props)), x = /* @__PURE__ */ O(() => h() && y.shouldTrapFocus);
  function P(E) {
    y.shouldTrapFocus || E.preventDefault(), l()(E);
  }
  var w = {
    get child() {
      return n();
    },
    set child(E) {
      n(E), m();
    },
    get children() {
      return s();
    },
    set children(E) {
      s(E), m();
    },
    get ref() {
      return o();
    },
    set ref(E = null) {
      o(E), m();
    },
    get id() {
      return i();
    },
    set id(E = me(r)) {
      i(E), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(E = !1) {
      a(E), m();
    },
    get onOpenAutoFocus() {
      return l();
    },
    set onOpenAutoFocus(E = _e) {
      l(E), m();
    },
    get onCloseAutoFocus() {
      return u();
    },
    set onCloseAutoFocus(E = _e) {
      u(E), m();
    },
    get onEscapeKeydown() {
      return c();
    },
    set onEscapeKeydown(E = _e) {
      c(E), m();
    },
    get onInteractOutside() {
      return f();
    },
    set onInteractOutside(E = _e) {
      f(E), m();
    },
    get trapFocus() {
      return h();
    },
    set trapFocus(E = !0) {
      h(E), m();
    },
    get preventScroll() {
      return _();
    },
    set preventScroll(E = !1) {
      _(E), m();
    },
    get customAnchor() {
      return b();
    },
    set customAnchor(E = null) {
      b(E), m();
    },
    get style() {
      return p();
    },
    set style(E) {
      p(E), m();
    }
  }, C = M(), k = D(C);
  {
    var $ = (E) => {
      Ch(E, ce(() => d(S), () => y.popperProps, {
        get ref() {
          return y.opts.ref;
        },
        get enabled() {
          return y.root.opts.open.current;
        },
        get id() {
          return i();
        },
        get trapFocus() {
          return d(x);
        },
        get preventScroll() {
          return _();
        },
        loop: !0,
        forceMount: !0,
        get customAnchor() {
          return b();
        },
        onOpenAutoFocus: P,
        get onCloseAutoFocus() {
          return u();
        },
        get shouldRender() {
          return y.shouldRender;
        },
        popper: (F, U) => {
          let B = () => U?.().props, R = () => U?.().wrapperProps;
          const Z = /* @__PURE__ */ O(() => Ce(B(), { style: Yc("popover") }, { style: p() }));
          var Y = M(), X = D(Y);
          {
            var ae = (j) => {
              var ee = M(), L = D(ee);
              {
                let N = /* @__PURE__ */ O(() => ({
                  props: d(Z),
                  wrapperProps: R(),
                  ...y.snippetProps
                }));
                te(L, n, () => d(N));
              }
              A(j, ee);
            }, J = (j) => {
              var ee = ON();
              ve(ee, () => ({ ...R() }));
              var L = ge(ee);
              ve(L, () => ({ ...d(Z) }));
              var N = ge(L);
              te(N, () => s() ?? he), de(L), de(ee), A(j, ee);
            };
            ue(X, (j) => {
              n() ? j(ae) : j(J, !1);
            });
          }
          A(F, Y);
        },
        $$slots: { popper: !0 }
      }));
    }, T = (E) => {
      var I = M(), F = D(I);
      {
        var U = (B) => {
          Oh(B, ce(() => d(S), () => y.popperProps, {
            get ref() {
              return y.opts.ref;
            },
            get open() {
              return y.root.opts.open.current;
            },
            get id() {
              return i();
            },
            get trapFocus() {
              return d(x);
            },
            get preventScroll() {
              return _();
            },
            loop: !0,
            forceMount: !1,
            get customAnchor() {
              return b();
            },
            onOpenAutoFocus: P,
            get onCloseAutoFocus() {
              return u();
            },
            get shouldRender() {
              return y.shouldRender;
            },
            popper: (Z, Y) => {
              let X = () => Y?.().props, ae = () => Y?.().wrapperProps;
              const J = /* @__PURE__ */ O(() => Ce(X(), { style: Yc("popover") }, { style: p() }));
              var j = M(), ee = D(j);
              {
                var L = (V) => {
                  var G = M(), fe = D(G);
                  {
                    let se = /* @__PURE__ */ O(() => ({
                      props: d(J),
                      wrapperProps: ae(),
                      ...y.snippetProps
                    }));
                    te(fe, n, () => d(se));
                  }
                  A(V, G);
                }, N = (V) => {
                  var G = CN();
                  ve(G, () => ({ ...ae() }));
                  var fe = ge(G);
                  ve(fe, () => ({ ...d(J) }));
                  var se = ge(fe);
                  te(se, () => s() ?? he), de(fe), de(G), A(V, G);
                };
                ue(ee, (V) => {
                  n() ? V(L) : V(N, !1);
                });
              }
              A(Z, j);
            },
            $$slots: { popper: !0 }
          }));
        };
        ue(
          F,
          (B) => {
            a() || B(U);
          },
          !0
        );
      }
      A(E, I);
    };
    ue(k, (E) => {
      a() ? E($) : E(T, !1);
    });
  }
  return A(t, C), H(w);
}
K(
  f1,
  {
    child: {},
    children: {},
    ref: {},
    id: {},
    forceMount: {},
    onOpenAutoFocus: {},
    onCloseAutoFocus: {},
    onEscapeKeydown: {},
    onInteractOutside: {},
    trapFocus: {},
    preventScroll: {},
    customAnchor: {},
    style: {}
  },
  [],
  [],
  { mode: "open" }
);
var kN = /* @__PURE__ */ ne("<button><!></button>");
function h1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7, !1), u = v(e, "openOnHover", 7, !1), c = v(e, "openDelay", 7, 700), f = v(e, "closeDelay", 7, 300), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "type",
    "disabled",
    "openOnHover",
    "openDelay",
    "closeDelay"
  ]);
  const _ = Vh.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g)),
    disabled: z(() => !!l()),
    openOnHover: z(() => u()),
    openDelay: z(() => c()),
    closeDelay: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(h, _.props, { type: a() }));
  var p = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    },
    get type() {
      return a();
    },
    set type(g = "button") {
      a(g), m();
    },
    get disabled() {
      return l();
    },
    set disabled(g = !1) {
      l(g), m();
    },
    get openOnHover() {
      return u();
    },
    set openOnHover(g = !1) {
      u(g), m();
    },
    get openDelay() {
      return c();
    },
    set openDelay(g = 700) {
      c(g), m();
    },
    get closeDelay() {
      return f();
    },
    set closeDelay(g = 300) {
      f(g), m();
    }
  };
  return Sh(t, {
    get id() {
      return o();
    },
    get ref() {
      return _.opts.ref;
    },
    children: (g, y) => {
      var S = M(), x = D(S);
      {
        var P = (C) => {
          var k = M(), $ = D(k);
          te($, s, () => ({ props: d(b) })), A(C, k);
        }, w = (C) => {
          var k = kN();
          ve(k, () => ({ ...d(b) }));
          var $ = ge(k);
          te($, () => n() ?? he), de(k), A(C, k);
        };
        ue(x, (C) => {
          s() ? C(P) : C(w, !1);
        });
      }
      A(g, S);
    },
    $$slots: { default: !0 }
  }), H(p);
}
K(
  h1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    type: {},
    disabled: {},
    openOnHover: {},
    openDelay: {},
    closeDelay: {}
  },
  [],
  [],
  { mode: "open" }
);
var $N = /* @__PURE__ */ ne("<button><!></button>");
function g1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "id",
    "ref"
  ]);
  const l = jh.create({
    id: z(() => o()),
    ref: z(() => i(), (p) => i(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get child() {
      return n();
    },
    set child(p) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    },
    get id() {
      return o();
    },
    set id(p = me(r)) {
      o(p), m();
    },
    get ref() {
      return i();
    },
    set ref(p = null) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, n, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = $N();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => s() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      n() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(g1, { child: {}, children: {}, id: {}, ref: {} }, [], [], { mode: "open" });
const p1 = new ht("RangeCalendar.Cell");
class Bh {
  static create(e) {
    return Ut.set(new Bh(e));
  }
  opts;
  attachment;
  #e = /* @__PURE__ */ O(() => this.months.map((e) => e.value));
  get visibleMonths() {
    return d(this.#e);
  }
  set visibleMonths(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ xe(Pt([]));
  get months() {
    return d(this.#t);
  }
  set months(e) {
    q(this.#t, e, !0);
  }
  announcer;
  formatter;
  accessibleHeadingId = En();
  #r = /* @__PURE__ */ xe(void 0);
  get focusedValue() {
    return d(this.#r);
  }
  set focusedValue(e) {
    q(this.#r, e, !0);
  }
  lastPressedDateValue = void 0;
  domContext;
  #n = /* @__PURE__ */ O(() => uw({
    months: this.months,
    formatter: this.formatter,
    weekdayFormat: this.opts.weekdayFormat.current
  }));
  get weekdays() {
    return d(this.#n);
  }
  set weekdays(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.opts.startValue.current ? this.isDateUnavailable(this.opts.startValue.current) || this.isDateDisabled(this.opts.startValue.current) : !1);
  get isStartInvalid() {
    return d(this.#s);
  }
  set isStartInvalid(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => this.opts.endValue.current ? this.isDateUnavailable(this.opts.endValue.current) || this.isDateDisabled(this.opts.endValue.current) : !1);
  get isEndInvalid() {
    return d(this.#o);
  }
  set isEndInvalid(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => !!(this.isStartInvalid || this.isEndInvalid || this.opts.endValue.current && this.opts.startValue.current && Bt(this.opts.endValue.current, this.opts.startValue.current)));
  get isInvalid() {
    return d(this.#i);
  }
  set isInvalid(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => fw({
    maxValue: this.opts.maxValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isNextButtonDisabled() {
    return d(this.#a);
  }
  set isNextButtonDisabled(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => hw({
    minValue: this.opts.minValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isPrevButtonDisabled() {
    return d(this.#u);
  }
  set isPrevButtonDisabled(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => (this.opts.monthFormat.current, this.opts.yearFormat.current, gw({
    months: this.months,
    formatter: this.formatter,
    locale: this.opts.locale.current
  })));
  get headingValue() {
    return d(this.#l);
  }
  set headingValue(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => `${this.opts.calendarLabel.current} ${this.headingValue}`);
  get fullCalendarLabel() {
    return d(this.#c);
  }
  set fullCalendarLabel(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => {
    if (this.opts.startValue.current && this.opts.endValue.current || !this.opts.startValue.current || !this.focusedValue) return null;
    const e = Bt(this.opts.startValue.current, this.focusedValue), r = e ? this.opts.startValue.current : this.focusedValue, n = e ? this.focusedValue : this.opts.startValue.current, s = { start: r, end: n };
    return _t(r.add({ days: 1 }), n) || _t(r, n) || UD(r, n, this.isDateUnavailable, this.isDateDisabled) ? s : null;
  });
  get highlightedRange() {
    return d(this.#d);
  }
  set highlightedRange(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => ot(() => this.opts.placeholder.current.year));
  get initialPlaceholderYear() {
    return d(this.#g);
  }
  set initialPlaceholderYear(e) {
    q(this.#g, e);
  }
  #m = /* @__PURE__ */ O(() => yw({
    minValue: this.opts.minValue.current,
    maxValue: this.opts.maxValue.current,
    placeholderYear: this.initialPlaceholderYear
  }));
  get defaultYears() {
    return d(this.#m);
  }
  set defaultYears(e) {
    q(this.#m, e);
  }
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref), this.domContext = new Fn(e.ref), this.announcer = yl(null), this.formatter = sw({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    }), this.months = jo({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    }), ko(() => {
      this.formatter.getLocale() !== this.opts.locale.current && this.formatter.setLocale(this.opts.locale.current);
    }), $o(() => {
      this.announcer = yl(this.domContext.getDocument());
    }), dw({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: this.setMonths
    }), cw({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    }), Xe(() => {
      const r = this.domContext.getElementById(this.accessibleHeadingId);
      r && (r.textContent = this.fullCalendarLabel);
    }), Fe(() => this.opts.value.current, (r) => {
      r.start && r.end ? (this.opts.startValue.current = r.start, this.opts.endValue.current = r.end) : r.start ? (this.opts.startValue.current = r.start, this.opts.endValue.current = void 0) : r.start === void 0 && r.end === void 0 && (this.opts.startValue.current = void 0, this.opts.endValue.current = void 0);
    }), Fe(() => this.opts.value.current, (r) => {
      const n = r.start;
      n && this.opts.placeholder.current !== n && (this.opts.placeholder.current = n);
    }), Fe(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current,
        () => this.opts.excludeDisabled.current
      ],
      ([r, n, s]) => {
        !s || !r || !n || this.#_(r, n) && (this.#f(void 0), this.#h(void 0), this.#y());
      }
    ), Fe(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([r, n]) => {
        this.opts.value.current && this.opts.value.current.start === r && this.opts.value.current.end === n || (r && n ? this.#p((s) => {
          if (s.start === r && s.end === n)
            return s;
          if (Bt(n, r)) {
            const o = r, i = n;
            return this.#f(i), this.#h(o), this.#b(n, r) ? { start: n, end: r } : (this.#f(r), this.#h(void 0), { start: r, end: void 0 });
          } else
            return this.#b(r, n) ? { start: r, end: n } : (this.#f(n), this.#h(void 0), { start: n, end: void 0 });
        }) : this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end && (this.opts.value.current.start = void 0, this.opts.value.current.end = void 0));
      }
    ), this.shiftFocus = this.shiftFocus.bind(this), this.handleCellClick = this.handleCellClick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.nextYear = this.nextYear.bind(this), this.prevYear = this.prevYear.bind(this), this.setYear = this.setYear.bind(this), this.setMonth = this.setMonth.bind(this), this.isDateDisabled = this.isDateDisabled.bind(this), this.isDateUnavailable = this.isDateUnavailable.bind(this), this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this), this.isSelected = this.isSelected.bind(this), mw({
      placeholder: e.placeholder,
      defaultPlaceholder: e.defaultPlaceholder,
      isDateDisabled: e.isDateDisabled,
      maxValue: e.maxValue,
      minValue: e.minValue,
      ref: e.ref
    });
  }
  #p(e) {
    const r = this.opts.value.current, n = e(r);
    this.opts.value.current = n, n.start && n.end && this.opts.onRangeSelect?.current?.();
  }
  #f(e) {
    this.opts.startValue.current = e, this.#p((r) => ({ ...r, start: e }));
  }
  #h(e) {
    this.opts.endValue.current = e, this.#p((r) => ({ ...r, end: e }));
  }
  setMonths = (e) => {
    this.months = e;
  };
  isOutsideVisibleMonths(e) {
    return !this.visibleMonths.some((r) => Lo(e, r));
  }
  isDateDisabled(e) {
    if (this.opts.isDateDisabled.current(e) || this.opts.disabled.current) return !0;
    const r = this.opts.minValue.current, n = this.opts.maxValue.current;
    return !!(r && Bt(e, r) || n && rw(e, n));
  }
  isDateUnavailable(e) {
    return !!this.opts.isDateUnavailable.current(e);
  }
  isSelectionStart(e) {
    return this.opts.startValue.current ? _t(e, this.opts.startValue.current) : !1;
  }
  isSelectionEnd(e) {
    return this.opts.endValue.current ? _t(e, this.opts.endValue.current) : !1;
  }
  isSelected(e) {
    return this.opts.startValue.current && _t(this.opts.startValue.current, e) || this.opts.endValue.current && _t(this.opts.endValue.current, e) ? !0 : this.opts.startValue.current && this.opts.endValue.current ? nw(e, this.opts.startValue.current, this.opts.endValue.current) : !1;
  }
  #b(e, r) {
    const n = Bt(r, e) ? r : e, s = Bt(r, e) ? e : r, o = n.toDate(ft()), a = s.toDate(ft()).getTime() - o.getTime(), u = Math.floor(a / (1e3 * 60 * 60 * 24)) + 1;
    return !(this.opts.minDays.current && u < this.opts.minDays.current || this.opts.maxDays.current && u > this.opts.maxDays.current || this.opts.excludeDisabled.current && this.#_(n, s));
  }
  shiftFocus(e, r) {
    return ow({
      node: e,
      add: r,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #y() {
    this.announcer.announce("Selected date is now empty.", "polite");
  }
  #v(e) {
    this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(e, !1)}`, "polite");
  }
  #S(e, r) {
    this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(e, !1)} to ${this.formatter.selectedDate(r, !1)}`, "polite");
  }
  handleCellClick(e, r) {
    if (this.isDateDisabled(r) || this.isDateUnavailable(r)) return;
    const n = this.lastPressedDateValue;
    if (this.lastPressedDateValue = r, this.opts.startValue.current && this.highlightedRange === null)
      if (_t(this.opts.startValue.current, r) && !this.opts.preventDeselect.current && !this.opts.endValue.current) {
        this.#f(void 0), this.opts.placeholder.current = r, this.#y();
        return;
      } else this.opts.endValue.current || (e.preventDefault(), n && _t(n, r) && (this.#f(r), this.#v(r)));
    if (this.opts.startValue.current && this.opts.endValue.current && _t(this.opts.endValue.current, r) && !this.opts.preventDeselect.current) {
      this.#f(void 0), this.#h(void 0), this.opts.placeholder.current = r, this.#y();
      return;
    }
    if (!this.opts.startValue.current)
      this.#v(r), this.#f(r);
    else if (this.opts.endValue.current)
      this.opts.endValue.current && this.opts.startValue.current && (this.#h(void 0), this.#v(r), this.#f(r));
    else {
      const s = this.opts.startValue.current, o = r, i = Bt(o, s) ? o : s, a = Bt(o, s) ? s : o;
      this.#b(i, a) ? Bt(o, s) ? (this.#f(o), this.#h(s), this.#S(o, s)) : (this.#h(r), this.#S(this.opts.startValue.current, r)) : (this.#f(r), this.#h(void 0), this.#v(r));
    }
  }
  onkeydown(e) {
    return iw({
      event: e,
      handleCellClick: this.handleCellClick,
      placeholderValue: this.opts.placeholder.current,
      shiftFocus: this.shiftFocus
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    aw({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    lw({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year: e });
  }
  setMonth(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month: e });
  }
  getBitsAttr = (e) => vw.getAttr(e, "range-calendar");
  #w = /* @__PURE__ */ O(() => ({ months: this.months, weekdays: this.weekdays }));
  get snippetProps() {
    return d(this.#w);
  }
  set snippetProps(e) {
    q(this.#w, e);
  }
  #x = /* @__PURE__ */ O(() => ({
    ...pw({
      fullCalendarLabel: this.fullCalendarLabel,
      id: this.opts.id.current,
      isInvalid: this.isInvalid,
      disabled: this.opts.disabled.current,
      readonly: this.opts.readonly.current
    }),
    [this.getBitsAttr("root")]: "",
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#x);
  }
  set props(e) {
    q(this.#x, e);
  }
  #_(e, r) {
    for (let n = e; Bt(n, r) || _t(n, r); n = n.add({ days: 1 }))
      if (this.isDateDisabled(n)) return !0;
    return !1;
  }
}
class zh {
  static create(e) {
    return p1.set(new zh(e, Ut.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => _r(this.opts.date.current));
  get cellDate() {
    return d(this.#e);
  }
  set cellDate(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => !Lo(this.opts.date.current, this.opts.month.current));
  get isOutsideMonth() {
    return d(this.#t);
  }
  set isOutsideMonth(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current);
  get isDisabled() {
    return d(this.#r);
  }
  set isDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.root.opts.isDateUnavailable.current(this.opts.date.current));
  get isUnavailable() {
    return d(this.#n);
  }
  set isUnavailable(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => I0(this.opts.date.current, ft()));
  get isDateToday() {
    return d(this.#s);
  }
  set isDateToday(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => this.root.isOutsideVisibleMonths(this.opts.date.current));
  get isOutsideVisibleMonths() {
    return d(this.#o);
  }
  set isOutsideVisibleMonths(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => _t(this.opts.date.current, this.root.opts.placeholder.current));
  get isFocusedDate() {
    return d(this.#i);
  }
  set isFocusedDate(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => this.root.isSelected(this.opts.date.current));
  get isSelectedDate() {
    return d(this.#a);
  }
  set isSelectedDate(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => this.root.isSelectionStart(this.opts.date.current));
  get isSelectionStart() {
    return d(this.#u);
  }
  set isSelectionStart(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => this.root.isSelectionStart(this.opts.date.current));
  get isRangeStart() {
    return d(this.#l);
  }
  set isRangeStart(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => this.root.opts.endValue.current ? this.root.isSelectionEnd(this.opts.date.current) : this.root.isSelectionStart(this.opts.date.current));
  get isRangeEnd() {
    return d(this.#c);
  }
  set isRangeEnd(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => this.isSelectionMiddle);
  get isRangeMiddle() {
    return d(this.#d);
  }
  set isRangeMiddle(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => this.isSelectedDate && !this.isSelectionStart && !this.isSelectionEnd);
  get isSelectionMiddle() {
    return d(this.#g);
  }
  set isSelectionMiddle(e) {
    q(this.#g, e);
  }
  #m = /* @__PURE__ */ O(() => this.root.isSelectionEnd(this.opts.date.current));
  get isSelectionEnd() {
    return d(this.#m);
  }
  set isSelectionEnd(e) {
    q(this.#m, e);
  }
  #p = /* @__PURE__ */ O(() => this.root.highlightedRange ? nw(this.opts.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : !1);
  get isHighlighted() {
    return d(this.#p);
  }
  set isHighlighted(e) {
    q(this.#p, e);
  }
  #f = /* @__PURE__ */ O(() => this.root.formatter.custom(this.cellDate, {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  }));
  get labelText() {
    return d(this.#f);
  }
  set labelText(e) {
    q(this.#f, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #h = /* @__PURE__ */ O(() => ({
    disabled: this.isDisabled,
    unavailable: this.isUnavailable,
    selected: this.isSelectedDate
  }));
  get snippetProps() {
    return d(this.#h);
  }
  set snippetProps(e) {
    q(this.#h, e);
  }
  #b = /* @__PURE__ */ O(() => this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable);
  get ariaDisabled() {
    return d(this.#b);
  }
  set ariaDisabled(e) {
    q(this.#b, e);
  }
  #y = /* @__PURE__ */ O(() => ({
    "data-unavailable": Re(this.isUnavailable),
    "data-today": this.isDateToday ? "" : void 0,
    "data-outside-month": this.isOutsideMonth ? "" : void 0,
    "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
    "data-focused": this.isFocusedDate ? "" : void 0,
    "data-selection-start": this.isSelectionStart ? "" : void 0,
    "data-selection-end": this.isSelectionEnd ? "" : void 0,
    "data-range-start": this.isRangeStart ? "" : void 0,
    "data-range-end": this.isRangeEnd ? "" : void 0,
    "data-range-middle": this.isRangeMiddle ? "" : void 0,
    "data-highlighted": this.isHighlighted ? "" : void 0,
    "data-selected": Re(this.isSelectedDate),
    "data-value": this.opts.date.current.toString(),
    "data-type": ew(this.opts.date.current),
    "data-disabled": Re(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
  }));
  get sharedDataAttrs() {
    return d(this.#y);
  }
  set sharedDataAttrs(e) {
    q(this.#y, e);
  }
  #v = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "gridcell",
    "aria-selected": at(this.isSelectedDate),
    "aria-disabled": at(this.ariaDisabled),
    ...this.sharedDataAttrs,
    [this.root.getBitsAttr("cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#v);
  }
  set props(e) {
    q(this.#v, e);
  }
}
class qh {
  static create(e) {
    return new qh(e, p1.get());
  }
  opts;
  cell;
  attachment;
  constructor(e, r) {
    this.opts = e, this.cell = r, this.attachment = Te(e.ref), this.onclick = this.onclick.bind(this), this.onmouseenter = this.onmouseenter.bind(this), this.onfocusin = this.onfocusin.bind(this);
  }
  #e = /* @__PURE__ */ O(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1);
  onclick(e) {
    this.cell.isDisabled || this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  onmouseenter(e) {
    this.cell.isDisabled || (this.cell.root.focusedValue = this.cell.opts.date.current);
  }
  onfocusin(e) {
    this.cell.isDisabled || (this.cell.root.focusedValue = this.cell.opts.date.current);
  }
  #t = /* @__PURE__ */ O(() => ({
    disabled: this.cell.isDisabled,
    unavailable: this.cell.isUnavailable,
    selected: this.cell.isSelectedDate,
    day: `${this.cell.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#t);
  }
  set snippetProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    "aria-label": this.cell.labelText,
    "aria-disabled": at(this.cell.ariaDisabled),
    ...this.cell.sharedDataAttrs,
    tabindex: d(this.#e),
    [this.cell.root.getBitsAttr("day")]: "",
    "data-bits-day": "",
    onclick: this.onclick,
    onmouseenter: this.onmouseenter,
    onfocusin: this.onfocusin,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
var AN = /* @__PURE__ */ ne("<td><!></td>");
function m1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "date", 7), l = v(e, "month", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "date",
    "month"
  ]);
  const c = zh.create({
    id: z(() => o()),
    ref: z(() => i(), (y) => i(y)),
    date: z(() => a()),
    month: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var h = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get id() {
      return o();
    },
    set id(y = me(r)) {
      o(y), m();
    },
    get ref() {
      return i();
    },
    set ref(y = null) {
      i(y), m();
    },
    get date() {
      return a();
    },
    set date(y) {
      a(y), m();
    },
    get month() {
      return l();
    },
    set month(y) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({ props: d(f), ...c.snippetProps }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, g = (y) => {
      var S = AN();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => n() ?? he, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(p) : y(g, !1);
    });
  }
  return A(t, _), H(h);
}
K(
  m1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    date: {},
    month: {}
  },
  [],
  [],
  { mode: "open" }
);
var EN = /* @__PURE__ */ ne("<div><!></div>");
function v1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const l = qh.create({
    id: z(() => o()),
    ref: z(() => i(), (p) => i(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get id() {
      return o();
    },
    set id(p = me(r)) {
      o(p), m();
    },
    get ref() {
      return i();
    },
    set ref(p = null) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      {
        let S = /* @__PURE__ */ O(() => ({ props: d(u), ...l.snippetProps }));
        te(y, s, () => d(S));
      }
      A(p, g);
    }, b = (p) => {
      var g = EN();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, () => n() ?? he, () => l.snippetProps), A(P, w);
        }, x = (P) => {
          var w = tt();
          ke(() => Ie(w, l.cell.opts.date.current.day)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(v1, { children: {}, child: {}, id: {}, ref: {} }, [], [], { mode: "open" });
function y1(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "onOpenChange", 7, _e), s = v(e, "onOpenChangeComplete", 7, _e), o = v(e, "children", 7);
  af.create({
    variant: z(() => "dialog"),
    open: z(() => r(), (u) => {
      r(u), n()(u);
    }),
    onOpenChangeComplete: z(() => s())
  });
  var i = {
    get open() {
      return r();
    },
    set open(u = !1) {
      r(u), m();
    },
    get onOpenChange() {
      return n();
    },
    set onOpenChange(u = _e) {
      n(u), m();
    },
    get onOpenChangeComplete() {
      return s();
    },
    set onOpenChangeComplete(u = _e) {
      s(u), m();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), m();
    }
  }, a = M(), l = D(a);
  return te(l, () => o() ?? he), A(t, a), H(i);
}
K(
  y1,
  {
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var TN = /* @__PURE__ */ ne("<button><!></button>");
function Uh(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "disabled", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "disabled"
  ]);
  const u = uf.create({
    variant: z(() => "close"),
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g)),
    disabled: z(() => !!a())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    },
    get disabled() {
      return a();
    },
    set disabled(g = !1) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = TN();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      s() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(Uh, { children: {}, child: {}, id: {}, ref: {}, disabled: {} }, [], [], { mode: "open" });
var DN = /* @__PURE__ */ ne("<!> <!>", 1), MN = /* @__PURE__ */ ne("<!> <div><!></div>", 1);
function b1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "ref", 15, null), a = v(e, "forceMount", 7, !1), l = v(e, "onCloseAutoFocus", 7, _e), u = v(e, "onOpenAutoFocus", 7, _e), c = v(e, "onEscapeKeydown", 7, _e), f = v(e, "onInteractOutside", 7, _e), h = v(e, "trapFocus", 7, !0), _ = v(e, "preventScroll", 7, !0), b = v(e, "restoreScrollDelay", 7, null), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "ref",
    "forceMount",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "restoreScrollDelay"
  ]);
  const g = ff.create({
    id: z(() => n()),
    ref: z(() => i(), (C) => i(C))
  }), y = /* @__PURE__ */ O(() => Ce(p, g.props));
  var S = {
    get id() {
      return n();
    },
    set id(C = me(r)) {
      n(C), m();
    },
    get children() {
      return s();
    },
    set children(C) {
      s(C), m();
    },
    get child() {
      return o();
    },
    set child(C) {
      o(C), m();
    },
    get ref() {
      return i();
    },
    set ref(C = null) {
      i(C), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(C = !1) {
      a(C), m();
    },
    get onCloseAutoFocus() {
      return l();
    },
    set onCloseAutoFocus(C = _e) {
      l(C), m();
    },
    get onOpenAutoFocus() {
      return u();
    },
    set onOpenAutoFocus(C = _e) {
      u(C), m();
    },
    get onEscapeKeydown() {
      return c();
    },
    set onEscapeKeydown(C = _e) {
      c(C), m();
    },
    get onInteractOutside() {
      return f();
    },
    set onInteractOutside(C = _e) {
      f(C), m();
    },
    get trapFocus() {
      return h();
    },
    set trapFocus(C = !0) {
      h(C), m();
    },
    get preventScroll() {
      return _();
    },
    set preventScroll(C = !0) {
      _(C), m();
    },
    get restoreScrollDelay() {
      return b();
    },
    set restoreScrollDelay(C = null) {
      b(C), m();
    }
  }, x = M(), P = D(x);
  {
    var w = (C) => {
      wf(C, {
        get ref() {
          return g.opts.ref;
        },
        loop: !0,
        get trapFocus() {
          return h();
        },
        get enabled() {
          return g.root.opts.open.current;
        },
        get onOpenAutoFocus() {
          return u();
        },
        get onCloseAutoFocus() {
          return l();
        },
        focusScope: ($, T) => {
          let E = () => T?.().props;
          yf($, ce(() => d(y), {
            get enabled() {
              return g.root.opts.open.current;
            },
            get ref() {
              return g.opts.ref;
            },
            onEscapeKeydown: (I) => {
              c()(I), !I.defaultPrevented && g.root.handleClose();
            },
            children: (I, F) => {
              mf(I, ce(() => d(y), {
                get ref() {
                  return g.opts.ref;
                },
                get enabled() {
                  return g.root.opts.open.current;
                },
                onInteractOutside: (U) => {
                  f()(U), !U.defaultPrevented && g.root.handleClose();
                },
                children: (U, B) => {
                  xf(U, ce(() => d(y), {
                    get ref() {
                      return g.opts.ref;
                    },
                    get enabled() {
                      return g.root.opts.open.current;
                    },
                    children: (R, Z) => {
                      var Y = M(), X = D(Y);
                      {
                        var ae = (j) => {
                          var ee = DN(), L = D(ee);
                          {
                            var N = (G) => {
                              Si(G, {
                                get preventScroll() {
                                  return _();
                                },
                                get restoreScrollDelay() {
                                  return b();
                                }
                              });
                            };
                            ue(L, (G) => {
                              g.root.opts.open.current && G(N);
                            });
                          }
                          var V = be(L, 2);
                          {
                            let G = /* @__PURE__ */ O(() => ({
                              props: Ce(d(y), E()),
                              ...g.snippetProps
                            }));
                            te(V, o, () => d(G));
                          }
                          A(j, ee);
                        }, J = (j) => {
                          var ee = MN(), L = D(ee);
                          Si(L, {
                            get preventScroll() {
                              return _();
                            }
                          });
                          var N = be(L, 2);
                          ve(N, (G) => ({ ...G }), [() => Ce(d(y), E())]);
                          var V = ge(N);
                          te(V, () => s() ?? he), de(N), A(j, ee);
                        };
                        ue(X, (j) => {
                          o() ? j(ae) : j(J, !1);
                        });
                      }
                      A(R, Y);
                    },
                    $$slots: { default: !0 }
                  }));
                },
                $$slots: { default: !0 }
              }));
            },
            $$slots: { default: !0 }
          }));
        },
        $$slots: { focusScope: !0 }
      });
    };
    ue(P, (C) => {
      (g.shouldRender || a()) && C(w);
    });
  }
  return A(t, x), H(S);
}
K(
  b1,
  {
    id: {},
    children: {},
    child: {},
    ref: {},
    forceMount: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onEscapeKeydown: {},
    onInteractOutside: {},
    trapFocus: {},
    preventScroll: {},
    restoreScrollDelay: {}
  },
  [],
  [],
  { mode: "open" }
);
const IN = nr({ component: "label", parts: ["root"] });
class Kh {
  static create(e) {
    return new Kh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.onmousedown = this.onmousedown.bind(this);
  }
  onmousedown(e) {
    e.detail > 1 && e.preventDefault();
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [IN.root]: "",
    onmousedown: this.onmousedown,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var NN = /* @__PURE__ */ ne("<label><!></label>");
function _1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "for", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "for"
  ]);
  const u = Kh.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { for: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    },
    get for() {
      return a();
    },
    set for(g) {
      a(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(g, y);
    }, p = (g) => {
      var y = NN();
      ve(y, () => ({ ...d(c), for: a() }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(g, y);
    };
    ue(_, (g) => {
      s() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(_1, { children: {}, child: {}, id: {}, ref: {}, for: {} }, [], [], { mode: "open" });
function w1(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "onOpenChange", 7, _e), s = v(e, "onOpenChangeComplete", 7, _e), o = v(e, "children", 7);
  Rh.create({
    open: z(() => r(), (a) => {
      r(a), n()(a);
    }),
    onOpenChangeComplete: z(() => s())
  });
  var i = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    },
    get onOpenChange() {
      return n();
    },
    set onOpenChange(a = _e) {
      n(a), m();
    },
    get onOpenChangeComplete() {
      return s();
    },
    set onOpenChangeComplete(a = _e) {
      s(a), m();
    },
    get children() {
      return o();
    },
    set children(a) {
      o(a), m();
    }
  };
  return fh(t, {
    children: (a, l) => {
      var u = M(), c = D(u);
      te(c, () => o() ?? he), A(a, u);
    },
    $$slots: { default: !0 }
  }), H(i);
}
K(
  w1,
  {
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
const Zc = nr({ component: "radio-group", parts: ["root", "item"] }), Wh = new ht("RadioGroup.Root");
class Hh {
  static create(e) {
    return Wh.set(new Hh(e));
  }
  opts;
  #e = /* @__PURE__ */ O(() => this.opts.value.current !== "");
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  rovingFocusGroup;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.rovingFocusGroup = new f0({
      rootNode: this.opts.ref,
      candidateAttr: Zc.item,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  isChecked(e) {
    return this.opts.value.current === e;
  }
  setValue(e) {
    this.opts.value.current = e;
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "radiogroup",
    "aria-required": at(this.opts.required.current),
    "aria-disabled": at(this.opts.disabled.current),
    "aria-readonly": this.opts.readonly.current ? "true" : void 0,
    "data-disabled": Re(this.opts.disabled.current),
    "data-readonly": Re(this.opts.readonly.current),
    "data-orientation": this.opts.orientation.current,
    [Zc.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Gh {
  static create(e) {
    return new Gh(e, Wh.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root.opts.value.current === this.opts.value.current);
  get checked() {
    return d(this.#e);
  }
  set checked(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.opts.disabled.current || this.root.opts.disabled.current);
  #r = /* @__PURE__ */ O(() => this.root.opts.readonly.current);
  #n = /* @__PURE__ */ O(() => this.root.isChecked(this.opts.value.current));
  #s = /* @__PURE__ */ xe(-1);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.opts.value.current === this.root.opts.value.current ? (this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current), q(this.#s, 0)) : this.root.opts.value.current || q(this.#s, 0), Xe(() => {
      q(this.#s, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), !0);
    }), Fe(
      [
        () => this.opts.value.current,
        () => this.root.opts.value.current
      ],
      () => {
        this.opts.value.current === this.root.opts.value.current && (this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current), q(this.#s, 0));
      }
    ), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.onfocus = this.onfocus.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || d(this.#r) || this.root.setValue(this.opts.value.current);
  }
  onfocus(e) {
    !this.root.hasValue || d(this.#r) || this.root.setValue(this.opts.value.current);
  }
  onkeydown(e) {
    if (!d(this.#t)) {
      if (e.key === xr) {
        e.preventDefault(), d(this.#r) || this.root.setValue(this.opts.value.current);
        return;
      }
      this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e, !0);
    }
  }
  #o = /* @__PURE__ */ O(() => ({ checked: d(this.#n) }));
  get snippetProps() {
    return d(this.#o);
  }
  set snippetProps(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    disabled: d(this.#t) ? !0 : void 0,
    "data-value": this.opts.value.current,
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Re(d(this.#t)),
    "data-readonly": Re(d(this.#r)),
    "data-state": d(this.#n) ? "checked" : "unchecked",
    "aria-checked": au(d(this.#n), !1),
    [Zc.item]: "",
    type: "button",
    role: "radio",
    tabindex: d(this.#s),
    onkeydown: this.onkeydown,
    onfocus: this.onfocus,
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#i);
  }
  set props(e) {
    q(this.#i, e);
  }
}
class Yh {
  static create() {
    return new Yh(Wh.get());
  }
  root;
  #e = /* @__PURE__ */ O(() => this.root.opts.name.current !== void 0);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e) {
    this.root = e, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    this.root.rovingFocusGroup.focusCurrentTabStop();
  }
  #t = /* @__PURE__ */ O(() => ({
    name: this.root.opts.name.current,
    value: this.root.opts.value.current,
    required: this.root.opts.required.current,
    disabled: this.root.opts.disabled.current,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function S1(t, e) {
  W(e, !1);
  const r = Yh.create();
  bd();
  var n = M(), s = D(n);
  {
    var o = (i) => {
      zi(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), H();
}
K(S1, {}, [], [], { mode: "open" });
var FN = /* @__PURE__ */ ne("<div><!></div>"), RN = /* @__PURE__ */ ne("<!> <!>", 1);
function x1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "disabled", 7, !1), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "value", 15, ""), a = v(e, "ref", 15, null), l = v(e, "orientation", 7, "vertical"), u = v(e, "loop", 7, !0), c = v(e, "name", 7, void 0), f = v(e, "required", 7, !1), h = v(e, "readonly", 7, !1), _ = v(e, "id", 23, () => me(r)), b = v(e, "onValueChange", 7, _e), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "disabled",
    "children",
    "child",
    "value",
    "ref",
    "orientation",
    "loop",
    "name",
    "required",
    "readonly",
    "id",
    "onValueChange"
  ]);
  const g = Hh.create({
    orientation: z(() => l()),
    disabled: z(() => n()),
    loop: z(() => u()),
    name: z(() => c()),
    required: z(() => f()),
    readonly: z(() => h()),
    id: z(() => _()),
    value: z(() => i(), ($) => {
      $ !== i() && (i($), b()?.($));
    }),
    ref: z(() => a(), ($) => a($))
  }), y = /* @__PURE__ */ O(() => Ce(p, g.props));
  var S = {
    get disabled() {
      return n();
    },
    set disabled($ = !1) {
      n($), m();
    },
    get children() {
      return s();
    },
    set children($) {
      s($), m();
    },
    get child() {
      return o();
    },
    set child($) {
      o($), m();
    },
    get value() {
      return i();
    },
    set value($ = "") {
      i($), m();
    },
    get ref() {
      return a();
    },
    set ref($ = null) {
      a($), m();
    },
    get orientation() {
      return l();
    },
    set orientation($ = "vertical") {
      l($), m();
    },
    get loop() {
      return u();
    },
    set loop($ = !0) {
      u($), m();
    },
    get name() {
      return c();
    },
    set name($ = void 0) {
      c($), m();
    },
    get required() {
      return f();
    },
    set required($ = !1) {
      f($), m();
    },
    get readonly() {
      return h();
    },
    set readonly($ = !1) {
      h($), m();
    },
    get id() {
      return _();
    },
    set id($ = me(r)) {
      _($), m();
    },
    get onValueChange() {
      return b();
    },
    set onValueChange($ = _e) {
      b($), m();
    }
  }, x = RN(), P = D(x);
  {
    var w = ($) => {
      var T = M(), E = D(T);
      te(E, o, () => ({ props: d(y) })), A($, T);
    }, C = ($) => {
      var T = FN();
      ve(T, () => ({ ...d(y) }));
      var E = ge(T);
      te(E, () => s() ?? he), de(T), A($, T);
    };
    ue(P, ($) => {
      o() ? $(w) : $(C, !1);
    });
  }
  var k = be(P, 2);
  return S1(k, {}), A(t, x), H(S);
}
K(
  x1,
  {
    disabled: {},
    children: {},
    child: {},
    value: {},
    ref: {},
    orientation: {},
    loop: {},
    name: {},
    required: {},
    readonly: {},
    id: {},
    onValueChange: {}
  },
  [],
  [],
  { mode: "open" }
);
var VN = /* @__PURE__ */ ne("<button><!></button>");
function P1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "value", 7), a = v(e, "disabled", 7, !1), l = v(e, "ref", 15, null), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "value",
    "disabled",
    "ref"
  ]);
  const c = Gh.create({
    value: z(() => i()),
    disabled: z(() => a() ?? !1),
    id: z(() => n()),
    ref: z(() => l(), (y) => l(y))
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var h = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get children() {
      return s();
    },
    set children(y) {
      s(y), m();
    },
    get child() {
      return o();
    },
    set child(y) {
      o(y), m();
    },
    get value() {
      return i();
    },
    set value(y) {
      i(y), m();
    },
    get disabled() {
      return a();
    },
    set disabled(y = !1) {
      a(y), m();
    },
    get ref() {
      return l();
    },
    set ref(y = null) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({ props: d(f), ...c.snippetProps }));
        te(x, o, () => d(P));
      }
      A(y, S);
    }, g = (y) => {
      var S = VN();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => s() ?? he, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      o() ? y(p) : y(g, !1);
    });
  }
  return A(t, _), H(h);
}
K(
  P1,
  {
    id: {},
    children: {},
    child: {},
    value: {},
    disabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
var LN = /* @__PURE__ */ ne("<div><!></div>");
function O1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "value", 15), l = v(e, "onValueChange", 7, _e), u = v(e, "placeholder", 15), c = v(e, "onPlaceholderChange", 7, _e), f = v(e, "weekdayFormat", 7, "narrow"), h = v(e, "weekStartsOn", 7), _ = v(e, "pagedNavigation", 7, !1), b = v(e, "isDateDisabled", 7, () => !1), p = v(e, "isDateUnavailable", 7, () => !1), g = v(e, "fixedWeeks", 7, !1), y = v(e, "numberOfMonths", 7, 1), S = v(e, "locale", 7), x = v(e, "calendarLabel", 7, "Event"), P = v(e, "disabled", 7, !1), w = v(e, "readonly", 7, !1), C = v(e, "minValue", 7, void 0), k = v(e, "maxValue", 7, void 0), $ = v(e, "preventDeselect", 7, !1), T = v(e, "disableDaysOutsideMonth", 7, !0), E = v(e, "minDays", 7), I = v(e, "maxDays", 7), F = v(e, "onStartValueChange", 7, _e), U = v(e, "onEndValueChange", 7, _e), B = v(e, "excludeDisabled", 7, !1), R = v(e, "monthFormat", 7, "long"), Z = v(e, "yearFormat", 7, "numeric"), Y = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "disableDaysOutsideMonth",
    "minDays",
    "maxDays",
    "onStartValueChange",
    "onEndValueChange",
    "excludeDisabled",
    "monthFormat",
    "yearFormat"
  ]), X = /* @__PURE__ */ xe(Pt(a()?.start)), ae = /* @__PURE__ */ xe(Pt(a()?.end));
  const J = Z0({
    defaultValue: a()?.start,
    minValue: C(),
    maxValue: k()
  });
  function j() {
    u() === void 0 && u(J);
  }
  j(), Fe.pre(() => u(), () => {
    j();
  });
  function ee() {
    a() === void 0 && a({ start: void 0, end: void 0 });
  }
  ee(), Fe.pre(() => a(), () => {
    ee();
  });
  const L = Bh.create({
    id: z(() => o()),
    ref: z(() => i(), (le) => i(le)),
    value: z(() => a(), (le) => {
      a(le), l()(le);
    }),
    placeholder: z(() => u(), (le) => {
      u(le), c()(le);
    }),
    disabled: z(() => P()),
    readonly: z(() => w()),
    preventDeselect: z(() => $()),
    minValue: z(() => C()),
    maxValue: z(() => k()),
    isDateUnavailable: z(() => p()),
    isDateDisabled: z(() => b()),
    pagedNavigation: z(() => _()),
    weekStartsOn: z(() => h()),
    weekdayFormat: z(() => f()),
    numberOfMonths: z(() => y()),
    locale: m0(() => S()),
    calendarLabel: z(() => x()),
    fixedWeeks: z(() => g()),
    disableDaysOutsideMonth: z(() => T()),
    minDays: z(() => E()),
    maxDays: z(() => I()),
    excludeDisabled: z(() => B()),
    startValue: z(() => d(X), (le) => {
      q(X, le, !0), F()(le);
    }),
    endValue: z(() => d(ae), (le) => {
      q(ae, le, !0), U()(le);
    }),
    monthFormat: z(() => R()),
    yearFormat: z(() => Z()),
    defaultPlaceholder: J
  }), N = /* @__PURE__ */ O(() => Ce(Y, L.props));
  var V = {
    get children() {
      return n();
    },
    set children(le) {
      n(le), m();
    },
    get child() {
      return s();
    },
    set child(le) {
      s(le), m();
    },
    get id() {
      return o();
    },
    set id(le = me(r)) {
      o(le), m();
    },
    get ref() {
      return i();
    },
    set ref(le = null) {
      i(le), m();
    },
    get value() {
      return a();
    },
    set value(le) {
      a(le), m();
    },
    get onValueChange() {
      return l();
    },
    set onValueChange(le = _e) {
      l(le), m();
    },
    get placeholder() {
      return u();
    },
    set placeholder(le) {
      u(le), m();
    },
    get onPlaceholderChange() {
      return c();
    },
    set onPlaceholderChange(le = _e) {
      c(le), m();
    },
    get weekdayFormat() {
      return f();
    },
    set weekdayFormat(le = "narrow") {
      f(le), m();
    },
    get weekStartsOn() {
      return h();
    },
    set weekStartsOn(le) {
      h(le), m();
    },
    get pagedNavigation() {
      return _();
    },
    set pagedNavigation(le = !1) {
      _(le), m();
    },
    get isDateDisabled() {
      return b();
    },
    set isDateDisabled(le = () => !1) {
      b(le), m();
    },
    get isDateUnavailable() {
      return p();
    },
    set isDateUnavailable(le = () => !1) {
      p(le), m();
    },
    get fixedWeeks() {
      return g();
    },
    set fixedWeeks(le = !1) {
      g(le), m();
    },
    get numberOfMonths() {
      return y();
    },
    set numberOfMonths(le = 1) {
      y(le), m();
    },
    get locale() {
      return S();
    },
    set locale(le) {
      S(le), m();
    },
    get calendarLabel() {
      return x();
    },
    set calendarLabel(le = "Event") {
      x(le), m();
    },
    get disabled() {
      return P();
    },
    set disabled(le = !1) {
      P(le), m();
    },
    get readonly() {
      return w();
    },
    set readonly(le = !1) {
      w(le), m();
    },
    get minValue() {
      return C();
    },
    set minValue(le = void 0) {
      C(le), m();
    },
    get maxValue() {
      return k();
    },
    set maxValue(le = void 0) {
      k(le), m();
    },
    get preventDeselect() {
      return $();
    },
    set preventDeselect(le = !1) {
      $(le), m();
    },
    get disableDaysOutsideMonth() {
      return T();
    },
    set disableDaysOutsideMonth(le = !0) {
      T(le), m();
    },
    get minDays() {
      return E();
    },
    set minDays(le) {
      E(le), m();
    },
    get maxDays() {
      return I();
    },
    set maxDays(le) {
      I(le), m();
    },
    get onStartValueChange() {
      return F();
    },
    set onStartValueChange(le = _e) {
      F(le), m();
    },
    get onEndValueChange() {
      return U();
    },
    set onEndValueChange(le = _e) {
      U(le), m();
    },
    get excludeDisabled() {
      return B();
    },
    set excludeDisabled(le = !1) {
      B(le), m();
    },
    get monthFormat() {
      return R();
    },
    set monthFormat(le = "long") {
      R(le), m();
    },
    get yearFormat() {
      return Z();
    },
    set yearFormat(le = "numeric") {
      Z(le), m();
    }
  }, G = M(), fe = D(G);
  {
    var se = (le) => {
      var re = M(), oe = D(re);
      {
        let pe = /* @__PURE__ */ O(() => ({ props: d(N), ...L.snippetProps }));
        te(oe, s, () => d(pe));
      }
      A(le, re);
    }, we = (le) => {
      var re = LN();
      ve(re, () => ({ ...d(N) }));
      var oe = ge(re);
      te(oe, () => n() ?? he, () => L.snippetProps), de(re), A(le, re);
    };
    ue(fe, (le) => {
      s() ? le(se) : le(we, !1);
    });
  }
  return A(t, G), H(V);
}
K(
  O1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    placeholder: {},
    onPlaceholderChange: {},
    weekdayFormat: {},
    weekStartsOn: {},
    pagedNavigation: {},
    isDateDisabled: {},
    isDateUnavailable: {},
    fixedWeeks: {},
    numberOfMonths: {},
    locale: {},
    calendarLabel: {},
    disabled: {},
    readonly: {},
    minValue: {},
    maxValue: {},
    preventDeselect: {},
    disableDaysOutsideMonth: {},
    minDays: {},
    maxDays: {},
    onStartValueChange: {},
    onEndValueChange: {},
    excludeDisabled: {},
    monthFormat: {},
    yearFormat: {}
  },
  [],
  [],
  { mode: "open" }
);
var jN = /* @__PURE__ */ ne("<!> <!>", 1);
function C1(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "onValueChange", 7, _e), s = v(e, "name", 7, ""), o = v(e, "disabled", 7, !1), i = v(e, "type", 7), a = v(e, "open", 15, !1), l = v(e, "onOpenChange", 7, _e), u = v(e, "onOpenChangeComplete", 7, _e), c = v(e, "loop", 7, !1), f = v(e, "scrollAlignment", 7, "nearest"), h = v(e, "required", 7, !1), _ = v(e, "items", 23, () => []), b = v(e, "allowDeselect", 7, !1), p = v(e, "autocomplete", 7), g = v(e, "children", 7);
  function y() {
    r() === void 0 && r(i() === "single" ? "" : []);
  }
  y(), Fe.pre(() => r(), () => {
    y();
  });
  let S = /* @__PURE__ */ xe("");
  const x = II.create({
    type: i(),
    value: z(() => r(), (E) => {
      r(E), n()(E);
    }),
    disabled: z(() => o()),
    required: z(() => h()),
    open: z(() => a(), (E) => {
      a(E), l()(E);
    }),
    loop: z(() => c()),
    scrollAlignment: z(() => f()),
    name: z(() => s()),
    isCombobox: !1,
    items: z(() => _()),
    allowDeselect: z(() => b()),
    inputValue: z(() => d(S), (E) => q(S, E, !0)),
    onOpenChangeComplete: z(() => u())
  });
  var P = {
    get value() {
      return r();
    },
    set value(E) {
      r(E), m();
    },
    get onValueChange() {
      return n();
    },
    set onValueChange(E = _e) {
      n(E), m();
    },
    get name() {
      return s();
    },
    set name(E = "") {
      s(E), m();
    },
    get disabled() {
      return o();
    },
    set disabled(E = !1) {
      o(E), m();
    },
    get type() {
      return i();
    },
    set type(E) {
      i(E), m();
    },
    get open() {
      return a();
    },
    set open(E = !1) {
      a(E), m();
    },
    get onOpenChange() {
      return l();
    },
    set onOpenChange(E = _e) {
      l(E), m();
    },
    get onOpenChangeComplete() {
      return u();
    },
    set onOpenChangeComplete(E = _e) {
      u(E), m();
    },
    get loop() {
      return c();
    },
    set loop(E = !1) {
      c(E), m();
    },
    get scrollAlignment() {
      return f();
    },
    set scrollAlignment(E = "nearest") {
      f(E), m();
    },
    get required() {
      return h();
    },
    set required(E = !1) {
      h(E), m();
    },
    get items() {
      return _();
    },
    set items(E = []) {
      _(E), m();
    },
    get allowDeselect() {
      return b();
    },
    set allowDeselect(E = !1) {
      b(E), m();
    },
    get autocomplete() {
      return p();
    },
    set autocomplete(E) {
      p(E), m();
    },
    get children() {
      return g();
    },
    set children(E) {
      g(E), m();
    }
  }, w = jN(), C = D(w);
  fh(C, {
    children: (E, I) => {
      var F = M(), U = D(F);
      te(U, () => g() ?? he), A(E, F);
    },
    $$slots: { default: !0 }
  });
  var k = be(C, 2);
  {
    var $ = (E) => {
      var I = M(), F = D(I);
      {
        var U = (R) => {
          Xa(R, {
            get autocomplete() {
              return p();
            }
          });
        }, B = (R) => {
          var Z = M(), Y = D(Z);
          st(Y, 16, () => x.opts.value.current, (X) => X, (X, ae) => {
            Xa(X, {
              get value() {
                return ae;
              },
              get autocomplete() {
                return p();
              }
            });
          }), A(R, Z);
        };
        ue(F, (R) => {
          x.opts.value.current.length === 0 ? R(U) : R(B, !1);
        });
      }
      A(E, I);
    }, T = (E) => {
      Xa(E, {
        get autocomplete() {
          return p();
        },
        get value() {
          return x.opts.value.current;
        },
        set value(I) {
          x.opts.value.current = I;
        }
      });
    };
    ue(k, (E) => {
      Array.isArray(x.opts.value.current) ? E($) : E(T, !1);
    });
  }
  return A(t, w), H(P);
}
K(
  C1,
  {
    value: {},
    onValueChange: {},
    name: {},
    disabled: {},
    type: {},
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    loop: {},
    scrollAlignment: {},
    required: {},
    items: {},
    allowDeselect: {},
    autocomplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var BN = /* @__PURE__ */ ne("<button><!></button>");
function k1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "type", 7, "button"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "type"
  ]);
  const u = hh.create({
    id: z(() => n()),
    ref: z(() => s(), (b) => s(b))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { type: a() }));
  var f = {
    get id() {
      return n();
    },
    set id(b = me(r)) {
      n(b), m();
    },
    get ref() {
      return s();
    },
    set ref(b = null) {
      s(b), m();
    },
    get child() {
      return o();
    },
    set child(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get type() {
      return a();
    },
    set type(b = "button") {
      a(b), m();
    }
  }, h = M(), _ = D(h);
  return Q(_, () => Sh, (b, p) => {
    p(b, {
      get id() {
        return n();
      },
      get ref() {
        return u.opts.ref;
      },
      children: (g, y) => {
        var S = M(), x = D(S);
        {
          var P = (C) => {
            var k = M(), $ = D(k);
            te($, o, () => ({ props: d(c) })), A(C, k);
          }, w = (C) => {
            var k = BN();
            ve(k, () => ({ ...d(c) }));
            var $ = ge(k);
            te($, () => i() ?? he), de(k), A(C, k);
          };
          ue(x, (C) => {
            o() ? C(P) : C(w, !1);
          });
        }
        A(g, S);
      },
      $$slots: { default: !0 }
    });
  }), A(t, h), H(f);
}
K(k1, { id: {}, ref: {}, child: {}, children: {}, type: {} }, [], [], { mode: "open" });
function Qm(t, e, r) {
  const n = {
    position: "absolute"
  };
  return t === "lr" ? (n.left = `${e}%`, n.right = `${r}%`) : t === "rl" ? (n.right = `${e}%`, n.left = `${r}%`) : t === "bt" ? (n.bottom = `${e}%`, n.top = `${r}%`) : (n.top = `${e}%`, n.bottom = `${r}%`), n;
}
function $1(t, e) {
  const r = {
    position: "absolute"
  };
  return t === "lr" ? (r.left = `${e}%`, r.translate = "-50% 0") : t === "rl" ? (r.right = `${e}%`, r.translate = "50% 0") : t === "bt" ? (r.bottom = `${e}%`, r.translate = "0 50%") : (r.top = `${e}%`, r.translate = "0 -50%"), r;
}
function A1(t, e, r) {
  const n = {
    position: "absolute"
  };
  return t === "lr" ? (n.left = `${e}%`, n.translate = `${r}% 0`) : t === "rl" ? (n.right = `${e}%`, n.translate = `${-r}% 0`) : t === "bt" ? (n.bottom = `${e}%`, n.translate = `0 ${-r}%`) : (n.top = `${e}%`, n.translate = `0 ${r}%`), n;
}
function zN(t) {
  if (Math.floor(t) === t)
    return 0;
  const e = t.toString();
  if (e.indexOf(".") !== -1 && e.indexOf("e-") === -1)
    return e.split(".")[1].length;
  if (e.indexOf("e-") !== -1) {
    const r = e.split("e-");
    return parseInt(r[1], 10);
  }
  return 0;
}
function qN(t, e) {
  const r = Math.pow(10, e);
  return Math.round(t * r) / r;
}
function Xh(t, e, r) {
  if (typeof t == "number") {
    const n = r - e;
    let s = Math.ceil(n / t);
    const o = zN(t), i = Math.pow(10, o), a = Math.round(n * i), l = Math.round(t * i);
    a % l === 0 && s++;
    const u = [];
    for (let c = 0; c < s; c++) {
      const f = e + c * t, h = qN(f, o);
      u.push(h);
    }
    return u;
  }
  return [...new Set(t)].filter((n) => n >= e && n <= r).sort((n, s) => n - s);
}
function Ts(t, e) {
  if (e.length === 0)
    return t;
  let r = e[0], n = Math.abs(t - r);
  for (const s of e) {
    const o = Math.abs(t - s);
    o < n && (n = o, r = s);
  }
  return r;
}
function Ba(t, e, r) {
  const n = e.indexOf(t);
  return n === -1 ? Ts(t, e) : r === "next" ? n < e.length - 1 ? e[n + 1] : t : n > 0 ? e[n - 1] : t;
}
function UN(t, e, r = !0) {
  const [n, s] = t, [o, i] = e, a = (i - o) / (s - n);
  return (l) => {
    const u = o + a * (l - n);
    return r ? u > Math.max(o, i) ? Math.max(o, i) : u < Math.min(o, i) ? Math.min(o, i) : u : u;
  };
}
const Xn = nr({
  component: "slider",
  parts: [
    "root",
    "thumb",
    "range",
    "tick",
    "tick-label",
    "thumb-label"
  ]
}), Jh = new ht("Slider.Root");
class E1 {
  opts;
  attachment;
  #e = /* @__PURE__ */ xe(!1);
  get isActive() {
    return d(this.#e);
  }
  set isActive(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ O(() => this.opts.orientation.current === "horizontal" ? this.opts.dir.current === "rtl" ? "rl" : "lr" : this.opts.dir.current === "rtl" ? "tb" : "bt");
  get direction() {
    return d(this.#t);
  }
  set direction(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => Xh(this.opts.step.current, this.opts.min.current, this.opts.max.current));
  get normalizedSteps() {
    return d(this.#r);
  }
  set normalizedSteps(e) {
    q(this.#r, e);
  }
  domContext;
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref), this.domContext = new Fn(this.opts.ref);
  }
  isThumbActive(e) {
    return this.isActive;
  }
  #n = /* @__PURE__ */ O(() => {
    if (!this.opts.disabled.current)
      return this.opts.orientation.current === "horizontal" ? "pan-y" : "pan-x";
  });
  getAllThumbs = () => {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Xn.selector("thumb"))) : [];
  };
  getThumbScale = () => {
    const e = this.opts.trackPadding?.current;
    if (e !== void 0 && e > 0)
      return [e, 100 - e];
    if (this.opts.thumbPositioning.current === "exact")
      return [0, 100];
    const r = this.opts.orientation.current === "vertical", n = this.getAllThumbs()[0], s = r ? n?.offsetHeight : n?.offsetWidth;
    if (s === void 0 || Number.isNaN(s) || s === 0) return [0, 100];
    const o = r ? this.opts.ref.current?.offsetHeight : this.opts.ref.current?.offsetWidth;
    if (o === void 0 || Number.isNaN(o) || o === 0) return [0, 100];
    const i = s / 2 / o * 100, a = i, l = 100 - i;
    return [a, l];
  };
  getPositionFromValue = (e) => {
    const r = this.getThumbScale();
    return UN([this.opts.min.current, this.opts.max.current], r)(e);
  };
  #s = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-orientation": this.opts.orientation.current,
    "data-disabled": Re(this.opts.disabled.current),
    style: { touchAction: d(this.#n) },
    [Xn.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class KN extends E1 {
  opts;
  isMulti = !1;
  constructor(e) {
    super(e), this.opts = e, tf(() => Es(Ye(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), Ye(this.domContext.getDocument(), "pointerup", this.handlePointerUp), Ye(this.domContext.getDocument(), "pointermove", this.handlePointerMove), Ye(this.domContext.getDocument(), "pointerleave", this.handlePointerUp))), Fe(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([r, n, s, o]) => {
        const i = Xh(r, n, s), a = (u) => i.includes(u), l = (u) => Ts(u, i);
        a(o) || (this.opts.value.current = l(o));
      }
    );
  }
  isTickValueSelected = (e) => this.opts.value.current === e;
  applyPosition({ clientXY: e, start: r, end: n }) {
    const s = this.opts.min.current, o = this.opts.max.current, a = (e - r) / (n - r) * (o - s) + s;
    if (a < s)
      this.updateValue(s);
    else if (a > o)
      this.updateValue(o);
    else {
      const l = this.normalizedSteps, u = Ts(a, l);
      this.updateValue(u);
    }
  }
  updateValue = (e) => {
    this.opts.value.current = Ts(e, this.normalizedSteps);
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault(), e.stopPropagation();
    const r = this.opts.ref.current, n = this.getAllThumbs()[0];
    if (!r || !n) return;
    n.focus();
    const { left: s, right: o, top: i, bottom: a } = r.getBoundingClientRect();
    this.direction === "lr" ? this.applyPosition({ clientXY: e.clientX, start: s, end: o }) : this.direction === "rl" ? this.applyPosition({ clientXY: e.clientX, start: o, end: s }) : this.direction === "bt" ? this.applyPosition({ clientXY: e.clientY, start: a, end: i }) : this.direction === "tb" && this.applyPosition({ clientXY: e.clientY, start: i, end: a });
  };
  handlePointerDown = (e) => {
    if (e.button !== 0 || this.opts.disabled.current) return;
    const r = this.opts.ref.current, n = this.getAllThumbs()[0];
    if (!n || !r) return;
    const s = e.composedPath()[0] ?? e.target;
    !of(s) || !r.contains(s) || (e.preventDefault(), n.focus(), this.isActive = !0, this.handlePointerMove(e));
  };
  handlePointerUp = () => {
    this.opts.disabled.current || (this.isActive && this.opts.onValueCommit.current(ot(() => this.opts.value.current)), this.isActive = !1);
  };
  #e = /* @__PURE__ */ O(() => {
    const e = this.opts.value.current;
    return Array.from({ length: 1 }, () => {
      const r = e, n = this.getPositionFromValue(r), s = $1(this.direction, n);
      return {
        role: "slider",
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": r,
        "aria-disabled": at(this.opts.disabled.current),
        "aria-orientation": this.opts.orientation.current,
        "data-value": r,
        "data-orientation": this.opts.orientation.current,
        style: s,
        [Xn.thumb]: ""
      };
    });
  });
  get thumbsPropsArr() {
    return d(this.#e);
  }
  set thumbsPropsArr(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.thumbsPropsArr.map((e, r) => r));
  get thumbsRenderArr() {
    return d(this.#t);
  }
  set thumbsRenderArr(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => {
    const e = this.normalizedSteps, r = this.opts.value.current;
    return e.map((n, s) => {
      const o = this.getPositionFromValue(n), i = s === 0, a = s === e.length - 1, l = i ? 0 : a ? -100 : -50, u = A1(this.direction, o, l), c = n <= r;
      return {
        "data-disabled": Re(this.opts.disabled.current),
        "data-orientation": this.opts.orientation.current,
        "data-bounded": c ? "" : void 0,
        "data-value": n,
        "data-selected": this.isTickValueSelected(n) ? "" : void 0,
        style: u,
        [Xn.tick]: ""
      };
    });
  });
  get ticksPropsArr() {
    return d(this.#r);
  }
  set ticksPropsArr(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => r));
  get ticksRenderArr() {
    return d(this.#n);
  }
  set ticksRenderArr(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => ({ value: e["data-value"], index: r })));
  get tickItemsArr() {
    return d(this.#s);
  }
  set tickItemsArr(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => [{ value: this.opts.value.current, index: 0 }]);
  get thumbItemsArr() {
    return d(this.#o);
  }
  set thumbItemsArr(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => ({
    ticks: this.ticksRenderArr,
    thumbs: this.thumbsRenderArr,
    tickItems: this.tickItemsArr,
    thumbItems: this.thumbItemsArr
  }));
  get snippetProps() {
    return d(this.#i);
  }
  set snippetProps(e) {
    q(this.#i, e);
  }
}
class WN extends E1 {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ xe(null);
  get activeThumb() {
    return d(this.#e);
  }
  set activeThumb(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(0);
  get currentThumbIdx() {
    return d(this.#t);
  }
  set currentThumbIdx(e) {
    q(this.#t, e, !0);
  }
  constructor(e) {
    super(e), this.opts = e, tf(() => Es(Ye(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), Ye(this.domContext.getDocument(), "pointerup", this.handlePointerUp), Ye(this.domContext.getDocument(), "pointermove", this.handlePointerMove), Ye(this.domContext.getDocument(), "pointerleave", this.handlePointerUp))), Fe(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([r, n, s, o]) => {
        const i = Xh(r, n, s), a = (u) => i.includes(u), l = (u) => Ts(u, i);
        o.some((u) => !a(u)) && (this.opts.value.current = o.map(l));
      }
    );
  }
  isTickValueSelected = (e) => this.opts.value.current.includes(e);
  isThumbActive(e) {
    return this.isActive && this.activeThumb?.idx === e;
  }
  applyPosition({ clientXY: e, activeThumbIdx: r, start: n, end: s }) {
    const o = this.opts.min.current, i = this.opts.max.current, l = (e - n) / (s - n) * (i - o) + o;
    if (l < o)
      this.updateValue(o, r);
    else if (l > i)
      this.updateValue(i, r);
    else {
      const u = this.normalizedSteps, c = Ts(l, u);
      this.updateValue(c, r);
    }
  }
  #r = (e) => {
    const r = this.getAllThumbs();
    if (!r.length) return;
    for (const i of r)
      i.blur();
    const n = r.map((i) => {
      if (this.opts.orientation.current === "horizontal") {
        const { left: a, right: l } = i.getBoundingClientRect();
        return Math.abs(e.clientX - (a + l) / 2);
      } else {
        const { top: a, bottom: l } = i.getBoundingClientRect();
        return Math.abs(e.clientY - (a + l) / 2);
      }
    }), s = r[n.indexOf(Math.min(...n))], o = r.indexOf(s);
    return { node: s, idx: o };
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault(), e.stopPropagation();
    const r = this.opts.ref.current, n = this.activeThumb;
    if (!r || !n) return;
    n.node.focus();
    const { left: s, right: o, top: i, bottom: a } = r.getBoundingClientRect(), l = this.direction;
    l === "lr" ? this.applyPosition({
      clientXY: e.clientX,
      activeThumbIdx: n.idx,
      start: s,
      end: o
    }) : l === "rl" ? this.applyPosition({
      clientXY: e.clientX,
      activeThumbIdx: n.idx,
      start: o,
      end: s
    }) : l === "bt" ? this.applyPosition({
      clientXY: e.clientY,
      activeThumbIdx: n.idx,
      start: a,
      end: i
    }) : l === "tb" && this.applyPosition({
      clientXY: e.clientY,
      activeThumbIdx: n.idx,
      start: i,
      end: a
    });
  };
  handlePointerDown = (e) => {
    if (e.button !== 0 || this.opts.disabled.current) return;
    const r = this.opts.ref.current, n = this.#r(e);
    if (!n || !r) return;
    const s = e.composedPath()[0] ?? e.target;
    !of(s) || !r.contains(s) || (e.preventDefault(), this.activeThumb = n, n.node.focus(), this.isActive = !0, this.handlePointerMove(e));
  };
  handlePointerUp = () => {
    this.opts.disabled.current || (this.isActive && this.opts.onValueCommit.current(ot(() => this.opts.value.current)), this.isActive = !1);
  };
  getAllThumbs = () => {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Xn.selector("thumb"))) : [];
  };
  updateValue = (e, r) => {
    const n = this.opts.value.current;
    if (!n.length) {
      this.opts.value.current.push(e);
      return;
    }
    if (n[r] === e) return;
    const o = [...n];
    if (!Ha(r, o)) return;
    const i = o[r] > e ? -1 : 1, a = () => {
      const u = r + i;
      o[r] = o[u], o[u] = e;
      const c = this.getAllThumbs();
      c.length && (c[u]?.focus(), this.activeThumb = { node: c[u], idx: u });
    };
    if (this.opts.autoSort.current && (i === -1 && e < o[r - 1] || i === 1 && e > o[r + 1])) {
      a(), this.opts.value.current = o;
      return;
    }
    const l = this.normalizedSteps;
    o[r] = Ts(e, l), this.opts.value.current = o;
  };
  #n = /* @__PURE__ */ O(() => {
    const e = this.opts.value.current;
    return Array.from({ length: e.length || 1 }, (r, n) => {
      const s = ot(() => this.currentThumbIdx);
      s < e.length && ot(() => {
        this.currentThumbIdx = s + 1;
      });
      const o = e[n], i = this.getPositionFromValue(o ?? 0), a = $1(this.direction, i);
      return {
        role: "slider",
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": o,
        "aria-disabled": at(this.opts.disabled.current),
        "aria-orientation": this.opts.orientation.current,
        "data-value": o,
        "data-orientation": this.opts.orientation.current,
        style: a,
        [Xn.thumb]: ""
      };
    });
  });
  get thumbsPropsArr() {
    return d(this.#n);
  }
  set thumbsPropsArr(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.thumbsPropsArr.map((e, r) => r));
  get thumbsRenderArr() {
    return d(this.#s);
  }
  set thumbsRenderArr(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => {
    const e = this.normalizedSteps, r = this.opts.value.current;
    return e.map((n, s) => {
      const o = this.getPositionFromValue(n), i = s === 0, a = s === e.length - 1, l = i ? 0 : a ? -100 : -50, u = A1(this.direction, o, l), c = r.length === 1 ? n <= r[0] : r[0] <= n && n <= r[r.length - 1];
      return {
        "data-disabled": Re(this.opts.disabled.current),
        "data-orientation": this.opts.orientation.current,
        "data-bounded": c ? "" : void 0,
        "data-value": n,
        style: u,
        [Xn.tick]: ""
      };
    });
  });
  get ticksPropsArr() {
    return d(this.#o);
  }
  set ticksPropsArr(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => r));
  get ticksRenderArr() {
    return d(this.#i);
  }
  set ticksRenderArr(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => ({ value: e["data-value"], index: r })));
  get tickItemsArr() {
    return d(this.#a);
  }
  set tickItemsArr(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => this.opts.value.current.map((r, n) => ({ value: r, index: n })));
  get thumbItemsArr() {
    return d(this.#u);
  }
  set thumbItemsArr(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => ({
    ticks: this.ticksRenderArr,
    thumbs: this.thumbsRenderArr,
    tickItems: this.tickItemsArr,
    thumbItems: this.thumbItemsArr
  }));
  get snippetProps() {
    return d(this.#l);
  }
  set snippetProps(e) {
    q(this.#l, e);
  }
}
class HN {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new KN(n) : new WN(n);
    return Jh.set(s);
  }
}
const GN = [
  ds,
  fs,
  Qt,
  dr,
  Vo,
  Ro
];
class Zh {
  static create(e) {
    return new Zh(e, Jh.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #e = /* @__PURE__ */ O(() => {
    if (Array.isArray(this.root.opts.value.current)) {
      const e = this.root.opts.value.current.length > 1 ? this.root.getPositionFromValue(Math.min(...this.root.opts.value.current) ?? 0) : 0, r = 100 - this.root.getPositionFromValue(Math.max(...this.root.opts.value.current) ?? 0);
      return {
        position: "absolute",
        ...Qm(this.root.direction, e, r)
      };
    } else {
      const e = this.root.opts.trackPadding?.current, r = this.root.opts.value.current, n = this.root.opts.max.current, s = 0, o = e !== void 0 && e > 0 && r === n ? 0 : (
        // 100% - 0% = full width
        100 - this.root.getPositionFromValue(r)
      );
      return {
        position: "absolute",
        ...Qm(this.root.direction, s, o)
      };
    }
  });
  get rangeStyles() {
    return d(this.#e);
  }
  set rangeStyles(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    style: this.rangeStyles,
    [Xn.range]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Qh {
  static create(e) {
    return new Qh(e, Jh.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root.opts.disabled.current || this.opts.disabled.current);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref), this.onkeydown = this.onkeydown.bind(this);
  }
  #t(e) {
    this.root.isMulti ? this.root.updateValue(e, this.opts.index.current) : this.root.updateValue(e);
  }
  onkeydown(e) {
    if (d(this.#e)) return;
    const r = this.opts.ref.current;
    if (!r) return;
    const n = this.root.getAllThumbs();
    if (!n.length) return;
    const s = n.indexOf(r);
    if (this.root.isMulti && (this.root.currentThumbIdx = s), !GN.includes(e.key)) return;
    e.preventDefault();
    const o = this.root.opts.min.current, i = this.root.opts.max.current, a = this.root.opts.value.current, l = Array.isArray(a) ? a[s] : a, u = this.root.opts.orientation.current, c = this.root.direction, f = this.root.normalizedSteps;
    switch (e.key) {
      case Vo:
        this.#t(o);
        break;
      case Ro:
        this.#t(i);
        break;
      case ds:
        if (u !== "horizontal") break;
        if (e.metaKey) {
          const h = c === "rl" ? i : o;
          this.#t(h);
        } else {
          const _ = Ba(l, f, c === "rl" ? "next" : "prev");
          this.#t(_);
        }
        break;
      case fs:
        if (u !== "horizontal") break;
        if (e.metaKey) {
          const h = c === "rl" ? o : i;
          this.#t(h);
        } else {
          const _ = Ba(l, f, c === "rl" ? "prev" : "next");
          this.#t(_);
        }
        break;
      case Qt:
        if (e.metaKey) {
          const h = c === "tb" ? o : i;
          this.#t(h);
        } else {
          const _ = Ba(l, f, c === "tb" ? "prev" : "next");
          this.#t(_);
        }
        break;
      case dr:
        if (e.metaKey) {
          const h = c === "tb" ? i : o;
          this.#t(h);
        } else {
          const _ = Ba(l, f, c === "tb" ? "next" : "prev");
          this.#t(_);
        }
        break;
    }
    this.root.opts.onValueCommit.current(this.root.opts.value.current);
  }
  #r = /* @__PURE__ */ O(() => ({
    ...this.root.thumbsPropsArr[this.opts.index.current],
    id: this.opts.id.current,
    onkeydown: this.onkeydown,
    "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
    "data-disabled": Re(this.opts.disabled.current || this.root.opts.disabled.current),
    tabindex: this.opts.disabled.current || this.root.opts.disabled.current ? -1 : 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
var YN = /* @__PURE__ */ ne("<span><!></span>");
function T1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "value", 15), l = v(e, "type", 7), u = v(e, "onValueChange", 7, _e), c = v(e, "onValueCommit", 7, _e), f = v(e, "disabled", 7, !1), h = v(e, "min", 7), _ = v(e, "max", 7), b = v(e, "step", 7, 1), p = v(e, "dir", 7, "ltr"), g = v(e, "autoSort", 7, !0), y = v(e, "orientation", 7, "horizontal"), S = v(e, "thumbPositioning", 7, "contain"), x = v(e, "trackPadding", 7), P = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "type",
    "onValueChange",
    "onValueCommit",
    "disabled",
    "min",
    "max",
    "step",
    "dir",
    "autoSort",
    "orientation",
    "thumbPositioning",
    "trackPadding"
  ]);
  const w = /* @__PURE__ */ O(() => h() !== void 0 ? h() : Array.isArray(b()) ? Math.min(...b()) : 0), C = /* @__PURE__ */ O(() => _() !== void 0 ? _() : Array.isArray(b()) ? Math.max(...b()) : 100);
  function k() {
    if (a() === void 0)
      return l() === "single" ? d(w) : [];
  }
  k(), Fe.pre(() => a(), () => {
    k();
  });
  const $ = HN.create({
    id: z(() => o()),
    ref: z(() => i(), (R) => i(R)),
    value: z(() => a(), (R) => {
      a(R), u()(R);
    }),
    // @ts-expect-error - we know
    onValueCommit: z(() => c()),
    disabled: z(() => f()),
    min: z(() => d(w)),
    max: z(() => d(C)),
    step: z(() => b()),
    dir: z(() => p()),
    autoSort: z(() => g()),
    orientation: z(() => y()),
    thumbPositioning: z(() => S()),
    type: l(),
    trackPadding: z(() => x())
  }), T = /* @__PURE__ */ O(() => Ce(P, $.props));
  var E = {
    get children() {
      return n();
    },
    set children(R) {
      n(R), m();
    },
    get child() {
      return s();
    },
    set child(R) {
      s(R), m();
    },
    get id() {
      return o();
    },
    set id(R = me(r)) {
      o(R), m();
    },
    get ref() {
      return i();
    },
    set ref(R = null) {
      i(R), m();
    },
    get value() {
      return a();
    },
    set value(R) {
      a(R), m();
    },
    get type() {
      return l();
    },
    set type(R) {
      l(R), m();
    },
    get onValueChange() {
      return u();
    },
    set onValueChange(R = _e) {
      u(R), m();
    },
    get onValueCommit() {
      return c();
    },
    set onValueCommit(R = _e) {
      c(R), m();
    },
    get disabled() {
      return f();
    },
    set disabled(R = !1) {
      f(R), m();
    },
    get min() {
      return h();
    },
    set min(R) {
      h(R), m();
    },
    get max() {
      return _();
    },
    set max(R) {
      _(R), m();
    },
    get step() {
      return b();
    },
    set step(R = 1) {
      b(R), m();
    },
    get dir() {
      return p();
    },
    set dir(R = "ltr") {
      p(R), m();
    },
    get autoSort() {
      return g();
    },
    set autoSort(R = !0) {
      g(R), m();
    },
    get orientation() {
      return y();
    },
    set orientation(R = "horizontal") {
      y(R), m();
    },
    get thumbPositioning() {
      return S();
    },
    set thumbPositioning(R = "contain") {
      S(R), m();
    },
    get trackPadding() {
      return x();
    },
    set trackPadding(R) {
      x(R), m();
    }
  }, I = M(), F = D(I);
  {
    var U = (R) => {
      var Z = M(), Y = D(Z);
      {
        let X = /* @__PURE__ */ O(() => ({ props: d(T), ...$.snippetProps }));
        te(Y, s, () => d(X));
      }
      A(R, Z);
    }, B = (R) => {
      var Z = YN();
      ve(Z, () => ({ ...d(T) }));
      var Y = ge(Z);
      te(Y, () => n() ?? he, () => $.snippetProps), de(Z), A(R, Z);
    };
    ue(F, (R) => {
      s() ? R(U) : R(B, !1);
    });
  }
  return A(t, I), H(E);
}
K(
  T1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    value: {},
    type: {},
    onValueChange: {},
    onValueCommit: {},
    disabled: {},
    min: {},
    max: {},
    step: {},
    dir: {},
    autoSort: {},
    orientation: {},
    thumbPositioning: {},
    trackPadding: {}
  },
  [],
  [],
  { mode: "open" }
);
var XN = /* @__PURE__ */ ne("<span><!></span>");
function D1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Zh.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      te(y, s, () => ({ props: d(u) })), A(p, g);
    }, b = (p) => {
      var g = XN();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => n() ?? he), de(g), A(p, g);
    };
    ue(h, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(D1, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var JN = /* @__PURE__ */ ne("<span><!></span>");
function M1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "index", 7), l = v(e, "disabled", 7, !1), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "index",
    "disabled"
  ]);
  const c = Qh.create({
    id: z(() => i()),
    ref: z(() => o(), (y) => o(y)),
    index: z(() => a()),
    disabled: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var h = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get ref() {
      return o();
    },
    set ref(y = null) {
      o(y), m();
    },
    get id() {
      return i();
    },
    set id(y = me(r)) {
      i(y), m();
    },
    get index() {
      return a();
    },
    set index(y) {
      a(y), m();
    },
    get disabled() {
      return l();
    },
    set disabled(y = !1) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({
          active: c.root.isThumbActive(c.opts.index.current),
          props: d(f)
        }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, g = (y) => {
      var S = JN();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      {
        let P = /* @__PURE__ */ O(() => ({
          active: c.root.isThumbActive(c.opts.index.current)
        }));
        te(x, () => n() ?? he, () => d(P));
      }
      de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(p) : y(g, !1);
    });
  }
  return A(t, _), H(h);
}
K(
  M1,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    index: {},
    disabled: {}
  },
  [],
  [],
  { mode: "open" }
);
const I1 = nr({ component: "switch", parts: ["root", "thumb"] }), eg = new ht("Switch.Root");
class tg {
  static create(e) {
    return eg.set(new tg(e));
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref), this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this);
  }
  #e() {
    this.opts.checked.current = !this.opts.checked.current;
  }
  onkeydown(e) {
    !(e.key === Br || e.key === xr) || this.opts.disabled.current || (e.preventDefault(), this.#e());
  }
  onclick(e) {
    this.opts.disabled.current || this.#e();
  }
  #t = /* @__PURE__ */ O(() => ({
    "data-disabled": Re(this.opts.disabled.current),
    "data-state": W2(this.opts.checked.current),
    "data-required": Re(this.opts.required.current)
  }));
  get sharedProps() {
    return d(this.#t);
  }
  set sharedProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => ({ checked: this.opts.checked.current }));
  get snippetProps() {
    return d(this.#r);
  }
  set snippetProps(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ({
    ...this.sharedProps,
    id: this.opts.id.current,
    role: "switch",
    disabled: _i(this.opts.disabled.current),
    "aria-checked": au(this.opts.checked.current, !1),
    "aria-required": at(this.opts.required.current),
    [I1.root]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
}
class rg {
  static create() {
    return new rg(eg.get());
  }
  root;
  #e = /* @__PURE__ */ O(() => this.root.opts.name.current !== void 0);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e) {
    this.root = e;
  }
  #t = /* @__PURE__ */ O(() => ({
    type: "checkbox",
    name: this.root.opts.name.current,
    value: this.root.opts.value.current,
    checked: this.root.opts.checked.current,
    disabled: this.root.opts.disabled.current,
    required: this.root.opts.required.current
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class ng {
  static create(e) {
    return new ng(e, eg.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #e = /* @__PURE__ */ O(() => ({ checked: this.root.opts.checked.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    ...this.root.sharedProps,
    id: this.opts.id.current,
    [I1.thumb]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function N1(t, e) {
  W(e, !1);
  const r = rg.create();
  bd();
  var n = M(), s = D(n);
  {
    var o = (i) => {
      zi(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), H();
}
K(N1, {}, [], [], { mode: "open" });
var ZN = /* @__PURE__ */ ne("<button><!></button>"), QN = /* @__PURE__ */ ne("<!> <!>", 1);
function F1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "disabled", 7, !1), l = v(e, "required", 7, !1), u = v(e, "checked", 15, !1), c = v(e, "value", 7, "on"), f = v(e, "name", 7, void 0), h = v(e, "type", 7, "button"), _ = v(e, "onCheckedChange", 7, _e), b = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id",
    "disabled",
    "required",
    "checked",
    "value",
    "name",
    "type",
    "onCheckedChange"
  ]);
  const p = tg.create({
    checked: z(() => u(), (k) => {
      u(k), _()?.(k);
    }),
    disabled: z(() => a() ?? !1),
    required: z(() => l()),
    value: z(() => c()),
    name: z(() => f()),
    id: z(() => i()),
    ref: z(() => o(), (k) => o(k))
  }), g = /* @__PURE__ */ O(() => Ce(b, p.props, { type: h() }));
  var y = {
    get child() {
      return n();
    },
    set child(k) {
      n(k), m();
    },
    get children() {
      return s();
    },
    set children(k) {
      s(k), m();
    },
    get ref() {
      return o();
    },
    set ref(k = null) {
      o(k), m();
    },
    get id() {
      return i();
    },
    set id(k = me(r)) {
      i(k), m();
    },
    get disabled() {
      return a();
    },
    set disabled(k = !1) {
      a(k), m();
    },
    get required() {
      return l();
    },
    set required(k = !1) {
      l(k), m();
    },
    get checked() {
      return u();
    },
    set checked(k = !1) {
      u(k), m();
    },
    get value() {
      return c();
    },
    set value(k = "on") {
      c(k), m();
    },
    get name() {
      return f();
    },
    set name(k = void 0) {
      f(k), m();
    },
    get type() {
      return h();
    },
    set type(k = "button") {
      h(k), m();
    },
    get onCheckedChange() {
      return _();
    },
    set onCheckedChange(k = _e) {
      _(k), m();
    }
  }, S = QN(), x = D(S);
  {
    var P = (k) => {
      var $ = M(), T = D($);
      {
        let E = /* @__PURE__ */ O(() => ({ props: d(g), ...p.snippetProps }));
        te(T, n, () => d(E));
      }
      A(k, $);
    }, w = (k) => {
      var $ = ZN();
      ve($, () => ({ ...d(g) }));
      var T = ge($);
      te(T, () => s() ?? he, () => p.snippetProps), de($), A(k, $);
    };
    ue(x, (k) => {
      n() ? k(P) : k(w, !1);
    });
  }
  var C = be(x, 2);
  return N1(C, {}), A(t, S), H(y);
}
K(
  F1,
  {
    child: {},
    children: {},
    ref: {},
    id: {},
    disabled: {},
    required: {},
    checked: {},
    value: {},
    name: {},
    type: {},
    onCheckedChange: {}
  },
  [],
  [],
  { mode: "open" }
);
var eF = /* @__PURE__ */ ne("<span><!></span>");
function R1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id"
  ]);
  const l = ng.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get child() {
      return n();
    },
    set child(p) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (p) => {
      var g = M(), y = D(g);
      {
        let S = /* @__PURE__ */ O(() => ({ props: d(u), ...l.snippetProps }));
        te(y, n, () => d(S));
      }
      A(p, g);
    }, b = (p) => {
      var g = eF();
      ve(g, () => ({ ...d(u) }));
      var y = ge(g);
      te(y, () => s() ?? he, () => l.snippetProps), de(g), A(p, g);
    };
    ue(h, (p) => {
      n() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(R1, { child: {}, children: {}, ref: {}, id: {} }, [], [], { mode: "open" });
const tF = nr({ component: "toggle", parts: ["root"] });
class sg {
  static create(e) {
    return new sg(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.onclick = this.onclick.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || (this.opts.pressed.current = !this.opts.pressed.current);
  }
  #e = /* @__PURE__ */ O(() => ({ pressed: this.opts.pressed.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    [tF.root]: "",
    id: this.opts.id.current,
    "data-disabled": Re(this.opts.disabled.current),
    "aria-pressed": at(this.opts.pressed.current),
    "data-state": rF(this.opts.pressed.current),
    disabled: _i(this.opts.disabled.current),
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function rF(t) {
  return t ? "on" : "off";
}
var nF = /* @__PURE__ */ ne("<button><!></button>");
function V1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "ref", 15, null), s = v(e, "id", 23, () => me(r)), o = v(e, "pressed", 15, !1), i = v(e, "onPressedChange", 7, _e), a = v(e, "disabled", 7, !1), l = v(e, "type", 7, "button"), u = v(e, "children", 7), c = v(e, "child", 7), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "id",
    "pressed",
    "onPressedChange",
    "disabled",
    "type",
    "children",
    "child"
  ]);
  const h = sg.create({
    pressed: z(() => o(), (x) => {
      o(x), i()(x);
    }),
    disabled: z(() => a() ?? !1),
    id: z(() => s()),
    ref: z(() => n(), (x) => n(x))
  }), _ = /* @__PURE__ */ O(() => Ce(f, h.props, { type: l() }));
  var b = {
    get ref() {
      return n();
    },
    set ref(x = null) {
      n(x), m();
    },
    get id() {
      return s();
    },
    set id(x = me(r)) {
      s(x), m();
    },
    get pressed() {
      return o();
    },
    set pressed(x = !1) {
      o(x), m();
    },
    get onPressedChange() {
      return i();
    },
    set onPressedChange(x = _e) {
      i(x), m();
    },
    get disabled() {
      return a();
    },
    set disabled(x = !1) {
      a(x), m();
    },
    get type() {
      return l();
    },
    set type(x = "button") {
      l(x), m();
    },
    get children() {
      return u();
    },
    set children(x) {
      u(x), m();
    },
    get child() {
      return c();
    },
    set child(x) {
      c(x), m();
    }
  }, p = M(), g = D(p);
  {
    var y = (x) => {
      var P = M(), w = D(P);
      {
        let C = /* @__PURE__ */ O(() => ({ props: d(_), ...h.snippetProps }));
        te(w, c, () => d(C));
      }
      A(x, P);
    }, S = (x) => {
      var P = nF();
      ve(P, () => ({ ...d(_) }));
      var w = ge(P);
      te(w, () => u() ?? he, () => h.snippetProps), de(P), A(x, P);
    };
    ue(g, (x) => {
      c() ? x(y) : x(S, !1);
    });
  }
  return A(t, p), H(b);
}
K(
  V1,
  {
    ref: {},
    id: {},
    pressed: {},
    onPressedChange: {},
    disabled: {},
    type: {},
    children: {},
    child: {}
  },
  [],
  [],
  { mode: "open" }
);
const Qc = nr({ component: "toggle-group", parts: ["root", "item"] }), L1 = new ht("ToggleGroup.Root");
class j1 {
  opts;
  rovingFocusGroup;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.rovingFocusGroup = new f0({
      candidateAttr: Qc.item,
      rootNode: e.ref,
      loop: e.loop,
      orientation: e.orientation
    });
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [Qc.root]: "",
    role: "group",
    "data-orientation": this.opts.orientation.current,
    "data-disabled": Re(this.opts.disabled.current),
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class sF extends j1 {
  opts;
  isMulti = !1;
  #e = /* @__PURE__ */ O(() => this.opts.value.current !== "");
  get anyPressed() {
    return d(this.#e);
  }
  set anyPressed(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e;
  }
  includesItem(e) {
    return this.opts.value.current === e;
  }
  toggleItem(e, r) {
    this.includesItem(e) ? this.opts.value.current = "" : (this.opts.value.current = e, this.rovingFocusGroup.setCurrentTabStopId(r));
  }
}
class oF extends j1 {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ O(() => this.opts.value.current.length > 0);
  get anyPressed() {
    return d(this.#e);
  }
  set anyPressed(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e;
  }
  includesItem(e) {
    return this.opts.value.current.includes(e);
  }
  toggleItem(e, r) {
    this.includesItem(e) ? this.opts.value.current = this.opts.value.current.filter((n) => n !== e) : (this.opts.value.current = [...this.opts.value.current, e], this.rovingFocusGroup.setCurrentTabStopId(r));
  }
}
class iF {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new sF(n) : new oF(n);
    return L1.set(s);
  }
}
class og {
  static create(e) {
    return new og(e, L1.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.opts.disabled.current || this.root.opts.disabled.current);
  #t = /* @__PURE__ */ O(() => this.root.includesItem(this.opts.value.current));
  get isPressed() {
    return d(this.#t);
  }
  set isPressed(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.isMulti ? void 0 : au(this.isPressed, !1));
  #n = /* @__PURE__ */ O(() => this.root.isMulti ? at(this.isPressed) : void 0);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), Xe(() => {
      this.root.opts.rovingFocus.current ? q(this.#o, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), !0) : q(this.#o, 0);
    }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  #s() {
    d(this.#e) || this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onclick(e) {
    d(this.#e) || this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onkeydown(e) {
    if (!d(this.#e)) {
      if (e.key === Br || e.key === xr) {
        e.preventDefault(), this.#s();
        return;
      }
      this.root.opts.rovingFocus.current && this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    }
  }
  #o = /* @__PURE__ */ xe(0);
  #i = /* @__PURE__ */ O(() => ({ pressed: this.isPressed }));
  get snippetProps() {
    return d(this.#i);
  }
  set snippetProps(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: this.root.isMulti ? void 0 : "radio",
    tabindex: d(this.#o),
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Re(d(this.#e)),
    "data-state": aF(this.isPressed),
    "data-value": this.opts.value.current,
    "aria-pressed": d(this.#n),
    "aria-checked": d(this.#r),
    disabled: _i(d(this.#e)),
    [Qc.item]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
function aF(t) {
  return t ? "on" : "off";
}
var lF = /* @__PURE__ */ ne("<div><!></div>");
function B1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 15), i = v(e, "onValueChange", 7, _e), a = v(e, "type", 7), l = v(e, "disabled", 7, !1), u = v(e, "loop", 7, !0), c = v(e, "orientation", 7, "horizontal"), f = v(e, "rovingFocus", 7, !0), h = v(e, "child", 7), _ = v(e, "children", 7), b = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "onValueChange",
    "type",
    "disabled",
    "loop",
    "orientation",
    "rovingFocus",
    "child",
    "children"
  ]);
  function p() {
    o() === void 0 && o(a() === "single" ? "" : []);
  }
  p(), Fe.pre(() => o(), () => {
    p();
  });
  const g = iF.create({
    id: z(() => n()),
    value: z(() => o(), (k) => {
      o(k), i()(k);
    }),
    disabled: z(() => l()),
    loop: z(() => u()),
    orientation: z(() => c()),
    rovingFocus: z(() => f()),
    type: a(),
    ref: z(() => s(), (k) => s(k))
  }), y = /* @__PURE__ */ O(() => Ce(b, g.props));
  var S = {
    get id() {
      return n();
    },
    set id(k = me(r)) {
      n(k), m();
    },
    get ref() {
      return s();
    },
    set ref(k = null) {
      s(k), m();
    },
    get value() {
      return o();
    },
    set value(k) {
      o(k), m();
    },
    get onValueChange() {
      return i();
    },
    set onValueChange(k = _e) {
      i(k), m();
    },
    get type() {
      return a();
    },
    set type(k) {
      a(k), m();
    },
    get disabled() {
      return l();
    },
    set disabled(k = !1) {
      l(k), m();
    },
    get loop() {
      return u();
    },
    set loop(k = !0) {
      u(k), m();
    },
    get orientation() {
      return c();
    },
    set orientation(k = "horizontal") {
      c(k), m();
    },
    get rovingFocus() {
      return f();
    },
    set rovingFocus(k = !0) {
      f(k), m();
    },
    get child() {
      return h();
    },
    set child(k) {
      h(k), m();
    },
    get children() {
      return _();
    },
    set children(k) {
      _(k), m();
    }
  }, x = M(), P = D(x);
  {
    var w = (k) => {
      var $ = M(), T = D($);
      te(T, h, () => ({ props: d(y) })), A(k, $);
    }, C = (k) => {
      var $ = lF();
      ve($, () => ({ ...d(y) }));
      var T = ge($);
      te(T, () => _() ?? he), de($), A(k, $);
    };
    ue(P, (k) => {
      h() ? k(w) : k(C, !1);
    });
  }
  return A(t, x), H(S);
}
K(
  B1,
  {
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    type: {},
    disabled: {},
    loop: {},
    orientation: {},
    rovingFocus: {},
    child: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var uF = /* @__PURE__ */ ne("<button><!></button>");
function z1(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "value", 7), a = v(e, "disabled", 7, !1), l = v(e, "id", 23, () => me(r)), u = v(e, "type", 7, "button"), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "value",
    "disabled",
    "id",
    "type"
  ]);
  const f = og.create({
    id: z(() => l()),
    value: z(() => i()),
    disabled: z(() => a() ?? !1),
    ref: z(() => o(), (S) => o(S))
  }), h = /* @__PURE__ */ O(() => Ce(c, f.props, { type: u() }));
  var _ = {
    get children() {
      return n();
    },
    set children(S) {
      n(S), m();
    },
    get child() {
      return s();
    },
    set child(S) {
      s(S), m();
    },
    get ref() {
      return o();
    },
    set ref(S = null) {
      o(S), m();
    },
    get value() {
      return i();
    },
    set value(S) {
      i(S), m();
    },
    get disabled() {
      return a();
    },
    set disabled(S = !1) {
      a(S), m();
    },
    get id() {
      return l();
    },
    set id(S = me(r)) {
      l(S), m();
    },
    get type() {
      return u();
    },
    set type(S = "button") {
      u(S), m();
    }
  }, b = M(), p = D(b);
  {
    var g = (S) => {
      var x = M(), P = D(x);
      {
        let w = /* @__PURE__ */ O(() => ({ props: d(h), ...f.snippetProps }));
        te(P, s, () => d(w));
      }
      A(S, x);
    }, y = (S) => {
      var x = uF();
      ve(x, () => ({ ...d(h) }));
      var P = ge(x);
      te(P, () => n() ?? he, () => f.snippetProps), de(x), A(S, x);
    };
    ue(p, (S) => {
      s() ? S(g) : S(y, !1);
    });
  }
  return A(t, b), H(_);
}
K(
  z1,
  {
    children: {},
    child: {},
    ref: {},
    value: {},
    disabled: {},
    id: {},
    type: {}
  },
  [],
  [],
  { mode: "open" }
);
function yu(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "data-slot", 7, "separator"), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "data-slot"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get "data-slot"() {
      return s();
    },
    set "data-slot"(u = "separator") {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:min-h-full data-[orientation=vertical]:w-px", n()));
    Q(l, () => zw, (c, f) => {
      f(c, ce(
        {
          get "data-slot"() {
            return s();
          },
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(yu, { ref: {}, class: {}, "data-slot": {} }, [], [], { mode: "open" });
function cF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "orientation", 7, "vertical"), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "orientation"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    },
    get class() {
      return n();
    },
    set class(a) {
      n(a), m();
    },
    get orientation() {
      return s();
    },
    set orientation(a = "vertical") {
      s(a), m();
    }
  };
  {
    let a = /* @__PURE__ */ O(() => Se("bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto", n()));
    yu(t, ce(
      {
        "data-slot": "button-group-separator",
        get orientation() {
          return s();
        },
        get class() {
          return d(a);
        }
      },
      () => o,
      {
        get ref() {
          return r();
        },
        set ref(l) {
          r(l);
        }
      }
    ));
  }
  return H(i);
}
K(cF, { ref: {}, class: {}, orientation: {} }, [], [], { mode: "open" });
const os = Ri({
  base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-xs",
      destructive: "bg-destructive hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white shadow-xs",
      outline: "bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80 shadow-xs",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
var dF = /* @__PURE__ */ ne("<a><!></a>"), fF = /* @__PURE__ */ ne("<button><!></button>");
function q1(t, e) {
  W(e, !0);
  let r = v(e, "class", 7), n = v(e, "variant", 7, "default"), s = v(e, "size", 7, "default"), o = v(e, "ref", 15, null), i = v(e, "href", 7, void 0), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7), u = v(e, "children", 7), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "class",
    "variant",
    "size",
    "ref",
    "href",
    "type",
    "disabled",
    "children"
  ]);
  var f = {
    get class() {
      return r();
    },
    set class(g) {
      r(g), m();
    },
    get variant() {
      return n();
    },
    set variant(g = "default") {
      n(g), m();
    },
    get size() {
      return s();
    },
    set size(g = "default") {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get href() {
      return i();
    },
    set href(g = void 0) {
      i(g), m();
    },
    get type() {
      return a();
    },
    set type(g = "button") {
      a(g), m();
    },
    get disabled() {
      return l();
    },
    set disabled(g) {
      l(g), m();
    },
    get children() {
      return u();
    },
    set children(g) {
      u(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = dF();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          href: l() ? void 0 : i(),
          "aria-disabled": l(),
          role: l() ? "link" : void 0,
          tabindex: l() ? -1 : void 0,
          ...c
        }),
        [
          () => Se(os({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), et(y, (x) => o(x), () => o()), A(g, y);
    }, p = (g) => {
      var y = fF();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          type: a(),
          disabled: l(),
          ...c
        }),
        [
          () => Se(os({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), et(y, (x) => o(x), () => o()), A(g, y);
    };
    ue(_, (g) => {
      i() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(
  q1,
  {
    class: {},
    variant: {},
    size: {},
    ref: {},
    href: {},
    type: {},
    disabled: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var hF = /* @__PURE__ */ ne("<!> <!>", 1), gF = /* @__PURE__ */ ne("<!> <!>", 1), pF = /* @__PURE__ */ ne("<!> <!>", 1), mF = /* @__PURE__ */ ne("<!> <!>", 1);
function U1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "placeholder", 15), o = v(e, "class", 7), i = v(e, "weekdayFormat", 7, "short"), a = v(e, "buttonVariant", 7, "ghost"), l = v(e, "captionLayout", 7, "label"), u = v(e, "locale", 7, "en-US"), c = v(e, "months", 7), f = v(e, "years", 7), h = v(e, "monthFormat", 7), _ = v(e, "yearFormat", 7, "numeric"), b = v(e, "day", 7), p = v(e, "disableDaysOutsideMonth", 7, !1), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "placeholder",
    "class",
    "weekdayFormat",
    "buttonVariant",
    "captionLayout",
    "locale",
    "months",
    "years",
    "monthFormat",
    "yearFormat",
    "day",
    "disableDaysOutsideMonth"
  ]);
  const y = /* @__PURE__ */ O(() => h() ? h() : l().startsWith("dropdown") ? "short" : "long");
  var S = {
    get ref() {
      return r();
    },
    set ref(w = null) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get placeholder() {
      return s();
    },
    set placeholder(w) {
      s(w), m();
    },
    get class() {
      return o();
    },
    set class(w) {
      o(w), m();
    },
    get weekdayFormat() {
      return i();
    },
    set weekdayFormat(w = "short") {
      i(w), m();
    },
    get buttonVariant() {
      return a();
    },
    set buttonVariant(w = "ghost") {
      a(w), m();
    },
    get captionLayout() {
      return l();
    },
    set captionLayout(w = "label") {
      l(w), m();
    },
    get locale() {
      return u();
    },
    set locale(w = "en-US") {
      u(w), m();
    },
    get months() {
      return c();
    },
    set months(w) {
      c(w), m();
    },
    get years() {
      return f();
    },
    set years(w) {
      f(w), m();
    },
    get monthFormat() {
      return h();
    },
    set monthFormat(w) {
      h(w), m();
    },
    get yearFormat() {
      return _();
    },
    set yearFormat(w = "numeric") {
      _(w), m();
    },
    get day() {
      return b();
    },
    set day(w) {
      b(w), m();
    },
    get disableDaysOutsideMonth() {
      return p();
    },
    set disableDaysOutsideMonth(w = !1) {
      p(w), m();
    }
  }, x = M(), P = D(x);
  {
    const w = (k, $) => {
      let T = () => $?.().months, E = () => $?.().weekdays;
      var I = M(), F = D(I);
      Q(F, () => Y1, (U, B) => {
        B(U, {
          children: (R, Z) => {
            var Y = mF(), X = D(Y);
            Q(X, () => sS, (J, j) => {
              j(J, {
                children: (ee, L) => {
                  var N = hF(), V = D(N);
                  Q(V, () => eS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  });
                  var G = be(V, 2);
                  Q(G, () => Q1, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  }), A(ee, N);
                },
                $$slots: { default: !0 }
              });
            });
            var ae = be(X, 2);
            st(ae, 18, T, (J) => J, (J, j, ee) => {
              var L = M(), N = D(L);
              Q(N, () => nS, (V, G) => {
                G(V, {
                  children: (fe, se) => {
                    var we = pF(), le = D(we);
                    Q(le, () => G1, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = M(), Ve = D(Oe);
                          Q(Ve, () => oS, (Ke, Le) => {
                            Le(Ke, {
                              get captionLayout() {
                                return l();
                              },
                              get months() {
                                return c();
                              },
                              get monthFormat() {
                                return d(y);
                              },
                              get years() {
                                return f();
                              },
                              get yearFormat() {
                                return _();
                              },
                              get month() {
                                return j.value;
                              },
                              get locale() {
                                return u();
                              },
                              get monthIndex() {
                                return d(ee);
                              },
                              get placeholder() {
                                return s();
                              },
                              set placeholder(je) {
                                s(je);
                              }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    });
                    var re = be(le, 2);
                    Q(re, () => H1, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = gF(), Ve = D(Oe);
                          Q(Ve, () => J1, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                Q($t, () => ed, (lt, ct) => {
                                  ct(lt, {
                                    class: "select-none",
                                    children: (pt, Kt) => {
                                      var yt = M(), Vt = D(yt);
                                      st(Vt, 16, E, (Mt) => Mt, (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        Q(fn, () => Z1, (sr, or) => {
                                          or(sr, {
                                            children: (kr, Xs) => {
                                              vt();
                                              var yr = tt();
                                              ke((Wr) => Ie(yr, Wr), [() => Wt.slice(0, 2)]), A(kr, yr);
                                            },
                                            $$slots: { default: !0 }
                                          });
                                        }), A(Mt, Ht);
                                      }), A(pt, yt);
                                    },
                                    $$slots: { default: !0 }
                                  });
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          });
                          var Ke = be(Ve, 2);
                          Q(Ke, () => X1, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                st($t, 16, () => j.weeks, (lt) => lt, (lt, ct) => {
                                  var pt = M(), Kt = D(pt);
                                  Q(Kt, () => ed, (yt, Vt) => {
                                    Vt(yt, {
                                      class: "mt-2 w-full",
                                      children: (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        st(fn, 16, () => ct, (sr) => sr, (sr, or) => {
                                          var kr = M(), Xs = D(kr);
                                          Q(Xs, () => K1, (yr, Wr) => {
                                            Wr(yr, {
                                              get date() {
                                                return or;
                                              },
                                              get month() {
                                                return j.value;
                                              },
                                              children: (Uo, bu) => {
                                                var Ko = M(), _u = D(Ko);
                                                {
                                                  var wu = (ir) => {
                                                    var $r = M(), gs = D($r);
                                                    {
                                                      let ps = /* @__PURE__ */ O(() => ({ day: or, outsideMonth: !D0(or, j.value) }));
                                                      te(gs, b, () => d(ps));
                                                    }
                                                    A(ir, $r);
                                                  }, Su = (ir) => {
                                                    var $r = M(), gs = D($r);
                                                    Q(gs, () => W1, (ps, xu) => {
                                                      xu(ps, {});
                                                    }), A(ir, $r);
                                                  };
                                                  ue(_u, (ir) => {
                                                    b() ? ir(wu) : ir(Su, !1);
                                                  });
                                                }
                                                A(Uo, Ko);
                                              },
                                              $$slots: { default: !0 }
                                            });
                                          }), A(sr, kr);
                                        }), A(Mt, Ht);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(lt, pt);
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(fe, we);
                  },
                  $$slots: { default: !0 }
                });
              }), A(J, L);
            }), A(R, Y);
          },
          $$slots: { default: !0 }
        });
      }), A(k, I);
    };
    let C = /* @__PURE__ */ O(() => Se("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", o()));
    Q(P, () => _w, (k, $) => {
      $(k, ce(
        {
          get weekdayFormat() {
            return i();
          },
          get disableDaysOutsideMonth() {
            return p();
          },
          get class() {
            return d(C);
          },
          get locale() {
            return u();
          },
          get monthFormat() {
            return d(y);
          },
          get yearFormat() {
            return _();
          }
        },
        () => g,
        {
          get value() {
            return n();
          },
          set value(T) {
            n(T);
          },
          get ref() {
            return r();
          },
          set ref(T) {
            r(T);
          },
          get placeholder() {
            return s();
          },
          set placeholder(T) {
            s(T);
          },
          children: w,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, x), H(S);
}
K(
  U1,
  {
    ref: {},
    value: {},
    placeholder: {},
    class: {},
    weekdayFormat: {},
    buttonVariant: {},
    captionLayout: {},
    locale: {},
    months: {},
    years: {},
    monthFormat: {},
    yearFormat: {},
    day: {},
    disableDaysOutsideMonth: {}
  },
  [],
  [],
  { mode: "open" }
);
function K1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("relative size-(--cell-size) p-0 text-center text-sm focus-within:z-20 [&:first-child[data-selected]_[data-bits-day]]:rounded-s-md [&:last-child[data-selected]_[data-bits-day]]:rounded-e-md", n()));
    Q(a, () => Sw, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(K1, { ref: {}, class: {} }, [], [], { mode: "open" });
function W1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(os({ variant: "ghost" }), "flex size-(--cell-size) flex-col items-center justify-center gap-1 p-0 leading-none font-normal whitespace-nowrap select-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground", "data-[selected]:bg-primary dark:data-[selected]:hover:bg-accent/50 data-[selected]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:text-muted-foreground data-[unavailable]:line-through", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", n()));
    Q(a, () => ww, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(W1, { ref: {}, class: {} }, [], [], { mode: "open" });
function H1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("mt-4 flex w-full border-collapse flex-col gap-1", n()));
    Q(a, () => Uf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(H1, { ref: {}, class: {} }, [], [], { mode: "open" });
function G1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex h-(--cell-size) w-full items-center justify-center gap-1.5 text-sm font-medium", n()));
    Q(a, () => Yf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(G1, { ref: {}, class: {} }, [], [], { mode: "open" });
var vF = /* @__PURE__ */ ne("<div><!></div>");
function Y1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = vF();
  ve(a, (u) => ({ class: u, ...o }), [
    () => Se("relative flex flex-col gap-4 md:flex-row", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(Y1, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function ed(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex", n()));
    Q(a, () => Gf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(ed, { ref: {}, class: {} }, [], [], { mode: "open" });
function yF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("px-(--cell-size) text-sm font-medium", n()));
    Q(a, () => Xf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(yF, { ref: {}, class: {} }, [], [], { mode: "open" });
function X1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(n()));
    Q(a, () => Kf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(X1, { ref: {}, class: {} }, [], [], { mode: "open" });
function J1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(n()));
    Q(a, () => Wf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(J1, { ref: {}, class: {} }, [], [], { mode: "open" });
function Z1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", n()));
    Q(a, () => Hf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(Z1, { ref: {}, class: {} }, [], [], { mode: "open" });
const bF = (t) => {
  Jd(t, { class: "size-4" });
};
function Q1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || bF);
    Q(u, () => Zf, (h, _) => {
      _(h, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(Q1, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
const _F = (t) => {
  Xd(t, { class: "size-4" });
};
function eS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || _F);
    Q(u, () => Qf, (h, _) => {
      _(h, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(eS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
var wF = /* @__PURE__ */ ne("<option> </option>"), SF = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), xF = /* @__PURE__ */ ne("<span><!></span>");
function tS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "onchange", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "onchange"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c) {
      s(c), m();
    },
    get onchange() {
      return o();
    },
    set onchange(c) {
      o(c), m();
    }
  }, l = xF(), u = ge(l);
  {
    const c = (f, h) => {
      let _ = () => h?.().props, b = () => h?.().monthItems, p = () => h?.().selectedMonthItem;
      var g = SF(), y = D(g);
      ve(y, () => ({ ..._(), value: s(), onchange: o() })), st(y, 21, b, (w) => w.value, (w, C) => {
        var k = wF(), $ = ge(k, !0);
        de(k);
        var T = {};
        ke(() => {
          Us(k, s() !== void 0 ? d(C).value === s() : d(C).value === p().value), Ie($, d(C).label), T !== (T = d(C).value) && (k.value = (k.__value = d(C).value) ?? "");
        }), A(w, k);
      }), de(y);
      var S = be(y, 2), x = ge(S), P = be(x);
      Hs(P, { class: "size-4" }), de(S), ke((w) => Ie(x, `${w ?? ""} `), [
        () => b().find((w) => w.value === s())?.label || p().label
      ]), A(f, g);
    };
    Q(u, () => Jf, (f, h) => {
      h(f, ce(
        {
          class: "dark:bg-popover dark:text-popover-foreground absolute inset-0 opacity-0"
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          child: c,
          $$slots: { child: !0 }
        }
      ));
    });
  }
  return de(l), ke((c) => ls(l, 1, c), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, l), H(a);
}
K(tS, { ref: {}, class: {}, value: {}, onchange: {} }, [], [], { mode: "open" });
var PF = /* @__PURE__ */ ne("<option> </option>"), OF = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), CF = /* @__PURE__ */ ne("<span><!></span>");
function rS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u) {
      s(u), m();
    }
  }, a = CF(), l = ge(a);
  {
    const u = (c, f) => {
      let h = () => f?.().props, _ = () => f?.().yearItems, b = () => f?.().selectedYearItem;
      var p = OF(), g = D(p);
      ve(g, () => ({ ...h(), value: s() })), st(g, 21, _, (P) => P.value, (P, w) => {
        var C = PF(), k = ge(C, !0);
        de(C);
        var $ = {};
        ke(() => {
          Us(C, s() !== void 0 ? d(w).value === s() : d(w).value === b().value), Ie(k, d(w).label), $ !== ($ = d(w).value) && (C.value = (C.__value = d(w).value) ?? "");
        }), A(P, C);
      }), de(g);
      var y = be(g, 2), S = ge(y), x = be(S);
      Hs(x, { class: "size-4" }), de(y), ke((P) => Ie(S, `${P ?? ""} `), [
        () => _().find((P) => P.value === s())?.label || b().label
      ]), A(c, p);
    };
    Q(l, () => eh, (c, f) => {
      f(c, ce(
        {
          class: "dark:bg-popover dark:text-popover-foreground absolute inset-0 opacity-0"
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          },
          child: u,
          $$slots: { child: !0 }
        }
      ));
    });
  }
  return de(a), ke((u) => ls(a, 1, u), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, a), H(i);
}
K(rS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var kF = /* @__PURE__ */ ne("<div><!></div>");
function nS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = kF();
  ve(a, (u) => ({ ...o, class: u }), [() => Se("flex flex-col", n())]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(nS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var $F = /* @__PURE__ */ ne("<nav><!></nav>");
function sS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = $F();
  ve(a, (u) => ({ ...o, class: u }), [
    () => Se("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(sS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var AF = /* @__PURE__ */ ne("<!> <!>", 1), EF = /* @__PURE__ */ ne("<!> <!>", 1), TF = /* @__PURE__ */ ne("<!> <!>", 1);
function oS(t, e) {
  W(e, !0);
  const r = (P) => {
    tS(P, {
      get months() {
        return o();
      },
      get monthFormat() {
        return i();
      },
      get value() {
        return u().month;
      },
      onchange: (w) => {
        if (!f()) return;
        const C = Number.parseInt(w.currentTarget.value), k = f().set({ month: C });
        f(k.subtract({ months: h() }));
      }
    });
  }, n = (P) => {
    rS(P, {
      get years() {
        return a();
      },
      get yearFormat() {
        return l();
      },
      get value() {
        return u().year;
      }
    });
  };
  let s = v(e, "captionLayout", 7), o = v(e, "months", 7), i = v(e, "monthFormat", 7), a = v(e, "years", 7), l = v(e, "yearFormat", 7), u = v(e, "month", 7), c = v(e, "locale", 7), f = v(e, "placeholder", 15), h = v(e, "monthIndex", 7, 0);
  function _(P) {
    const w = P.toDate(ft());
    return typeof l() == "function" ? l()(w.getFullYear()) : new jt(c(), { year: l() }).format(w);
  }
  function b(P) {
    const w = P.toDate(ft());
    return typeof i() == "function" ? i()(w.getMonth() + 1) : new jt(c(), { month: i() }).format(w);
  }
  var p = {
    get captionLayout() {
      return s();
    },
    set captionLayout(P) {
      s(P), m();
    },
    get months() {
      return o();
    },
    set months(P) {
      o(P), m();
    },
    get monthFormat() {
      return i();
    },
    set monthFormat(P) {
      i(P), m();
    },
    get years() {
      return a();
    },
    set years(P) {
      a(P), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(P) {
      l(P), m();
    },
    get month() {
      return u();
    },
    set month(P) {
      u(P), m();
    },
    get locale() {
      return c();
    },
    set locale(P) {
      c(P), m();
    },
    get placeholder() {
      return f();
    },
    set placeholder(P) {
      f(P), m();
    },
    get monthIndex() {
      return h();
    },
    set monthIndex(P = 0) {
      h(P), m();
    }
  }, g = M(), y = D(g);
  {
    var S = (P) => {
      var w = AF(), C = D(w);
      r(C);
      var k = be(C, 2);
      n(k), A(P, w);
    }, x = (P) => {
      var w = M(), C = D(w);
      {
        var k = (T) => {
          var E = EF(), I = D(E);
          r(I);
          var F = be(I, 2);
          {
            var U = (B) => {
              var R = tt();
              ke((Z) => Ie(R, Z), [() => _(f())]), A(B, R);
            };
            ue(F, (B) => {
              f() && B(U);
            });
          }
          A(T, E);
        }, $ = (T) => {
          var E = M(), I = D(E);
          {
            var F = (B) => {
              var R = TF(), Z = D(R);
              {
                var Y = (ae) => {
                  var J = tt();
                  ke((j) => Ie(J, j), [() => b(f())]), A(ae, J);
                };
                ue(Z, (ae) => {
                  f() && ae(Y);
                });
              }
              var X = be(Z, 2);
              n(X), A(B, R);
            }, U = (B) => {
              var R = tt();
              ke((Z, Y) => Ie(R, `${Z ?? ""} ${Y ?? ""}`), [() => b(u()), () => _(u())]), A(B, R);
            };
            ue(
              I,
              (B) => {
                s() === "dropdown-years" ? B(F) : B(U, !1);
              },
              !0
            );
          }
          A(T, E);
        };
        ue(
          C,
          (T) => {
            s() === "dropdown-months" ? T(k) : T($, !1);
          },
          !0
        );
      }
      A(P, w);
    };
    ue(y, (P) => {
      s() === "dropdown" ? P(S) : P(x, !1);
    });
  }
  return A(t, g), H(p);
}
K(
  oS,
  {
    captionLayout: {},
    months: {},
    monthFormat: {},
    years: {},
    yearFormat: {},
    month: {},
    locale: {},
    placeholder: {},
    monthIndex: {}
  },
  [],
  [],
  { mode: "open" }
);
var DF = /* @__PURE__ */ ne('<div data-slot="checkbox-indicator" class="text-current transition-none"><!></div>');
function iS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "checked", 15, !1), s = v(e, "indeterminate", 15, !1), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "checked",
    "indeterminate",
    "class"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get checked() {
      return n();
    },
    set checked(c = !1) {
      n(c), m();
    },
    get indeterminate() {
      return s();
    },
    set indeterminate(c = !1) {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    const c = (h, _) => {
      let b = () => _?.().checked, p = () => _?.().indeterminate;
      var g = DF(), y = ge(g);
      {
        var S = (P) => {
          su(P, { class: "size-3.5" });
        }, x = (P) => {
          var w = M(), C = D(w);
          {
            var k = ($) => {
              T_($, { class: "size-3.5" });
            };
            ue(
              C,
              ($) => {
                p() && $(k);
              },
              !0
            );
          }
          A(P, w);
        };
        ue(y, (P) => {
          b() ? P(S) : P(x, !1);
        });
      }
      de(g), A(h, g);
    };
    let f = /* @__PURE__ */ O(() => Se("border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive peer flex size-4 shrink-0 items-center justify-center rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", o()));
    Q(u, () => Ow, (h, _) => {
      _(h, ce(
        {
          "data-slot": "checkbox",
          get class() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get checked() {
            return n();
          },
          set checked(b) {
            n(b);
          },
          get indeterminate() {
            return s();
          },
          set indeterminate(b) {
            s(b);
          },
          children: c,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(iS, { ref: {}, checked: {}, indeterminate: {}, class: {} }, [], [], { mode: "open" });
function ig(t, e) {
  W(e, !0);
  let r = v(e, "api", 15, null), n = v(e, "ref", 15, null), s = v(e, "value", 15, ""), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "api",
    "ref",
    "value",
    "class"
  ]);
  var a = {
    get api() {
      return r();
    },
    set api(c = null) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c = null) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c = "") {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", o()));
    Q(u, () => e1, (f, h) => {
      et(
        h(f, ce(
          {
            "data-slot": "command",
            get class() {
              return d(c);
            }
          },
          () => i,
          {
            get value() {
              return s();
            },
            set value(_) {
              s(_);
            },
            get ref() {
              return n();
            },
            set ref(_) {
              n(_);
            }
          }
        )),
        (_) => r(_),
        () => r()
      );
    });
  }
  return A(t, l), H(a);
}
K(ig, { api: {}, ref: {}, value: {}, class: {} }, [], [], { mode: "open" });
function MF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => u1, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(MF, { ref: {} }, [], [], { mode: "open" });
function aS(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open"]);
  var s = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => y1, (a, l) => {
    l(a, ce(() => n, {
      get open() {
        return r();
      },
      set open(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(aS, { open: {} }, [], [], { mode: "open" });
function lS(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = M(), s = D(n);
  Q(s, () => lu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(lS, {}, [], [], { mode: "open" });
function uS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-lg leading-none font-semibold", n()));
    Q(a, () => h0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-title",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(uS, { ref: {}, class: {} }, [], [], { mode: "open" });
var IF = /* @__PURE__ */ ne("<div><!></div>");
function NF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = IF();
  ve(a, (u) => ({ "data-slot": "dialog-footer", class: u, ...o }), [
    () => Se("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(NF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var FF = /* @__PURE__ */ ne("<div><!></div>");
function cS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = FF();
  ve(a, (u) => ({ "data-slot": "dialog-header", class: u, ...o }), [
    () => Se("flex flex-col gap-2 text-center sm:text-start", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(cS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function dS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", n()));
    Q(a, () => $0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-overlay",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(dS, { ref: {}, class: {} }, [], [], { mode: "open" });
var RF = /* @__PURE__ */ ne('<!> <span class="sr-only">Close</span>', 1), VF = /* @__PURE__ */ ne("<!> <!>", 1), LF = /* @__PURE__ */ ne("<!> <!>", 1);
function fS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "portalProps", 7), o = v(e, "children", 7), i = v(e, "showCloseButton", 7, !0), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "portalProps",
    "children",
    "showCloseButton"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get portalProps() {
      return s();
    },
    set portalProps(u) {
      s(u), m();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), m();
    },
    get showCloseButton() {
      return i();
    },
    set showCloseButton(u = !0) {
      i(u), m();
    }
  };
  return lS(t, ce(s, {
    children: (u, c) => {
      var f = LF(), h = D(f);
      Q(h, () => dS, (b, p) => {
        p(b, {});
      });
      var _ = be(h, 2);
      {
        let b = /* @__PURE__ */ O(() => Se("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", n()));
        Q(_, () => b1, (p, g) => {
          g(p, ce(
            {
              "data-slot": "dialog-content",
              get class() {
                return d(b);
              }
            },
            () => a,
            {
              get ref() {
                return r();
              },
              set ref(y) {
                r(y);
              },
              children: (y, S) => {
                var x = VF(), P = D(x);
                te(P, () => o() ?? he);
                var w = be(P, 2);
                {
                  var C = (k) => {
                    var $ = M(), T = D($);
                    Q(T, () => Uh, (E, I) => {
                      I(E, {
                        class: "ring-offset-background focus:ring-ring absolute end-4 top-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
                        children: (F, U) => {
                          var B = RF(), R = D(B);
                          N_(R, {}), vt(2), A(F, B);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(k, $);
                  };
                  ue(w, (k) => {
                    i() && k(C);
                  });
                }
                A(y, x);
              },
              $$slots: { default: !0 }
            }
          ));
        });
      }
      A(u, f);
    },
    $$slots: { default: !0 }
  })), H(l);
}
K(
  fS,
  {
    ref: {},
    class: {},
    portalProps: {},
    children: {},
    showCloseButton: {}
  },
  [],
  [],
  { mode: "open" }
);
function hS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-muted-foreground text-sm", n()));
    Q(a, () => E0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-description",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(hS, { ref: {}, class: {} }, [], [], { mode: "open" });
function jF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => A0, (a, l) => {
    l(a, ce({ "data-slot": "dialog-trigger" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(jF, { ref: {} }, [], [], { mode: "open" });
function BF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Uh, (a, l) => {
    l(a, ce({ "data-slot": "dialog-close" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(BF, { ref: {} }, [], [], { mode: "open" });
var zF = /* @__PURE__ */ ne("<!> <!>", 1), qF = /* @__PURE__ */ ne("<!> <!>", 1);
function UF(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "ref", 15, null), s = v(e, "value", 15, ""), o = v(e, "title", 7, "Command Palette"), i = v(e, "description", 7, "Search for a command to run"), a = v(e, "portalProps", 7), l = v(e, "children", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "open",
    "ref",
    "value",
    "title",
    "description",
    "portalProps",
    "children"
  ]);
  var c = {
    get open() {
      return r();
    },
    set open(_ = !1) {
      r(_), m();
    },
    get ref() {
      return n();
    },
    set ref(_ = null) {
      n(_), m();
    },
    get value() {
      return s();
    },
    set value(_ = "") {
      s(_), m();
    },
    get title() {
      return o();
    },
    set title(_ = "Command Palette") {
      o(_), m();
    },
    get description() {
      return i();
    },
    set description(_ = "Search for a command to run") {
      i(_), m();
    },
    get portalProps() {
      return a();
    },
    set portalProps(_) {
      a(_), m();
    },
    get children() {
      return l();
    },
    set children(_) {
      l(_), m();
    }
  }, f = M(), h = D(f);
  return Q(h, () => aS, (_, b) => {
    b(_, ce(() => u, {
      get open() {
        return r();
      },
      set open(p) {
        r(p);
      },
      children: (p, g) => {
        var y = qF(), S = D(y);
        Q(S, () => cS, (P, w) => {
          w(P, {
            class: "sr-only",
            children: (C, k) => {
              var $ = zF(), T = D($);
              Q(T, () => uS, (I, F) => {
                F(I, {
                  children: (U, B) => {
                    vt();
                    var R = tt();
                    ke(() => Ie(R, o())), A(U, R);
                  },
                  $$slots: { default: !0 }
                });
              });
              var E = be(T, 2);
              Q(E, () => hS, (I, F) => {
                F(I, {
                  children: (U, B) => {
                    vt();
                    var R = tt();
                    ke(() => Ie(R, i())), A(U, R);
                  },
                  $$slots: { default: !0 }
                });
              }), A(C, $);
            },
            $$slots: { default: !0 }
          });
        });
        var x = be(S, 2);
        Q(x, () => fS, (P, w) => {
          w(P, {
            class: "overflow-hidden p-0",
            get portalProps() {
              return a();
            },
            children: (C, k) => {
              ig(C, ce(
                {
                  class: "**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]]:px-2 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5"
                },
                () => u,
                {
                  get children() {
                    return l();
                  },
                  get value() {
                    return s();
                  },
                  set value($) {
                    s($);
                  },
                  get ref() {
                    return n();
                  },
                  set ref($) {
                    n($);
                  }
                }
              ));
            },
            $$slots: { default: !0 }
          });
        }), A(p, y);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, f), H(c);
}
K(
  UF,
  {
    open: {},
    ref: {},
    value: {},
    title: {},
    description: {},
    portalProps: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
function gS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("py-6 text-center text-sm", n()));
    Q(a, () => t1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-empty",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(gS, { ref: {}, class: {} }, [], [], { mode: "open" });
var KF = /* @__PURE__ */ ne("<!> <!>", 1);
function pS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "heading", 7), i = v(e, "value", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "heading",
    "value"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get class() {
      return n();
    },
    set class(f) {
      n(f), m();
    },
    get children() {
      return s();
    },
    set children(f) {
      s(f), m();
    },
    get heading() {
      return o();
    },
    set heading(f) {
      o(f), m();
    },
    get value() {
      return i();
    },
    set value(f) {
      i(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => Se("text-foreground overflow-hidden p-1", n())), h = /* @__PURE__ */ O(() => i() ?? o() ?? `----${En()}`);
    Q(c, () => r1, (_, b) => {
      b(_, ce(
        {
          "data-slot": "command-group",
          get class() {
            return d(f);
          },
          get value() {
            return d(h);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          children: (p, g) => {
            var y = KF(), S = D(y);
            {
              var x = (w) => {
                var C = M(), k = D(C);
                Q(k, () => n1, ($, T) => {
                  T($, {
                    class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                    children: (E, I) => {
                      vt();
                      var F = tt();
                      ke(() => Ie(F, o())), A(E, F);
                    },
                    $$slots: { default: !0 }
                  });
                }), A(w, C);
              };
              ue(S, (w) => {
                o() && w(x);
              });
            }
            var P = be(S, 2);
            Q(P, () => s1, (w, C) => {
              C(w, {
                get children() {
                  return s();
                }
              });
            }), A(p, y);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, u), H(l);
}
K(pS, { ref: {}, class: {}, children: {}, heading: {}, value: {} }, [], [], { mode: "open" });
function mS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(a, () => i1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-item",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(mS, { ref: {}, class: {} }, [], [], { mode: "open" });
var WF = /* @__PURE__ */ ne('<div class="flex h-9 items-center gap-2 border-b ps-3 pe-8" data-slot="command-input-wrapper"><!> <!></div>');
function vS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 15, ""), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c = "") {
      s(c), m();
    }
  }, a = WF(), l = ge(a);
  D_(l, { class: "size-4 shrink-0 opacity-50" });
  var u = be(l, 2);
  {
    let c = /* @__PURE__ */ O(() => Se("placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(u, () => o1, (f, h) => {
      h(f, ce(
        {
          "data-slot": "command-input",
          get class() {
            return d(c);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          get value() {
            return s();
          },
          set value(_) {
            s(_);
          }
        }
      ));
    });
  }
  return de(a), A(t, a), H(i);
}
K(vS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
function yS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto", n()));
    Q(a, () => l1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-list",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(yS, { ref: {}, class: {} }, [], [], { mode: "open" });
function HF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("bg-border -mx-1 h-px", n()));
    Q(a, () => c1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-separator",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(HF, { ref: {}, class: {} }, [], [], { mode: "open" });
var GF = /* @__PURE__ */ ne("<span><!></span>");
function YF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = GF();
  ve(a, (u) => ({ "data-slot": "command-shortcut", class: u, ...o }), [
    () => Se("text-muted-foreground ms-auto text-xs tracking-widest", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(YF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function XF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(a, () => a1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-item",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(XF, { ref: {}, class: {} }, [], [], { mode: "open" });
const JF = Ri({
  base: "group/field data-[invalid=true]:text-destructive flex w-full gap-3",
  variants: {
    orientation: {
      vertical: "flex-col [&>*]:w-full [&>.sr-only]:w-auto",
      horizontal: [
        "flex-row items-center",
        "[&>[data-slot=field-label]]:flex-auto",
        "has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ],
      responsive: [
        "flex-col @md/field-group:flex-row @md/field-group:items-center [&>*]:w-full @md/field-group:[&>*]:w-auto [&>.sr-only]:w-auto",
        "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
        "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ]
    }
  },
  defaultVariants: { orientation: "vertical" }
});
var ZF = /* @__PURE__ */ ne("<div><!></div>");
function bS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "orientation", 7, "vertical"), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "orientation",
    "children"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get orientation() {
      return s();
    },
    set orientation(c = "vertical") {
      s(c), m();
    },
    get children() {
      return o();
    },
    set children(c) {
      o(c), m();
    }
  }, l = ZF();
  ve(
    l,
    (c) => ({
      role: "group",
      "data-slot": "field",
      "data-orientation": s(),
      class: c,
      ...i
    }),
    [
      () => Se(JF({ orientation: s() }), n())
    ]
  );
  var u = ge(l);
  return te(u, () => o() ?? he), de(l), et(l, (c) => r(c), () => r()), A(t, l), H(a);
}
K(bS, { ref: {}, class: {}, orientation: {}, children: {} }, [], [], { mode: "open" });
var QF = /* @__PURE__ */ ne("<fieldset><!></fieldset>");
function _S(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = QF();
  ve(a, (u) => ({ "data-slot": "field-set", class: u, ...o }), [
    () => Se("flex flex-col gap-6", "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(_S, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var eR = /* @__PURE__ */ ne("<legend><!></legend>");
function wS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "variant", 7, "legend"), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "variant",
    "children"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get variant() {
      return s();
    },
    set variant(c = "legend") {
      s(c), m();
    },
    get children() {
      return o();
    },
    set children(c) {
      o(c), m();
    }
  }, l = eR();
  ve(
    l,
    (c) => ({
      "data-slot": "field-legend",
      "data-variant": s(),
      class: c,
      ...i
    }),
    [
      () => Se("mb-3 font-medium", "data-[variant=legend]:text-base", "data-[variant=label]:text-sm", n())
    ]
  );
  var u = ge(l);
  return te(u, () => o() ?? he), de(l), et(l, (c) => r(c), () => r()), A(t, l), H(a);
}
K(wS, { ref: {}, class: {}, variant: {}, children: {} }, [], [], { mode: "open" });
var tR = /* @__PURE__ */ ne("<div><!></div>");
function SS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = tR();
  ve(a, (u) => ({ "data-slot": "field-group", class: u, ...o }), [
    () => Se("group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(SS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var rR = /* @__PURE__ */ ne("<div><!></div>");
function nR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = rR();
  ve(a, (u) => ({ "data-slot": "field-content", class: u, ...o }), [
    () => Se("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(nR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function xS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", n()));
    Q(a, () => _1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "label",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(xS, { ref: {}, class: {} }, [], [], { mode: "open" });
function PS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    },
    get class() {
      return n();
    },
    set class(a) {
      n(a), m();
    },
    get children() {
      return s();
    },
    set children(a) {
      s(a), m();
    }
  };
  {
    let a = /* @__PURE__ */ O(() => Se("group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50", "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4", "has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10", n()));
    xS(t, ce(
      {
        "data-slot": "field-label",
        get class() {
          return d(a);
        }
      },
      () => o,
      {
        get ref() {
          return r();
        },
        set ref(l) {
          r(l);
        },
        children: (l, u) => {
          var c = M(), f = D(c);
          te(f, () => s() ?? he), A(l, c);
        },
        $$slots: { default: !0 }
      }
    ));
  }
  return H(i);
}
K(PS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var sR = /* @__PURE__ */ ne("<div><!></div>");
function OS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = sR();
  ve(a, (u) => ({ "data-slot": "field-title", class: u, ...o }), [
    () => Se("flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(OS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var oR = /* @__PURE__ */ ne("<p><!></p>");
function CS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = oR();
  ve(a, (u) => ({ "data-slot": "field-description", class: u, ...o }), [
    () => Se("text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance", "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5", "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(CS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var iR = /* @__PURE__ */ ne('<span class="bg-background text-muted-foreground relative mx-auto block w-fit px-2" data-slot="field-separator-content"><!></span>'), aR = /* @__PURE__ */ ne("<div><!> <!></div>");
function lR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  const i = /* @__PURE__ */ O(() => !!s());
  var a = {
    get ref() {
      return r();
    },
    set ref(h = null) {
      r(h), m();
    },
    get class() {
      return n();
    },
    set class(h) {
      n(h), m();
    },
    get children() {
      return s();
    },
    set children(h) {
      s(h), m();
    }
  }, l = aR();
  ve(
    l,
    (h) => ({
      "data-slot": "field-separator",
      "data-content": d(i),
      class: h,
      ...o
    }),
    [
      () => Se("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", n())
    ]
  );
  var u = ge(l);
  yu(u, { class: "absolute inset-0 top-1/2" });
  var c = be(u, 2);
  {
    var f = (h) => {
      var _ = iR(), b = ge(_);
      te(b, s), de(_), A(h, _);
    };
    ue(c, (h) => {
      s() && h(f);
    });
  }
  return de(l), et(l, (h) => r(h), () => r()), A(t, l), H(a);
}
K(lR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var uR = /* @__PURE__ */ ne("<li> </li>"), cR = /* @__PURE__ */ ne('<ul class="ms-4 flex list-disc flex-col gap-1"></ul>'), dR = /* @__PURE__ */ ne("<div><!></div>");
function kS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "errors", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "errors"
  ]);
  const a = /* @__PURE__ */ O(() => s() ? !0 : !(!o() || o().length === 0 || o().length === 1 && !o()[0]?.message)), l = /* @__PURE__ */ O(() => o() && o().length > 1), u = /* @__PURE__ */ O(() => o() && o().length === 1 && o()[0]?.message);
  var c = {
    get ref() {
      return r();
    },
    set ref(b = null) {
      r(b), m();
    },
    get class() {
      return n();
    },
    set class(b) {
      n(b), m();
    },
    get children() {
      return s();
    },
    set children(b) {
      s(b), m();
    },
    get errors() {
      return o();
    },
    set errors(b) {
      o(b), m();
    }
  }, f = M(), h = D(f);
  {
    var _ = (b) => {
      var p = dR();
      ve(
        p,
        (x) => ({
          role: "alert",
          "data-slot": "field-error",
          class: x,
          ...i
        }),
        [
          () => Se("text-destructive text-sm font-normal", n())
        ]
      );
      var g = ge(p);
      {
        var y = (x) => {
          var P = M(), w = D(P);
          te(w, s), A(x, P);
        }, S = (x) => {
          var P = M(), w = D(P);
          {
            var C = ($) => {
              var T = tt();
              ke(() => Ie(T, d(u))), A($, T);
            }, k = ($) => {
              var T = M(), E = D(T);
              {
                var I = (F) => {
                  var U = cR();
                  st(U, 21, () => o() ?? [], jl, (B, R) => {
                    var Z = M(), Y = D(Z);
                    {
                      var X = (ae) => {
                        var J = uR(), j = ge(J, !0);
                        de(J), ke(() => Ie(j, d(R).message)), A(ae, J);
                      };
                      ue(Y, (ae) => {
                        d(R)?.message && ae(X);
                      });
                    }
                    A(B, Z);
                  }), de(U), A(F, U);
                };
                ue(
                  E,
                  (F) => {
                    d(l) && F(I);
                  },
                  !0
                );
              }
              A($, T);
            };
            ue(
              w,
              ($) => {
                d(u) ? $(C) : $(k, !1);
              },
              !0
            );
          }
          A(x, P);
        };
        ue(g, (x) => {
          s() ? x(y) : x(S, !1);
        });
      }
      de(p), et(p, (x) => r(x), () => r()), A(b, p);
    };
    ue(h, (b) => {
      d(a) && b(_);
    });
  }
  return A(t, f), H(c);
}
K(kS, { ref: {}, class: {}, children: {}, errors: {} }, [], [], { mode: "open" });
var fR = /* @__PURE__ */ ne("<input/>"), hR = /* @__PURE__ */ ne("<input/>");
function $S(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "type", 7), o = v(e, "files", 15), i = v(e, "class", 7), a = v(e, "data-slot", 7, "input"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "type",
    "files",
    "class",
    "data-slot"
  ]);
  var u = {
    get ref() {
      return r();
    },
    set ref(b = null) {
      r(b), m();
    },
    get value() {
      return n();
    },
    set value(b) {
      n(b), m();
    },
    get type() {
      return s();
    },
    set type(b) {
      s(b), m();
    },
    get files() {
      return o();
    },
    set files(b) {
      o(b), m();
    },
    get class() {
      return i();
    },
    set class(b) {
      i(b), m();
    },
    get "data-slot"() {
      return a();
    },
    set "data-slot"(b = "input") {
      a(b), m();
    }
  }, c = M(), f = D(c);
  {
    var h = (b) => {
      var p = fR();
      ve(
        p,
        (g) => ({
          "data-slot": a(),
          class: g,
          type: "file",
          ...l
        }),
        [
          () => Se("selection:bg-primary dark:bg-input/30 selection:text-primary-foreground border-input ring-offset-background placeholder:text-muted-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 pt-1.5 text-sm font-medium shadow-xs transition-[color,box-shadow] outline-none disabled:cursor-not-allowed disabled:opacity-50", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", i())
        ],
        void 0,
        void 0,
        void 0,
        !0
      ), et(p, (g) => r(g), () => r()), ay(p, o), go(p, n), A(b, p);
    }, _ = (b) => {
      var p = hR();
      ve(
        p,
        (g) => ({
          "data-slot": a(),
          class: g,
          type: s(),
          ...l
        }),
        [
          () => Se("border-input bg-background selection:bg-primary dark:bg-input/30 selection:text-primary-foreground ring-offset-background placeholder:text-muted-foreground flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", i())
        ],
        void 0,
        void 0,
        void 0,
        !0
      ), et(p, (g) => r(g), () => r()), go(p, n), A(b, p);
    };
    ue(f, (b) => {
      s() === "file" ? b(h) : b(_, !1);
    });
  }
  return A(t, c), H(u);
}
K(
  $S,
  {
    ref: {},
    value: {},
    type: {},
    files: {},
    class: {},
    "data-slot": {}
  },
  [],
  [],
  { mode: "open" }
);
function AS(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open"]);
  var s = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => w1, (a, l) => {
    l(a, ce(() => n, {
      get open() {
        return r();
      },
      set open(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(AS, { open: {} }, [], [], { mode: "open" });
function gR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => g1, (a, l) => {
    l(a, ce({ "data-slot": "popover-close" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(gR, { ref: {} }, [], [], { mode: "open" });
function ES(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = M(), s = D(n);
  Q(s, () => lu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(ES, {}, [], [], { mode: "open" });
function TS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "sideOffset", 7, 4), o = v(e, "align", 7, "center"), i = v(e, "portalProps", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "sideOffset",
    "align",
    "portalProps"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(u = 4) {
      s(u), m();
    },
    get align() {
      return o();
    },
    set align(u = "center") {
      o(u), m();
    },
    get portalProps() {
      return i();
    },
    set portalProps(u) {
      i(u), m();
    }
  };
  return ES(t, ce(i, {
    children: (u, c) => {
      var f = M(), h = D(f);
      {
        let _ = /* @__PURE__ */ O(() => Se("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-end-2 data-[side=right]:slide-in-from-start-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--bits-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden", n()));
        Q(h, () => f1, (b, p) => {
          p(b, ce(
            {
              "data-slot": "popover-content",
              get sideOffset() {
                return s();
              },
              get align() {
                return o();
              },
              get class() {
                return d(_);
              }
            },
            () => a,
            {
              get ref() {
                return r();
              },
              set ref(g) {
                r(g);
              }
            }
          ));
        });
      }
      A(u, f);
    },
    $$slots: { default: !0 }
  })), H(l);
}
K(
  TS,
  {
    ref: {},
    class: {},
    sideOffset: {},
    align: {},
    portalProps: {}
  },
  [],
  [],
  { mode: "open" }
);
function DS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("", n()));
    Q(a, () => h1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "popover-trigger",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(DS, { ref: {}, class: {} }, [], [], { mode: "open" });
function MS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 15, ""), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u = "") {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("grid gap-3", n()));
    Q(l, () => x1, (c, f) => {
      f(c, ce(
        {
          "data-slot": "radio-group",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          },
          get value() {
            return s();
          },
          set value(h) {
            s(h);
          }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(MS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var pR = /* @__PURE__ */ ne('<div data-slot="radio-group-indicator" class="relative flex items-center justify-center"><!></div>');
function IS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    const l = (c, f) => {
      let h = () => f?.().checked;
      var _ = pR(), b = ge(_);
      {
        var p = (g) => {
          A_(g, {
            class: "fill-primary absolute start-1/2 top-1/2 size-2 -translate-x-1/2 -translate-y-1/2"
          });
        };
        ue(b, (g) => {
          h() && g(p);
        });
      }
      de(_), A(c, _);
    };
    let u = /* @__PURE__ */ O(() => Se("border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(a, () => P1, (c, f) => {
      f(c, ce(
        {
          "data-slot": "radio-group-item",
          get class() {
            return d(u);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          },
          children: l,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(IS, { ref: {}, class: {} }, [], [], { mode: "open" });
var mR = /* @__PURE__ */ ne("<!> <!>", 1), vR = /* @__PURE__ */ ne("<!> <!>", 1), yR = /* @__PURE__ */ ne("<!> <!>", 1), bR = /* @__PURE__ */ ne("<!> <!>", 1);
function NS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "placeholder", 15), o = v(e, "weekdayFormat", 7, "short"), i = v(e, "class", 7), a = v(e, "buttonVariant", 7, "ghost"), l = v(e, "captionLayout", 7, "label"), u = v(e, "locale", 7, "en-US"), c = v(e, "months", 7), f = v(e, "years", 7), h = v(e, "monthFormat", 7), _ = v(e, "yearFormat", 7, "numeric"), b = v(e, "day", 7), p = v(e, "disableDaysOutsideMonth", 7, !1), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "placeholder",
    "weekdayFormat",
    "class",
    "buttonVariant",
    "captionLayout",
    "locale",
    "months",
    "years",
    "monthFormat",
    "yearFormat",
    "day",
    "disableDaysOutsideMonth"
  ]);
  const y = /* @__PURE__ */ O(() => h() ? h() : l().startsWith("dropdown") ? "short" : "long");
  var S = {
    get ref() {
      return r();
    },
    set ref(w = null) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get placeholder() {
      return s();
    },
    set placeholder(w) {
      s(w), m();
    },
    get weekdayFormat() {
      return o();
    },
    set weekdayFormat(w = "short") {
      o(w), m();
    },
    get class() {
      return i();
    },
    set class(w) {
      i(w), m();
    },
    get buttonVariant() {
      return a();
    },
    set buttonVariant(w = "ghost") {
      a(w), m();
    },
    get captionLayout() {
      return l();
    },
    set captionLayout(w = "label") {
      l(w), m();
    },
    get locale() {
      return u();
    },
    set locale(w = "en-US") {
      u(w), m();
    },
    get months() {
      return c();
    },
    set months(w) {
      c(w), m();
    },
    get years() {
      return f();
    },
    set years(w) {
      f(w), m();
    },
    get monthFormat() {
      return h();
    },
    set monthFormat(w) {
      h(w), m();
    },
    get yearFormat() {
      return _();
    },
    set yearFormat(w = "numeric") {
      _(w), m();
    },
    get day() {
      return b();
    },
    set day(w) {
      b(w), m();
    },
    get disableDaysOutsideMonth() {
      return p();
    },
    set disableDaysOutsideMonth(w = !1) {
      p(w), m();
    }
  }, x = M(), P = D(x);
  {
    const w = (k, $) => {
      let T = () => $?.().months, E = () => $?.().weekdays;
      var I = M(), F = D(I);
      Q(F, () => jS, (U, B) => {
        B(U, {
          children: (R, Z) => {
            var Y = bR(), X = D(Y);
            Q(X, () => HS, (J, j) => {
              j(J, {
                children: (ee, L) => {
                  var N = mR(), V = D(N);
                  Q(V, () => qS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  });
                  var G = be(V, 2);
                  Q(G, () => zS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  }), A(ee, N);
                },
                $$slots: { default: !0 }
              });
            });
            var ae = be(X, 2);
            st(ae, 18, T, (J) => J, (J, j, ee) => {
              var L = M(), N = D(L);
              Q(N, () => GS, (V, G) => {
                G(V, {
                  children: (fe, se) => {
                    var we = yR(), le = D(we);
                    Q(le, () => LS, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = M(), Ve = D(Oe);
                          Q(Ve, () => WS, (Ke, Le) => {
                            Le(Ke, {
                              get captionLayout() {
                                return l();
                              },
                              get months() {
                                return c();
                              },
                              get monthFormat() {
                                return d(y);
                              },
                              get years() {
                                return f();
                              },
                              get yearFormat() {
                                return _();
                              },
                              get month() {
                                return j.value;
                              },
                              get locale() {
                                return u();
                              },
                              get monthIndex() {
                                return d(ee);
                              },
                              get placeholder() {
                                return s();
                              },
                              set placeholder(je) {
                                s(je);
                              }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    });
                    var re = be(le, 2);
                    Q(re, () => VS, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = vR(), Ve = D(Oe);
                          Q(Ve, () => XS, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                Q($t, () => td, (lt, ct) => {
                                  ct(lt, {
                                    class: "select-none",
                                    children: (pt, Kt) => {
                                      var yt = M(), Vt = D(yt);
                                      st(Vt, 16, E, (Mt) => Mt, (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        Q(fn, () => BS, (sr, or) => {
                                          or(sr, {
                                            children: (kr, Xs) => {
                                              vt();
                                              var yr = tt();
                                              ke((Wr) => Ie(yr, Wr), [() => Wt.slice(0, 2)]), A(kr, yr);
                                            },
                                            $$slots: { default: !0 }
                                          });
                                        }), A(Mt, Ht);
                                      }), A(pt, yt);
                                    },
                                    $$slots: { default: !0 }
                                  });
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          });
                          var Ke = be(Ve, 2);
                          Q(Ke, () => YS, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                st($t, 16, () => j.weeks, (lt) => lt, (lt, ct) => {
                                  var pt = M(), Kt = D(pt);
                                  Q(Kt, () => td, (yt, Vt) => {
                                    Vt(yt, {
                                      class: "mt-2 w-full",
                                      children: (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        st(fn, 16, () => ct, (sr) => sr, (sr, or) => {
                                          var kr = M(), Xs = D(kr);
                                          Q(Xs, () => FS, (yr, Wr) => {
                                            Wr(yr, {
                                              get date() {
                                                return or;
                                              },
                                              get month() {
                                                return j.value;
                                              },
                                              children: (Uo, bu) => {
                                                var Ko = M(), _u = D(Ko);
                                                {
                                                  var wu = (ir) => {
                                                    var $r = M(), gs = D($r);
                                                    {
                                                      let ps = /* @__PURE__ */ O(() => ({ day: or, outsideMonth: !D0(or, j.value) }));
                                                      te(gs, b, () => d(ps));
                                                    }
                                                    A(ir, $r);
                                                  }, Su = (ir) => {
                                                    var $r = M(), gs = D($r);
                                                    Q(gs, () => RS, (ps, xu) => {
                                                      xu(ps, {});
                                                    }), A(ir, $r);
                                                  };
                                                  ue(_u, (ir) => {
                                                    b() ? ir(wu) : ir(Su, !1);
                                                  });
                                                }
                                                A(Uo, Ko);
                                              },
                                              $$slots: { default: !0 }
                                            });
                                          }), A(sr, kr);
                                        }), A(Mt, Ht);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(lt, pt);
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(fe, we);
                  },
                  $$slots: { default: !0 }
                });
              }), A(J, L);
            }), A(R, Y);
          },
          $$slots: { default: !0 }
        });
      }), A(k, I);
    };
    let C = /* @__PURE__ */ O(() => Se("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", i()));
    Q(P, () => O1, (k, $) => {
      $(k, ce(
        {
          get weekdayFormat() {
            return o();
          },
          get disableDaysOutsideMonth() {
            return p();
          },
          get class() {
            return d(C);
          },
          get locale() {
            return u();
          },
          get monthFormat() {
            return d(y);
          },
          get yearFormat() {
            return _();
          }
        },
        () => g,
        {
          get ref() {
            return r();
          },
          set ref(T) {
            r(T);
          },
          get value() {
            return n();
          },
          set value(T) {
            n(T);
          },
          get placeholder() {
            return s();
          },
          set placeholder(T) {
            s(T);
          },
          children: w,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, x), H(S);
}
K(
  NS,
  {
    ref: {},
    value: {},
    placeholder: {},
    weekdayFormat: {},
    class: {},
    buttonVariant: {},
    captionLayout: {},
    locale: {},
    months: {},
    years: {},
    monthFormat: {},
    yearFormat: {},
    day: {},
    disableDaysOutsideMonth: {}
  },
  [],
  [],
  { mode: "open" }
);
function FS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("dark:[&:has([data-range-start])]:hover:bg-accent dark:[&:has([data-range-end])]:hover:bg-accent [&:has([data-range-middle])]:bg-accent dark:[&:has([data-range-middle])]:hover:bg-accent/50 [&:has([data-selected])]:bg-accent relative size-(--cell-size) p-0 text-center text-sm focus-within:z-20 data-[range-middle]:rounded-e-md [&:first-child[data-selected]_[data-bits-day]]:rounded-s-md [&:has([data-range-end])]:rounded-e-md [&:has([data-range-middle])]:rounded-none first:[&:has([data-range-middle])]:rounded-s-md last:[&:has([data-range-middle])]:rounded-e-md [&:has([data-range-start])]:rounded-s-md [&:last-child[data-selected]_[data-bits-day]]:rounded-e-md", n()));
    Q(a, () => m1, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(FS, { ref: {}, class: {} }, [], [], { mode: "open" });
function RS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(os({ variant: "ghost" }), "flex size-(--cell-size) flex-col items-center justify-center gap-1 p-0 leading-none font-normal whitespace-nowrap select-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground data-[range-middle]:rounded-none", "data-[range-start]:bg-primary dark:data-[range-start]:hover:bg-accent data-[range-start]:text-primary-foreground", "data-[range-end]:bg-primary dark:data-[range-end]:hover:bg-accent data-[range-end]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:line-through", "dark:data-[range-middle]:hover:bg-accent/0", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", n()));
    Q(a, () => v1, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(RS, { ref: {}, class: {} }, [], [], { mode: "open" });
function VS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("mt-4 flex w-full border-collapse flex-col gap-1", n()));
    Q(a, () => Uf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(VS, { ref: {}, class: {} }, [], [], { mode: "open" });
function LS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex h-(--cell-size) w-full items-center justify-center gap-1.5 text-sm font-medium", n()));
    Q(a, () => Yf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(LS, { ref: {}, class: {} }, [], [], { mode: "open" });
var _R = /* @__PURE__ */ ne("<div><!></div>");
function jS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = _R();
  ve(a, (u) => ({ class: u, ...o }), [
    () => Se("relative flex flex-col gap-4 md:flex-row", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(jS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function td(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex", n()));
    Q(a, () => Gf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(td, { ref: {}, class: {} }, [], [], { mode: "open" });
function wR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("px-(--cell-size) text-sm font-medium", n()));
    Q(a, () => Xf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(wR, { ref: {}, class: {} }, [], [], { mode: "open" });
function BS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", n()));
    Q(a, () => Hf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(BS, { ref: {}, class: {} }, [], [], { mode: "open" });
const SR = (t) => {
  Jd(t, { class: "size-4" });
};
function zS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || SR);
    Q(u, () => Zf, (h, _) => {
      _(h, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(zS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
const xR = (t) => {
  Xd(t, { class: "size-4" });
};
function qS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || xR);
    Q(u, () => Qf, (h, _) => {
      _(h, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(qS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
var PR = /* @__PURE__ */ ne("<option> </option>"), OR = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), CR = /* @__PURE__ */ ne("<span><!></span>");
function US(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "onchange", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "onchange"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c) {
      s(c), m();
    },
    get onchange() {
      return o();
    },
    set onchange(c) {
      o(c), m();
    }
  }, l = CR(), u = ge(l);
  {
    const c = (f, h) => {
      let _ = () => h?.().props, b = () => h?.().monthItems, p = () => h?.().selectedMonthItem;
      var g = OR(), y = D(g);
      ve(y, () => ({ ..._(), value: s(), onchange: o() })), st(y, 21, b, (w) => w.value, (w, C) => {
        var k = PR(), $ = ge(k, !0);
        de(k);
        var T = {};
        ke(() => {
          Us(k, s() !== void 0 ? d(C).value === s() : d(C).value === p().value), Ie($, d(C).label), T !== (T = d(C).value) && (k.value = (k.__value = d(C).value) ?? "");
        }), A(w, k);
      }), de(y);
      var S = be(y, 2), x = ge(S), P = be(x);
      Hs(P, { class: "size-4" }), de(S), ke((w) => Ie(x, `${w ?? ""} `), [
        () => b().find((w) => w.value === s())?.label || p().label
      ]), A(f, g);
    };
    Q(u, () => Jf, (f, h) => {
      h(f, ce({ class: "absolute inset-0 opacity-0" }, () => i, {
        get ref() {
          return r();
        },
        set ref(_) {
          r(_);
        },
        child: c,
        $$slots: { child: !0 }
      }));
    });
  }
  return de(l), ke((c) => ls(l, 1, c), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, l), H(a);
}
K(US, { ref: {}, class: {}, value: {}, onchange: {} }, [], [], { mode: "open" });
var kR = /* @__PURE__ */ ne("<option> </option>"), $R = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), AR = /* @__PURE__ */ ne("<span><!></span>");
function KS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u) {
      s(u), m();
    }
  }, a = AR(), l = ge(a);
  {
    const u = (c, f) => {
      let h = () => f?.().props, _ = () => f?.().yearItems, b = () => f?.().selectedYearItem;
      var p = $R(), g = D(p);
      ve(g, () => ({ ...h(), value: s() })), st(g, 21, _, (P) => P.value, (P, w) => {
        var C = kR(), k = ge(C, !0);
        de(C);
        var $ = {};
        ke(() => {
          Us(C, s() !== void 0 ? d(w).value === s() : d(w).value === b().value), Ie(k, d(w).label), $ !== ($ = d(w).value) && (C.value = (C.__value = d(w).value) ?? "");
        }), A(P, C);
      }), de(g);
      var y = be(g, 2), S = ge(y), x = be(S);
      Hs(x, { class: "size-4" }), de(y), ke((P) => Ie(S, `${P ?? ""} `), [
        () => _().find((P) => P.value === s())?.label || b().label
      ]), A(c, p);
    };
    Q(l, () => eh, (c, f) => {
      f(c, ce({ class: "absolute inset-0 opacity-0" }, () => o, {
        get ref() {
          return r();
        },
        set ref(h) {
          r(h);
        },
        child: u,
        $$slots: { child: !0 }
      }));
    });
  }
  return de(a), ke((u) => ls(a, 1, u), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, a), H(i);
}
K(KS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var ER = /* @__PURE__ */ ne("<!> <!>", 1), TR = /* @__PURE__ */ ne("<!> <!>", 1), DR = /* @__PURE__ */ ne("<!> <!>", 1);
function WS(t, e) {
  W(e, !0);
  const r = (P) => {
    US(P, {
      get months() {
        return o();
      },
      get monthFormat() {
        return i();
      },
      get value() {
        return u().month;
      },
      onchange: (w) => {
        if (!f()) return;
        const C = Number.parseInt(w.currentTarget.value), k = f().set({ month: C });
        f(k.subtract({ months: h() }));
      }
    });
  }, n = (P) => {
    KS(P, {
      get years() {
        return a();
      },
      get yearFormat() {
        return l();
      },
      get value() {
        return u().year;
      }
    });
  };
  let s = v(e, "captionLayout", 7), o = v(e, "months", 7), i = v(e, "monthFormat", 7), a = v(e, "years", 7), l = v(e, "yearFormat", 7), u = v(e, "month", 7), c = v(e, "locale", 7), f = v(e, "placeholder", 15), h = v(e, "monthIndex", 7, 0);
  function _(P) {
    const w = P.toDate(ft());
    return typeof l() == "function" ? l()(w.getFullYear()) : new jt(c(), { year: l() }).format(w);
  }
  function b(P) {
    const w = P.toDate(ft());
    return typeof i() == "function" ? i()(w.getMonth() + 1) : new jt(c(), { month: i() }).format(w);
  }
  var p = {
    get captionLayout() {
      return s();
    },
    set captionLayout(P) {
      s(P), m();
    },
    get months() {
      return o();
    },
    set months(P) {
      o(P), m();
    },
    get monthFormat() {
      return i();
    },
    set monthFormat(P) {
      i(P), m();
    },
    get years() {
      return a();
    },
    set years(P) {
      a(P), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(P) {
      l(P), m();
    },
    get month() {
      return u();
    },
    set month(P) {
      u(P), m();
    },
    get locale() {
      return c();
    },
    set locale(P) {
      c(P), m();
    },
    get placeholder() {
      return f();
    },
    set placeholder(P) {
      f(P), m();
    },
    get monthIndex() {
      return h();
    },
    set monthIndex(P = 0) {
      h(P), m();
    }
  }, g = M(), y = D(g);
  {
    var S = (P) => {
      var w = ER(), C = D(w);
      r(C);
      var k = be(C, 2);
      n(k), A(P, w);
    }, x = (P) => {
      var w = M(), C = D(w);
      {
        var k = (T) => {
          var E = TR(), I = D(E);
          r(I);
          var F = be(I, 2);
          {
            var U = (B) => {
              var R = tt();
              ke((Z) => Ie(R, Z), [() => _(f())]), A(B, R);
            };
            ue(F, (B) => {
              f() && B(U);
            });
          }
          A(T, E);
        }, $ = (T) => {
          var E = M(), I = D(E);
          {
            var F = (B) => {
              var R = DR(), Z = D(R);
              {
                var Y = (ae) => {
                  var J = tt();
                  ke((j) => Ie(J, j), [() => b(f())]), A(ae, J);
                };
                ue(Z, (ae) => {
                  f() && ae(Y);
                });
              }
              var X = be(Z, 2);
              n(X), A(B, R);
            }, U = (B) => {
              var R = tt();
              ke((Z, Y) => Ie(R, `${Z ?? ""} ${Y ?? ""}`), [() => b(u()), () => _(u())]), A(B, R);
            };
            ue(
              I,
              (B) => {
                s() === "dropdown-years" ? B(F) : B(U, !1);
              },
              !0
            );
          }
          A(T, E);
        };
        ue(
          C,
          (T) => {
            s() === "dropdown-months" ? T(k) : T($, !1);
          },
          !0
        );
      }
      A(P, w);
    };
    ue(y, (P) => {
      s() === "dropdown" ? P(S) : P(x, !1);
    });
  }
  return A(t, g), H(p);
}
K(
  WS,
  {
    captionLayout: {},
    months: {},
    monthFormat: {},
    years: {},
    yearFormat: {},
    month: {},
    locale: {},
    placeholder: {},
    monthIndex: {}
  },
  [],
  [],
  { mode: "open" }
);
var MR = /* @__PURE__ */ ne("<nav><!></nav>");
function HS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = MR();
  ve(a, (u) => ({ ...o, class: u }), [
    () => Se("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(HS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var IR = /* @__PURE__ */ ne("<div><!></div>");
function GS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = IR();
  ve(a, (u) => ({ ...o, class: u }), [() => Se("flex flex-col", n())]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(GS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function YS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Kf, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(YS, { ref: {} }, [], [], { mode: "open" });
function XS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Wf, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(XS, { ref: {} }, [], [], { mode: "open" });
function JS(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "value", 15), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open", "value"]);
  var o = {
    get open() {
      return r();
    },
    set open(l = !1) {
      r(l), m();
    },
    get value() {
      return n();
    },
    set value(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  return Q(a, () => C1, (l, u) => {
    u(l, ce(() => s, {
      get open() {
        return r();
      },
      set open(c) {
        r(c);
      },
      get value() {
        return n();
      },
      set value(c) {
        n(c);
      }
    }));
  }), A(t, i), H(o);
}
K(JS, { open: {}, value: {} }, [], [], { mode: "open" });
function NR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Ww, (a, l) => {
    l(a, ce({ "data-slot": "select-group" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(NR, { ref: {} }, [], [], { mode: "open" });
var FR = /* @__PURE__ */ ne("<div><!></div>");
function RR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = FR();
  ve(a, (u) => ({ "data-slot": "select-label", class: u, ...o }), [
    () => Se("text-muted-foreground px-2 py-1.5 text-xs", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), et(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(RR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var VR = /* @__PURE__ */ ne('<span class="absolute end-2 flex size-3.5 items-center justify-center"><!></span> <!>', 1);
function ZS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "label", 7), i = v(e, "children", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "label",
    "children"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get class() {
      return n();
    },
    set class(f) {
      n(f), m();
    },
    get value() {
      return s();
    },
    set value(f) {
      s(f), m();
    },
    get label() {
      return o();
    },
    set label(f) {
      o(f), m();
    },
    get children() {
      return i();
    },
    set children(f) {
      i(f), m();
    }
  }, u = M(), c = D(u);
  {
    const f = (_, b) => {
      let p = () => b?.().selected, g = () => b?.().highlighted;
      var y = VR(), S = D(y), x = ge(S);
      {
        var P = ($) => {
          su($, { class: "size-4" });
        };
        ue(x, ($) => {
          p() && $(P);
        });
      }
      de(S);
      var w = be(S, 2);
      {
        var C = ($) => {
          var T = M(), E = D(T);
          te(E, i, () => ({ selected: p(), highlighted: g() })), A($, T);
        }, k = ($) => {
          var T = tt();
          ke(() => Ie(T, o() || s())), A($, T);
        };
        ue(w, ($) => {
          i() ? $(C) : $(k, !1);
        });
      }
      A(_, y);
    };
    let h = /* @__PURE__ */ O(() => Se("data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 ps-2 pe-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", n()));
    Q(c, () => Kw, (_, b) => {
      b(_, ce(
        {
          get value() {
            return s();
          },
          "data-slot": "select-item",
          get class() {
            return d(h);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          children: f,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, u), H(l);
}
K(ZS, { ref: {}, class: {}, value: {}, label: {}, children: {} }, [], [], { mode: "open" });
function QS(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = M(), s = D(n);
  Q(s, () => lu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(QS, {}, [], [], { mode: "open" });
function ex(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex cursor-default items-center justify-center py-1", n()));
    Q(a, () => Xw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "select-scroll-up-button",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          },
          children: (f, h) => {
            k_(f, { class: "size-4" });
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(ex, { ref: {}, class: {} }, [], [], { mode: "open" });
function tx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex cursor-default items-center justify-center py-1", n()));
    Q(a, () => Yw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "select-scroll-down-button",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          },
          children: (f, h) => {
            Hs(f, { class: "size-4" });
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(tx, { ref: {}, class: {} }, [], [], { mode: "open" });
var LR = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function rx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "sideOffset", 7, 4), o = v(e, "portalProps", 7), i = v(e, "children", 7), a = v(e, "preventScroll", 7, !0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "sideOffset",
    "portalProps",
    "children",
    "preventScroll"
  ]);
  var u = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(c = 4) {
      s(c), m();
    },
    get portalProps() {
      return o();
    },
    set portalProps(c) {
      o(c), m();
    },
    get children() {
      return i();
    },
    set children(c) {
      i(c), m();
    },
    get preventScroll() {
      return a();
    },
    set preventScroll(c = !0) {
      a(c), m();
    }
  };
  return QS(t, ce(o, {
    children: (c, f) => {
      var h = M(), _ = D(h);
      {
        let b = /* @__PURE__ */ O(() => Se("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-end-2 data-[side=right]:slide-in-from-start-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--bits-select-content-available-height) min-w-[8rem] origin-(--bits-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", n()));
        Q(_, () => Uw, (p, g) => {
          g(p, ce(
            {
              get sideOffset() {
                return s();
              },
              get preventScroll() {
                return a();
              },
              "data-slot": "select-content",
              get class() {
                return d(b);
              }
            },
            () => l,
            {
              get ref() {
                return r();
              },
              set ref(y) {
                r(y);
              },
              children: (y, S) => {
                var x = LR(), P = D(x);
                ex(P, {});
                var w = be(P, 2);
                {
                  let k = /* @__PURE__ */ O(() => Se("h-(--bits-select-anchor-height) w-full min-w-(--bits-select-anchor-width) scroll-my-1 p-1"));
                  Q(w, () => Gw, ($, T) => {
                    T($, {
                      get class() {
                        return d(k);
                      },
                      children: (E, I) => {
                        var F = M(), U = D(F);
                        te(U, () => i() ?? he), A(E, F);
                      },
                      $$slots: { default: !0 }
                    });
                  });
                }
                var C = be(w, 2);
                tx(C, {}), A(y, x);
              },
              $$slots: { default: !0 }
            }
          ));
        });
      }
      A(c, h);
    },
    $$slots: { default: !0 }
  })), H(u);
}
K(
  rx,
  {
    ref: {},
    class: {},
    sideOffset: {},
    portalProps: {},
    children: {},
    preventScroll: {}
  },
  [],
  [],
  { mode: "open" }
);
var jR = /* @__PURE__ */ ne("<!> <!>", 1);
function nx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "size", 7, "default"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "size"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get size() {
      return o();
    },
    set size(c = "default") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none select-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(u, () => k1, (f, h) => {
      h(f, ce(
        {
          "data-slot": "select-trigger",
          get "data-size"() {
            return o();
          },
          get class() {
            return d(c);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          children: (_, b) => {
            var p = jR(), g = D(p);
            te(g, () => s() ?? he);
            var y = be(g, 2);
            Hs(y, { class: "size-4 opacity-50" }), A(_, p);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(nx, { ref: {}, class: {}, children: {}, size: {} }, [], [], { mode: "open" });
function BR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(i = null) {
      r(i), m();
    },
    get class() {
      return n();
    },
    set class(i) {
      n(i), m();
    }
  };
  {
    let i = /* @__PURE__ */ O(() => Se("bg-border pointer-events-none -mx-1 my-1 h-px", n()));
    yu(t, ce(
      {
        "data-slot": "select-separator",
        get class() {
          return d(i);
        }
      },
      () => s,
      {
        get ref() {
          return r();
        },
        set ref(a) {
          r(a);
        }
      }
    ));
  }
  return H(o);
}
K(BR, { ref: {}, class: {} }, [], [], { mode: "open" });
function zR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("text-muted-foreground px-2 py-1.5 text-xs", n()));
    Q(l, () => Hw, (c, f) => {
      f(c, ce(
        {
          "data-slot": "select-group-heading",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          },
          children: (h, _) => {
            var b = M(), p = D(b);
            te(p, () => s() ?? he), A(h, b);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(zR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var qR = /* @__PURE__ */ ne('<span data-slot="slider-track"><!></span> <!>', 1);
function sx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "orientation", 7, "horizontal"), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "orientation",
    "class"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get value() {
      return n();
    },
    set value(c) {
      n(c), m();
    },
    get orientation() {
      return s();
    },
    set orientation(c = "horizontal") {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    const c = (h, _) => {
      let b = () => _?.().thumbs;
      var p = qR(), g = D(p), y = ge(g);
      {
        let x = /* @__PURE__ */ O(() => Se("bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"));
        Q(y, () => D1, (P, w) => {
          w(P, {
            "data-slot": "slider-range",
            get class() {
              return d(x);
            }
          });
        });
      }
      de(g);
      var S = be(g, 2);
      st(S, 16, b, (x) => x, (x, P) => {
        var w = M(), C = D(w);
        Q(C, () => M1, (k, $) => {
          $(k, {
            "data-slot": "slider-thumb",
            get index() {
              return P;
            },
            class: "border-primary ring-ring/50 block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
          });
        }), A(x, w);
      }), ke(
        (x) => {
          An(g, "data-orientation", s()), ls(g, 1, x);
        },
        [
          () => as(Se("bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"))
        ]
      ), A(h, p);
    };
    let f = /* @__PURE__ */ O(() => Se("relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col", o()));
    Q(u, () => T1, (h, _) => {
      _(h, ce(
        {
          "data-slot": "slider",
          get orientation() {
            return s();
          },
          get class() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get value() {
            return n();
          },
          set value(b) {
            n(b);
          },
          children: c,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(sx, { ref: {}, value: {}, orientation: {}, class: {} }, [], [], { mode: "open" });
function ox(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "checked", 15, !1), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "checked"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get checked() {
      return s();
    },
    set checked(u = !1) {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(l, () => F1, (c, f) => {
      f(c, ce(
        {
          "data-slot": "switch",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          },
          get checked() {
            return s();
          },
          set checked(h) {
            s(h);
          },
          children: (h, _) => {
            var b = M(), p = D(b);
            {
              let g = /* @__PURE__ */ O(() => Se("bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"));
              Q(p, () => R1, (y, S) => {
                S(y, {
                  "data-slot": "switch-thumb",
                  get class() {
                    return d(g);
                  }
                });
              });
            }
            A(h, b);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(ox, { ref: {}, class: {}, checked: {} }, [], [], { mode: "open" });
var UR = /* @__PURE__ */ ne("<textarea></textarea>");
function ix(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "data-slot", 7, "textarea"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "data-slot"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get value() {
      return n();
    },
    set value(u) {
      n(u), m();
    },
    get class() {
      return s();
    },
    set class(u) {
      s(u), m();
    },
    get "data-slot"() {
      return o();
    },
    set "data-slot"(u = "textarea") {
      o(u), m();
    }
  }, l = UR();
  return Av(l), ve(l, (u) => ({ "data-slot": o(), class: u, ...i }), [
    () => Se("border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", s())
  ]), et(l, (u) => r(u), () => r()), go(l, n), A(t, l), H(a);
}
K(ix, { ref: {}, value: {}, class: {}, "data-slot": {} }, [], [], { mode: "open" });
const ax = Ri({
  base: "hover:bg-muted hover:text-muted-foreground data-[state=on]:bg-accent data-[state=on]:text-accent-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-transparent",
      outline: "border-input hover:bg-accent hover:text-accent-foreground border bg-transparent shadow-xs"
    },
    size: {
      default: "h-9 min-w-9 px-2",
      sm: "h-8 min-w-8 px-1.5",
      lg: "h-10 min-w-10 px-2.5"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
function KR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "pressed", 15, !1), s = v(e, "class", 7), o = v(e, "size", 7, "default"), i = v(e, "variant", 7, "default"), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "pressed",
    "class",
    "size",
    "variant"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get pressed() {
      return n();
    },
    set pressed(f = !1) {
      n(f), m();
    },
    get class() {
      return s();
    },
    set class(f) {
      s(f), m();
    },
    get size() {
      return o();
    },
    set size(f = "default") {
      o(f), m();
    },
    get variant() {
      return i();
    },
    set variant(f = "default") {
      i(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => Se(ax({ variant: i(), size: o() }), s()));
    Q(c, () => V1, (h, _) => {
      _(h, ce(
        {
          "data-slot": "toggle",
          get class() {
            return d(f);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get pressed() {
            return n();
          },
          set pressed(b) {
            n(b);
          }
        }
      ));
    });
  }
  return A(t, u), H(l);
}
K(KR, { ref: {}, pressed: {}, class: {}, size: {}, variant: {} }, [], [], { mode: "open" });
function WR(t) {
  Oo("toggleGroup", t);
}
function HR() {
  return Ms("toggleGroup");
}
function lx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "size", 7, "default"), i = v(e, "spacing", 7, 0), a = v(e, "variant", 7, "default"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "size",
    "spacing",
    "variant"
  ]);
  WR({ variant: a(), size: o(), spacing: i() });
  var u = {
    get ref() {
      return r();
    },
    set ref(h = null) {
      r(h), m();
    },
    get value() {
      return n();
    },
    set value(h) {
      n(h), m();
    },
    get class() {
      return s();
    },
    set class(h) {
      s(h), m();
    },
    get size() {
      return o();
    },
    set size(h = "default") {
      o(h), m();
    },
    get spacing() {
      return i();
    },
    set spacing(h = 0) {
      i(h), m();
    },
    get variant() {
      return a();
    },
    set variant(h = "default") {
      a(h), m();
    }
  }, c = M(), f = D(c);
  {
    let h = /* @__PURE__ */ O(() => `--gap: ${i()}`), _ = /* @__PURE__ */ O(() => Se("group/toggle-group flex w-fit items-center gap-[--spacing(var(--gap))] rounded-md data-[spacing=default]:data-[variant=outline]:shadow-xs", s()));
    Q(f, () => B1, (b, p) => {
      p(b, ce(
        {
          "data-slot": "toggle-group",
          get "data-variant"() {
            return a();
          },
          get "data-size"() {
            return o();
          },
          get "data-spacing"() {
            return i();
          },
          get style() {
            return d(h);
          },
          get class() {
            return d(_);
          }
        },
        () => l,
        {
          get value() {
            return n();
          },
          set value(g) {
            n(g);
          },
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          }
        }
      ));
    });
  }
  return A(t, c), H(u);
}
K(
  lx,
  {
    ref: {},
    value: {},
    class: {},
    size: {},
    spacing: {},
    variant: {}
  },
  [],
  [],
  { mode: "open" }
);
function ux(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "size", 7), i = v(e, "variant", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "size",
    "variant"
  ]);
  const l = HR();
  var u = {
    get ref() {
      return r();
    },
    set ref(h = null) {
      r(h), m();
    },
    get value() {
      return n();
    },
    set value(h) {
      n(h), m();
    },
    get class() {
      return s();
    },
    set class(h) {
      s(h), m();
    },
    get size() {
      return o();
    },
    set size(h) {
      o(h), m();
    },
    get variant() {
      return i();
    },
    set variant(h) {
      i(h), m();
    }
  }, c = M(), f = D(c);
  {
    let h = /* @__PURE__ */ O(() => l.variant || i()), _ = /* @__PURE__ */ O(() => l.size || o()), b = /* @__PURE__ */ O(() => Se(ax({ variant: l.variant || i(), size: l.size || o() }), "w-auto min-w-0 shrink-0 px-3 focus:z-10 focus-visible:z-10 data-[spacing=0]:rounded-none data-[spacing=0]:shadow-none data-[spacing=0]:first:rounded-l-md data-[spacing=0]:last:rounded-r-md data-[spacing=0]:data-[variant=outline]:border-l-0 data-[spacing=0]:data-[variant=outline]:first:border-l", s()));
    Q(f, () => z1, (p, g) => {
      g(p, ce(
        {
          "data-slot": "toggle-group-item",
          get "data-variant"() {
            return d(h);
          },
          get "data-size"() {
            return d(_);
          },
          get "data-spacing"() {
            return l.spacing;
          },
          get class() {
            return d(b);
          },
          get value() {
            return n();
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(y) {
            r(y);
          }
        }
      ));
    });
  }
  return A(t, c), H(u);
}
K(ux, { ref: {}, value: {}, class: {}, size: {}, variant: {} }, [], [], { mode: "open" });
var GR = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function cx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Checkbox), i = /* @__PURE__ */ O(() => d(s).FieldLabel);
  let a = v(e, "value", 15), l = v(e, "options", 7), u = v(e, "config", 7), c = v(e, "handlers", 7);
  const f = w_({
    mapper: () => Mo(l()),
    value: () => a(),
    update: (w) => a(w)
  }), h = /* @__PURE__ */ O(() => new Set(f.current)), _ = /* @__PURE__ */ O(() => c().oninput), b = /* @__PURE__ */ O(() => c().onchange), p = /* @__PURE__ */ O(() => Nn(c(), ["oninput", "onchange"])), g = /* @__PURE__ */ O(() => mr(r, u().path)), y = /* @__PURE__ */ O(() => pr(r, u(), "shadcn4Checkboxes", cn(d(p))({ ...c(), name: d(g), required: u().required })));
  var S = {
    get value() {
      return a();
    },
    set value(w) {
      a(w), m();
    },
    get options() {
      return l();
    },
    set options(w) {
      l(w), m();
    },
    get config() {
      return u();
    },
    set config(w) {
      u(w), m();
    },
    get handlers() {
      return c();
    },
    set handlers(w) {
      c(w), m();
    }
  }, x = M(), P = D(x);
  return st(P, 17, l, (w) => w.id, (w, C) => {
    var k = GR(), $ = ge(k);
    {
      let E = /* @__PURE__ */ O(() => d(h).has(d(C).id)), I = /* @__PURE__ */ O(() => d(C).disabled || d(y).disabled);
      Q($, () => d(o), (F, U) => {
        U(F, ce(
          {
            get checked() {
              return d(E);
            },
            get value() {
              return d(C).id;
            },
            onCheckedChange: (B) => {
              f.current = B ? f.current.concat(d(C).id) : f.current.filter((R) => R !== d(C).id), d(_)?.(), d(b)?.();
            }
          },
          () => d(y),
          {
            get id() {
              return d(C).id;
            },
            get disabled() {
              return d(I);
            }
          }
        ));
      });
    }
    var T = be($, 2);
    Q(T, () => d(i), (E, I) => {
      I(E, {
        get for() {
          return d(C).id;
        },
        children: (F, U) => {
          vt();
          var B = tt();
          ke(() => Ie(B, d(C).label)), A(F, B);
        },
        $$slots: { default: !0 }
      });
    }), de(k), A(w, k);
  }), A(t, x), H(S);
}
K(cx, { value: {}, options: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.checkboxesWidget = cx;
function Cl(...t) {
  return Qd(io(t));
}
var YR = /* @__PURE__ */ ne("<span> </span> <!>", 1), XR = /* @__PURE__ */ ne("<!> ", 1), JR = /* @__PURE__ */ ne("<!> <!>", 1), ZR = /* @__PURE__ */ ne("<!> <!>", 1), QR = /* @__PURE__ */ ne("<!> <!>", 1);
function dx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Popover), i = /* @__PURE__ */ O(() => d(s).PopoverContent), a = /* @__PURE__ */ O(() => d(s).PopoverTrigger), l = /* @__PURE__ */ O(() => d(s).Button), u = /* @__PURE__ */ O(() => d(s).CommandInput), c = /* @__PURE__ */ O(() => d(s).Command), f = /* @__PURE__ */ O(() => d(s).CommandList), h = /* @__PURE__ */ O(() => d(s).CommandEmpty), _ = /* @__PURE__ */ O(() => d(s).CommandGroup), b = /* @__PURE__ */ O(() => d(s).CommandItem);
  let p = v(e, "value", 15), g = v(e, "config", 7), y = v(e, "handlers", 7), S = v(e, "options", 7);
  const x = /* @__PURE__ */ O(() => new Map(S().map((Y) => [Y.id, Y.label]))), P = nu({
    mapper: () => Mo(S()),
    value: () => p(),
    update: (Y) => p(Y)
  });
  let w = /* @__PURE__ */ xe(!1), C = /* @__PURE__ */ xe(null);
  function k() {
    q(w, !1), Vl().then(() => {
      d(C).focus();
    });
  }
  const $ = /* @__PURE__ */ O(() => Ni(r, g(), "shadcn4ComboboxInput", y(), {})), T = /* @__PURE__ */ O(() => d(x).get(P.current) ?? d($).placeholder), E = /* @__PURE__ */ O(() => Nt(r, g(), "shadcn4ComboboxEmptyText")), I = /* @__PURE__ */ O(() => y().oninput), F = /* @__PURE__ */ O(() => y().onchange), U = /* @__PURE__ */ O(() => Nn(y(), ["oninput", "onchange"]));
  var B = {
    get value() {
      return p();
    },
    set value(Y) {
      p(Y), m();
    },
    get config() {
      return g();
    },
    set config(Y) {
      g(Y), m();
    },
    get handlers() {
      return y();
    },
    set handlers(Y) {
      y(Y), m();
    },
    get options() {
      return S();
    },
    set options(Y) {
      S(Y), m();
    }
  }, R = M(), Z = D(R);
  return Q(Z, () => d(o), (Y, X) => {
    X(Y, {
      get open() {
        return d(w);
      },
      set open(ae) {
        q(w, ae, !0);
      },
      children: (ae, J) => {
        var j = QR(), ee = D(j);
        {
          const N = (G, fe) => {
            let se = () => fe?.().props;
            var we = M(), le = D(we);
            {
              let re = /* @__PURE__ */ O(() => Ft(
                r,
                g(),
                {
                  variant: "outline",
                  ...se(),
                  role: "combobox",
                  "aria-expanded": d(w)
                },
                St("shadcn4ComboboxTrigger"),
                cn(d(U)),
                Ws
              ));
              Q(le, () => d(l), (oe, pe) => {
                pe(oe, ce(() => d(re), {
                  children: (ye, Pe) => {
                    var Oe = YR(), Ve = D(Oe), Ke = ge(Ve, !0);
                    de(Ve);
                    var Le = be(Ve, 2);
                    $_(Le, { class: "ml-2 size-4 shrink-0 opacity-50" }), ke(() => Ie(Ke, d(T))), A(ye, Oe);
                  },
                  $$slots: { default: !0 }
                }));
              });
            }
            A(G, we);
          };
          let V = /* @__PURE__ */ O(() => Do({}, g(), r));
          Q(ee, () => d(a), (G, fe) => {
            fe(G, ce({ class: "w-full justify-between" }, () => d(V), {
              get ref() {
                return d(C);
              },
              set ref(se) {
                q(C, se, !0);
              },
              child: N,
              $$slots: { child: !0 }
            }));
          });
        }
        var L = be(ee, 2);
        Q(L, () => d(i), (N, V) => {
          V(N, {
            class: "w-[200px] p-0",
            children: (G, fe) => {
              var se = M(), we = D(se);
              Q(we, () => d(c), (le, re) => {
                re(le, {
                  children: (oe, pe) => {
                    var ye = ZR(), Pe = D(ye);
                    Q(Pe, () => d(u), (Ve, Ke) => {
                      Ke(Ve, ce(() => d($)));
                    });
                    var Oe = be(Pe, 2);
                    Q(Oe, () => d(f), (Ve, Ke) => {
                      Ke(Ve, {
                        children: (Le, je) => {
                          var We = JR(), gt = D(We);
                          {
                            var Ze = (lt) => {
                              var ct = M(), pt = D(ct);
                              Q(pt, () => d(h), (Kt, yt) => {
                                yt(Kt, {
                                  children: (Vt, Mt) => {
                                    vt();
                                    var Wt = tt();
                                    ke(() => Ie(Wt, d(E))), A(Vt, Wt);
                                  },
                                  $$slots: { default: !0 }
                                });
                              }), A(lt, ct);
                            };
                            ue(gt, (lt) => {
                              d(E) && lt(Ze);
                            });
                          }
                          var $t = be(gt, 2);
                          Q($t, () => d(_), (lt, ct) => {
                            ct(lt, {
                              children: (pt, Kt) => {
                                var yt = M(), Vt = D(yt);
                                st(Vt, 17, S, (Mt) => Mt.id, (Mt, Wt) => {
                                  var Ht = M(), fn = D(Ht);
                                  Q(fn, () => d(b), (sr, or) => {
                                    or(sr, {
                                      get value() {
                                        return d(Wt).label;
                                      },
                                      onSelect: () => {
                                        P.current = d(Wt).id, d(I)?.(), d(F)?.(), k();
                                      },
                                      get disabled() {
                                        return d(Wt).disabled;
                                      },
                                      children: (kr, Xs) => {
                                        var yr = XR(), Wr = D(yr);
                                        {
                                          let bu = /* @__PURE__ */ O(() => Cl("mr-2 size-4", P.current !== d(Wt).id && "text-transparent"));
                                          su(Wr, {
                                            get class() {
                                              return d(bu);
                                            }
                                          });
                                        }
                                        var Uo = be(Wr);
                                        ke(() => Ie(Uo, ` ${d(Wt).label ?? ""}`)), A(kr, yr);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(Mt, Ht);
                                }), A(pt, yt);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(Le, We);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(oe, ye);
                  },
                  $$slots: { default: !0 }
                });
              }), A(G, se);
            },
            $$slots: { default: !0 }
          });
        }), A(ae, j);
      },
      $$slots: { default: !0 }
    });
  }), A(t, R), H(B);
}
K(dx, { value: {}, config: {}, handlers: {}, options: {} }, [], [], { mode: "open" });
rr.comboboxWidget = dx;
var e5 = /* @__PURE__ */ ne("<!> <!>", 1);
function fx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Popover), i = /* @__PURE__ */ O(() => d(s).PopoverTrigger), a = /* @__PURE__ */ O(() => d(s).Button), l = /* @__PURE__ */ O(() => d(s).PopoverContent), u = /* @__PURE__ */ O(() => d(s).Calendar);
  let c = v(e, "value", 15), f = v(e, "config", 7), h = v(e, "handlers", 7);
  const _ = /* @__PURE__ */ O(() => h().oninput), b = /* @__PURE__ */ O(() => h().onchange), p = /* @__PURE__ */ O(() => Nn(h(), ["oninput", "onchange"])), g = /* @__PURE__ */ O(() => pr(r, f(), "shadcn4DatePicker", {
    initialFocus: !0,
    onValueChange: () => {
      d(_)?.(), d(b)?.();
    }
  })), y = /* @__PURE__ */ O(() => c() !== void 0 ? Pi(c()) : void 0), S = /* @__PURE__ */ O(() => {
    const k = Nt(r, f(), "shadcn4DateFormatter");
    if (k !== void 0)
      return k;
    const $ = new Intl.DateTimeFormat(void 0, { year: "numeric", month: "2-digit", day: "numeric" });
    return (T) => $.format(T);
  }), x = /* @__PURE__ */ O(() => {
    const k = d(y);
    return k === void 0 ? d(g).placeholder : d(S)(k.toDate(ft()));
  });
  var P = {
    get value() {
      return c();
    },
    set value(k) {
      c(k), m();
    },
    get config() {
      return f();
    },
    set config(k) {
      f(k), m();
    },
    get handlers() {
      return h();
    },
    set handlers(k) {
      h(k), m();
    }
  }, w = M(), C = D(w);
  return Q(C, () => d(o), (k, $) => {
    $(k, {
      children: (T, E) => {
        var I = e5(), F = D(I);
        {
          const B = (R, Z) => {
            let Y = () => Z?.().props;
            var X = M(), ae = D(X);
            {
              let J = /* @__PURE__ */ O(() => [
                "w-full",
                d(y) === void 0 && "text-muted-foreground"
              ]), j = /* @__PURE__ */ O(() => Ft(r, f(), {}, St("shadcn4DatePickerTrigger"), cn(d(p)), Ws));
              Q(ae, () => d(a), (ee, L) => {
                L(ee, ce(
                  Y,
                  {
                    get class() {
                      return d(J);
                    }
                  },
                  () => d(j),
                  {
                    children: (N, V) => {
                      vt();
                      var G = tt();
                      ke(() => Ie(G, d(x))), A(N, G);
                    },
                    $$slots: { default: !0 }
                  }
                ));
              });
            }
            A(R, X);
          };
          Q(F, () => d(i), (R, Z) => {
            Z(R, { child: B, $$slots: { child: !0 } });
          });
        }
        var U = be(F, 2);
        Q(U, () => d(l), (B, R) => {
          R(B, {
            children: (Z, Y) => {
              var X = M(), ae = D(X), J = () => d(y), j = (ee) => {
                c(ee?.toDate(ft()).toLocaleDateString("en-CA"));
              };
              Q(ae, () => d(u), (ee, L) => {
                L(ee, ce(
                  {
                    get value() {
                      return J();
                    },
                    set value(N) {
                      j(N);
                    }
                  },
                  () => d(g),
                  { type: "single" }
                ));
              }), A(Z, X);
            },
            $$slots: { default: !0 }
          });
        }), A(T, I);
      },
      $$slots: { default: !0 }
    });
  }), A(t, w), H(P);
}
K(fx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.datePickerWidget = fx;
const rd = Ri({
  base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
      destructive: "bg-destructive shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white",
      outline: "bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border",
      secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
var t5 = /* @__PURE__ */ ne("<a><!></a>"), r5 = /* @__PURE__ */ ne("<button><!></button>");
function n5(t, e) {
  W(e, !0);
  let r = v(e, "class", 7), n = v(e, "variant", 7, "default"), s = v(e, "size", 7, "default"), o = v(e, "ref", 15, null), i = v(e, "href", 7, void 0), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7), u = v(e, "children", 7), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "class",
    "variant",
    "size",
    "ref",
    "href",
    "type",
    "disabled",
    "children"
  ]);
  var f = {
    get class() {
      return r();
    },
    set class(g) {
      r(g), m();
    },
    get variant() {
      return n();
    },
    set variant(g = "default") {
      n(g), m();
    },
    get size() {
      return s();
    },
    set size(g = "default") {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get href() {
      return i();
    },
    set href(g = void 0) {
      i(g), m();
    },
    get type() {
      return a();
    },
    set type(g = "button") {
      a(g), m();
    },
    get disabled() {
      return l();
    },
    set disabled(g) {
      l(g), m();
    },
    get children() {
      return u();
    },
    set children(g) {
      u(g), m();
    }
  }, h = M(), _ = D(h);
  {
    var b = (g) => {
      var y = t5();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          href: l() ? void 0 : i(),
          "aria-disabled": l(),
          role: l() ? "link" : void 0,
          tabindex: l() ? -1 : void 0,
          ...c
        }),
        [
          () => Cl(rd({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), et(y, (x) => o(x), () => o()), A(g, y);
    }, p = (g) => {
      var y = r5();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          type: a(),
          disabled: l(),
          ...c
        }),
        [
          () => Cl(rd({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), et(y, (x) => o(x), () => o()), A(g, y);
    };
    ue(_, (g) => {
      i() ? g(b) : g(p, !1);
    });
  }
  return A(t, h), H(f);
}
K(
  n5,
  {
    class: {},
    variant: {},
    size: {},
    ref: {},
    href: {},
    type: {},
    disabled: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var s5 = /* @__PURE__ */ ne("<!> ", 1), o5 = /* @__PURE__ */ ne("<!> <!>", 1);
function ag(t, e) {
  W(e, !0);
  const r = Ee(), n = ut();
  let s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "handlers", 7);
  const a = /* @__PURE__ */ O(() => i().oninput), l = /* @__PURE__ */ O(() => i().onchange), u = /* @__PURE__ */ O(() => Nn(i(), ["oninput", "onchange"])), c = /* @__PURE__ */ O(() => n.components), f = /* @__PURE__ */ O(() => d(c).Popover), h = /* @__PURE__ */ O(() => d(c).PopoverTrigger), _ = /* @__PURE__ */ O(() => d(c).PopoverContent), b = /* @__PURE__ */ O(() => d(c).RangeCalendar), p = /* @__PURE__ */ O(() => pr(r, o(), "shadcn4DateRangePicker", {
    numberOfMonths: 2,
    onValueChange: () => {
      d(a)?.(), d(l)?.();
    }
  })), g = /* @__PURE__ */ O(() => {
    const w = Nt(r, o(), "shadcn4DateRangeFormatter");
    if (w !== void 0)
      return w;
    const C = Nt(r, o(), "shadcn4DateRangePickerPlaceholder"), k = new jt("en-US", { dateStyle: "medium" });
    return ({ start: $, end: T }) => $ && T ? `${k.format($.toDate(ft()))} - ${k.format(T.toDate(ft()))}` : $ ? k.format($.toDate(ft())) : C;
  }), y = /* @__PURE__ */ O(() => ({
    start: typeof s()?.start == "string" ? Pi(s().start) : void 0,
    end: typeof s()?.end == "string" ? Pi(s().end) : void 0
  }));
  var S = {
    get value() {
      return s();
    },
    set value(w) {
      s(w), m();
    },
    get config() {
      return o();
    },
    set config(w) {
      o(w), m();
    },
    get handlers() {
      return i();
    },
    set handlers(w) {
      i(w), m();
    }
  }, x = M(), P = D(x);
  return Q(P, () => d(f), (w, C) => {
    C(w, {
      children: (k, $) => {
        var T = o5(), E = D(T);
        {
          let F = /* @__PURE__ */ O(() => Cl(
            rd({
              variant: "outline",
              class: "justify-start text-start font-normal"
            }),
            !s() && "text-muted-foreground"
          ));
          Q(E, () => d(h), (U, B) => {
            B(U, ce(() => d(u), {
              get class() {
                return d(F);
              },
              children: (R, Z) => {
                var Y = s5(), X = D(Y);
                C_(X, { class: "me-2 size-4" });
                var ae = be(X);
                ke((J) => Ie(ae, ` ${J ?? ""}`), [() => d(g)(d(y))]), A(R, Y);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var I = be(E, 2);
        Q(I, () => d(_), (F, U) => {
          U(F, {
            class: "w-auto p-0",
            align: "start",
            children: (B, R) => {
              var Z = M(), Y = D(Z), X = () => d(y), ae = (J) => {
                const j = ft();
                s({
                  start: J?.start?.toDate(j).toLocaleDateString("en-CA"),
                  end: J?.end?.toDate(j).toLocaleDateString("en-CA")
                });
              };
              Q(Y, () => d(b), (J, j) => {
                j(J, ce(() => d(p), {
                  get value() {
                    return X();
                  },
                  set value(ee) {
                    ae(ee);
                  }
                }));
              }), A(B, Z);
            },
            $$slots: { default: !0 }
          });
        }), A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), H(S);
}
K(ag, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.dateRangePickerWidget = ag;
rr.shadcn4DateRangePickerWidget = ag;
var i5 = /* @__PURE__ */ ne("<input/>");
function a5(t, e) {
  W(e, !0);
  let r = v(e, "handlers", 7), n = v(e, "multiple", 7), s = v(e, "loading", 7), o = v(e, "processing", 7), i = v(e, "config", 7), a = v(e, "value", 15);
  const l = Ee(), u = /* @__PURE__ */ O(() => Ni(l, i(), "file", r(), {
    multiple: n(),
    class: "sjsf-file",
    "data-loading": s(),
    "data-processing": o()
  }));
  var c = {
    get handlers() {
      return r();
    },
    set handlers(h) {
      r(h), m();
    },
    get multiple() {
      return n();
    },
    set multiple(h) {
      n(h), m();
    },
    get loading() {
      return s();
    },
    set loading(h) {
      s(h), m();
    },
    get processing() {
      return o();
    },
    set processing(h) {
      o(h), m();
    },
    get config() {
      return i();
    },
    set config(h) {
      i(h), m();
    },
    get value() {
      return a();
    },
    set value(h) {
      a(h), m();
    }
  }, f = i5();
  return ve(f, () => ({ type: "file", ...d(u) }), void 0, void 0, void 0, void 0, !0), ay(f, a), A(t, f), H(c);
}
K(
  a5,
  {
    handlers: {},
    multiple: {},
    loading: {},
    processing: {},
    config: {},
    value: {}
  },
  [],
  [],
  { mode: "open" }
);
function hx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Input);
  let i = v(e, "config", 7), a = v(e, "handlers", 7), l = v(e, "multiple", 7), u = v(e, "loading", 7), c = v(e, "processing", 7), f = v(e, "value", 15);
  var h = {
    get config() {
      return i();
    },
    set config(p) {
      i(p), m();
    },
    get handlers() {
      return a();
    },
    set handlers(p) {
      a(p), m();
    },
    get multiple() {
      return l();
    },
    set multiple(p) {
      l(p), m();
    },
    get loading() {
      return u();
    },
    set loading(p) {
      u(p), m();
    },
    get processing() {
      return c();
    },
    set processing(p) {
      c(p), m();
    },
    get value() {
      return f();
    },
    set value(p) {
      f(p), m();
    }
  }, _ = M(), b = D(_);
  {
    let p = /* @__PURE__ */ O(() => Ni(r, i(), "file", a(), { multiple: l() }));
    Q(b, () => d(o), (g, y) => {
      y(g, ce(() => d(p), {
        type: "file",
        get "data-loading"() {
          return u();
        },
        get "data-processing"() {
          return c();
        },
        get files() {
          return f();
        },
        set files(S) {
          f(S);
        }
      }));
    });
  }
  return A(t, _), H(h);
}
K(
  hx,
  {
    config: {},
    handlers: {},
    multiple: {},
    loading: {},
    processing: {},
    value: {}
  },
  [],
  [],
  { mode: "open" }
);
rr.fileWidget = hx;
var l5 = /* @__PURE__ */ ne("<span> </span>"), u5 = /* @__PURE__ */ ne("<!> <!>", 1);
function gx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Select), i = /* @__PURE__ */ O(() => d(s).SelectTrigger), a = /* @__PURE__ */ O(() => d(s).SelectContent), l = /* @__PURE__ */ O(() => d(s).SelectItem);
  let u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7), h = v(e, "config", 7);
  const _ = /* @__PURE__ */ O(() => new Map(f().map(($) => [$.id, $.label]))), b = w_({
    mapper: () => Mo(f()),
    value: () => c(),
    update: ($) => c($)
  }), p = /* @__PURE__ */ O(() => u().oninput), g = /* @__PURE__ */ O(() => u().onchange), y = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), S = /* @__PURE__ */ O(() => pr(r, h(), "shadcn4MultiSelect", {
    onValueChange: () => {
      d(p)?.(), d(g)?.();
    },
    required: h().required
  })), x = /* @__PURE__ */ O(() => b.current.map(($) => d(_).get($)).join(", ") || d(S).placeholder), P = /* @__PURE__ */ O(() => mr(r, h().path));
  var w = {
    get handlers() {
      return u();
    },
    set handlers($) {
      u($), m();
    },
    get value() {
      return c();
    },
    set value($) {
      c($), m();
    },
    get options() {
      return f();
    },
    set options($) {
      f($), m();
    },
    get config() {
      return h();
    },
    set config($) {
      h($), m();
    }
  }, C = M(), k = D(C);
  return Q(k, () => d(o), ($, T) => {
    T($, ce(() => d(S), {
      type: "multiple",
      get value() {
        return b.current;
      },
      set value(E) {
        b.current = E;
      },
      children: (E, I) => {
        var F = u5(), U = D(F);
        {
          let R = /* @__PURE__ */ O(() => pr(r, h(), "shadcn4MultiSelectTrigger", cn(d(y))({ id: d(P), name: d(P) })));
          Q(U, () => d(i), (Z, Y) => {
            Y(Z, ce({ class: "w-full" }, () => d(R), {
              children: (X, ae) => {
                var J = l5(), j = ge(J, !0);
                de(J), ke(() => Ie(j, d(x))), A(X, J);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var B = be(U, 2);
        Q(B, () => d(a), (R, Z) => {
          Z(R, {
            children: (Y, X) => {
              var ae = M(), J = D(ae);
              st(J, 17, f, (j) => j.id, (j, ee) => {
                var L = M(), N = D(L);
                Q(N, () => d(l), (V, G) => {
                  G(V, {
                    get value() {
                      return d(ee).id;
                    },
                    get label() {
                      return d(ee).label;
                    },
                    get disabled() {
                      return d(ee).disabled;
                    }
                  });
                }), A(j, L);
              }), A(Y, ae);
            },
            $$slots: { default: !0 }
          });
        }), A(E, F);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, C), H(w);
}
K(gx, { handlers: {}, value: {}, options: {}, config: {} }, [], [], { mode: "open" });
rr.multiSelectWidget = gx;
function px(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).ToggleGroup), i = /* @__PURE__ */ O(() => d(s).ToggleGroupItem);
  let a = v(e, "value", 15), l = v(e, "config", 7), u = v(e, "handlers", 7), c = v(e, "options", 7);
  const f = nu({
    mapper: () => Mo(c()),
    value: () => a(),
    update: (x) => a(x)
  }), h = /* @__PURE__ */ O(() => u().oninput), _ = /* @__PURE__ */ O(() => u().onchange), b = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), p = /* @__PURE__ */ O(() => pr(r, l(), "shadcn4RadioButtons", {
    type: "single",
    id: mr(r, l().path),
    variant: "outline",
    onValueChange: () => {
      d(h)?.(), d(_)?.();
    }
  }));
  var g = {
    get value() {
      return a();
    },
    set value(x) {
      a(x), m();
    },
    get config() {
      return l();
    },
    set config(x) {
      l(x), m();
    },
    get handlers() {
      return u();
    },
    set handlers(x) {
      u(x), m();
    },
    get options() {
      return c();
    },
    set options(x) {
      c(x), m();
    }
  }, y = M(), S = D(y);
  return Q(S, () => d(o), (x, P) => {
    P(x, ce(() => d(p), {
      get value() {
        return f.current;
      },
      set value(w) {
        f.current = w;
      },
      children: (w, C) => {
        var k = M(), $ = D(k);
        st($, 17, c, (T) => T.id, (T, E) => {
          var I = M(), F = D(I);
          {
            let U = /* @__PURE__ */ O(() => Ft(r, l(), { value: d(E).id }, St("shadcn4RadioButtonsItem"), cn(d(b)), Ws));
            Q(F, () => d(i), (B, R) => {
              R(B, ce(() => d(U), {
                children: (Z, Y) => {
                  vt();
                  var X = tt();
                  ke(() => Ie(X, d(E).label)), A(Z, X);
                },
                $$slots: { default: !0 }
              }));
            });
          }
          A(T, I);
        }), A(w, k);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, y), H(g);
}
K(px, { value: {}, config: {}, handlers: {}, options: {} }, [], [], { mode: "open" });
rr.radioButtonsWidget = px;
var c5 = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function mx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).RadioGroup), i = /* @__PURE__ */ O(() => d(s).RadioGroupItem), a = /* @__PURE__ */ O(() => d(s).FieldLabel);
  let l = v(e, "config", 7), u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7);
  const h = nu({
    mapper: () => Mo(f()),
    value: () => c(),
    update: (S) => c(S)
  }), _ = /* @__PURE__ */ O(() => pr(r, l(), "shadcn4RadioGroup", { onValueChange: u().onchange })), b = /* @__PURE__ */ O(() => Ft(r, l(), { onclick: u().oninput, onblur: u().onblur }, St("shadcn4RadioItem"), Ws));
  var p = {
    get config() {
      return l();
    },
    set config(S) {
      l(S), m();
    },
    get handlers() {
      return u();
    },
    set handlers(S) {
      u(S), m();
    },
    get value() {
      return c();
    },
    set value(S) {
      c(S), m();
    },
    get options() {
      return f();
    },
    set options(S) {
      f(S), m();
    }
  }, g = M(), y = D(g);
  return Q(y, () => d(o), (S, x) => {
    x(S, ce(() => d(_), {
      get value() {
        return h.current;
      },
      set value(P) {
        h.current = P;
      },
      children: (P, w) => {
        var C = M(), k = D(C);
        st(k, 17, f, ($) => $.id, ($, T) => {
          var E = c5(), I = ge(E);
          Q(I, () => d(i), (U, B) => {
            B(U, ce(() => d(b), {
              get value() {
                return d(T).id;
              },
              get id() {
                return d(T).id;
              },
              get disabled() {
                return d(T).disabled;
              }
            }));
          });
          var F = be(I, 2);
          Q(F, () => d(a), (U, B) => {
            B(U, {
              get for() {
                return d(T).id;
              },
              children: (R, Z) => {
                vt();
                var Y = tt();
                ke(() => Ie(Y, d(T).label)), A(R, Y);
              },
              $$slots: { default: !0 }
            });
          }), de(E), A($, E);
        }), A(P, C);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, g), H(p);
}
K(mx, { config: {}, handlers: {}, value: {}, options: {} }, [], [], { mode: "open" });
rr.radioWidget = mx;
function vx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Slider);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ O(() => mr(r, a().path));
  var c = {
    get value() {
      return i();
    },
    set value(p) {
      i(p), m();
    },
    get config() {
      return a();
    },
    set config(p) {
      a(p), m();
    },
    get handlers() {
      return l();
    },
    set handlers(p) {
      l(p), m();
    }
  }, f = M(), h = D(f), _ = () => i() ?? 0, b = (p) => i(p);
  {
    let p = /* @__PURE__ */ O(() => pr(r, a(), "shadcn4Range", {
      id: d(u),
      min: a().schema.minimum,
      max: a().schema.maximum,
      step: a().schema.multipleOf,
      onValueChange: l().oninput,
      onValueCommit: l().onchange
    }));
    Q(h, () => d(o), (g, y) => {
      y(g, ce(
        {
          get value() {
            return _();
          },
          set value(S) {
            b(S);
          }
        },
        () => d(p),
        { type: "single" }
      ));
    });
  }
  return A(t, f), H(c);
}
K(vx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.rangeWidget = vx;
function yx(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "handlers", 7);
  const o = Ee(), i = ut(), a = /* @__PURE__ */ O(() => i.components), l = /* @__PURE__ */ O(() => d(a).Slider), u = /* @__PURE__ */ O(() => mr(o, n().path));
  var c = {
    get value() {
      return r();
    },
    set value(p) {
      r(p), m();
    },
    get config() {
      return n();
    },
    set config(p) {
      n(p), m();
    },
    get handlers() {
      return s();
    },
    set handlers(p) {
      s(p), m();
    }
  }, f = M(), h = D(f), _ = () => [r()?.start ?? 0, r()?.end ?? 0], b = (p) => {
    r({ start: p[0], end: p[1] });
  };
  {
    let p = /* @__PURE__ */ O(() => pr(o, n(), "shadcn4RangeSlider", {
      id: d(u),
      min: n().schema.minimum,
      max: n().schema.maximum,
      step: n().schema.multipleOf,
      onValueChange: s().oninput,
      onValueCommit: s().onchange
    }));
    Q(h, () => d(l), (g, y) => {
      y(g, ce(
        {
          get value() {
            return _();
          },
          set value(S) {
            b(S);
          }
        },
        () => d(p),
        { type: "multiple" }
      ));
    });
  }
  return A(t, f), H(c);
}
K(yx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.rangeSliderWidget = yx;
var d5 = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function bx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Switch), i = /* @__PURE__ */ O(() => d(s).FieldLabel);
  let a = v(e, "value", 15), l = v(e, "config", 7), u = v(e, "handlers", 7);
  const c = /* @__PURE__ */ O(() => u().oninput), f = /* @__PURE__ */ O(() => u().onchange), h = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), _ = /* @__PURE__ */ O(() => mr(r, l().path));
  var b = {
    get value() {
      return a();
    },
    set value(P) {
      a(P), m();
    },
    get config() {
      return l();
    },
    set config(P) {
      l(P), m();
    },
    get handlers() {
      return u();
    },
    set handlers(P) {
      u(P), m();
    }
  }, p = d5(), g = ge(p), y = () => a() ?? !1, S = (P) => a(P);
  {
    let P = /* @__PURE__ */ O(() => pr(r, l(), "shadcn4Switch", cn(d(h))({
      id: d(_),
      name: d(_),
      required: l().required,
      onCheckedChange: () => {
        d(c)?.(), d(f)?.();
      }
    })));
    Q(g, () => d(o), (w, C) => {
      C(w, ce(
        {
          get checked() {
            return y();
          },
          set checked(k) {
            S(k);
          }
        },
        () => d(P)
      ));
    });
  }
  var x = be(g, 2);
  return Q(x, () => d(i), (P, w) => {
    w(P, {
      get for() {
        return d(_);
      },
      children: (C, k) => {
        vt();
        var $ = tt();
        ke(() => Ie($, l().title)), A(C, $);
      },
      $$slots: { default: !0 }
    });
  }), de(p), A(t, p), H(b);
}
K(bx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.switchWidget = bx;
var f5 = /* @__PURE__ */ ne("<textarea></textarea>");
function h5(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "handlers", 7);
  const o = Ee(), i = /* @__PURE__ */ O(() => ub(o, n(), "textarea", s(), { class: "sjsf-textarea" }));
  var a = {
    get value() {
      return r();
    },
    set value(u) {
      r(u), m();
    },
    get config() {
      return n();
    },
    set config(u) {
      n(u), m();
    },
    get handlers() {
      return s();
    },
    set handlers(u) {
      s(u), m();
    }
  }, l = f5();
  return Av(l), ve(l, () => ({ ...d(i) })), go(l, r), A(t, l), H(a);
}
K(h5, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
function _x(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Textarea);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  var u = {
    get value() {
      return i();
    },
    set value(h) {
      i(h), m();
    },
    get config() {
      return a();
    },
    set config(h) {
      a(h), m();
    },
    get handlers() {
      return l();
    },
    set handlers(h) {
      l(h), m();
    }
  }, c = M(), f = D(c);
  {
    let h = /* @__PURE__ */ O(() => ub(r, a(), "textarea", l(), {}));
    Q(f, () => d(o), (_, b) => {
      b(_, ce(() => d(h), {
        get value() {
          return i();
        },
        set value(p) {
          i(p);
        }
      }));
    });
  }
  return A(t, c), H(u);
}
K(_x, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
rr.textareaWidget = _x;
function g5() {
  sE({
    components: {
      ButtonGroup: Q_,
      Field: bS,
      FieldLabel: PS,
      FieldError: kS,
      FieldDescription: CS,
      FieldGroup: SS,
      FieldLegend: wS,
      FieldTitle: OS,
      FieldSet: _S,
      Button: q1,
      Checkbox: iS,
      Input: $S,
      Select: JS,
      SelectContent: rx,
      SelectItem: ZS,
      SelectTrigger: nx,
      Textarea: ix,
      RadioGroup: MS,
      RadioGroupItem: IS,
      // @ts-expect-error - Can be safely ignored
      Command: ig,
      CommandEmpty: gS,
      CommandGroup: pS,
      CommandInput: vS,
      CommandItem: mS,
      CommandList: yS,
      Calendar: U1,
      ToggleGroup: lx,
      ToggleGroupItem: ux,
      Slider: sx,
      Switch: ox,
      Popover: AS,
      PopoverContent: TS,
      PopoverTrigger: DS,
      RangeCalendar: NS
    }
  });
}
const p5 = Qy(ME, {
  formataQrField: R_
});
function m5(t, e) {
  return hb({
    resolver: XA,
    theme: p5,
    icons: t7,
    idBuilder: Q$,
    validator: H$,
    merger: tA,
    translation: sA,
    schema: t.schema,
    uiSchema: t.uiSchema,
    onSubmitError: J$(),
    onSubmit: (r) => {
      e().dispatchEvent(
        new CustomEvent("submit", {
          bubbles: !0,
          composed: !0,
          cancelable: !0,
          detail: iA.serialize(r)
        })
      );
    }
  });
}
const v5 = "@layer properties{:host{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-pan-x:initial;--tw-pan-y:initial;--tw-pinch-zoom:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-divide-x-reverse:0;--tw-border-style:solid;--tw-divide-y-reverse:0;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-pan-x:initial;--tw-pan-y:initial;--tw-pinch-zoom:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-divide-x-reverse:0;--tw-border-style:solid;--tw-divide-y-reverse:0;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;--color-slate-50:oklch(98.4% .003 247.858);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-lg:32rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--tracking-widest:.1em;--leading-snug:1.375;--leading-normal:1.5;--radius-xs:.125rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{border-color:var(--border);outline-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){*{outline-color:color-mix(in oklab,var(--ring)50%,transparent)}}body{background-color:var(--background);color:var(--foreground)}}@layer components;@layer utilities{.\\@container\\/field-group{container:field-group/inline-size}.\\@container{container-type:inline-size}.pointer-events-none{pointer-events:none}.collapse{visibility:collapse}.invisible{visibility:hidden}.visible{visibility:visible}.sr-only{clip-path:inset(50%);white-space:nowrap;border-width:0;width:1px;height:1px;margin:-1px;padding:0;position:absolute;overflow:hidden}.not-sr-only{clip-path:none;white-space:normal;width:auto;height:auto;margin:0;padding:0;position:static;overflow:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.inset-0{inset:calc(var(--spacing)*0)}.inset-x-0{inset-inline:calc(var(--spacing)*0)}.start-1{inset-inline-start:calc(var(--spacing)*1)}.start-1\\/2{inset-inline-start:50%}.end-2{inset-inline-end:calc(var(--spacing)*2)}.end-4{inset-inline-end:calc(var(--spacing)*4)}.top-0{top:calc(var(--spacing)*0)}.top-1{top:calc(var(--spacing)*1)}.top-1\\/2{top:50%}.top-4{top:calc(var(--spacing)*4)}.top-\\[50\\%\\]{top:50%}.right-2{right:calc(var(--spacing)*2)}.left-1{left:calc(var(--spacing)*1)}.left-1\\/2,.left-\\[50\\%\\]{left:50%}.isolate{isolation:isolate}.isolation-auto{isolation:auto}.z-50{z-index:50}.container{width:100%}@media(min-width:40rem){.container{max-width:40rem}}@media(min-width:48rem){.container{max-width:48rem}}@media(min-width:64rem){.container{max-width:64rem}}@media(min-width:80rem){.container{max-width:80rem}}@media(min-width:96rem){.container{max-width:96rem}}.\\!m-0{margin:calc(var(--spacing)*0)!important}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.mx-auto{margin-inline:auto}.-my-2{margin-block:calc(var(--spacing)*-2)}.my-1{margin-block:calc(var(--spacing)*1)}.ms-4{margin-inline-start:calc(var(--spacing)*4)}.ms-auto{margin-inline-start:auto}.me-2{margin-inline-end:calc(var(--spacing)*2)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-4{margin-top:calc(var(--spacing)*4)}.mr-2{margin-right:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.ml-2{margin-left:calc(var(--spacing)*2)}.ml-4{margin-left:calc(var(--spacing)*4)}.ml-auto{margin-left:auto}.block{display:block}.contents{display:contents}.flex{display:flex}.flow-root{display:flow-root}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.inline-grid{display:inline-grid}.inline-table{display:inline-table}.list-item{display:list-item}.table{display:table}.table-caption{display:table-caption}.table-cell{display:table-cell}.table-column{display:table-column}.table-column-group{display:table-column-group}.table-footer-group{display:table-footer-group}.table-header-group{display:table-header-group}.table-row{display:table-row}.table-row-group{display:table-row-group}.field-sizing-content{field-sizing:content}.aspect-square{aspect-ratio:1}.size-\\(--cell-size\\){width:var(--cell-size);height:var(--cell-size)}.size-2{width:calc(var(--spacing)*2);height:calc(var(--spacing)*2)}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-3\\.5{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-9{width:calc(var(--spacing)*9);height:calc(var(--spacing)*9)}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.size-48{width:calc(var(--spacing)*48);height:calc(var(--spacing)*48)}.h-\\(--bits-select-anchor-height\\){height:var(--bits-select-anchor-height)}.h-\\(--cell-size\\){height:var(--cell-size)}.h-5{height:calc(var(--spacing)*5)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-\\[1\\.15rem\\]{height:1.15rem}.h-full{height:100%}.h-px{height:1px}.max-h-\\(--bits-select-content-available-height\\){max-height:var(--bits-select-content-available-height)}.max-h-\\[300px\\]{max-height:300px}.min-h-5{min-height:calc(var(--spacing)*5)}.min-h-16{min-height:calc(var(--spacing)*16)}.w-\\(--cell-size\\){width:var(--cell-size)}.w-8{width:calc(var(--spacing)*8)}.w-72{width:calc(var(--spacing)*72)}.w-\\[200px\\]{width:200px}.w-auto{width:auto}.w-fit{width:fit-content}.w-full{width:100%}.max-w-\\[calc\\(100\\%-2rem\\)\\]{max-width:calc(100% - 2rem)}.min-w-\\(--bits-select-anchor-width\\){min-width:var(--bits-select-anchor-width)}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-8{min-width:calc(var(--spacing)*8)}.min-w-9{min-width:calc(var(--spacing)*9)}.min-w-10{min-width:calc(var(--spacing)*10)}.min-w-\\[8rem\\]{min-width:8rem}.flex-1{flex:1}.shrink{flex-shrink:1}.shrink-0{flex-shrink:0}.grow{flex-grow:1}.border-collapse{border-collapse:collapse}.origin-\\(--bits-popover-content-transform-origin\\){transform-origin:var(--bits-popover-content-transform-origin)}.origin-\\(--bits-select-content-transform-origin\\){transform-origin:var(--bits-select-content-transform-origin)}.-translate-x-1{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-x-\\[-50\\%\\]{--tw-translate-x:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-\\[-50\\%\\]{--tw-translate-y:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-none{translate:none}.scale-3d{scale:var(--tw-scale-x)var(--tw-scale-y)var(--tw-scale-z)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-default{cursor:default}.touch-pinch-zoom{--tw-pinch-zoom:pinch-zoom;touch-action:var(--tw-pan-x,)var(--tw-pan-y,)var(--tw-pinch-zoom,)}.touch-none{touch-action:none}.resize{resize:both}.scroll-my-1{scroll-margin-block:calc(var(--spacing)*1)}.scroll-py-1{scroll-padding-block:calc(var(--spacing)*1)}.list-disc{list-style-type:disc}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-rows-\\[1fr\\]{grid-template-rows:1fr}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-start{justify-content:flex-start}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-6{gap:calc(var(--spacing)*6)}.gap-7{gap:calc(var(--spacing)*7)}.gap-\\[--spacing\\(var\\(--gap\\)\\)\\]{gap:calc(var(--spacing)*var(--gap))}:where(.space-y-reverse>:not(:last-child)){--tw-space-y-reverse:1}.gap-x-1{column-gap:calc(var(--spacing)*1)}.gap-x-1\\.5{column-gap:calc(var(--spacing)*1.5)}:where(.space-x-3>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*3)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-x-reverse)))}:where(.space-x-reverse>:not(:last-child)){--tw-space-x-reverse:1}:where(.divide-x>:not(:last-child)){--tw-divide-x-reverse:0;border-inline-style:var(--tw-border-style);border-inline-start-width:calc(1px*var(--tw-divide-x-reverse));border-inline-end-width:calc(1px*calc(1 - var(--tw-divide-x-reverse)))}:where(.divide-y>:not(:last-child)){--tw-divide-y-reverse:0;border-bottom-style:var(--tw-border-style);border-top-style:var(--tw-border-style);border-top-width:calc(1px*var(--tw-divide-y-reverse));border-bottom-width:calc(1px*calc(1 - var(--tw-divide-y-reverse)))}:where(.divide-y-reverse>:not(:last-child)){--tw-divide-y-reverse:1}.self-stretch{align-self:stretch}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:.25rem}.rounded-\\[4px\\]{border-radius:4px}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-none{border-radius:0}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xs{border-radius:var(--radius-xs)}.rounded-s{border-start-start-radius:.25rem;border-end-start-radius:.25rem}.rounded-ss{border-start-start-radius:.25rem}.rounded-e{border-start-end-radius:.25rem;border-end-end-radius:.25rem}.rounded-se{border-start-end-radius:.25rem}.rounded-ee{border-end-end-radius:.25rem}.rounded-es{border-end-start-radius:.25rem}.rounded-t{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.rounded-l{border-top-left-radius:.25rem;border-bottom-left-radius:.25rem}.rounded-tl{border-top-left-radius:.25rem}.rounded-r{border-top-right-radius:.25rem;border-bottom-right-radius:.25rem}.rounded-tr{border-top-right-radius:.25rem}.rounded-b{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.rounded-br{border-bottom-right-radius:.25rem}.rounded-bl{border-bottom-left-radius:.25rem}.border{border-style:var(--tw-border-style);border-width:1px}.border-x{border-inline-style:var(--tw-border-style);border-inline-width:1px}.border-y{border-block-style:var(--tw-border-style);border-block-width:1px}.border-s{border-inline-start-style:var(--tw-border-style);border-inline-start-width:1px}.border-e{border-inline-end-style:var(--tw-border-style);border-inline-end-width:1px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-r{border-right-style:var(--tw-border-style);border-right-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-l{border-left-style:var(--tw-border-style);border-left-width:1px}.border-input{border-color:var(--input)}.border-primary{border-color:var(--primary)}.border-transparent{border-color:#0000}.bg-background{background-color:var(--background)}.bg-black{background-color:var(--color-black)}.bg-black\\/50{background-color:#00000080}@supports (color:color-mix(in lab,red,red)){.bg-black\\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-border{background-color:var(--border)}.bg-destructive{background-color:var(--destructive)}.bg-input{background-color:var(--input)}.bg-muted{background-color:var(--muted)}.bg-popover{background-color:var(--popover)}.bg-primary{background-color:var(--primary)}.bg-secondary{background-color:var(--secondary)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.bg-repeat{background-repeat:repeat}.mask-no-clip{-webkit-mask-clip:no-clip;mask-clip:no-clip}.mask-repeat{-webkit-mask-repeat:repeat;mask-repeat:repeat}.fill-primary{fill:var(--primary)}.object-contain{object-fit:contain}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.px-\\(--cell-size\\){padding-inline:var(--cell-size)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-6{padding-inline:calc(var(--spacing)*6)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-6{padding-block:calc(var(--spacing)*6)}.ps-2{padding-inline-start:calc(var(--spacing)*2)}.ps-3{padding-inline-start:calc(var(--spacing)*3)}.pe-1{padding-inline-end:calc(var(--spacing)*1)}.pe-8{padding-inline-end:calc(var(--spacing)*8)}.pt-1{padding-top:calc(var(--spacing)*1)}.pt-1\\.5{padding-top:calc(var(--spacing)*1.5)}.pr-1{padding-right:calc(var(--spacing)*1)}.pr-8{padding-right:calc(var(--spacing)*8)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.text-center{text-align:center}.text-start{text-align:start}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[0\\.8rem\\]{font-size:.8rem}.leading-none{--tw-leading:1;line-height:1}.leading-normal{--tw-leading:var(--leading-normal);line-height:var(--leading-normal)}.leading-snug{--tw-leading:var(--leading-snug);line-height:var(--leading-snug)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-widest{--tw-tracking:var(--tracking-widest);letter-spacing:var(--tracking-widest)}.text-wrap{text-wrap:wrap}.text-clip{text-overflow:clip}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.text-current{color:currentColor}.text-destructive{color:var(--destructive)}.text-foreground{color:var(--foreground)}.text-muted-foreground{color:var(--muted-foreground)}.text-popover-foreground{color:var(--popover-foreground)}.text-primary{color:var(--primary)}.text-primary-foreground{color:var(--primary-foreground)}.text-secondary-foreground{color:var(--secondary-foreground)}.text-transparent{color:#0000}.text-white{color:var(--color-white)}.capitalize{text-transform:capitalize}.lowercase{text-transform:lowercase}.normal-case{text-transform:none}.uppercase{text-transform:uppercase}.italic{font-style:italic}.not-italic{font-style:normal}.diagonal-fractions{--tw-numeric-fraction:diagonal-fractions;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.lining-nums{--tw-numeric-figure:lining-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.oldstyle-nums{--tw-numeric-figure:oldstyle-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.ordinal{--tw-ordinal:ordinal;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.proportional-nums{--tw-numeric-spacing:proportional-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.slashed-zero{--tw-slashed-zero:slashed-zero;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.stacked-fractions{--tw-numeric-fraction:stacked-fractions;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.tabular-nums{--tw-numeric-spacing:tabular-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.normal-nums{font-variant-numeric:normal}.line-through{text-decoration-line:line-through}.no-underline{text-decoration-line:none}.overline{text-decoration-line:overline}.underline{text-decoration-line:underline}.underline-offset-4{text-underline-offset:4px}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.subpixel-antialiased{-webkit-font-smoothing:auto;-moz-osx-font-smoothing:auto}.opacity-0{opacity:0}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-none{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-0{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(0px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.inset-ring{--tw-inset-ring-shadow:inset 0 0 0 1px var(--tw-inset-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-ring,.ring-ring\\/50{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.ring-ring\\/50{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.ring-offset-background{--tw-ring-offset-color:var(--background)}.outline-hidden{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.outline-hidden{outline-offset:2px;outline:2px solid #0000}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow{--tw-drop-shadow-size:drop-shadow(0 1px 2px var(--tw-drop-shadow-color,#0000001a))drop-shadow(0 1px 1px var(--tw-drop-shadow-color,#0000000f));--tw-drop-shadow:drop-shadow(0 1px 2px #0000001a)drop-shadow(0 1px 1px #0000000f);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.grayscale{--tw-grayscale:grayscale(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.sepia{--tw-sepia:sepia(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter\\!{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)!important}.backdrop-blur{--tw-backdrop-blur:blur(8px);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-grayscale{--tw-backdrop-grayscale:grayscale(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-invert{--tw-backdrop-invert:invert(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-sepia{--tw-backdrop-sepia:sepia(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-\\[color\\,box-shadow\\]{transition-property:color,box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-shadow{transition-property:box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-none{transition-property:none}.duration-200{--tw-duration:.2s;transition-duration:.2s}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.\\[--cell-size\\:--spacing\\(8\\)\\]{--cell-size:calc(var(--spacing)*8)}:where(.divide-x-reverse>:not(:last-child)){--tw-divide-x-reverse:1}.ring-inset{--tw-ring-inset:inset}.zoom-in{--tw-enter-scale:0}.zoom-out{--tw-exit-scale:0}.group-has-\\[\\[data-orientation\\=horizontal\\]\\]\\/field\\:text-balance:is(:where(.group\\/field):has([data-orientation=horizontal]) *){text-wrap:balance}.group-data-\\[disabled\\=true\\]\\:pointer-events-none:is(:where(.group)[data-disabled=true] *){pointer-events:none}.group-data-\\[disabled\\=true\\]\\:opacity-50:is(:where(.group)[data-disabled=true] *),.group-data-\\[disabled\\=true\\]\\/field\\:opacity-50:is(:where(.group\\/field)[data-disabled=true] *){opacity:.5}.group-data-\\[variant\\=outline\\]\\/field-group\\:-mb-2:is(:where(.group\\/field-group)[data-variant=outline] *){margin-bottom:calc(var(--spacing)*-2)}.peer-disabled\\:cursor-not-allowed:is(:where(.peer):disabled~*){cursor:not-allowed}.peer-disabled\\:opacity-50:is(:where(.peer):disabled~*){opacity:.5}.selection\\:bg-primary ::selection{background-color:var(--primary)}.selection\\:bg-primary::selection{background-color:var(--primary)}.selection\\:text-primary-foreground ::selection{color:var(--primary-foreground)}.selection\\:text-primary-foreground::selection{color:var(--primary-foreground)}.placeholder\\:text-muted-foreground::placeholder{color:var(--muted-foreground)}.first\\:rounded-l-md:first-child{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.last\\:mt-0:last-child{margin-top:calc(var(--spacing)*0)}.last\\:rounded-r-md:last-child{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.focus-within\\:z-20:focus-within{z-index:20}@media(hover:hover){.hover\\:bg-accent:hover{background-color:var(--accent)}.hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}.hover\\:bg-muted:hover{background-color:var(--muted)}.hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}.hover\\:bg-secondary\\/80:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-secondary\\/80:hover{background-color:color-mix(in oklab,var(--secondary)80%,transparent)}}.hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}.hover\\:text-muted-foreground:hover{color:var(--muted-foreground)}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}.hover\\:ring-4:hover{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}.focus\\:relative:focus{position:relative}.focus\\:z-10:focus{z-index:10}.focus\\:border-ring:focus{border-color:var(--ring)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-ring:focus,.focus\\:ring-ring\\/50:focus{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus\\:ring-ring\\/50:focus{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus\\:ring-offset-2:focus{--tw-ring-offset-width:2px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}.focus\\:outline-hidden:focus{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.focus\\:outline-hidden:focus{outline-offset:2px;outline:2px solid #0000}}.focus-visible\\:z-10:focus-visible{z-index:10}.focus-visible\\:border-ring:focus-visible{border-color:var(--ring)}.focus-visible\\:ring-4:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-\\[3px\\]:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus-visible\\:outline-hidden:focus-visible{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.focus-visible\\:outline-hidden:focus-visible{outline-offset:2px;outline:2px solid #0000}}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.has-focus\\:border-ring:has(:focus){border-color:var(--ring)}.has-focus\\:ring-\\[3px\\]:has(:focus){--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.has-focus\\:ring-ring\\/50:has(:focus){--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.has-focus\\:ring-ring\\/50:has(:focus){--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.has-data-\\[state\\=checked\\]\\:border-primary:has([data-state=checked]){border-color:var(--primary)}.has-data-\\[state\\=checked\\]\\:bg-primary\\/5:has([data-state=checked]){background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.has-data-\\[state\\=checked\\]\\:bg-primary\\/5:has([data-state=checked]){background-color:color-mix(in oklab,var(--primary)5%,transparent)}}.has-\\[\\>\\[data-slot\\=button-group\\]\\]\\:gap-2:has(>[data-slot=button-group]){gap:calc(var(--spacing)*2)}.has-\\[\\>\\[data-slot\\=checkbox-group\\]\\]\\:gap-3:has(>[data-slot=checkbox-group]){gap:calc(var(--spacing)*3)}.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:items-start:has(>[data-slot=field-content]){align-items:flex-start}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:w-full:has(>[data-slot=field]){width:100%}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:flex-col:has(>[data-slot=field]){flex-direction:column}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:rounded-md:has(>[data-slot=field]){border-radius:calc(var(--radius) - 2px)}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:border:has(>[data-slot=field]){border-style:var(--tw-border-style);border-width:1px}.has-\\[\\>\\[data-slot\\=radio-group\\]\\]\\:gap-3:has(>[data-slot=radio-group]){gap:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-2\\.5:has(>svg){padding-inline:calc(var(--spacing)*2.5)}.has-\\[\\>svg\\]\\:px-3:has(>svg){padding-inline:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-4:has(>svg){padding-inline:calc(var(--spacing)*4)}.aria-disabled\\:pointer-events-none[aria-disabled=true]{pointer-events:none}.aria-disabled\\:opacity-50[aria-disabled=true]{opacity:.5}.aria-invalid\\:border-destructive[aria-invalid=true]{border-color:var(--destructive)}.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.aria-selected\\:bg-accent[aria-selected=true]{background-color:var(--accent)}.aria-selected\\:text-accent-foreground[aria-selected=true]{color:var(--accent-foreground)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:text-muted-foreground[data-disabled]{color:var(--muted-foreground)}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[disabled\\=true\\]\\:pointer-events-none[data-disabled=true]{pointer-events:none}.data-\\[disabled\\=true\\]\\:opacity-50[data-disabled=true]{opacity:.5}.data-\\[highlighted\\]\\:bg-accent[data-highlighted]{background-color:var(--accent)}.data-\\[highlighted\\]\\:text-accent-foreground[data-highlighted]{color:var(--accent-foreground)}.data-\\[invalid\\=true\\]\\:text-destructive[data-invalid=true]{color:var(--destructive)}.data-\\[orientation\\=horizontal\\]\\:h-1\\.5[data-orientation=horizontal]{height:calc(var(--spacing)*1.5)}.data-\\[orientation\\=horizontal\\]\\:h-full[data-orientation=horizontal]{height:100%}.data-\\[orientation\\=horizontal\\]\\:h-px[data-orientation=horizontal]{height:1px}.data-\\[orientation\\=horizontal\\]\\:w-full[data-orientation=horizontal]{width:100%}.data-\\[orientation\\=vertical\\]\\:h-auto[data-orientation=vertical]{height:auto}.data-\\[orientation\\=vertical\\]\\:h-full[data-orientation=vertical]{height:100%}.data-\\[orientation\\=vertical\\]\\:min-h-44[data-orientation=vertical]{min-height:calc(var(--spacing)*44)}.data-\\[orientation\\=vertical\\]\\:min-h-full[data-orientation=vertical]{min-height:100%}.data-\\[orientation\\=vertical\\]\\:w-1\\.5[data-orientation=vertical]{width:calc(var(--spacing)*1.5)}.data-\\[orientation\\=vertical\\]\\:w-auto[data-orientation=vertical]{width:auto}.data-\\[orientation\\=vertical\\]\\:w-full[data-orientation=vertical]{width:100%}.data-\\[orientation\\=vertical\\]\\:w-px[data-orientation=vertical]{width:1px}.data-\\[orientation\\=vertical\\]\\:flex-col[data-orientation=vertical]{flex-direction:column}.data-\\[placeholder\\]\\:text-muted-foreground[data-placeholder]{color:var(--muted-foreground)}.data-\\[range-end\\]\\:bg-primary[data-range-end]{background-color:var(--primary)}.data-\\[range-end\\]\\:text-primary-foreground[data-range-end]{color:var(--primary-foreground)}.data-\\[range-middle\\]\\:rounded-none[data-range-middle]{border-radius:0}.data-\\[range-middle\\]\\:rounded-e-md[data-range-middle]{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.data-\\[range-start\\]\\:bg-primary[data-range-start]{background-color:var(--primary)}.data-\\[range-start\\]\\:text-primary-foreground[data-range-start]{color:var(--primary-foreground)}.data-\\[selected\\]\\:bg-primary[data-selected]{background-color:var(--primary)}.data-\\[selected\\]\\:text-primary-foreground[data-selected]{color:var(--primary-foreground)}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=left\\]\\:slide-in-from-end-2[data-side=left]:where(:dir(ltr),[dir=ltr]){--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=left\\]\\:slide-in-from-end-2[data-side=left]:where(:dir(rtl),[dir=rtl]){--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=right\\]\\:slide-in-from-start-2[data-side=right]:where(:dir(ltr),[dir=ltr]){--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=right\\]\\:slide-in-from-start-2[data-side=right]:where(:dir(rtl),[dir=rtl]){--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y:calc(2*var(--spacing))}.data-\\[size\\=default\\]\\:h-9[data-size=default]{height:calc(var(--spacing)*9)}.data-\\[size\\=sm\\]\\:h-8[data-size=sm]{height:calc(var(--spacing)*8)}.data-\\[slot\\=checkbox-group\\]\\:gap-3[data-slot=checkbox-group]{gap:calc(var(--spacing)*3)}:is(.\\*\\*\\:data-\\[slot\\=command-input-wrapper\\]\\:h-12 *)[data-slot=command-input-wrapper]{height:calc(var(--spacing)*12)}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:line-clamp-1>*)[data-slot=select-value]{-webkit-line-clamp:1;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:flex>*)[data-slot=select-value]{display:flex}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:items-center>*)[data-slot=select-value]{align-items:center}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:gap-2>*)[data-slot=select-value]{gap:calc(var(--spacing)*2)}.data-\\[spacing\\=0\\]\\:rounded-none[data-spacing=\"0\"]{border-radius:0}.data-\\[spacing\\=0\\]\\:shadow-none[data-spacing=\"0\"]{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.data-\\[spacing\\=0\\]\\:first\\:rounded-l-md[data-spacing=\"0\"]:first-child{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.data-\\[spacing\\=0\\]\\:last\\:rounded-r-md[data-spacing=\"0\"]:last-child{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.data-\\[state\\=checked\\]\\:translate-x-\\[calc\\(100\\%-2px\\)\\][data-state=checked]{--tw-translate-x: calc(100% - 2px) ;translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=checked\\]\\:border-primary[data-state=checked]{border-color:var(--primary)}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:var(--primary)}.data-\\[state\\=checked\\]\\:text-primary-foreground[data-state=checked]{color:var(--primary-foreground)}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity:0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale:.95}.data-\\[state\\=on\\]\\:bg-accent[data-state=on]{background-color:var(--accent)}.data-\\[state\\=on\\]\\:text-accent-foreground[data-state=on]{color:var(--accent-foreground)}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity:0}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale:.95}.data-\\[state\\=unchecked\\]\\:translate-x-0[data-state=unchecked]{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=unchecked\\]\\:bg-input[data-state=unchecked]{background-color:var(--input)}.data-\\[unavailable\\]\\:text-muted-foreground[data-unavailable]{color:var(--muted-foreground)}.data-\\[unavailable\\]\\:line-through[data-unavailable]{text-decoration-line:line-through}.data-\\[variant\\=label\\]\\:text-sm[data-variant=label]{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.data-\\[variant\\=legend\\]\\:text-base[data-variant=legend]{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.data-\\[variant\\=outline\\]\\:border-l-0[data-variant=outline]{border-left-style:var(--tw-border-style);border-left-width:0}.data-\\[variant\\=outline\\]\\:shadow-xs[data-variant=outline]{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.data-\\[variant\\=outline\\]\\:first\\:border-l[data-variant=outline]:first-child{border-left-style:var(--tw-border-style);border-left-width:1px}.data-\\[spacing\\=0\\]\\:data-\\[variant\\=outline\\]\\:border-l-0[data-spacing=\"0\"][data-variant=outline]{border-left-style:var(--tw-border-style);border-left-width:0}.data-\\[spacing\\=0\\]\\:data-\\[variant\\=outline\\]\\:first\\:border-l[data-spacing=\"0\"][data-variant=outline]:first-child{border-left-style:var(--tw-border-style);border-left-width:1px}.data-\\[spacing\\=default\\]\\:data-\\[variant\\=outline\\]\\:shadow-xs[data-spacing=default][data-variant=outline]{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.nth-last-2\\:-mt-1:nth-last-child(2){margin-top:calc(var(--spacing)*-1)}@media(min-width:40rem){.sm\\:max-w-lg{max-width:var(--container-lg)}.sm\\:flex-row{flex-direction:row}.sm\\:justify-end{justify-content:flex-end}.sm\\:text-left{text-align:left}.sm\\:text-start{text-align:start}}@media(min-width:48rem){.md\\:flex-row{flex-direction:row}.md\\:text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}}@container field-group (min-width:28rem){.\\@md\\/field-group\\:flex-row{flex-direction:row}.\\@md\\/field-group\\:items-center{align-items:center}.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:items-start:has(>[data-slot=field-content]){align-items:flex-start}}.rtl\\:rotate-180:where(:dir(rtl),[dir=rtl],[dir=rtl] *){rotate:180deg}.dark\\:border-input:is(.dark *){border-color:var(--input)}.dark\\:bg-destructive\\/60:is(.dark *){background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-destructive\\/60:is(.dark *){background-color:color-mix(in oklab,var(--destructive)60%,transparent)}}.dark\\:bg-input\\/30:is(.dark *){background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-input\\/30:is(.dark *){background-color:color-mix(in oklab,var(--input)30%,transparent)}}.dark\\:bg-popover:is(.dark *){background-color:var(--popover)}.dark\\:text-popover-foreground:is(.dark *){color:var(--popover-foreground)}@media(hover:hover){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--input)50%,transparent)}}.dark\\:hover\\:text-accent-foreground:is(.dark *):hover{color:var(--accent-foreground)}}.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:has-data-\\[state\\=checked\\]\\:bg-primary\\/10:is(.dark *):has([data-state=checked]){background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.dark\\:has-data-\\[state\\=checked\\]\\:bg-primary\\/10:is(.dark *):has([data-state=checked]){background-color:color-mix(in oklab,var(--primary)10%,transparent)}}.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}@media(hover:hover){.dark\\:data-\\[range-end\\]\\:hover\\:bg-accent:is(.dark *)[data-range-end]:hover,.dark\\:data-\\[range-middle\\]\\:hover\\:bg-accent\\/0:is(.dark *)[data-range-middle]:hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[range-middle\\]\\:hover\\:bg-accent\\/0:is(.dark *)[data-range-middle]:hover{background-color:color-mix(in oklab,var(--accent)0%,transparent)}}.dark\\:data-\\[range-start\\]\\:hover\\:bg-accent:is(.dark *)[data-range-start]:hover,.dark\\:data-\\[selected\\]\\:hover\\:bg-accent\\/50:is(.dark *)[data-selected]:hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[selected\\]\\:hover\\:bg-accent\\/50:is(.dark *)[data-selected]:hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}}.dark\\:data-\\[state\\=checked\\]\\:bg-primary:is(.dark *)[data-state=checked]{background-color:var(--primary)}.dark\\:data-\\[state\\=checked\\]\\:bg-primary-foreground:is(.dark *)[data-state=checked]{background-color:var(--primary-foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-foreground:is(.dark *)[data-state=unchecked]{background-color:var(--foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:color-mix(in oklab,var(--input)80%,transparent)}}.\\[\\&_\\[data-command-group\\]\\]\\:px-2 [data-command-group]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[data-command-group\\]\\:not\\(\\[hidden\\]\\)_\\~\\[data-command-group\\]\\]\\:pt-0 [data-command-group]:not([hidden])~[data-command-group]{padding-top:calc(var(--spacing)*0)}.\\[\\&_\\[data-command-input-wrapper\\]_svg\\]\\:h-5 [data-command-input-wrapper] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-input-wrapper\\]_svg\\]\\:w-5 [data-command-input-wrapper] svg{width:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-input\\]\\]\\:h-12 [data-command-input]{height:calc(var(--spacing)*12)}.\\[\\&_\\[data-command-item\\]\\]\\:px-2 [data-command-item]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[data-command-item\\]\\]\\:py-3 [data-command-item]{padding-block:calc(var(--spacing)*3)}.\\[\\&_\\[data-command-item\\]_svg\\]\\:h-5 [data-command-item] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-item\\]_svg\\]\\:w-5 [data-command-item] svg{width:calc(var(--spacing)*5)}.\\[\\&_svg\\]\\:pointer-events-none svg{pointer-events:none}.\\[\\&_svg\\]\\:shrink-0 svg{flex-shrink:0}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\\'size-\\\'\\]\\)\\]\\:size-4 svg:not([class*=size-]){width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\\'text-\\\'\\]\\)\\]\\:text-muted-foreground svg:not([class*=text-]){color:var(--muted-foreground)}.\\[\\&\\:first-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-s-md:first-child[data-selected] [data-bits-day]{border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}.\\[\\&\\:first-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-l-md:first-child[data-selected] [data-bits-day]{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.\\[\\&\\:has\\(\\>\\:nth-child\\(2\\)\\)\\]\\:grid-cols-\\[1fr_1fr_auto\\]:has(>:nth-child(2)){grid-template-columns:1fr 1fr auto}.\\[\\&\\:has\\(\\[data-range-end\\]\\)\\]\\:rounded-e-md:has([data-range-end]){border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-end\\]\\)\\]\\:hover\\:bg-accent:is(.dark *):has([data-range-end]):hover{background-color:var(--accent)}}.\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-none:has([data-range-middle]){border-radius:0}.\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:bg-accent:has([data-range-middle]){background-color:var(--accent)}.first\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-s-md:first-child:has([data-range-middle]){border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}.last\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-e-md:last-child:has([data-range-middle]){border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:hover\\:bg-accent\\/50:is(.dark *):has([data-range-middle]):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:hover\\:bg-accent\\/50:is(.dark *):has([data-range-middle]):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}}.\\[\\&\\:has\\(\\[data-range-start\\]\\)\\]\\:rounded-s-md:has([data-range-start]){border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-start\\]\\)\\]\\:hover\\:bg-accent:is(.dark *):has([data-range-start]):hover{background-color:var(--accent)}}.\\[\\&\\:has\\(\\[data-selected\\]\\)\\]\\:bg-accent:has([data-selected]){background-color:var(--accent)}:is(.\\*\\:\\[span\\]\\:last\\:flex>*):is(span):last-child{display:flex}:is(.\\*\\:\\[span\\]\\:last\\:items-center>*):is(span):last-child{align-items:center}:is(.\\*\\:\\[span\\]\\:last\\:gap-2>*):is(span):last-child{gap:calc(var(--spacing)*2)}.\\[\\&\\:last-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-e-md:last-child[data-selected] [data-bits-day]{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.\\[\\&\\:last-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-r-md:last-child[data-selected] [data-bits-day]{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.\\[\\&\\>\\*\\]\\:w-full>*{width:100%}.\\[\\&\\>\\*\\]\\:focus-visible\\:relative>:focus-visible{position:relative}.\\[\\&\\>\\*\\]\\:focus-visible\\:z-10>:focus-visible{z-index:10}.\\[\\&\\>\\*\\]\\:data-\\[slot\\=field\\]\\:p-4>[data-slot=field]{padding:calc(var(--spacing)*4)}@container field-group (min-width:28rem){.\\@md\\/field-group\\:\\[\\&\\>\\*\\]\\:w-auto>*{width:auto}}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-s-none>:not(:first-child){border-start-start-radius:0;border-end-start-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-t-none>:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-l-none>:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-s-0>:not(:first-child){border-inline-start-style:var(--tw-border-style);border-inline-start-width:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-t-0>:not(:first-child){border-top-style:var(--tw-border-style);border-top-width:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-l-0>:not(:first-child){border-left-style:var(--tw-border-style);border-left-width:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-e-none>:not(:last-child){border-start-end-radius:0;border-end-end-radius:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-r-none>:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-b-none>:not(:last-child){border-bottom-right-radius:0;border-bottom-left-radius:0}.\\[\\&\\>\\.sr-only\\]\\:w-auto>.sr-only{width:auto}.\\[\\&\\>\\[data-slot\\=field-group\\]\\]\\:gap-4>[data-slot=field-group]{gap:calc(var(--spacing)*4)}.\\[\\&\\>\\[data-slot\\=field-label\\]\\]\\:flex-auto>[data-slot=field-label]{flex:auto}@container field-group (min-width:28rem){.\\@md\\/field-group\\:\\[\\&\\>\\[data-slot\\=field-label\\]\\]\\:flex-auto>[data-slot=field-label]{flex:auto}}.has-\\[select\\[aria-hidden\\=true\\]\\:last-child\\]\\:\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:last-of-type\\]\\:rounded-e-md:has(:is(select[aria-hidden=true]:last-child))>[data-slot=select-trigger]:last-of-type{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.has-\\[select\\[aria-hidden\\=true\\]\\:last-child\\]\\:\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:last-of-type\\]\\:rounded-r-md:has(:is(select[aria-hidden=true]:last-child))>[data-slot=select-trigger]:last-of-type{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:not\\(\\[class\\*\\=\\\'w-\\\'\\]\\)\\]\\:w-fit>[data-slot=select-trigger]:not([class*=w-]){width:fit-content}.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content])>[role=checkbox],.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content]) [role=radio]{margin-top:1px}@container field-group (min-width:28rem){.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content])>[role=checkbox],.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content]) [role=radio]{margin-top:1px}}.\\[\\&\\>a\\]\\:underline>a{text-decoration-line:underline}.\\[\\&\\>a\\]\\:underline-offset-4>a{text-underline-offset:4px}.\\[\\&\\>a\\:hover\\]\\:text-primary>a:hover{color:var(--primary)}.\\[\\&\\>input\\]\\:flex-1>input{flex:1}.\\[\\&\\>span\\]\\:text-xs>span{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.\\[\\&\\>span\\]\\:opacity-70>span{opacity:.7}.\\[\\&\\>svg\\]\\:size-3\\.5>svg{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.\\[\\&\\>svg\\]\\:text-muted-foreground>svg,.\\[\\&\\[data-outside-month\\]\\:not\\(\\[data-selected\\]\\)\\]\\:text-muted-foreground[data-outside-month]:not([data-selected]){color:var(--muted-foreground)}@media(hover:hover){.\\[\\&\\[data-outside-month\\]\\:not\\(\\[data-selected\\]\\)\\]\\:hover\\:text-accent-foreground[data-outside-month]:not([data-selected]):hover{color:var(--accent-foreground)}}.\\[\\&\\[data-today\\]\\:not\\(\\[data-selected\\]\\)\\]\\:bg-accent[data-today]:not([data-selected]){background-color:var(--accent)}.\\[\\&\\[data-today\\]\\:not\\(\\[data-selected\\]\\)\\]\\:text-accent-foreground[data-today]:not([data-selected]){color:var(--accent-foreground)}.\\[\\&\\[data-today\\]\\[data-disabled\\]\\]\\:text-muted-foreground[data-today][data-disabled]{color:var(--muted-foreground)}[data-slot=card-content] .\\[\\[data-slot\\=card-content\\]_\\&\\]\\:bg-transparent,[data-slot=popover-content] .\\[\\[data-slot\\=popover-content\\]_\\&\\]\\:bg-transparent{background-color:#0000}[data-variant=legend]+.\\[\\[data-variant\\=legend\\]\\+\\&\\]\\:-mt-1\\.5{margin-top:calc(var(--spacing)*-1.5)}}@property --tw-animation-delay{syntax:\"*\";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:\"*\";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:\"*\";inherits:false}@property --tw-animation-fill-mode{syntax:\"*\";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:\"*\";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:\"*\";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:\"*\";inherits:false;initial-value:0}:root,:host{--radius:.625rem;--background:oklch(100% 0 0);--foreground:oklch(12.9% .042 264.695);--card:oklch(100% 0 0);--card-foreground:oklch(12.9% .042 264.695);--popover:oklch(100% 0 0);--popover-foreground:oklch(12.9% .042 264.695);--primary:oklch(20.8% .042 265.755);--primary-foreground:oklch(98.4% .003 247.858);--secondary:oklch(96.8% .007 247.896);--secondary-foreground:oklch(20.8% .042 265.755);--muted:oklch(96.8% .007 247.896);--muted-foreground:oklch(55.4% .046 257.417);--accent:oklch(96.8% .007 247.896);--accent-foreground:oklch(20.8% .042 265.755);--destructive:oklch(57.7% .245 27.325);--border:oklch(92.9% .013 255.508);--input:oklch(92.9% .013 255.508);--ring:oklch(70.4% .04 256.788);--chart-1:oklch(64.6% .222 41.116);--chart-2:oklch(60% .118 184.704);--chart-3:oklch(39.8% .07 227.392);--chart-4:oklch(82.8% .189 84.429);--chart-5:oklch(76.9% .188 70.08);--sidebar:oklch(98.4% .003 247.858);--sidebar-foreground:oklch(12.9% .042 264.695);--sidebar-primary:oklch(20.8% .042 265.755);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(96.8% .007 247.896);--sidebar-accent-foreground:oklch(20.8% .042 265.755);--sidebar-border:oklch(92.9% .013 255.508);--sidebar-ring:oklch(70.4% .04 256.788)}.dark{--background:oklch(12.9% .042 264.695);--foreground:oklch(98.4% .003 247.858);--card:oklch(20.8% .042 265.755);--card-foreground:oklch(98.4% .003 247.858);--popover:oklch(20.8% .042 265.755);--popover-foreground:oklch(98.4% .003 247.858);--primary:oklch(92.9% .013 255.508);--primary-foreground:oklch(20.8% .042 265.755);--secondary:oklch(27.9% .041 260.031);--secondary-foreground:oklch(98.4% .003 247.858);--muted:oklch(27.9% .041 260.031);--muted-foreground:oklch(70.4% .04 256.788);--accent:oklch(27.9% .041 260.031);--accent-foreground:oklch(98.4% .003 247.858);--destructive:oklch(70.4% .191 22.216);--border:oklch(100% 0 0/.1);--input:oklch(100% 0 0/.15);--ring:oklch(55.1% .027 264.364);--chart-1:oklch(48.8% .243 264.376);--chart-2:oklch(69.6% .17 162.48);--chart-3:oklch(76.9% .188 70.08);--chart-4:oklch(62.7% .265 303.9);--chart-5:oklch(64.5% .246 16.439);--sidebar:oklch(20.8% .042 265.755);--sidebar-foreground:oklch(98.4% .003 247.858);--sidebar-primary:oklch(48.8% .243 264.376);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(27.9% .041 260.031);--sidebar-accent-foreground:oklch(98.4% .003 247.858);--sidebar-border:oklch(100% 0 0/.1);--sidebar-ring:oklch(55.1% .027 264.364)}@property --tw-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-z{syntax:\"*\";inherits:false;initial-value:0}@property --tw-scale-x{syntax:\"*\";inherits:false;initial-value:1}@property --tw-scale-y{syntax:\"*\";inherits:false;initial-value:1}@property --tw-scale-z{syntax:\"*\";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:\"*\";inherits:false}@property --tw-rotate-y{syntax:\"*\";inherits:false}@property --tw-rotate-z{syntax:\"*\";inherits:false}@property --tw-skew-x{syntax:\"*\";inherits:false}@property --tw-skew-y{syntax:\"*\";inherits:false}@property --tw-pan-x{syntax:\"*\";inherits:false}@property --tw-pan-y{syntax:\"*\";inherits:false}@property --tw-pinch-zoom{syntax:\"*\";inherits:false}@property --tw-space-y-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-space-x-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-divide-x-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-border-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-divide-y-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-leading{syntax:\"*\";inherits:false}@property --tw-font-weight{syntax:\"*\";inherits:false}@property --tw-tracking{syntax:\"*\";inherits:false}@property --tw-ordinal{syntax:\"*\";inherits:false}@property --tw-slashed-zero{syntax:\"*\";inherits:false}@property --tw-numeric-figure{syntax:\"*\";inherits:false}@property --tw-numeric-spacing{syntax:\"*\";inherits:false}@property --tw-numeric-fraction{syntax:\"*\";inherits:false}@property --tw-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:\"*\";inherits:false}@property --tw-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:\"*\";inherits:false}@property --tw-inset-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:\"*\";inherits:false}@property --tw-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:\"*\";inherits:false}@property --tw-inset-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:\"*\";inherits:false}@property --tw-ring-offset-width{syntax:\"<length>\";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:\"*\";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-blur{syntax:\"*\";inherits:false}@property --tw-brightness{syntax:\"*\";inherits:false}@property --tw-contrast{syntax:\"*\";inherits:false}@property --tw-grayscale{syntax:\"*\";inherits:false}@property --tw-hue-rotate{syntax:\"*\";inherits:false}@property --tw-invert{syntax:\"*\";inherits:false}@property --tw-opacity{syntax:\"*\";inherits:false}@property --tw-saturate{syntax:\"*\";inherits:false}@property --tw-sepia{syntax:\"*\";inherits:false}@property --tw-drop-shadow{syntax:\"*\";inherits:false}@property --tw-drop-shadow-color{syntax:\"*\";inherits:false}@property --tw-drop-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:\"*\";inherits:false}@property --tw-backdrop-blur{syntax:\"*\";inherits:false}@property --tw-backdrop-brightness{syntax:\"*\";inherits:false}@property --tw-backdrop-contrast{syntax:\"*\";inherits:false}@property --tw-backdrop-grayscale{syntax:\"*\";inherits:false}@property --tw-backdrop-hue-rotate{syntax:\"*\";inherits:false}@property --tw-backdrop-invert{syntax:\"*\";inherits:false}@property --tw-backdrop-opacity{syntax:\"*\";inherits:false}@property --tw-backdrop-saturate{syntax:\"*\";inherits:false}@property --tw-backdrop-sepia{syntax:\"*\";inherits:false}@property --tw-duration{syntax:\"*\";inherits:false}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));filter:blur(var(--tw-enter-blur,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));filter:blur(var(--tw-exit-blur,0))}}\n";
function y5(t) {
  if (!t) return;
  const e = new CSSStyleSheet();
  e.replaceSync(v5), t.adoptedStyleSheets = [e];
}
var b5 = /* @__PURE__ */ ne("<div><!></div> <!>", 1);
function _5(t, e) {
  W(e, !0);
  let r = v(e, "schema", 7), n = v(e, "uiSchema", 7), s = v(e, "darkMode", 7), o = v(e, "preventPageReload", 7);
  g5(), $o(() => {
    y5(e.$$host?.shadowRoot);
  });
  const i = /* @__PURE__ */ O(() => m5({ schema: r(), uiSchema: n() }, () => e.$$host));
  Xe(() => {
    o() && xk(d(i));
  });
  var a = {
    get schema() {
      return r();
    },
    set schema(h) {
      r(h), m();
    },
    get uiSchema() {
      return n();
    },
    set uiSchema(h) {
      n(h), m();
    },
    get darkMode() {
      return s();
    },
    set darkMode(h) {
      s(h), m();
    },
    get preventPageReload() {
      return o();
    },
    set preventPageReload(h) {
      o(h), m();
    }
  }, l = b5(), u = D(l), c = ge(u);
  Rd(c, {
    get form() {
      return d(i);
    }
  }), de(u);
  var f = be(u, 2);
  return ue(f, (h) => {
  }), ke(() => ls(u, 1, as([s() && "dark"]))), A(t, l), H(a);
}
customElements.define("formata-form", K(
  _5,
  {
    schema: { attribute: "schema", reflect: !0, type: "Object" },
    uiSchema: { attribute: "ui-schema", reflect: !0, type: "Object" },
    preventPageReload: {
      attribute: "prevent-page-reload",
      reflect: !0,
      type: "Boolean"
    },
    darkMode: { attribute: "dark-mode", reflect: !0, type: "Boolean" }
  },
  [],
  [],
  { mode: "open" }
));
export {
  _5 as Form
};
