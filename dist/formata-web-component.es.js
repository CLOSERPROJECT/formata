typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add("5");
const kx = 1, $x = 2, rv = 4, Ax = 8, Ex = 16, Tx = 1, Dx = 2, Mx = 4, Ix = 8, Nx = 16, Fx = 1, Rx = 2, nv = "[", kl = "[!", od = "]", lo = {}, xt = /* @__PURE__ */ Symbol(), Vx = "http://www.w3.org/1999/xhtml", Lx = "http://www.w3.org/2000/svg", sv = "@attach", dc = !1;
var $l = Array.isArray, jx = Array.prototype.indexOf, uo = Array.prototype.includes, Al = Array.from, Ja = Object.keys, Za = Object.defineProperty, Sn = Object.getOwnPropertyDescriptor, ov = Object.getOwnPropertyDescriptors, iv = Object.prototype, Bx = Array.prototype, El = Object.getPrototypeOf, cg = Object.isExtensible;
function Ko(t) {
  return typeof t == "function";
}
const he = () => {
};
function zx(t) {
  return t();
}
function fc(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function av() {
  var t, e, r = new Promise((n, s) => {
    t = n, e = s;
  });
  return { promise: r, resolve: t, reject: e };
}
function qx(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const r = [];
  for (const n of t)
    if (r.push(n), r.length === e) break;
  return r;
}
const Et = 2, Qa = 4, Ci = 8, id = 1 << 24, In = 16, Ur = 32, is = 64, ad = 128, wr = 512, Ot = 1024, Tt = 2048, Fr = 4096, hr = 8192, xn = 16384, Tl = 32768, kn = 65536, dg = 1 << 17, lv = 1 << 18, zs = 1 << 19, uv = 1 << 20, bn = 1 << 25, Ms = 32768, hc = 1 << 21, ld = 1 << 22, Wn = 1 << 23, en = /* @__PURE__ */ Symbol("$state"), ud = /* @__PURE__ */ Symbol("legacy props"), Ux = /* @__PURE__ */ Symbol(""), no = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), Kx = 1, ki = 3, qs = 8;
function cd(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Wx() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Hx(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Gx() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function Yx(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Xx() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Jx() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function Zx(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function Qx() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function eP() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function tP() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function rP() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
function Dl(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function nP() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function sP() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ne = !1;
function zt(t) {
  Ne = t;
}
let ze;
function _t(t) {
  if (t === null)
    throw Dl(), lo;
  return ze = t;
}
function $n() {
  return _t(/* @__PURE__ */ ln(ze));
}
function de(t) {
  if (Ne) {
    if (/* @__PURE__ */ ln(ze) !== null)
      throw Dl(), lo;
    ze = t;
  }
}
function St(t = 1) {
  if (Ne) {
    for (var e = t, r = ze; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ ln(r);
    ze = r;
  }
}
function el(t = !0) {
  for (var e = 0, r = ze; ; ) {
    if (r.nodeType === qs) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === od) {
        if (e === 0) return r;
        e -= 1;
      } else (n === nv || n === kl) && (e += 1);
    }
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ ln(r)
    );
    t && r.remove(), r = s;
  }
}
function cv(t) {
  if (!t || t.nodeType !== qs)
    throw Dl(), lo;
  return (
    /** @type {Comment} */
    t.data
  );
}
function dv(t) {
  return t === this.v;
}
function oP(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function fv(t) {
  return !oP(t, this.v);
}
let So = !1, iP = !1;
function aP() {
  So = !0;
}
const lP = [];
function xo(t, e = !1, r = !1) {
  return za(t, /* @__PURE__ */ new Map(), "", lP, null, r);
}
function za(t, e, r, n, s = null, o = !1) {
  if (typeof t == "object" && t !== null) {
    var i = e.get(t);
    if (i !== void 0) return i;
    if (t instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(t)
    );
    if (t instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(t)
    );
    if ($l(t)) {
      var a = (
        /** @type {Snapshot<any>} */
        Array(t.length)
      );
      e.set(t, a), s !== null && e.set(s, a);
      for (var l = 0; l < t.length; l += 1) {
        var u = t[l];
        l in t && (a[l] = za(u, e, r, n, null, o));
      }
      return a;
    }
    if (El(t) === iv) {
      a = {}, e.set(t, a), s !== null && e.set(s, a);
      for (var c in t)
        a[c] = za(
          // @ts-expect-error
          t[c],
          e,
          r,
          n,
          null,
          o
        );
      return a;
    }
    if (t instanceof Date)
      return (
        /** @type {Snapshot<T>} */
        structuredClone(t)
      );
    if (typeof /** @type {T & { toJSON?: any } } */
    t.toJSON == "function" && !o)
      return za(
        /** @type {T & { toJSON(): any } } */
        t.toJSON(),
        e,
        r,
        n,
        // Associate the instance with the toJSON clone
        t
      );
  }
  if (t instanceof EventTarget)
    return (
      /** @type {Snapshot<T>} */
      t
    );
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(t)
    );
  } catch {
    return (
      /** @type {Snapshot<T>} */
      t
    );
  }
}
let it = null;
function co(t) {
  it = t;
}
function Is(t) {
  return (
    /** @type {T} */
    Ml().get(t)
  );
}
function Po(t, e) {
  return Ml().set(t, e), e;
}
function uP(t) {
  return Ml().has(t);
}
function cP() {
  return Ml();
}
function W(t, e = !1, r) {
  it = {
    p: it,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: So && !e ? { s: null, u: null, $: [] } : null
  };
}
function H(t) {
  var e = (
    /** @type {ComponentContext} */
    it
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      Nv(n);
  }
  return t !== void 0 && (e.x = t), e.i = !0, it = e.p, t ?? /** @type {T} */
  {};
}
function Oo() {
  return !So || it !== null && it.l === null;
}
function Ml(t) {
  return it === null && cd(), it.c ??= new Map(dP(it) || void 0);
}
function dP(t) {
  let e = t.p;
  for (; e !== null; ) {
    const r = e.c;
    if (r !== null)
      return r;
    e = e.p;
  }
  return null;
}
let Cs = [];
function hv() {
  var t = Cs;
  Cs = [], fc(t);
}
function Ir(t) {
  if (Cs.length === 0 && !li) {
    var e = Cs;
    queueMicrotask(() => {
      e === Cs && hv();
    });
  }
  Cs.push(t);
}
function fP() {
  for (; Cs.length > 0; )
    hv();
}
function gv(t) {
  var e = Je;
  if (e === null)
    return Ge.f |= Wn, t;
  if ((e.f & Tl) === 0) {
    if ((e.f & ad) === 0)
      throw t;
    e.b.error(t);
  } else
    fo(t, e);
}
function fo(t, e) {
  for (; e !== null; ) {
    if ((e.f & ad) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const hP = -7169;
function dt(t, e) {
  t.f = t.f & hP | e;
}
function dd(t) {
  (t.f & wr) !== 0 || t.deps === null ? dt(t, Ot) : dt(t, Fr);
}
function pv(t) {
  if (t !== null)
    for (const e of t)
      (e.f & Et) === 0 || (e.f & Ms) === 0 || (e.f ^= Ms, pv(
        /** @type {Derived} */
        e.deps
      ));
}
function mv(t, e, r) {
  (t.f & Tt) !== 0 ? e.add(t) : (t.f & Fr) !== 0 && r.add(t), pv(t.deps), dt(t, Ot);
}
const Ui = /* @__PURE__ */ new Set();
let rt = null, gc = null, Er = null, ur = [], Il = null, pc = !1, li = !1;
class Pn {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #s = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #i = /* @__PURE__ */ new Set();
  /**
   * A map of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`.
   * The value contains child effects that were dirty/maybe_dirty before being reset,
   * so they can be rescheduled if the branch survives.
   * @type {Map<Effect, { d: Effect[], m: Effect[] }>}
   */
  #a = /* @__PURE__ */ new Map();
  is_fork = !1;
  #u = !1;
  is_deferred() {
    return this.is_fork || this.#n > 0;
  }
  /**
   * Add an effect to the #skipped_branches map and reset its children
   * @param {Effect} effect
   */
  skip_effect(e) {
    this.#a.has(e) || this.#a.set(e, { d: [], m: [] });
  }
  /**
   * Remove an effect from the #skipped_branches map and reschedule
   * any tracked dirty/maybe_dirty child effects
   * @param {Effect} effect
   */
  unskip_effect(e) {
    var r = this.#a.get(e);
    if (r) {
      this.#a.delete(e);
      for (var n of r.d)
        dt(n, Tt), Dr(n);
      for (n of r.m)
        dt(n, Fr), Dr(n);
    }
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    ur = [], this.apply();
    var r = [], n = [];
    for (const s of e)
      this.#l(s, r, n);
    if (this.is_deferred()) {
      this.#c(n), this.#c(r);
      for (const [s, o] of this.#a)
        _v(s, o);
    } else {
      for (const s of this.#e) s();
      this.#e.clear(), this.#r === 0 && this.#d(), gc = this, rt = null, fg(n), fg(r), gc = null, this.#s?.resolve();
    }
    Er = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {Effect[]} effects
   * @param {Effect[]} render_effects
   */
  #l(e, r, n) {
    e.f ^= Ot;
    for (var s = e.first, o = null; s !== null; ) {
      var i = s.f, a = (i & (Ur | is)) !== 0, l = a && (i & Ot) !== 0, u = l || (i & hr) !== 0 || this.#a.has(s);
      if (!u && s.fn !== null) {
        a ? s.f ^= Ot : o !== null && (i & (Qa | Ci | id)) !== 0 ? o.b.defer_effect(s) : (i & Qa) !== 0 ? r.push(s) : Ei(s) && ((i & In) !== 0 && this.#i.add(s), di(s));
        var c = s.first;
        if (c !== null) {
          s = c;
          continue;
        }
      }
      var f = s.parent;
      for (s = s.next; s === null && f !== null; )
        f === o && (o = null), s = f.next, f = f.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #c(e) {
    for (var r = 0; r < e.length; r += 1)
      mv(e[r], this.#o, this.#i);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    r !== xt && !this.previous.has(e) && this.previous.set(e, r), (e.f & Wn) === 0 && (this.current.set(e, e.v), Er?.set(e, e.v));
  }
  activate() {
    rt = this, this.apply();
  }
  deactivate() {
    rt === this && (rt = null, Er = null);
  }
  flush() {
    if (this.activate(), ur.length > 0) {
      if (vv(), rt !== null && rt !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #d() {
    if (Ui.size > 1) {
      this.previous.clear();
      var e = Er, r = !0;
      for (const s of Ui) {
        if (s === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (s.current.has(a))
            if (r && l !== s.current.get(a))
              s.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const i = [...s.current.keys()].filter((a) => !this.current.has(a));
        if (i.length > 0) {
          var n = ur;
          ur = [];
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            yv(u, i, a, l);
          if (ur.length > 0) {
            rt = s, s.apply();
            for (const u of ur)
              s.#l(u, [], []);
            s.deactivate();
          }
          ur = n;
        }
      }
      rt = null, Er = e;
    }
    this.committed = !0, Ui.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), !this.#u && (this.#u = !0, Ir(() => {
      this.#u = !1, this.is_deferred() ? ur.length > 0 && this.flush() : this.revive();
    }));
  }
  revive() {
    for (const e of this.#o)
      this.#i.delete(e), dt(e, Tt), Dr(e);
    for (const e of this.#i)
      dt(e, Fr), Dr(e);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#s ??= av()).promise;
  }
  static ensure() {
    if (rt === null) {
      const e = rt = new Pn();
      Ui.add(rt), li || Ir(() => {
        rt === e && e.flush();
      });
    }
    return rt;
  }
  apply() {
  }
}
function m(t) {
  var e = li;
  li = !0;
  try {
    for (var r; ; ) {
      if (fP(), ur.length === 0 && (rt?.flush(), ur.length === 0))
        return Il = null, /** @type {T} */
        r;
      vv();
    }
  } finally {
    li = e;
  }
}
function vv() {
  pc = !0;
  var t = null;
  try {
    for (var e = 0; ur.length > 0; ) {
      var r = Pn.ensure();
      if (e++ > 1e3) {
        var n, s;
        gP();
      }
      r.process(ur), Hn.clear();
    }
  } finally {
    pc = !1, Il = null;
  }
}
function gP() {
  try {
    Xx();
  } catch (t) {
    fo(t, Il);
  }
}
let vn = null;
function fg(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (xn | hr)) === 0 && Ei(n) && (vn = /* @__PURE__ */ new Set(), di(n), n.deps === null && n.first === null && n.nodes === null && (n.teardown === null && n.ac === null ? jv(n) : n.fn = null), vn?.size > 0)) {
        Hn.clear();
        for (const s of vn) {
          if ((s.f & (xn | hr)) !== 0) continue;
          const o = [s];
          let i = s.parent;
          for (; i !== null; )
            vn.has(i) && (vn.delete(i), o.push(i)), i = i.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (xn | hr)) === 0 && di(l);
          }
        }
        vn.clear();
      }
    }
    vn = null;
  }
}
function yv(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const s of t.reactions) {
      const o = s.f;
      (o & Et) !== 0 ? yv(
        /** @type {Derived} */
        s,
        e,
        r,
        n
      ) : (o & (ld | In)) !== 0 && (o & Tt) === 0 && bv(s, e, n) && (dt(s, Tt), Dr(
        /** @type {Effect} */
        s
      ));
    }
}
function bv(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const s of t.deps) {
      if (uo.call(e, s))
        return !0;
      if ((s.f & Et) !== 0 && bv(
        /** @type {Derived} */
        s,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          s,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Dr(t) {
  for (var e = Il = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (pc && e === Je && (r & In) !== 0 && (r & lv) === 0)
      return;
    if ((r & (is | Ur)) !== 0) {
      if ((r & Ot) === 0) return;
      e.f ^= Ot;
    }
  }
  ur.push(e);
}
function _v(t, e) {
  if (!((t.f & Ur) !== 0 && (t.f & Ot) !== 0)) {
    (t.f & Tt) !== 0 ? e.d.push(t) : (t.f & Fr) !== 0 && e.m.push(t), dt(t, Ot);
    for (var r = t.first; r !== null; )
      _v(r, e), r = r.next;
  }
}
function fd(t) {
  let e = 0, r = Jn(0), n;
  return () => {
    md() && (d(r), Ai(() => (e === 0 && (n = ot(() => t(() => Hr(r)))), e += 1, () => {
      Ir(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Hr(r));
      });
    })));
  };
}
var pP = kn | zs | ad;
function mP(t, e, r) {
  new vP(t, e, r);
}
class vP {
  /** @type {Boundary | null} */
  parent;
  is_pending = !1;
  /** @type {TemplateNode} */
  #e;
  /** @type {TemplateNode | null} */
  #t = Ne ? ze : null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #n;
  /** @type {Effect} */
  #s;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #a = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #l = null;
  #c = 0;
  #d = 0;
  #g = !1;
  #m = !1;
  /** @type {Set<Effect>} */
  #p = /* @__PURE__ */ new Set();
  /** @type {Set<Effect>} */
  #f = /* @__PURE__ */ new Set();
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #h = null;
  #b = fd(() => (this.#h = Jn(this.#c), () => {
    this.#h = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#e = e, this.#r = r, this.#n = n, this.parent = /** @type {Effect} */
    Je.b, this.is_pending = !!this.#r.pending, this.#s = Us(() => {
      if (Je.b = this, Ne) {
        const o = this.#t;
        $n(), /** @type {Comment} */
        o.nodeType === qs && /** @type {Comment} */
        o.data === kl ? this.#v() : (this.#y(), this.#d === 0 && (this.is_pending = !1));
      } else {
        var s = this.#S();
        try {
          this.#o = Xt(() => n(s));
        } catch (o) {
          this.error(o);
        }
        this.#d > 0 ? this.#x() : this.is_pending = !1;
      }
      return () => {
        this.#l?.remove();
      };
    }, pP), Ne && (this.#e = ze);
  }
  #y() {
    try {
      this.#o = Xt(() => this.#n(this.#e));
    } catch (e) {
      this.error(e);
    }
  }
  #v() {
    const e = this.#r.pending;
    e && (this.#i = Xt(() => e(this.#e)), Ir(() => {
      var r = this.#S();
      this.#o = this.#w(() => (Pn.ensure(), Xt(() => this.#n(r)))), this.#d > 0 ? this.#x() : (Es(
        /** @type {Effect} */
        this.#i,
        () => {
          this.#i = null;
        }
      ), this.is_pending = !1);
    }));
  }
  #S() {
    var e = this.#e;
    return this.is_pending && (this.#l = qt(), this.#e.before(this.#l), e = this.#l), e;
  }
  /**
   * Defer an effect inside a pending boundary until the boundary resolves
   * @param {Effect} effect
   */
  defer_effect(e) {
    mv(e, this.#p, this.#f);
  }
  /**
   * Returns `false` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_rendered() {
    return !this.is_pending && (!this.parent || this.parent.is_rendered());
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #w(e) {
    var r = Je, n = Ge, s = it;
    nn(this.#s), Pr(this.#s), co(this.#s.ctx);
    try {
      return e();
    } catch (o) {
      return gv(o), null;
    } finally {
      nn(r), Pr(n), co(s);
    }
  }
  #x() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#o !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#l
    ), qv(this.#o, this.#u)), this.#i === null && (this.#i = Xt(() => e(this.#e)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #_(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#_(e);
      return;
    }
    if (this.#d += e, this.#d === 0) {
      this.is_pending = !1;
      for (const r of this.#p)
        dt(r, Tt), Dr(r);
      for (const r of this.#f)
        dt(r, Fr), Dr(r);
      this.#p.clear(), this.#f.clear(), this.#i && Es(this.#i, () => {
        this.#i = null;
      }), this.#u && (this.#e.before(this.#u), this.#u = null);
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#_(e), this.#c += e, !(!this.#h || this.#g) && (this.#g = !0, Ir(() => {
      this.#g = !1, this.#h && ho(this.#h, this.#c);
    }));
  }
  get_effect_pending() {
    return this.#b(), d(
      /** @type {Source<number>} */
      this.#h
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#r.onerror;
    let n = this.#r.failed;
    if (this.#m || !r && !n)
      throw e;
    this.#o && (Ct(this.#o), this.#o = null), this.#i && (Ct(this.#i), this.#i = null), this.#a && (Ct(this.#a), this.#a = null), Ne && (_t(
      /** @type {TemplateNode} */
      this.#t
    ), St(), _t(el()));
    var s = !1, o = !1;
    const i = () => {
      if (s) {
        sP();
        return;
      }
      s = !0, o && rP(), Pn.ensure(), this.#c = 0, this.#a !== null && Es(this.#a, () => {
        this.#a = null;
      }), this.is_pending = this.has_pending_snippet(), this.#o = this.#w(() => (this.#m = !1, Xt(() => this.#n(this.#e)))), this.#d > 0 ? this.#x() : this.is_pending = !1;
    };
    Ir(() => {
      try {
        o = !0, r?.(e, i), o = !1;
      } catch (a) {
        fo(a, this.#s && this.#s.parent);
      }
      n && (this.#a = this.#w(() => {
        Pn.ensure(), this.#m = !0;
        try {
          return Xt(() => {
            n(
              this.#e,
              () => e,
              () => i
            );
          });
        } catch (a) {
          return fo(
            a,
            /** @type {Effect} */
            this.#s.parent
          ), null;
        } finally {
          this.#m = !1;
        }
      }));
    });
  }
}
function wv(t, e, r, n) {
  const s = Oo() ? $i : hd;
  var o = t.filter((g) => !g.settled);
  if (r.length === 0 && o.length === 0) {
    n(e.map(s));
    return;
  }
  var i = rt, a = (
    /** @type {Effect} */
    Je
  ), l = yP(), u = o.length === 1 ? o[0].promise : o.length > 1 ? Promise.all(o.map((g) => g.promise)) : null;
  function c(g) {
    l();
    try {
      n(g);
    } catch (_) {
      (a.f & xn) === 0 && fo(_, a);
    }
    i?.deactivate(), mc();
  }
  if (r.length === 0) {
    u.then(() => c(e.map(s)));
    return;
  }
  function f() {
    l(), Promise.all(r.map((g) => /* @__PURE__ */ bP(g))).then((g) => c([...e.map(s), ...g])).catch((g) => fo(g, a));
  }
  u ? u.then(f) : f();
}
function yP() {
  var t = Je, e = Ge, r = it, n = rt;
  return function(o = !0) {
    nn(t), Pr(e), co(r), o && n?.activate();
  };
}
function mc() {
  nn(null), Pr(null), co(null);
}
// @__NO_SIDE_EFFECTS__
function $i(t) {
  var e = Et | Tt, r = Ge !== null && (Ge.f & Et) !== 0 ? (
    /** @type {Derived} */
    Ge
  ) : null;
  return Je !== null && (Je.f |= zs), {
    ctx: it,
    deps: null,
    effects: null,
    equals: dv,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      xt
    ),
    wv: 0,
    parent: r ?? Je,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function bP(t, e, r) {
  let n = (
    /** @type {Effect | null} */
    Je
  );
  n === null && Wx();
  var s = (
    /** @type {Boundary} */
    n.b
  ), o = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), i = Jn(
    /** @type {V} */
    xt
  ), a = !Ge, l = /* @__PURE__ */ new Map();
  return kP(() => {
    var u = av();
    o = u.promise;
    try {
      Promise.resolve(t()).then(u.resolve, u.reject).then(() => {
        c === rt && c.committed && c.deactivate(), mc();
      });
    } catch (_) {
      u.reject(_), mc();
    }
    var c = (
      /** @type {Batch} */
      rt
    );
    if (a) {
      var f = s.is_rendered();
      s.update_pending_count(1), c.increment(f), l.get(c)?.reject(no), l.delete(c), l.set(c, u);
    }
    const g = (_, b = void 0) => {
      if (c.activate(), b)
        b !== no && (i.f |= Wn, ho(i, b));
      else {
        (i.f & Wn) !== 0 && (i.f ^= Wn), ho(i, _);
        for (const [p, h] of l) {
          if (l.delete(p), p === c) break;
          h.reject(no);
        }
      }
      a && (s.update_pending_count(-1), c.decrement(f));
    };
    u.promise.then(g, (_) => g(null, _ || "unknown"));
  }), vd(() => {
    for (const u of l.values())
      u.reject(no);
  }), new Promise((u) => {
    function c(f) {
      function g() {
        f === o ? u(i) : c(o);
      }
      f.then(g, g);
    }
    c(o);
  });
}
// @__NO_SIDE_EFFECTS__
function O(t) {
  const e = /* @__PURE__ */ $i(t);
  return Uv(e), e;
}
// @__NO_SIDE_EFFECTS__
function hd(t) {
  const e = /* @__PURE__ */ $i(t);
  return e.equals = fv, e;
}
function Sv(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Ct(
        /** @type {Effect} */
        e[r]
      );
  }
}
function _P(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & Et) === 0)
      return (e.f & xn) === 0 ? (
        /** @type {Effect} */
        e
      ) : null;
    e = e.parent;
  }
  return null;
}
function gd(t) {
  var e, r = Je;
  nn(_P(t));
  try {
    t.f &= ~Ms, Sv(t), e = Gv(t);
  } finally {
    nn(r);
  }
  return e;
}
function xv(t) {
  var e = gd(t);
  if (!t.equals(e) && (t.wv = Wv(), (!rt?.is_fork || t.deps === null) && (t.v = e, t.deps === null))) {
    dt(t, Ot);
    return;
  }
  Zn || (Er !== null ? (md() || rt?.is_fork) && Er.set(t, e) : dd(t));
}
let vc = /* @__PURE__ */ new Set();
const Hn = /* @__PURE__ */ new Map();
let Pv = !1;
function Jn(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: dv,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function xe(t, e) {
  const r = Jn(t);
  return Uv(r), r;
}
// @__NO_SIDE_EFFECTS__
function Ov(t, e = !1, r = !0) {
  const n = Jn(t);
  return e || (n.equals = fv), So && r && it !== null && it.l !== null && (it.l.s ??= []).push(n), n;
}
function q(t, e, r = !1) {
  Ge !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Mr || (Ge.f & dg) !== 0) && Oo() && (Ge.f & (Et | In | ld | dg)) !== 0 && (Sr === null || !uo.call(Sr, t)) && tP();
  let n = r ? Pt(e) : e;
  return ho(t, n);
}
function ho(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Zn ? Hn.set(t, e) : Hn.set(t, r), t.v = e;
    var n = Pn.ensure();
    if (n.capture(t, r), (t.f & Et) !== 0) {
      const s = (
        /** @type {Derived} */
        t
      );
      (t.f & Tt) !== 0 && gd(s), dd(s);
    }
    t.wv = Wv(), Cv(t, Tt), Oo() && Je !== null && (Je.f & Ot) !== 0 && (Je.f & (Ur | is)) === 0 && (br === null ? EP([t]) : br.push(t)), !n.is_fork && vc.size > 0 && !Pv && wP();
  }
  return e;
}
function wP() {
  Pv = !1;
  for (const t of vc)
    (t.f & Ot) !== 0 && dt(t, Fr), Ei(t) && di(t);
  vc.clear();
}
function Hr(t) {
  q(t, t.v + 1);
}
function Cv(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = Oo(), s = r.length, o = 0; o < s; o++) {
      var i = r[o], a = i.f;
      if (!(!n && i === Je)) {
        var l = (a & Tt) === 0;
        if (l && dt(i, e), (a & Et) !== 0) {
          var u = (
            /** @type {Derived} */
            i
          );
          Er?.delete(u), (a & Ms) === 0 && (a & wr && (i.f |= Ms), Cv(u, Fr));
        } else l && ((a & In) !== 0 && vn !== null && vn.add(
          /** @type {Effect} */
          i
        ), Dr(
          /** @type {Effect} */
          i
        ));
      }
    }
}
function Pt(t) {
  if (typeof t != "object" || t === null || en in t)
    return t;
  const e = El(t);
  if (e !== iv && e !== Bx)
    return t;
  var r = /* @__PURE__ */ new Map(), n = $l(t), s = /* @__PURE__ */ xe(0), o = On, i = (a) => {
    if (On === o)
      return a();
    var l = Ge, u = On;
    Pr(null), vg(o);
    var c = a();
    return Pr(l), vg(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ xe(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Qx();
        var c = r.get(l);
        return c === void 0 ? c = i(() => {
          var f = /* @__PURE__ */ xe(u.value);
          return r.set(l, f), f;
        }) : q(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = i(() => /* @__PURE__ */ xe(xt));
            r.set(l, c), Hr(s);
          }
        } else
          q(u, xt), Hr(s);
        return !0;
      },
      get(a, l, u) {
        if (l === en)
          return t;
        var c = r.get(l), f = l in a;
        if (c === void 0 && (!f || Sn(a, l)?.writable) && (c = i(() => {
          var _ = Pt(f ? a[l] : xt), b = /* @__PURE__ */ xe(_);
          return b;
        }), r.set(l, c)), c !== void 0) {
          var g = d(c);
          return g === xt ? void 0 : g;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = d(c));
        } else if (u === void 0) {
          var f = r.get(l), g = f?.v;
          if (f !== void 0 && g !== xt)
            return {
              enumerable: !0,
              configurable: !0,
              value: g,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === en)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== xt || Reflect.has(a, l);
        if (u !== void 0 || Je !== null && (!c || Sn(a, l)?.writable)) {
          u === void 0 && (u = i(() => {
            var g = c ? Pt(a[l]) : xt, _ = /* @__PURE__ */ xe(g);
            return _;
          }), r.set(l, u));
          var f = d(u);
          if (f === xt)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var f = r.get(l), g = l in a;
        if (n && l === "length")
          for (var _ = u; _ < /** @type {Source<number>} */
          f.v; _ += 1) {
            var b = r.get(_ + "");
            b !== void 0 ? q(b, xt) : _ in a && (b = i(() => /* @__PURE__ */ xe(xt)), r.set(_ + "", b));
          }
        if (f === void 0)
          (!g || Sn(a, l)?.writable) && (f = i(() => /* @__PURE__ */ xe(void 0)), q(f, Pt(u)), r.set(l, f));
        else {
          g = f.v !== xt;
          var p = i(() => Pt(u));
          q(f, p);
        }
        var h = Reflect.getOwnPropertyDescriptor(a, l);
        if (h?.set && h.set.call(c, u), !g) {
          if (n && typeof l == "string") {
            var y = (
              /** @type {Source<number>} */
              r.get("length")
            ), S = Number(l);
            Number.isInteger(S) && S >= y.v && q(y, S + 1);
          }
          Hr(s);
        }
        return !0;
      },
      ownKeys(a) {
        d(s);
        var l = Reflect.ownKeys(a).filter((f) => {
          var g = r.get(f);
          return g === void 0 || g.v !== xt;
        });
        for (var [u, c] of r)
          c.v !== xt && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        eP();
      }
    }
  );
}
function hg(t) {
  try {
    if (t !== null && typeof t == "object" && en in t)
      return t[en];
  } catch {
  }
  return t;
}
function SP(t, e) {
  return Object.is(hg(t), hg(e));
}
var gg, kv, $v, Av;
function yc() {
  if (gg === void 0) {
    gg = window, kv = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    $v = Sn(e, "firstChild").get, Av = Sn(e, "nextSibling").get, cg(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), cg(r) && (r.__t = void 0);
  }
}
function qt(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Rr(t) {
  return (
    /** @type {TemplateNode | null} */
    $v.call(t)
  );
}
// @__NO_SIDE_EFFECTS__
function ln(t) {
  return (
    /** @type {TemplateNode | null} */
    Av.call(t)
  );
}
function ge(t, e) {
  if (!Ne)
    return /* @__PURE__ */ Rr(t);
  var r = /* @__PURE__ */ Rr(ze);
  if (r === null)
    r = ze.appendChild(qt());
  else if (e && r.nodeType !== ki) {
    var n = qt();
    return r?.before(n), _t(n), n;
  }
  return e && Nl(
    /** @type {Text} */
    r
  ), _t(r), r;
}
function D(t, e = !1) {
  if (!Ne) {
    var r = /* @__PURE__ */ Rr(t);
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ ln(r) : r;
  }
  if (e) {
    if (ze?.nodeType !== ki) {
      var n = qt();
      return ze?.before(n), _t(n), n;
    }
    Nl(
      /** @type {Text} */
      ze
    );
  }
  return ze;
}
function be(t, e = 1, r = !1) {
  let n = Ne ? ze : t;
  for (var s; e--; )
    s = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ ln(n);
  if (!Ne)
    return n;
  if (r) {
    if (n?.nodeType !== ki) {
      var o = qt();
      return n === null ? s?.after(o) : n.before(o), _t(o), o;
    }
    Nl(
      /** @type {Text} */
      n
    );
  }
  return _t(n), n;
}
function pd(t) {
  t.textContent = "";
}
function Ev() {
  return !1;
}
function xP(t = "") {
  return document.createComment(t);
}
function Nl(t) {
  if (
    /** @type {string} */
    t.nodeValue.length < 65536
  )
    return;
  let e = t.nextSibling;
  for (; e !== null && e.nodeType === ki; )
    e.remove(), t.nodeValue += /** @type {string} */
    e.nodeValue, e = t.nextSibling;
}
function PP(t, e) {
  if (e) {
    const r = document.body;
    t.autofocus = !0, Ir(() => {
      document.activeElement === r && t.focus();
    });
  }
}
function Tv(t) {
  Ne && /* @__PURE__ */ Rr(t) !== null && pd(t);
}
let pg = !1;
function Dv() {
  pg || (pg = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
    { capture: !0 }
  ));
}
function Fl(t) {
  var e = Ge, r = Je;
  Pr(null), nn(null);
  try {
    return t();
  } finally {
    Pr(e), nn(r);
  }
}
function Mv(t, e, r, n = r) {
  t.addEventListener(e, () => Fl(r));
  const s = t.__on_r;
  s ? t.__on_r = () => {
    s(), n(!0);
  } : t.__on_r = () => n(!0), Dv();
}
function Iv(t) {
  Je === null && (Ge === null && Yx(), Gx()), Zn && Hx();
}
function OP(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function Or(t, e, r) {
  var n = Je;
  n !== null && (n.f & hr) !== 0 && (t |= hr);
  var s = {
    ctx: it,
    deps: null,
    nodes: null,
    f: t | Tt | wr,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: n,
    b: n && n.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      di(s), s.f |= Tl;
    } catch (a) {
      throw Ct(s), a;
    }
  else e !== null && Dr(s);
  var o = s;
  if (r && o.deps === null && o.teardown === null && o.nodes === null && o.first === o.last && // either `null`, or a singular child
  (o.f & zs) === 0 && (o = o.first, (t & In) !== 0 && (t & kn) !== 0 && o !== null && (o.f |= kn)), o !== null && (o.parent = n, n !== null && OP(o, n), Ge !== null && (Ge.f & Et) !== 0 && (t & is) === 0)) {
    var i = (
      /** @type {Derived} */
      Ge
    );
    (i.effects ??= []).push(o);
  }
  return s;
}
function md() {
  return Ge !== null && !Mr;
}
function vd(t) {
  const e = Or(Ci, null, !1);
  return dt(e, Ot), e.teardown = t, e;
}
function Xe(t) {
  Iv();
  var e = (
    /** @type {Effect} */
    Je.f
  ), r = !Ge && (e & Ur) !== 0 && (e & Tl) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      it
    );
    (n.e ??= []).push(t);
  } else
    return Nv(t);
}
function Nv(t) {
  return Or(Qa | uv, t, !1);
}
function Co(t) {
  return Iv(), Or(Ci | uv, t, !0);
}
function Fv(t) {
  Pn.ensure();
  const e = Or(is | zs, t, !0);
  return () => {
    Ct(e);
  };
}
function CP(t) {
  Pn.ensure();
  const e = Or(is | zs, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? Es(e, () => {
      Ct(e), n(void 0);
    }) : (Ct(e), n(void 0));
  });
}
function Rl(t) {
  return Or(Qa, t, !1);
}
function kP(t) {
  return Or(ld | zs, t, !0);
}
function Ai(t, e = 0) {
  return Or(Ci | e, t, !0);
}
function ke(t, e = [], r = [], n = []) {
  wv(n, e, r, (s) => {
    Or(Ci, () => t(...s.map(d)), !0);
  });
}
function Us(t, e = 0) {
  var r = Or(In | e, t, !0);
  return r;
}
function Rv(t, e = 0) {
  var r = Or(id | e, t, !0);
  return r;
}
function Xt(t) {
  return Or(Ur | zs, t, !0);
}
function Vv(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Zn, n = Ge;
    mg(!0), Pr(null);
    try {
      e.call(null);
    } finally {
      mg(r), Pr(n);
    }
  }
}
function Lv(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const s = r.ac;
    s !== null && Fl(() => {
      s.abort(no);
    });
    var n = r.next;
    (r.f & is) !== 0 ? r.parent = null : Ct(r, e), r = n;
  }
}
function $P(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & Ur) === 0 && Ct(e), e = r;
  }
}
function Ct(t, e = !0) {
  var r = !1;
  (e || (t.f & lv) !== 0) && t.nodes !== null && t.nodes.end !== null && (AP(
    t.nodes.start,
    /** @type {TemplateNode} */
    t.nodes.end
  ), r = !0), Lv(t, e && !r), tl(t, 0), dt(t, xn);
  var n = t.nodes && t.nodes.t;
  if (n !== null)
    for (const o of n)
      o.stop();
  Vv(t);
  var s = t.parent;
  s !== null && s.first !== null && jv(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes = t.ac = null;
}
function AP(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : /* @__PURE__ */ ln(t);
    t.remove(), t = r;
  }
}
function jv(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function Es(t, e, r = !0) {
  var n = [];
  Bv(t, n, !0);
  var s = () => {
    r && Ct(t), e && e();
  }, o = n.length;
  if (o > 0) {
    var i = () => --o || s();
    for (var a of n)
      a.out(i);
  } else
    s();
}
function Bv(t, e, r) {
  if ((t.f & hr) === 0) {
    t.f ^= hr;
    var n = t.nodes && t.nodes.t;
    if (n !== null)
      for (const a of n)
        (a.is_global || r) && e.push(a);
    for (var s = t.first; s !== null; ) {
      var o = s.next, i = (s.f & kn) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (s.f & Ur) !== 0 && (t.f & In) !== 0;
      Bv(s, e, i ? r : !1), s = o;
    }
  }
}
function yd(t) {
  zv(t, !0);
}
function zv(t, e) {
  if ((t.f & hr) !== 0) {
    t.f ^= hr, (t.f & Ot) === 0 && (dt(t, Tt), Dr(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, s = (r.f & kn) !== 0 || (r.f & Ur) !== 0;
      zv(r, s ? e : !1), r = n;
    }
    var o = t.nodes && t.nodes.t;
    if (o !== null)
      for (const i of o)
        (i.is_global || e) && i.in();
  }
}
function qv(t, e) {
  if (t.nodes)
    for (var r = t.nodes.start, n = t.nodes.end; r !== null; ) {
      var s = r === n ? null : /* @__PURE__ */ ln(r);
      e.append(r), r = s;
    }
}
let qa = !1, Zn = !1;
function mg(t) {
  Zn = t;
}
let Ge = null, Mr = !1;
function Pr(t) {
  Ge = t;
}
let Je = null;
function nn(t) {
  Je = t;
}
let Sr = null;
function Uv(t) {
  Ge !== null && (Sr === null ? Sr = [t] : Sr.push(t));
}
let Yt = null, lr = 0, br = null;
function EP(t) {
  br = t;
}
let Kv = 1, ks = 0, On = ks;
function vg(t) {
  On = t;
}
function Wv() {
  return ++Kv;
}
function Ei(t) {
  var e = t.f;
  if ((e & Tt) !== 0)
    return !0;
  if (e & Et && (t.f &= ~Ms), (e & Fr) !== 0) {
    for (var r = (
      /** @type {Value[]} */
      t.deps
    ), n = r.length, s = 0; s < n; s++) {
      var o = r[s];
      if (Ei(
        /** @type {Derived} */
        o
      ) && xv(
        /** @type {Derived} */
        o
      ), o.wv > t.wv)
        return !0;
    }
    (e & wr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Er === null && dt(t, Ot);
  }
  return !1;
}
function Hv(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !(Sr !== null && uo.call(Sr, t)))
    for (var s = 0; s < n.length; s++) {
      var o = n[s];
      (o.f & Et) !== 0 ? Hv(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? dt(o, Tt) : (o.f & Ot) !== 0 && dt(o, Fr), Dr(
        /** @type {Effect} */
        o
      ));
    }
}
function Gv(t) {
  var e = Yt, r = lr, n = br, s = Ge, o = Sr, i = it, a = Mr, l = On, u = t.f;
  Yt = /** @type {null | Value[]} */
  null, lr = 0, br = null, Ge = (u & (Ur | is)) === 0 ? t : null, Sr = null, co(t.ctx), Mr = !1, On = ++ks, t.ac !== null && (Fl(() => {
    t.ac.abort(no);
  }), t.ac = null);
  try {
    t.f |= hc;
    var c = (
      /** @type {Function} */
      t.fn
    ), f = c(), g = t.deps, _ = rt?.is_fork;
    if (Yt !== null) {
      var b;
      if (_ || tl(t, lr), g !== null && lr > 0)
        for (g.length = lr + Yt.length, b = 0; b < Yt.length; b++)
          g[lr + b] = Yt[b];
      else
        t.deps = g = Yt;
      if (md() && (t.f & wr) !== 0)
        for (b = lr; b < g.length; b++)
          (g[b].reactions ??= []).push(t);
    } else !_ && g !== null && lr < g.length && (tl(t, lr), g.length = lr);
    if (Oo() && br !== null && !Mr && g !== null && (t.f & (Et | Fr | Tt)) === 0)
      for (b = 0; b < /** @type {Source[]} */
      br.length; b++)
        Hv(
          br[b],
          /** @type {Effect} */
          t
        );
    if (s !== null && s !== t) {
      if (ks++, s.deps !== null)
        for (let p = 0; p < r; p += 1)
          s.deps[p].rv = ks;
      if (e !== null)
        for (const p of e)
          p.rv = ks;
      br !== null && (n === null ? n = br : n.push(.../** @type {Source[]} */
      br));
    }
    return (t.f & Wn) !== 0 && (t.f ^= Wn), f;
  } catch (p) {
    return gv(p);
  } finally {
    t.f ^= hc, Yt = e, lr = r, br = n, Ge = s, Sr = o, co(i), Mr = a, On = l;
  }
}
function TP(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = jx.call(r, t);
    if (n !== -1) {
      var s = r.length - 1;
      s === 0 ? r = e.reactions = null : (r[n] = r[s], r.pop());
    }
  }
  if (r === null && (e.f & Et) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Yt === null || !uo.call(Yt, e))) {
    var o = (
      /** @type {Derived} */
      e
    );
    (o.f & wr) !== 0 && (o.f ^= wr, o.f &= ~Ms), dd(o), Sv(o), tl(o, 0);
  }
}
function tl(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      TP(t, r[n]);
}
function di(t) {
  var e = t.f;
  if ((e & xn) === 0) {
    dt(t, Ot);
    var r = Je, n = qa;
    Je = t, qa = !0;
    try {
      (e & (In | id)) !== 0 ? $P(t) : Lv(t), Vv(t);
      var s = Gv(t);
      t.teardown = typeof s == "function" ? s : null, t.wv = Kv;
      var o;
      dc && iP && (t.f & Tt) !== 0 && t.deps;
    } finally {
      qa = n, Je = r;
    }
  }
}
async function Vl() {
  await Promise.resolve(), m();
}
function d(t) {
  var e = t.f, r = (e & Et) !== 0;
  if (Ge !== null && !Mr) {
    var n = Je !== null && (Je.f & xn) !== 0;
    if (!n && (Sr === null || !uo.call(Sr, t))) {
      var s = Ge.deps;
      if ((Ge.f & hc) !== 0)
        t.rv < ks && (t.rv = ks, Yt === null && s !== null && s[lr] === t ? lr++ : Yt === null ? Yt = [t] : Yt.push(t));
      else {
        (Ge.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Ge] : uo.call(o, Ge) || o.push(Ge);
      }
    }
  }
  if (Zn && Hn.has(t))
    return Hn.get(t);
  if (r) {
    var i = (
      /** @type {Derived} */
      t
    );
    if (Zn) {
      var a = i.v;
      return ((i.f & Ot) === 0 && i.reactions !== null || Xv(i)) && (a = gd(i)), Hn.set(i, a), a;
    }
    var l = (i.f & wr) === 0 && !Mr && Ge !== null && (qa || (Ge.f & wr) !== 0), u = i.deps === null;
    Ei(i) && (l && (i.f |= wr), xv(i)), l && !u && Yv(i);
  }
  if (Er?.has(t))
    return Er.get(t);
  if ((t.f & Wn) !== 0)
    throw t.v;
  return t.v;
}
function Yv(t) {
  if (t.deps !== null) {
    t.f |= wr;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & Et) !== 0 && (e.f & wr) === 0 && Yv(
        /** @type {Derived} */
        e
      );
  }
}
function Xv(t) {
  if (t.v === xt) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Hn.has(e) || (e.f & Et) !== 0 && Xv(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function ot(t) {
  var e = Mr;
  try {
    return Mr = !0, t();
  } finally {
    Mr = e;
  }
}
function Nn(t, e) {
  var r = {};
  for (var n in t)
    e.includes(n) || (r[n] = t[n]);
  for (var s of Object.getOwnPropertySymbols(t))
    Object.propertyIsEnumerable.call(t, s) && !e.includes(s) && (r[s] = t[s]);
  return r;
}
function DP(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (en in t)
      bc(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && en in r && bc(r);
      }
  }
}
function bc(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        bc(t[n], e);
      } catch {
      }
    const r = El(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = ov(r);
      for (let s in n) {
        const o = n[s].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
const Jv = /* @__PURE__ */ new Set(), _c = /* @__PURE__ */ new Set();
function Zv(t, e, r, n = {}) {
  function s(o) {
    if (n.capture || ni.call(e, o), !o.cancelBubble)
      return Fl(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? Ir(() => {
    e.addEventListener(t, s, n);
  }) : e.addEventListener(t, s, n), s;
}
function Ye(t, e, r, n = {}) {
  var s = Zv(e, t, r, n);
  return () => {
    t.removeEventListener(e, s, n);
  };
}
function MP(t) {
  for (var e = 0; e < t.length; e++)
    Jv.add(t[e]);
  for (var r of _c)
    r(t);
}
let yg = null;
function ni(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, s = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    s[0] || t.target
  );
  yg = t;
  var i = 0, a = yg === t && t.__root;
  if (a) {
    var l = s.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = s.indexOf(e);
    if (u === -1)
      return;
    l <= u && (i = l);
  }
  if (o = /** @type {Element} */
  s[i] || t.target, o !== e) {
    Za(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Ge, f = Je;
    Pr(null), nn(null);
    try {
      for (var g, _ = []; o !== null; ) {
        var b = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var p = o["__" + n];
          p != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && p.call(o, t);
        } catch (h) {
          g ? _.push(h) : g = h;
        }
        if (t.cancelBubble || b === e || b === null)
          break;
        o = b;
      }
      if (g) {
        for (let h of _)
          queueMicrotask(() => {
            throw h;
          });
        throw g;
      }
    } finally {
      t.__root = e, delete t.currentTarget, Pr(c), nn(f);
    }
  }
}
function Qv(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Nr(t, e) {
  var r = (
    /** @type {Effect} */
    Je
  );
  r.nodes === null && (r.nodes = { start: t, end: e, a: null, t: null });
}
// @__NO_SIDE_EFFECTS__
function ne(t, e) {
  var r = (e & Fx) !== 0, n = (e & Rx) !== 0, s, o = !t.startsWith("<!>");
  return () => {
    if (Ne)
      return Nr(ze, null), ze;
    s === void 0 && (s = Qv(o ? t : "<!>" + t), r || (s = /** @type {TemplateNode} */
    /* @__PURE__ */ Rr(s)));
    var i = (
      /** @type {TemplateNode} */
      n || kv ? document.importNode(s, !0) : s.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Rr(i)
      ), l = (
        /** @type {TemplateNode} */
        i.lastChild
      );
      Nr(a, l);
    } else
      Nr(i, i);
    return i;
  };
}
// @__NO_SIDE_EFFECTS__
function IP(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), s = `<${r}>${n ? t : "<!>" + t}</${r}>`, o;
  return () => {
    if (Ne)
      return Nr(ze, null), ze;
    if (!o) {
      var i = (
        /** @type {DocumentFragment} */
        Qv(s)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ Rr(i)
      );
      o = /** @type {Element} */
      /* @__PURE__ */ Rr(a);
    }
    var l = (
      /** @type {TemplateNode} */
      o.cloneNode(!0)
    );
    return Nr(l, l), l;
  };
}
// @__NO_SIDE_EFFECTS__
function NP(t, e) {
  return /* @__PURE__ */ IP(t, e, "svg");
}
function st(t = "") {
  if (!Ne) {
    var e = qt(t + "");
    return Nr(e, e), e;
  }
  var r = ze;
  return r.nodeType !== ki ? (r.before(r = qt()), _t(r)) : Nl(
    /** @type {Text} */
    r
  ), Nr(r, r), r;
}
function M() {
  if (Ne)
    return Nr(ze, null), ze;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = qt();
  return t.append(e, r), Nr(e, r), t;
}
function A(t, e) {
  if (Ne) {
    var r = (
      /** @type {Effect & { nodes: EffectNodes }} */
      Je
    );
    ((r.f & Tl) === 0 || r.nodes.end === null) && (r.nodes.end = ze), $n();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
function De() {
  if (Ne && ze && ze.nodeType === qs && ze.textContent?.startsWith("$")) {
    const t = ze.textContent.substring(1);
    return $n(), t;
  }
  return (window.__svelte ??= {}).uid ??= 1, `c${window.__svelte.uid++}`;
}
function FP(t) {
  return t.endsWith("capture") && t !== "gotpointercapture" && t !== "lostpointercapture";
}
const RP = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function VP(t) {
  return RP.includes(t);
}
const LP = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function jP(t) {
  return t = t.toLowerCase(), LP[t] ?? t;
}
const BP = ["touchstart", "touchmove"];
function zP(t) {
  return BP.includes(t);
}
const qP = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function UP(t) {
  return qP.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    t
  );
}
function Ie(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function bd(t, e) {
  return ey(t, e);
}
function KP(t, e) {
  yc(), e.intro = e.intro ?? !1;
  const r = e.target, n = Ne, s = ze;
  try {
    for (var o = /* @__PURE__ */ Rr(r); o && (o.nodeType !== qs || /** @type {Comment} */
    o.data !== nv); )
      o = /* @__PURE__ */ ln(o);
    if (!o)
      throw lo;
    zt(!0), _t(
      /** @type {Comment} */
      o
    );
    const i = ey(t, { ...e, anchor: o });
    return zt(!1), /**  @type {Exports} */
    i;
  } catch (i) {
    if (i instanceof Error && i.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw i;
    return i !== lo && console.warn("Failed to hydrate: ", i), e.recover === !1 && Jx(), yc(), pd(r), zt(!1), bd(t, e);
  } finally {
    zt(n), _t(s);
  }
}
const Js = /* @__PURE__ */ new Map();
function ey(t, { target: e, anchor: r, props: n = {}, events: s, context: o, intro: i = !0 }) {
  yc();
  var a = /* @__PURE__ */ new Set(), l = (f) => {
    for (var g = 0; g < f.length; g++) {
      var _ = f[g];
      if (!a.has(_)) {
        a.add(_);
        var b = zP(_);
        e.addEventListener(_, ni, { passive: b });
        var p = Js.get(_);
        p === void 0 ? (document.addEventListener(_, ni, { passive: b }), Js.set(_, 1)) : Js.set(_, p + 1);
      }
    }
  };
  l(Al(Jv)), _c.add(l);
  var u = void 0, c = CP(() => {
    var f = r ?? e.appendChild(qt());
    return mP(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (g) => {
        if (o) {
          W({});
          var _ = (
            /** @type {ComponentContext} */
            it
          );
          _.c = o;
        }
        if (s && (n.$$events = s), Ne && Nr(
          /** @type {TemplateNode} */
          g,
          null
        ), u = t(g, n) || {}, Ne && (Je.nodes.end = ze, ze === null || ze.nodeType !== qs || /** @type {Comment} */
        ze.data !== od))
          throw Dl(), lo;
        o && H();
      }
    ), () => {
      for (var g of a) {
        e.removeEventListener(g, ni);
        var _ = (
          /** @type {number} */
          Js.get(g)
        );
        --_ === 0 ? (document.removeEventListener(g, ni), Js.delete(g)) : Js.set(g, _);
      }
      _c.delete(l), f !== r && f.parentNode?.removeChild(f);
    };
  });
  return wc.set(u, c), u;
}
let wc = /* @__PURE__ */ new WeakMap();
function ty(t, e) {
  const r = wc.get(t);
  return r ? (wc.delete(t), r(e)) : Promise.resolve();
}
class Ti {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /**
   * Map of keys to effects that are currently rendered in the DOM.
   * These effects are visible and actively part of the document tree.
   * Example:
   * ```
   * {#if condition}
   * 	foo
   * {:else}
   * 	bar
   * {/if}
   * ```
   * Can result in the entries `true->Effect` and `false->Effect`
   * @type {Map<Key, Effect>}
   */
  #t = /* @__PURE__ */ new Map();
  /**
   * Similar to #onscreen with respect to the keys, but contains branches that are not yet
   * in the DOM, because their insertion is deferred.
   * @type {Map<Key, Branch>}
   */
  #r = /* @__PURE__ */ new Map();
  /**
   * Keys of effects that are currently outroing
   * @type {Set<Key>}
   */
  #n = /* @__PURE__ */ new Set();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #s = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#s = r;
  }
  #o = () => {
    var e = (
      /** @type {Batch} */
      rt
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        yd(n), this.#n.delete(r);
      else {
        var s = this.#r.get(r);
        s && (this.#t.set(r, s.effect), this.#r.delete(r), s.fragment.lastChild.remove(), this.anchor.before(s.fragment), n = s.effect);
      }
      for (const [o, i] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(i);
        a && (Ct(a.effect), this.#r.delete(i));
      }
      for (const [o, i] of this.#t) {
        if (o === r || this.#n.has(o)) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var u = document.createDocumentFragment();
            qv(i, u), u.append(qt()), this.#r.set(o, { effect: i, fragment: u });
          } else
            Ct(i);
          this.#n.delete(o), this.#t.delete(o);
        };
        this.#s || !n ? (this.#n.add(o), Es(i, a, !1)) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #i = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, s] of this.#r)
      r.includes(n) || (Ct(s.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      rt
    ), s = Ev();
    if (r && !this.#t.has(e) && !this.#r.has(e))
      if (s) {
        var o = document.createDocumentFragment(), i = qt();
        o.append(i), this.#r.set(e, {
          effect: Xt(() => r(i)),
          fragment: o
        });
      } else
        this.#t.set(
          e,
          Xt(() => r(this.anchor))
        );
    if (this.#e.set(n, e), s) {
      for (const [a, l] of this.#t)
        a === e ? n.unskip_effect(l) : n.skip_effect(l);
      for (const [a, l] of this.#r)
        a === e ? n.unskip_effect(l.effect) : n.skip_effect(l.effect);
      n.oncommit(this.#o), n.ondiscard(this.#i);
    } else
      Ne && (this.anchor = ze), this.#o();
  }
}
function te(t, e, ...r) {
  var n = new Ti(t);
  Us(() => {
    const s = e() ?? null;
    n.ensure(s, s && ((o) => s(o, ...r)));
  }, kn);
}
function ko(t) {
  it === null && cd(), So && it.l !== null ? HP(it).m.push(t) : Xe(() => {
    const e = ot(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function WP(t) {
  it === null && cd(), ko(() => () => ot(t));
}
function HP(t) {
  var e = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
function ry() {
  return Symbol(sv);
}
function ue(t, e, r = !1) {
  Ne && $n();
  var n = new Ti(t), s = r ? kn : 0;
  function o(i, a) {
    if (Ne) {
      const u = cv(t) === kl;
      if (i === u) {
        var l = el();
        _t(l), n.anchor = l, zt(!1), n.ensure(i, a), zt(!0);
        return;
      }
    }
    n.ensure(i, a);
  }
  Us(() => {
    var i = !1;
    e((a, l = !0) => {
      i = !0, o(l, a);
    }), i || o(!1, null);
  }, s);
}
function Ll(t, e, r) {
  Ne && $n();
  var n = new Ti(t), s = !Oo();
  Us(() => {
    var o = e();
    s && o !== null && typeof o == "object" && (o = /** @type {V} */
    {}), n.ensure(o, r);
  });
}
function jl(t, e) {
  return e;
}
function GP(t, e, r) {
  for (var n = [], s = e.length, o, i = e.length, a = 0; a < s; a++) {
    let f = e[a];
    Es(
      f,
      () => {
        if (o) {
          if (o.pending.delete(f), o.done.add(f), o.pending.size === 0) {
            var g = (
              /** @type {Set<EachOutroGroup>} */
              t.outrogroups
            );
            Sc(Al(o.done)), g.delete(o), g.size === 0 && (t.outrogroups = null);
          }
        } else
          i -= 1;
      },
      !1
    );
  }
  if (i === 0) {
    var l = n.length === 0 && r !== null;
    if (l) {
      var u = (
        /** @type {Element} */
        r
      ), c = (
        /** @type {Element} */
        u.parentNode
      );
      pd(c), c.append(u), t.items.clear();
    }
    Sc(e, !l);
  } else
    o = {
      pending: new Set(e),
      done: /* @__PURE__ */ new Set()
    }, (t.outrogroups ??= /* @__PURE__ */ new Set()).add(o);
}
function Sc(t, e = !0) {
  for (var r = 0; r < t.length; r++)
    Ct(t[r], e);
}
var bg;
function nt(t, e, r, n, s, o = null) {
  var i = t, a = /* @__PURE__ */ new Map(), l = (e & rv) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    i = Ne ? _t(/* @__PURE__ */ Rr(u)) : u.appendChild(qt());
  }
  Ne && $n();
  var c = null, f = /* @__PURE__ */ hd(() => {
    var y = r();
    return $l(y) ? y : y == null ? [] : Al(y);
  }), g, _ = !0;
  function b() {
    h.fallback = c, YP(h, g, i, e, n), c !== null && (g.length === 0 ? (c.f & bn) === 0 ? yd(c) : (c.f ^= bn, si(c, null, i)) : Es(c, () => {
      c = null;
    }));
  }
  var p = Us(() => {
    g = /** @type {V[]} */
    d(f);
    var y = g.length;
    let S = !1;
    if (Ne) {
      var x = cv(i) === kl;
      x !== (y === 0) && (i = el(), _t(i), zt(!1), S = !0);
    }
    for (var P = /* @__PURE__ */ new Set(), w = (
      /** @type {Batch} */
      rt
    ), C = Ev(), k = 0; k < y; k += 1) {
      Ne && ze.nodeType === qs && /** @type {Comment} */
      ze.data === od && (i = /** @type {Comment} */
      ze, S = !0, zt(!1));
      var $ = g[k], T = n($, k), E = _ ? null : a.get(T);
      E ? (E.v && ho(E.v, $), E.i && ho(E.i, k), C && w.unskip_effect(E.e)) : (E = XP(
        a,
        _ ? i : bg ??= qt(),
        $,
        T,
        k,
        s,
        e,
        r
      ), _ || (E.e.f |= bn), a.set(T, E)), P.add(T);
    }
    if (y === 0 && o && !c && (_ ? c = Xt(() => o(i)) : (c = Xt(() => o(bg ??= qt())), c.f |= bn)), Ne && y > 0 && _t(el()), !_)
      if (C) {
        for (const [I, F] of a)
          P.has(I) || w.skip_effect(F.e);
        w.oncommit(b), w.ondiscard(() => {
        });
      } else
        b();
    S && zt(!0), d(f);
  }), h = { effect: p, items: a, outrogroups: null, fallback: c };
  _ = !1, Ne && (i = ze);
}
function Wo(t) {
  for (; t !== null && (t.f & Ur) === 0; )
    t = t.next;
  return t;
}
function YP(t, e, r, n, s) {
  var o = (n & Ax) !== 0, i = e.length, a = t.items, l = Wo(t.effect.first), u, c = null, f, g = [], _ = [], b, p, h, y;
  if (o)
    for (y = 0; y < i; y += 1)
      b = e[y], p = s(b, y), h = /** @type {EachItem} */
      a.get(p).e, (h.f & bn) === 0 && (h.nodes?.a?.measure(), (f ??= /* @__PURE__ */ new Set()).add(h));
  for (y = 0; y < i; y += 1) {
    if (b = e[y], p = s(b, y), h = /** @type {EachItem} */
    a.get(p).e, t.outrogroups !== null)
      for (const E of t.outrogroups)
        E.pending.delete(h), E.done.delete(h);
    if ((h.f & bn) !== 0)
      if (h.f ^= bn, h === l)
        si(h, null, r);
      else {
        var S = c ? c.next : l;
        h === t.effect.last && (t.effect.last = h.prev), h.prev && (h.prev.next = h.next), h.next && (h.next.prev = h.prev), Rn(t, c, h), Rn(t, h, S), si(h, S, r), c = h, g = [], _ = [], l = Wo(c.next);
        continue;
      }
    if ((h.f & hr) !== 0 && (yd(h), o && (h.nodes?.a?.unfix(), (f ??= /* @__PURE__ */ new Set()).delete(h))), h !== l) {
      if (u !== void 0 && u.has(h)) {
        if (g.length < _.length) {
          var x = _[0], P;
          c = x.prev;
          var w = g[0], C = g[g.length - 1];
          for (P = 0; P < g.length; P += 1)
            si(g[P], x, r);
          for (P = 0; P < _.length; P += 1)
            u.delete(_[P]);
          Rn(t, w.prev, C.next), Rn(t, c, w), Rn(t, C, x), l = x, c = C, y -= 1, g = [], _ = [];
        } else
          u.delete(h), si(h, l, r), Rn(t, h.prev, h.next), Rn(t, h, c === null ? t.effect.first : c.next), Rn(t, c, h), c = h;
        continue;
      }
      for (g = [], _ = []; l !== null && l !== h; )
        (u ??= /* @__PURE__ */ new Set()).add(l), _.push(l), l = Wo(l.next);
      if (l === null)
        continue;
    }
    (h.f & bn) === 0 && g.push(h), c = h, l = Wo(h.next);
  }
  if (t.outrogroups !== null) {
    for (const E of t.outrogroups)
      E.pending.size === 0 && (Sc(Al(E.done)), t.outrogroups?.delete(E));
    t.outrogroups.size === 0 && (t.outrogroups = null);
  }
  if (l !== null || u !== void 0) {
    var k = [];
    if (u !== void 0)
      for (h of u)
        (h.f & hr) === 0 && k.push(h);
    for (; l !== null; )
      (l.f & hr) === 0 && l !== t.fallback && k.push(l), l = Wo(l.next);
    var $ = k.length;
    if ($ > 0) {
      var T = (n & rv) !== 0 && i === 0 ? r : null;
      if (o) {
        for (y = 0; y < $; y += 1)
          k[y].nodes?.a?.measure();
        for (y = 0; y < $; y += 1)
          k[y].nodes?.a?.fix();
      }
      GP(t, k, T);
    }
  }
  o && Ir(() => {
    if (f !== void 0)
      for (h of f)
        h.nodes?.a?.apply();
  });
}
function XP(t, e, r, n, s, o, i, a) {
  var l = (i & kx) !== 0 ? (i & Ex) === 0 ? /* @__PURE__ */ Ov(r, !1, !1) : Jn(r) : null, u = (i & $x) !== 0 ? Jn(s) : null;
  return {
    v: l,
    i: u,
    e: Xt(() => (o(e, l ?? r, u ?? s, a), () => {
      t.delete(n);
    }))
  };
}
function si(t, e, r) {
  if (t.nodes)
    for (var n = t.nodes.start, s = t.nodes.end, o = e && (e.f & bn) === 0 ? (
      /** @type {EffectNodes} */
      e.nodes.start
    ) : r; n !== null; ) {
      var i = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ ln(n)
      );
      if (o.before(n), n === s)
        return;
      n = i;
    }
}
function Rn(t, e, r) {
  e === null ? t.effect.first = r : e.next = r, r === null ? t.effect.last = e : r.prev = e;
}
function Q(t, e, r) {
  Ne && $n();
  var n = new Ti(t);
  Us(() => {
    var s = e() ?? null;
    n.ensure(s, s && ((o) => r(o, s)));
  }, kn);
}
function JP(t, e, r, n, s, o) {
  let i = Ne;
  Ne && $n();
  var a = null;
  Ne && ze.nodeType === Kx && (a = /** @type {Element} */
  ze, $n());
  var l = (
    /** @type {TemplateNode} */
    Ne ? ze : t
  ), u = new Ti(l, !1);
  Us(() => {
    const c = e() || null;
    var f = Lx;
    if (c === null) {
      u.ensure(null, null);
      return;
    }
    return u.ensure(c, (g) => {
      if (c) {
        if (a = Ne ? (
          /** @type {Element} */
          a
        ) : document.createElementNS(f, c), Nr(a, a), n) {
          Ne && UP(c) && a.append(document.createComment(""));
          var _ = Ne ? /* @__PURE__ */ Rr(a) : a.appendChild(qt());
          Ne && (_ === null ? zt(!1) : _t(_)), n(a, _);
        }
        Je.nodes.end = a, g.before(a);
      }
      Ne && _t(g);
    }), () => {
    };
  }, kn), vd(() => {
  }), i && (zt(!0), _t(l));
}
function ZP(t, e) {
  Rl(() => {
    var r = t.getRootNode(), n = (
      /** @type {ShadowRoot} */
      r.host ? (
        /** @type {ShadowRoot} */
        r
      ) : (
        /** @type {Document} */
        r.head ?? /** @type {Document} */
        r.ownerDocument.head
      )
    );
    if (!n.querySelector("#" + e.hash)) {
      const s = document.createElement("style");
      s.id = e.hash, s.textContent = e.code, n.appendChild(s);
    }
  });
}
function QP(t, e) {
  var r = void 0, n;
  Rv(() => {
    r !== (r = e()) && (n && (Ct(n), n = null), r && (n = Xt(() => {
      Rl(() => (
        /** @type {(node: Element) => void} */
        r(t)
      ));
    })));
  });
}
function ny(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (r = ny(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function io() {
  for (var t, e, r = 0, n = "", s = arguments.length; r < s; r++) (t = arguments[r]) && (e = ny(t)) && (n && (n += " "), n += e);
  return n;
}
function as(t) {
  return typeof t == "object" ? io(t) : t ?? "";
}
const _g = [...` 	
\r\fÂ \v\uFEFF`];
function eO(t, e, r) {
  var n = t == null ? "" : "" + t;
  if (r) {
    for (var s in r)
      if (r[s])
        n = n ? n + " " + s : s;
      else if (n.length)
        for (var o = s.length, i = 0; (i = n.indexOf(s, i)) >= 0; ) {
          var a = i + o;
          (i === 0 || _g.includes(n[i - 1])) && (a === n.length || _g.includes(n[a])) ? n = (i === 0 ? "" : n.substring(0, i)) + n.substring(a + 1) : i = a;
        }
  }
  return n === "" ? null : n;
}
function wg(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var s in t) {
    var o = t[s];
    o != null && o !== "" && (n += " " + s + ": " + o + r);
  }
  return n;
}
function Ou(t) {
  return t[0] !== "-" || t[1] !== "-" ? t.toLowerCase() : t;
}
function tO(t, e) {
  if (e) {
    var r = "", n, s;
    if (Array.isArray(e) ? (n = e[0], s = e[1]) : n = e, t) {
      t = String(t).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var o = !1, i = 0, a = !1, l = [];
      n && l.push(...Object.keys(n).map(Ou)), s && l.push(...Object.keys(s).map(Ou));
      var u = 0, c = -1;
      const p = t.length;
      for (var f = 0; f < p; f++) {
        var g = t[f];
        if (a ? g === "/" && t[f - 1] === "*" && (a = !1) : o ? o === g && (o = !1) : g === "/" && t[f + 1] === "*" ? a = !0 : g === '"' || g === "'" ? o = g : g === "(" ? i++ : g === ")" && i--, !a && o === !1 && i === 0) {
          if (g === ":" && c === -1)
            c = f;
          else if (g === ";" || f === p - 1) {
            if (c !== -1) {
              var _ = Ou(t.substring(u, c).trim());
              if (!l.includes(_)) {
                g !== ";" && f++;
                var b = t.substring(u, f).trim();
                r += " " + b + ";";
              }
            }
            u = f + 1, c = -1;
          }
        }
      }
    }
    return n && (r += wg(n)), s && (r += wg(s, !0)), r = r.trim(), r === "" ? null : r;
  }
  return t == null ? null : String(t);
}
function ls(t, e, r, n, s, o) {
  var i = t.__className;
  if (Ne || i !== r || i === void 0) {
    var a = eO(r, n, o);
    (!Ne || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : e ? t.className = a : t.setAttribute("class", a)), t.__className = r;
  } else if (o && s !== o)
    for (var l in o) {
      var u = !!o[l];
      (s == null || u !== !!s[l]) && t.classList.toggle(l, u);
    }
  return o;
}
function Cu(t, e = {}, r, n) {
  for (var s in r) {
    var o = r[s];
    e[s] !== o && (r[s] == null ? t.style.removeProperty(s) : t.style.setProperty(s, o, n));
  }
}
function rO(t, e, r, n) {
  var s = t.__style;
  if (Ne || s !== e) {
    var o = tO(e, n);
    (!Ne || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (Cu(t, r?.[0], n[0]), Cu(t, r?.[1], n[1], "important")) : Cu(t, r, n));
  return n;
}
function xc(t, e, r = !1) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!$l(e))
      return nP();
    for (var n of t.options)
      n.selected = e.includes(Sg(n));
    return;
  }
  for (n of t.options) {
    var s = Sg(n);
    if (SP(s, e)) {
      n.selected = !0;
      return;
    }
  }
  (!r || e !== void 0) && (t.selectedIndex = -1);
}
function nO(t) {
  var e = new MutationObserver(() => {
    xc(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), vd(() => {
    e.disconnect();
  });
}
function Sg(t) {
  return "__value" in t ? t.__value : t.value;
}
const Ho = /* @__PURE__ */ Symbol("class"), Go = /* @__PURE__ */ Symbol("style"), sy = /* @__PURE__ */ Symbol("is custom element"), oy = /* @__PURE__ */ Symbol("is html");
function iy(t) {
  if (Ne) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          An(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var s = t.checked;
          An(t, "checked", null), t.checked = s;
        }
      }
    };
    t.__on_r = r, Ir(r), Dv();
  }
}
function sO(t, e) {
  var r = _d(t);
  r.value === (r.value = // treat null and undefined the same for the initial value
  e ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  t.value === e && (e !== 0 || t.nodeName !== "PROGRESS") || (t.value = e ?? "");
}
function Ks(t, e) {
  e ? t.hasAttribute("selected") || t.setAttribute("selected", "") : t.removeAttribute("selected");
}
function An(t, e, r, n) {
  var s = _d(t);
  Ne && (s[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || s[e] !== (s[e] = r) && (e === "loading" && (t[Ux] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && ay(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function oO(t, e, r, n, s = !1, o = !1) {
  if (Ne && s && t.tagName === "INPUT") {
    var i = (
      /** @type {HTMLInputElement} */
      t
    ), a = i.type === "checkbox" ? "defaultChecked" : "defaultValue";
    a in r || iy(i);
  }
  var l = _d(t), u = l[sy], c = !l[oy];
  let f = Ne && u;
  f && zt(!1);
  var g = e || {}, _ = t.tagName === "OPTION";
  for (var b in e)
    b in r || (r[b] = null);
  r.class ? r.class = as(r.class) : r[Ho] && (r.class = null), r[Go] && (r.style ??= null);
  var p = ay(t);
  for (const C in r) {
    let k = r[C];
    if (_ && C === "value" && k == null) {
      t.value = t.__value = "", g[C] = k;
      continue;
    }
    if (C === "class") {
      var h = t.namespaceURI === "http://www.w3.org/1999/xhtml";
      ls(t, h, k, n, e?.[Ho], r[Ho]), g[C] = k, g[Ho] = r[Ho];
      continue;
    }
    if (C === "style") {
      rO(t, k, e?.[Go], r[Go]), g[C] = k, g[Go] = r[Go];
      continue;
    }
    var y = g[C];
    if (!(k === y && !(k === void 0 && t.hasAttribute(C)))) {
      g[C] = k;
      var S = C[0] + C[1];
      if (S !== "$$")
        if (S === "on") {
          const $ = {}, T = "$$" + C;
          let E = C.slice(2);
          var x = VP(E);
          if (FP(E) && (E = E.slice(0, -7), $.capture = !0), !x && y) {
            if (k != null) continue;
            t.removeEventListener(E, g[T], $), g[T] = null;
          }
          if (k != null)
            if (x)
              t[`__${E}`] = k, MP([E]);
            else {
              let I = function(F) {
                g[C].call(this, F);
              };
              g[T] = Zv(E, t, I, $);
            }
          else x && (t[`__${E}`] = void 0);
        } else if (C === "style")
          An(t, C, k);
        else if (C === "autofocus")
          PP(
            /** @type {HTMLElement} */
            t,
            !!k
          );
        else if (!u && (C === "__value" || C === "value" && k != null))
          t.value = t.__value = k;
        else if (C === "selected" && _)
          Ks(
            /** @type {HTMLOptionElement} */
            t,
            k
          );
        else {
          var P = C;
          c || (P = jP(P));
          var w = P === "defaultValue" || P === "defaultChecked";
          if (k == null && !u && !w)
            if (l[C] = null, P === "value" || P === "checked") {
              let $ = (
                /** @type {HTMLInputElement} */
                t
              );
              const T = e === void 0;
              if (P === "value") {
                let E = $.defaultValue;
                $.removeAttribute(P), $.defaultValue = E, $.value = $.__value = T ? E : null;
              } else {
                let E = $.defaultChecked;
                $.removeAttribute(P), $.defaultChecked = E, $.checked = T ? E : !1;
              }
            } else
              t.removeAttribute(C);
          else w || p.includes(P) && (u || typeof k != "string") ? (t[P] = k, P in l && (l[P] = xt)) : typeof k != "function" && An(t, P, k);
        }
    }
  }
  return f && zt(!0), g;
}
function ve(t, e, r = [], n = [], s = [], o, i = !1, a = !1) {
  wv(s, r, n, (l) => {
    var u = void 0, c = {}, f = t.nodeName === "SELECT", g = !1;
    if (Rv(() => {
      var b = e(...l.map(d)), p = oO(
        t,
        u,
        b,
        o,
        i,
        a
      );
      g && f && "value" in b && xc(
        /** @type {HTMLSelectElement} */
        t,
        b.value
      );
      for (let y of Object.getOwnPropertySymbols(c))
        b[y] || Ct(c[y]);
      for (let y of Object.getOwnPropertySymbols(b)) {
        var h = b[y];
        y.description === sv && (!u || h !== u[y]) && (c[y] && Ct(c[y]), c[y] = Xt(() => QP(t, () => h))), p[y] = h;
      }
      u = p;
    }), f) {
      var _ = (
        /** @type {HTMLSelectElement} */
        t
      );
      Rl(() => {
        xc(
          _,
          /** @type {Record<string | symbol, any>} */
          u.value,
          !0
        ), nO(_);
      });
    }
    g = !0;
  });
}
function _d(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [sy]: t.nodeName.includes("-"),
      [oy]: t.namespaceURI === Vx
    }
  );
}
var xg = /* @__PURE__ */ new Map();
function ay(t) {
  var e = t.getAttribute("is") || t.nodeName, r = xg.get(e);
  if (r) return r;
  xg.set(e, r = []);
  for (var n, s = t, o = Element.prototype; o !== s; ) {
    n = ov(s);
    for (var i in n)
      n[i].set && r.push(i);
    s = El(s);
  }
  return r;
}
let ku = null;
function iO() {
  if (ku === null) {
    var t = document.createElement("select");
    t.innerHTML = "<option><span>t</span></option>", ku = /** @type {Element} */
    t.firstChild?.firstChild?.nodeType === 1;
  }
  return ku;
}
function ly(t, e) {
  var r = Ne;
  iO() || (zt(!1), t.textContent = "", t.append(xP("")));
  try {
    e();
  } finally {
    r && (Ne ? de(t) : (zt(!0), _t(t)));
  }
}
function Di(t, e, r = e) {
  var n = /* @__PURE__ */ new WeakSet();
  Mv(t, "input", async (s) => {
    var o = s ? t.defaultValue : t.value;
    if (o = $u(t) ? Au(o) : o, r(o), rt !== null && n.add(rt), await Vl(), o !== (o = e())) {
      var i = t.selectionStart, a = t.selectionEnd, l = t.value.length;
      if (t.value = o ?? "", a !== null) {
        var u = t.value.length;
        i === a && a === l && u > l ? (t.selectionStart = u, t.selectionEnd = u) : (t.selectionStart = i, t.selectionEnd = Math.min(a, u));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (Ne && t.defaultValue !== t.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  ot(e) == null && t.value) && (r($u(t) ? Au(t.value) : t.value), rt !== null && n.add(rt)), Ai(() => {
    var s = e();
    if (t === document.activeElement) {
      var o = (
        /** @type {Batch} */
        gc ?? rt
      );
      if (n.has(o))
        return;
    }
    $u(t) && s === Au(t.value) || t.type === "date" && !s && !t.value || s !== t.value && (t.value = s ?? "");
  });
}
function $u(t) {
  var e = t.type;
  return e === "number" || e === "range";
}
function Au(t) {
  return t === "" ? null : +t;
}
function uy(t, e, r = e) {
  Mv(t, "change", () => {
    r(t.files);
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  Ne && t.files && r(t.files), Ai(() => {
    t.files = e();
  });
}
function Pg(t, e) {
  return t === e || t?.[en] === e;
}
function Qe(t = {}, e, r, n) {
  return Rl(() => {
    var s, o;
    return Ai(() => {
      s = o, o = [], ot(() => {
        t !== r(...o) && (e(t, ...o), s && Pg(r(...s), t) && e(null, ...s));
      });
    }), () => {
      Ir(() => {
        o && Pg(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
function wd(t = !1) {
  const e = (
    /** @type {ComponentContextLegacy} */
    it
  ), r = e.l.u;
  if (!r) return;
  let n = () => DP(e.s);
  if (t) {
    let s = 0, o = (
      /** @type {Record<string, any>} */
      {}
    );
    const i = /* @__PURE__ */ $i(() => {
      let a = !1;
      const l = e.s;
      for (const u in l)
        l[u] !== o[u] && (o[u] = l[u], a = !0);
      return a && s++, s;
    });
    n = () => d(i);
  }
  r.b.length && Co(() => {
    Og(e, n), fc(r.b);
  }), Xe(() => {
    const s = ot(() => r.m.map(zx));
    return () => {
      for (const o of s)
        typeof o == "function" && o();
    };
  }), r.a.length && Xe(() => {
    Og(e, n), fc(r.a);
  });
}
function Og(t, e) {
  if (t.l.s)
    for (const r of t.l.s) d(r);
  e();
}
let Ki = !1;
function aO(t) {
  var e = Ki;
  try {
    return Ki = !1, [t(), Ki];
  } finally {
    Ki = e;
  }
}
const lO = {
  get(t, e) {
    if (!t.exclude.includes(e))
      return t.props[e];
  },
  set(t, e) {
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    if (!t.exclude.includes(e) && e in t.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: t.props[e]
      };
  },
  has(t, e) {
    return t.exclude.includes(e) ? !1 : e in t.props;
  },
  ownKeys(t) {
    return Reflect.ownKeys(t.props).filter((e) => !t.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function ie(t, e, r) {
  return new Proxy(
    { props: t, exclude: e },
    lO
  );
}
const uO = {
  get(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Ko(n) && (n = n()), typeof n == "object" && n !== null && e in n) return n[e];
    }
  },
  set(t, e, r) {
    let n = t.props.length;
    for (; n--; ) {
      let s = t.props[n];
      Ko(s) && (s = s());
      const o = Sn(s, e);
      if (o && o.set)
        return o.set(r), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Ko(n) && (n = n()), typeof n == "object" && n !== null && e in n) {
        const s = Sn(n, e);
        return s && !s.configurable && (s.configurable = !0), s;
      }
    }
  },
  has(t, e) {
    if (e === en || e === ud) return !1;
    for (let r of t.props)
      if (Ko(r) && (r = r()), r != null && e in r) return !0;
    return !1;
  },
  ownKeys(t) {
    const e = [];
    for (let r of t.props)
      if (Ko(r) && (r = r()), !!r) {
        for (const n in r)
          e.includes(n) || e.push(n);
        for (const n of Object.getOwnPropertySymbols(r))
          e.includes(n) || e.push(n);
      }
    return e;
  }
};
function ce(...t) {
  return new Proxy({ props: t }, uO);
}
function v(t, e, r, n) {
  var s = !So || (r & Dx) !== 0, o = (r & Ix) !== 0, i = (r & Nx) !== 0, a = (
    /** @type {V} */
    n
  ), l = !0, u = () => (l && (l = !1, a = i ? ot(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), a), c;
  if (o) {
    var f = en in t || ud in t;
    c = Sn(t, e)?.set ?? (f && e in t ? (x) => t[e] = x : void 0);
  }
  var g, _ = !1;
  o ? [g, _] = aO(() => (
    /** @type {V} */
    t[e]
  )) : g = /** @type {V} */
  t[e], g === void 0 && n !== void 0 && (g = u(), c && (s && Zx(), c(g)));
  var b;
  if (s ? b = () => {
    var x = (
      /** @type {V} */
      t[e]
    );
    return x === void 0 ? u() : (l = !0, x);
  } : b = () => {
    var x = (
      /** @type {V} */
      t[e]
    );
    return x !== void 0 && (a = /** @type {V} */
    void 0), x === void 0 ? a : x;
  }, s && (r & Mx) === 0)
    return b;
  if (c) {
    var p = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(x, P) {
        return arguments.length > 0 ? ((!s || !P || p || _) && c(P ? b() : x), x) : b();
      })
    );
  }
  var h = !1, y = ((r & Tx) !== 0 ? $i : hd)(() => (h = !1, b()));
  o && d(y);
  var S = (
    /** @type {Effect} */
    Je
  );
  return (
    /** @type {() => V} */
    (function(x, P) {
      if (arguments.length > 0) {
        const w = P ? d(y) : s && o ? Pt(x) : x;
        return q(y, w), h = !0, a !== void 0 && (a = w), x;
      }
      return Zn && h || (S.f & xn) !== 0 ? y.v : d(y);
    })
  );
}
function cO(t) {
  return new dO(t);
}
class dO {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, i) => {
      var a = /* @__PURE__ */ Ov(i, !1, !1);
      return r.set(o, a), a;
    };
    const s = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, i) {
          return d(r.get(i) ?? n(i, Reflect.get(o, i)));
        },
        has(o, i) {
          return i === ud ? !0 : (d(r.get(i) ?? n(i, Reflect.get(o, i))), Reflect.has(o, i));
        },
        set(o, i, a) {
          return q(r.get(i) ?? n(i, a), a), Reflect.set(o, i, a);
        }
      }
    );
    this.#t = (e.hydrate ? KP : bd)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: s,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && m(), this.#e = s.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || Za(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(i) {
          this.#t[o] = i;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(s, o);
    }, this.#t.$destroy = () => {
      ty(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...s) => r.call(this, ...s);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (s) => s !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
let cy;
typeof HTMLElement == "function" && (cy = class extends HTMLElement {
  /** The Svelte component constructor */
  $$ctor;
  /** Slots */
  $$s;
  /** @type {any} The Svelte component instance */
  $$c;
  /** Whether or not the custom element is connected */
  $$cn = !1;
  /** @type {Record<string, any>} Component props data */
  $$d = {};
  /** `true` if currently in the process of reflecting component props back to attributes */
  $$r = !1;
  /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
  $$p_d = {};
  /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
  $$l = {};
  /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
  $$l_u = /* @__PURE__ */ new Map();
  /** @type {any} The managed render effect for reflecting attributes */
  $$me;
  /** @type {ShadowRoot | null} The ShadowRoot of the custom element */
  $$shadowRoot = null;
  /**
   * @param {*} $$componentCtor
   * @param {*} $$slots
   * @param {ShadowRootInit | undefined} shadow_root_init
   */
  constructor(t, e, r) {
    super(), this.$$ctor = t, this.$$s = e, r && (this.$$shadowRoot = this.attachShadow(r));
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  addEventListener(t, e, r) {
    if (this.$$l[t] = this.$$l[t] || [], this.$$l[t].push(e), this.$$c) {
      const n = this.$$c.$on(t, e);
      this.$$l_u.set(e, n);
    }
    super.addEventListener(t, e, r);
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  removeEventListener(t, e, r) {
    if (super.removeEventListener(t, e, r), this.$$c) {
      const n = this.$$l_u.get(e);
      n && (n(), this.$$l_u.delete(e));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let t = function(n) {
        return (s) => {
          const o = document.createElement("slot");
          n !== "default" && (o.name = n), A(s, o);
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const e = {}, r = fO(this);
      for (const n of this.$$s)
        n in r && (n === "default" && !this.$$d.children ? (this.$$d.children = t(n), e.default = !0) : e[n] = t(n));
      for (const n of this.attributes) {
        const s = this.$$g_p(n.name);
        s in this.$$d || (this.$$d[s] = Ua(s, n.value, this.$$p_d, "toProp"));
      }
      for (const n in this.$$p_d)
        !(n in this.$$d) && this[n] !== void 0 && (this.$$d[n] = this[n], delete this[n]);
      this.$$c = cO({
        component: this.$$ctor,
        target: this.$$shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: e,
          $$host: this
        }
      }), this.$$me = Fv(() => {
        Ai(() => {
          this.$$r = !0;
          for (const n of Ja(this.$$c)) {
            if (!this.$$p_d[n]?.reflect) continue;
            this.$$d[n] = this.$$c[n];
            const s = Ua(
              n,
              this.$$d[n],
              this.$$p_d,
              "toAttribute"
            );
            s == null ? this.removeAttribute(this.$$p_d[n].attribute || n) : this.setAttribute(this.$$p_d[n].attribute || n, s);
          }
          this.$$r = !1;
        });
      });
      for (const n in this.$$l)
        for (const s of this.$$l[n]) {
          const o = this.$$c.$on(n, s);
          this.$$l_u.set(s, o);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  /**
   * @param {string} attr
   * @param {string} _oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(t, e, r) {
    this.$$r || (t = this.$$g_p(t), this.$$d[t] = Ua(t, r, this.$$p_d, "toProp"), this.$$c?.$set({ [t]: this.$$d[t] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
    });
  }
  /**
   * @param {string} attribute_name
   */
  $$g_p(t) {
    return Ja(this.$$p_d).find(
      (e) => this.$$p_d[e].attribute === t || !this.$$p_d[e].attribute && e.toLowerCase() === t
    ) || t;
  }
});
function Ua(t, e, r, n) {
  const s = r[t]?.type;
  if (e = s === "Boolean" && typeof e != "boolean" ? e != null : e, !n || !r[t])
    return e;
  if (n === "toAttribute")
    switch (s) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (s) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      // conversion already handled above
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function fO(t) {
  const e = {};
  return t.childNodes.forEach((r) => {
    e[
      /** @type {Element} node */
      r.slot || "default"
    ] = !0;
  }), e;
}
function K(t, e, r, n, s, o) {
  let i = class extends cy {
    constructor() {
      super(t, r, s), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Ja(e).map(
        (a) => (e[a].attribute || a).toLowerCase()
      );
    }
  };
  return Ja(e).forEach((a) => {
    Za(i.prototype, a, {
      get() {
        return this.$$c && a in this.$$c ? this.$$c[a] : this.$$d[a];
      },
      set(l) {
        l = Ua(a, l, e), this.$$d[a] = l;
        var u = this.$$c;
        if (u) {
          var c = Sn(u, a)?.get;
          c ? u[a] = l : u.$set({ [a]: l });
        }
      }
    });
  }), n.forEach((a) => {
    Za(i.prototype, a, {
      get() {
        return this.$$c?.[a];
      }
    });
  }), t.element = /** @type {any} */
  i, i;
}
const Vr = "$ref", Cg = "$id", kg = "properties", hO = "items", dy = "dependencies", fy = "if", hy = "allOf", so = "anyOf", oo = "oneOf", gO = "__sjsf_rootSchema", Bl = "__additional_property", gy = "data-url";
function pO(t) {
  return t.properties !== void 0;
}
function mO(t) {
  return typeof t == "object" && !Array.isArray(t);
}
function vO(t, e) {
  return Array.from(new Array(t), (r, n) => e(n));
}
function $g(t) {
  return Array.from(new Set(t));
}
function Eu(t, e) {
  const r = t.length;
  if (r === 0)
    return e;
  let n = e.length;
  if (n === 0)
    return t;
  if (r < n) {
    const o = t;
    t = e, e = o, n = r;
  }
  const s = new Set(t);
  for (let o = 0; o < n; o++)
    s.add(e[o]);
  return Array.from(s);
}
function yO(t, e) {
  const r = [];
  if (t.length === 0 || e.length === 0)
    return r;
  if (t.length > e.length) {
    const s = t;
    t = e, e = s;
  }
  const n = new Set(e);
  for (let s = 0; s < t.length && n.size > 0; s++) {
    const o = t[s];
    n.delete(o) && r.push(o);
  }
  return r;
}
function Ns(t) {
  return t !== null && typeof t == "object";
}
const bO = Object.prototype;
function fi(t) {
  const e = Object.getPrototypeOf(t);
  return e === bO || e === null;
}
function Pc(t) {
  return Ns(t) && fi(t);
}
function tn(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return !1;
  return !0;
}
const _O = [
  "array",
  "boolean",
  "integer",
  "null",
  "number",
  "object",
  "string"
], wO = new Set(_O);
function SO(t) {
  return wO.has(t);
}
const Sd = [
  "$defs",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies"
];
new Set(Sd);
const xd = [
  "items",
  "allOf",
  "oneOf",
  "anyOf"
];
new Set(xd);
const Pd = [
  "items",
  "additionalItems",
  "additionalProperties",
  "propertyNames",
  "contains",
  "if",
  "then",
  "else",
  "not"
];
new Set(Pd);
[
  ...Sd,
  ...xd,
  ...Pd
];
function er(t) {
  return typeof t == "object";
}
function zn(t) {
  return er(t) ? tn(t) : t === !0;
}
function Ka(t, e, r = { type: "root", path: [] }) {
  if (!er(t))
    return e(t, r);
  const n = {
    ...t
  };
  for (const i of xd) {
    const a = t[i];
    if (a === void 0 || !Array.isArray(a))
      continue;
    const l = {
      type: "array",
      parent: t,
      key: i,
      index: 0,
      path: r.path.concat(i, 0)
    };
    n[i] = a.map((u, c) => (l.index = c, l.path[l.path.length - 1] = c, Ka(u, e, l)));
  }
  const s = /* @__PURE__ */ new Map();
  for (const i of Sd) {
    const a = t[i];
    if (a === void 0)
      continue;
    const l = {
      type: "record",
      parent: t,
      key: i,
      property: "",
      path: r.path.concat(i, "")
    }, u = Object.keys(a), c = u.length;
    for (let f = 0; f < c; f++) {
      const g = u[f], _ = a[g];
      if (Array.isArray(_)) {
        s.set(g, _);
        continue;
      }
      l.property = g, l.path[l.path.length - 1] = g, s.set(g, Ka(_, e, l));
    }
    n[i] = Object.fromEntries(s), s.clear();
  }
  const o = {
    type: "sub",
    parent: t,
    key: "items",
    path: r.path.concat("")
  };
  for (const i of Pd) {
    const a = t[i];
    a === void 0 || Array.isArray(a) || (o.key = i, o.path[o.path.length - 1] = i, n[i] = Ka(a, e, o));
  }
  return e(n, r);
}
function py(t, e) {
  return (r) => {
    if (t.has(r))
      return t.get(r);
    const n = e(r);
    return t.set(r, n), n;
  };
}
const zl = py;
function my() {
}
function rl(t) {
  return t;
}
const vy = (t, e) => t ? vy(e % t, t) : e, xO = (t, e) => Math.abs(t * e) / vy(t, e);
function PO(t, e) {
  return t === e ? t : `^(?=.*(?:${t}))(?=.*(?:${e})).*$`;
}
function* Tu(t, e, r) {
  const n = t.length, s = e.length;
  if (n > 0 && s > 0)
    for (let o = 0; o < n; o++) {
      const i = t[o];
      for (let a = 0; a < s; a++)
        yield r(i, e[a]);
    }
}
function Du(t, e) {
  return t || e;
}
function Ag(t) {
  return (e, r) => {
    const n = { ...e }, s = Object.keys(r), o = s.length;
    for (let i = 0; i < o; i++) {
      const a = s[i];
      n[a] = e[a] === void 0 ? r[a] : t(e[a], r[a]);
    }
    return n;
  };
}
function OO(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t)
    for (const n of r[0])
      e.set(n, r[1]);
  return e;
}
function vs(t, e, r) {
  r === void 0 || zn(r) ? delete t[e] : t[e] = r;
}
const CO = [
  "properties",
  "patternProperties",
  "additionalProperties"
];
function Eg(t) {
  const e = Object.keys(t), r = e.length, n = [];
  for (let s = 0; s < r; s++) {
    const o = e[s];
    n.push({
      regExp: new RegExp(o),
      schema: t[o]
    });
  }
  return [n, e];
}
const Tg = [[], []];
function Dg(t, e, r) {
  const n = r.length;
  for (let s = 0; s < n; s++) {
    const o = r[s];
    if (!o.regExp.test(e))
      continue;
    const i = o.schema;
    if (i === !1)
      return !0;
    t.push(i);
  }
  return !1;
}
const kO = [
  "items",
  "additionalItems"
], $O = [
  "if",
  "then",
  "else"
];
function Mg(t, e) {
  return e.if !== void 0 && (t.if = e.if), e.then !== void 0 && (t.then = e.then), e.else !== void 0 && (t.else = e.else), t;
}
function Mu(t, e) {
  if (t === e)
    return t;
  switch (t) {
    case "number":
      if (e === "integer")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    case "integer":
      if (e === "number")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    default:
      return;
  }
}
function ys(t, e, r) {
  return [t, e, r];
}
function AO(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [r, n, s] of t) {
    const o = (i) => {
      if (!s(i))
        throw new Error(`Schema keys '${r}' and '${n}' are conflicting (${r}: ${JSON.stringify(i[r])}, ${n}: ${JSON.stringify(i[n])})`);
    };
    for (const i of [
      [r, n],
      [n, r]
    ]) {
      let a = e.get(i[0]);
      a === void 0 && (a = [], e.set(i[0], a)), a.push({ oppositeKey: i[1], check: o });
    }
  }
  return e;
}
const EO = [
  ys("minimum", "maximum", (t) => t.maximum >= t.minimum),
  ys("exclusiveMinimum", "maximum", (t) => t.maximum > t.exclusiveMinimum),
  ys("minimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.minimum),
  ys("exclusiveMinimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.exclusiveMinimum),
  ys("minLength", "maxLength", (t) => t.maxLength >= t.minLength),
  ys("minItems", "maxItems", (t) => t.maxItems >= t.minItems),
  ys("minProperties", "maxProperties", (t) => t.maxProperties >= t.minProperties)
];
function TO({ mergePatterns: t = PO, isSubRegExp: e = Object.is, intersectJson: r = yO, deduplicateJsonSchemaDef: n = rl, defaultMerger: s = rl, assigners: o = [], mergers: i, checks: a = EO } = {}) {
  function l(P) {
    const w = P.length;
    let C = P[0];
    for (let k = 1; k < w; k++) {
      const $ = y(C, P[k]);
      if ($ === !1)
        return !1;
      zn($) || (C = $);
    }
    return C;
  }
  function u(P, w, C, k, $, T, E) {
    if (P.length = 0, C === !1)
      return !1;
    if (P.push(C), $ !== void 0) {
      if ($ === !1)
        return !1;
      P.push($);
    }
    if (Dg(P, w, T))
      return !1;
    const F = P.length < 2;
    if (E === !1) {
      if (F)
        return;
      if (Dg(P, w, k))
        return !1;
    } else F && E !== void 0 && P.push(E);
    return P.length === 1 ? P[0] : l(P);
  }
  function c(P, w, C, k, $, T) {
    const E = C.length;
    if (E > 0 && $ !== !1)
      if (T)
        Object.assign(P, w);
      else
        for (let I = 0; I < E; I++) {
          const F = C[I];
          k.has(F) || (P[F] = y(w[F], $));
        }
    return P;
  }
  const f = (P, { properties: w = {}, patternProperties: C, additionalProperties: k = !0 }, { properties: $ = {}, patternProperties: T, additionalProperties: E = !0 }) => {
    const I = zn(k), F = zn(E);
    if (I && F)
      return vs(P, "properties", S(w, $)), vs(P, "patternProperties", C && T ? S(C, T) : C ?? T), delete P.additionalProperties, P;
    const U = y(k, E);
    vs(P, "additionalProperties", U);
    const B = {}, R = Object.keys(w), Z = R.length, [Y, X] = C ? Eg(C) : Tg, [ae, J] = T ? Eg(T) : Tg, j = [], ee = /* @__PURE__ */ new Set(), L = F ? void 0 : E;
    for (let we = 0; we < Z; we++) {
      const le = R[we];
      ee.add(le);
      const re = u(j, le, w[le], Y, $[le], ae, L);
      re !== void 0 && (B[le] = re);
    }
    const N = Object.keys($), V = N.length, G = I ? void 0 : k;
    for (let we = 0; we < V; we++) {
      const le = N[we];
      if (ee.has(le))
        continue;
      const re = u(j, le, $[le], ae, void 0, Y, G);
      re !== void 0 && (B[le] = re);
    }
    vs(P, "properties", B);
    let fe = {};
    const se = /* @__PURE__ */ new Set();
    if (X.length > 0 && J.length > 0) {
      const we = Tu(X, J, (le, re) => {
        e(le, re) && se.add(le), e(re, le) && se.add(re), fe[t(le, re)] = y(C[le], T[re]);
      });
      for (; !we.next().done; )
        ;
    }
    return fe = c(fe, C, X, se, E, F), fe = c(fe, T, J, se, k, I), vs(P, "patternProperties", fe), P;
  }, g = (P, { items: w = [], additionalItems: C }, { items: k = [], additionalItems: $ }) => {
    const T = Array.isArray(w), E = Array.isArray(k), I = [];
    if (P.items = I, T && E) {
      const [F, U, B] = w.length < k.length ? [w.length, C, k] : [k.length, $, w];
      let R = 0;
      for (; R < F; R++)
        I.push(y(w[R], k[R]));
      if (U === !1)
        P.additionalItems = !1;
      else {
        const Z = U === void 0 || zn(U);
        for (; R < B.length; R++)
          I.push(Z ? B[R] : y(B[R], U));
        vs(P, "additionalItems", C !== void 0 && $ !== void 0 ? y(C, $) : C ?? $);
      }
    } else if (T || E) {
      const [F, U, B] = T ? [w, k, C] : [k, w, $];
      vs(P, "additionalItems", B && y(B, U));
      for (let R = 0; R < F.length; R++)
        I.push(y(F[R], U));
    } else
      delete P.additionalItems, P.items = y(w, k);
    return P;
  }, _ = (P, w, C) => {
    Mg(P, w);
    const k = Mg({}, C);
    return P.allOf === void 0 ? P.allOf = [k] : P.allOf = P.allOf.concat(k), P;
  };
  function b(P, w) {
    return n(Array.from(Tu(P, w, y)));
  }
  const p = OO([
    [CO, f],
    [kO, g],
    [$O, _],
    ...o
  ]), h = AO(a);
  function y(P, w) {
    if (P === !1 || w === !1)
      return !1;
    if (zn(P))
      return zn(w) ? !0 : w;
    if (zn(w))
      return P;
    let C = { ...P };
    const k = /* @__PURE__ */ new Set(), $ = /* @__PURE__ */ new Set(), T = Object.keys(w), E = T.length;
    for (let I = 0; I < E; I++) {
      const F = T[I], U = w[F];
      if (U === void 0)
        continue;
      const B = h.get(F);
      if (B !== void 0) {
        const X = B.length;
        for (let ae = 0; ae < X; ae++) {
          const J = B[ae];
          P[J.oppositeKey] !== void 0 && $.add(J.check);
        }
      }
      const R = P[F];
      if (R === void 0) {
        C[F] = U;
        continue;
      }
      const Z = p.get(F);
      if (Z) {
        k.add(Z);
        continue;
      }
      const Y = x[F] ?? s;
      C[F] = Y(R, U);
    }
    for (const I of k)
      C = I(C, P, w);
    for (const I of $)
      I(C);
    return C;
  }
  const S = Ag(y), x = {
    $id: s,
    $ref: s,
    $schema: s,
    $comment: s,
    $defs: S,
    definitions: S,
    type: (P, w) => {
      if (P === w)
        return P;
      const C = Array.isArray(P), k = Array.isArray(w);
      if (!C && !k) {
        const $ = Mu(P, w);
        if ($ !== void 0)
          return $;
      } else if (C || k) {
        const $ = /* @__PURE__ */ new Set();
        if (C && k)
          for (const E of Tu(P, w, Mu))
            E !== void 0 && $.add(E);
        else {
          const E = C ? P : w, I = C ? w : P, F = E.length;
          for (let U = 0; U < F; U++) {
            const B = Mu(I, E[U]);
            B !== void 0 && $.add(B);
          }
        }
        const T = $.size;
        if (T === 1)
          return $.values().next().value;
        if (T > 1)
          return Array.from($);
      }
      throw new Error(`It is not possible to create an intersection of the following incompatible types: ${P.toString()}, ${w.toString()}`);
    },
    default: s,
    description: s,
    title: s,
    const: s,
    format: s,
    contentEncoding: s,
    contentMediaType: s,
    not: (P, w) => {
      const C = n([P, w]);
      return C.length === 1 ? C[0] : { anyOf: C };
    },
    pattern: t,
    readOnly: Du,
    writeOnly: Du,
    enum: (P, w) => {
      const C = r(P, w);
      if (C.length === 0)
        throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(P)}", "${JSON.stringify(w)}"`);
      return C;
    },
    anyOf: b,
    oneOf: b,
    allOf: (P, w) => n(P.concat(w)),
    propertyNames: y,
    contains: y,
    dependencies: Ag((P, w) => Array.isArray(P) ? Array.isArray(w) ? Eu(P, w) : y(w, { required: P }) : Array.isArray(w) ? y(P, { required: w }) : y(P, w)),
    examples: (P, w) => {
      if (!Array.isArray(P) || !Array.isArray(w))
        throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(P)}" and "${JSON.stringify(w)}"`);
      return Eu(P, w);
    },
    multipleOf: (P, w) => {
      let C = 1;
      for (; !Number.isInteger(P) || !Number.isInteger(w); )
        C *= 10, P *= 10, w *= 10;
      return xO(P, w) / C;
    },
    exclusiveMaximum: Math.min,
    maximum: Math.min,
    maxItems: Math.min,
    maxLength: Math.min,
    maxProperties: Math.min,
    exclusiveMinimum: Math.max,
    minimum: Math.max,
    minItems: Math.max,
    minLength: Math.max,
    minProperties: Math.max,
    uniqueItems: Du,
    required: Eu,
    ...i
  };
  return {
    mergeSchemaDefinitions: y,
    mergeArrayOfSchemaDefinitions: l
  };
}
function DO(t) {
  const e = [], r = [t];
  for (; r.length > 0; ) {
    const n = r.pop();
    if (typeof n == "boolean" || n.allOf === void 0) {
      e.push(n);
      continue;
    }
    const { allOf: s, ...o } = n;
    e.push(o);
    for (let i = s.length - 1; i >= 0; i--)
      r.push(s[i]);
  }
  return e;
}
function MO(t) {
  return (e) => t(DO(e));
}
function hi(t) {
  if (t === null)
    return "null";
  if (Array.isArray(t))
    return "array";
  const e = typeof t;
  switch (e) {
    case "boolean":
    // TODO: Integer type inference ?
    // eslint-disable-next-line no-fallthrough
    case "number":
    case "object":
    case "string":
      return e;
    default:
      return "unknown";
  }
}
function ql(t) {
  if (t.type)
    return t.type;
  if (t.const !== void 0)
    return hi(t.const);
  if (t.properties || t.additionalProperties || t.propertyNames || t.patternProperties)
    return "object";
  if (Array.isArray(t.enum) && t.enum.length > 0)
    return $g(t.enum.map(hi));
  const e = t.allOf ?? t.anyOf ?? t.oneOf;
  if (e) {
    let r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      er(s) && (r = r.concat(ql(s)));
    }
    return $g(r);
  }
  return "unknown";
}
function IO(t) {
  return t === "null" || Array.isArray(t) && t.includes("null");
}
function yy(t) {
  return IO(ql(t));
}
function NO(t) {
  if (t.length === 0)
    throw new Error("Unsupported schema types: empty type array");
  const e = t[0];
  return t.length === 1 ? e : e === "null" ? t[1] : e;
}
const go = (t) => {
  const e = ql(t);
  return Array.isArray(e) ? NO(e) : e;
};
function Ig(t) {
  return t === "boolean" || t === "integer" || t === "number" || t === "string" || t === "null";
}
function FO(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Yo = {}, Ng;
function RO() {
  if (Ng) return Yo;
  Ng = 1;
  var t = /~/, e = /~[01]/g;
  function r(u) {
    switch (u) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + u);
  }
  function n(u) {
    return t.test(u) ? u.replace(e, r) : u;
  }
  function s(u, c, f) {
    for (var g, _, b = 1, p = c.length; b < p; ) {
      if (c[b] === "constructor" || c[b] === "prototype" || c[b] === "__proto__") return u;
      if (g = n(c[b++]), _ = p > b, typeof u[g] > "u" && (Array.isArray(u) && g === "-" && (g = u.length), _ && (c[b] !== "" && c[b] < 1 / 0 || c[b] === "-" ? u[g] = [] : u[g] = {})), !_) break;
      u = u[g];
    }
    var h = u[g];
    return f === void 0 ? delete u[g] : u[g] = f, h;
  }
  function o(u) {
    if (typeof u == "string") {
      if (u = u.split("/"), u[0] === "") return u;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(u)) {
      for (const c of u)
        if (typeof c != "string" && typeof c != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return u;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function i(u, c) {
    if (typeof u != "object") throw new Error("Invalid input object.");
    c = o(c);
    var f = c.length;
    if (f === 1) return u;
    for (var g = 1; g < f; ) {
      if (u = u[n(c[g++])], f === g) return u;
      if (typeof u != "object" || u === null) return;
    }
  }
  function a(u, c, f) {
    if (typeof u != "object") throw new Error("Invalid input object.");
    if (c = o(c), c.length === 0) throw new Error("Invalid JSON pointer for set.");
    return s(u, c, f);
  }
  function l(u) {
    var c = o(u);
    return {
      get: function(f) {
        return i(f, c);
      },
      set: function(f, g) {
        return a(f, c, g);
      }
    };
  }
  return Yo.get = i, Yo.set = a, Yo.compile = l, Yo;
}
var VO = RO();
const LO = /* @__PURE__ */ FO(VO);
function by(t, e) {
  if (!t.startsWith("#"))
    throw new Error(`Invalid reference: ${t}, must start with #`);
  const r = LO.get(e, decodeURIComponent(t.substring(1)));
  if (r === void 0)
    throw new Error(`Could not find a definition for ${t}.`);
  return r;
}
function Od(t, e, r, n = /* @__PURE__ */ new Set()) {
  const s = by(e, r);
  if (!er(s))
    throw new Error(`Definition for ${e} should be a schema (object)`);
  const o = s[Vr];
  if (o) {
    if (n.has(o)) {
      if (n.size === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const u = Array.from(n), c = u[0];
      throw u.push(e, c), new Error(`Definition for ${c} contains a circular reference through ${u.join(" -> ")}`);
    }
    const i = Od(t, o, r, new Set(n).add(e));
    if (Object.keys(s).length < 2)
      return i;
    const { [Vr]: a, ...l } = s;
    return t.mergeSchemas(l, i);
  }
  return s;
}
function Be(t) {
  return Pc(t);
}
function jO(t) {
  return Array.isArray(t);
}
function Oc(t) {
  if (typeof t == "string" || Array.isArray(t))
    return t.length === 0;
  if (!Ns(t))
    return !0;
  if (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
    return t.byteLength === 0;
  const e = Object.getPrototypeOf(t);
  return e === Object.prototype || e === null ? tn(t) : Object.prototype.hasOwnProperty.call(e, "size") ? t.size === 0 : !0;
}
function Fg(t) {
  return typeof t == "string" ? t : JSON.stringify(t);
}
function Fs(t) {
  return t.discriminator?.propertyName;
}
function _y(t, e, r) {
  if (r && Be(t)) {
    const n = t[r];
    if (n === void 0)
      return;
    for (let s = 0; s < e.length; s++) {
      const i = e[s].properties?.[r] ?? {};
      if (i === !0)
        return s;
      if (!(i === !1 || i.type === "object" || i.type === "array") && (i.const === n || i.enum?.includes(n)))
        return s;
    }
  }
}
function BO({ required: t, ...e }) {
  return {
    allOf: [
      e,
      {
        anyOf: Object.keys(e.properties).map((r) => ({
          required: [r]
        }))
      }
    ]
  };
}
const zO = /* @__PURE__ */ new WeakMap(), qO = zl(zO, BO);
function wy(t, e, r, n, s, o) {
  if (!pO(t))
    return e.isValid(t, n, r);
  const i = s !== void 0 ? t.properties[s] : void 0;
  return i !== void 0 ? e.isValid(i, n, o) : e.isValid(qO(t), n, r);
}
function UO(t, e, r, n, s) {
  if (e === void 0)
    return 0;
  const o = _y(e, r, s);
  if (o !== void 0)
    return o;
  const i = Be(e) && s !== void 0;
  for (let a = 0; a < r.length; a++)
    if (wy(r[a], t, e, n, i ? s : void 0, i ? e[s] : void 0))
      return a;
  return 0;
}
function Cc(t, e, r, n, s) {
  let o = 0;
  if (n) {
    const i = n.properties;
    if (i && Be(s))
      for (const [a, l] of Object.entries(i)) {
        const u = s[a];
        if (typeof l == "boolean")
          continue;
        if (l[Vr] !== void 0) {
          const f = Lr(t, e, l, r, u);
          o += Cc(t, e, r, f, u);
          continue;
        }
        const c = l.oneOf || l.anyOf;
        if (c && u) {
          const f = Fs(l);
          o += gi(t, e, r, u, c.filter(er), -1, f);
          continue;
        }
        if (l.type === "object") {
          Be(u) && (o += 1), o += Cc(t, e, r, l, u);
          continue;
        }
        if (u !== void 0 && l.type === hi(u)) {
          o += 1;
          const f = l.default ?? l.const;
          f !== void 0 && (o += u === f ? 1 : -1);
          continue;
        }
      }
    else s !== void 0 && typeof n.type == "string" && n.type === hi(s) && (o += 1);
  }
  return o;
}
function gi(t, e, r, n, s, o = -1, i) {
  if (s.length === 0)
    return o;
  const a = s.map((_) => $s(e, _, r)), l = _y(n, s, i);
  if (typeof l == "number")
    return l;
  const u = [];
  if (n !== void 0) {
    const _ = Be(n) && i !== void 0;
    for (let b = 0; b < a.length; b++)
      wy(a[b], t, n, r, _ ? i : void 0, _ ? n[i] : void 0) && u.push(b);
    if (u.length === 1)
      return u[0];
  }
  if (u.length === 0)
    for (let _ = 0; _ < a.length; _++)
      u.push(_);
  const c = /* @__PURE__ */ new Set();
  let f = 0, g = o;
  for (let _ = 0; _ < u.length; _++) {
    const b = u[_], p = a[b], h = Cc(t, e, r, p, n);
    c.add(h), h > f && (f = h, g = b);
  }
  return u.length > 1 && c.size === 1 && o >= 0 ? o : g;
}
function KO(t, e, r) {
  const n = Object.keys(t);
  let s;
  for (let o = n.length; o-- !== 0; )
    if (s = n[o], !r(t[s], e[s]))
      return !1;
  return Object.keys(e).length === n.length;
}
function WO(t, e, r) {
  const n = Object.keys(t), s = Object.keys(e);
  if (n.length !== s.length)
    return !1;
  let o;
  for (let i = n.length; i-- !== 0; )
    if (o = n[i], o !== s[i] || !r(t[o], e[o]))
      return !1;
  return !0;
}
function Sy(t) {
  return function e(r, n) {
    if (r === n)
      return !0;
    if (Ns(r) && Ns(n)) {
      if (Array.isArray(r)) {
        if (!Array.isArray(n))
          return !1;
        const { length: s } = r;
        if (s !== n.length)
          return !1;
        for (let o = s; o-- !== 0; )
          if (!Ul(r[o], n[o]))
            return !1;
        return !0;
      }
      return Array.isArray(n) || !fi(r) || !fi(n) ? !1 : t(r, n, e);
    }
    return r !== r && n !== n;
  };
}
const Ul = Sy(KO), HO = Ul, xy = Sy(WO);
function Lr(t, e, r, n = {}, s, o = !1) {
  return Yr(t, e, r, n, s, void 0, void 0, o)[0];
}
function $s(t, e, r, n = /* @__PURE__ */ new Set(), s) {
  let o = e;
  const i = o[Vr];
  if (i) {
    if (n.has(i))
      return o;
    n.add(i);
    const { [Vr]: u, ...c } = o, f = Od(t, i, r);
    return $s(t, tn(c) ? f : t.mergeSchemas(f, c), r, n, s);
  }
  const a = o[kg];
  if (a) {
    const u = /* @__PURE__ */ new Map(), c = [];
    for (const [g, _] of Object.entries(a))
      if (typeof _ == "boolean")
        u.set(g, _);
      else {
        const b = new Set(n);
        u.set(g, $s(t, _, r, b, s)), c.push(b);
      }
    const f = n.size;
    for (const g of c)
      g.size !== f && g.forEach(n.add, n);
    o = {
      ...o,
      [kg]: Object.fromEntries(u)
    };
  }
  const l = o[hO];
  if (l && !Array.isArray(l) && typeof l != "boolean" && (o = {
    ...o,
    items: $s(t, l, r, n, s)
  }), s) {
    let u, c;
    so in e && Array.isArray(e[so]) ? (u = so, c = o[so]) : oo in e && Array.isArray(e[oo]) && (u = oo, c = o[oo]), u && c && (o = {
      ...o,
      [u]: c.map((f) => typeof f == "boolean" ? f : $s(t, f, r, n, s))
    });
  }
  return o;
}
function Py(t, e, r, n, s, o, i, a) {
  const l = $s(e, r, n, o, a);
  return HO(r, l) ? [r] : Yr(t, e, l, n, i, s, o, a);
}
function Yr(t, e, r, n, s, o = !1, i = /* @__PURE__ */ new Set(), a) {
  return XO(t, e, r, n, o, i, s, a).flatMap((u) => {
    let c = u;
    if (fy in c)
      return GO(t, e, c, n, o, i, s);
    const f = c.allOf;
    if (f) {
      if (o) {
        const { allOf: y, ...S } = c, x = [];
        for (let P = 0; P < f.length; P++) {
          const w = f[P];
          typeof w != "boolean" && x.push(w);
        }
        return x.push(S), x;
      }
      try {
        const y = [], S = [];
        c.allOf?.forEach((x) => {
          er(x) && x.contains ? y.push(x) : S.push(x);
        }), y.length && (c = { ...c, allOf: S }), c = e.mergeAllOf(c), y.length && (c.allOf = y);
      } catch (y) {
        console.warn(`could not merge subschemas in allOf:
`, y);
        const { allOf: S, ...x } = c;
        return x;
      }
    }
    const g = c.patternProperties, _ = g !== void 0, b = c.additionalProperties !== void 0 && c.additionalProperties !== !1;
    if (!_ && !b)
      return c;
    const p = { ...c.properties }, h = Be(s);
    if (_)
      for (const y of Object.keys(p)) {
        const S = $y(g, y);
        S.length > 0 && (S.push(p[y]), p[y] = Lr(t, e, { allOf: S }, n, h ? s[y] : void 0));
      }
    return YO(t, e, {
      ...c,
      properties: p
    }, n, h ? s : void 0);
  });
}
function GO(t, e, r, n, s, o, i) {
  const { if: a, then: l, else: u, ...c } = r, f = a !== void 0 && t.isValid(a, n, i || {});
  let g = [c], _ = [];
  if (s)
    l && typeof l != "boolean" && (_ = _.concat(Yr(t, e, l, n, i, s, o))), u && typeof u != "boolean" && (_ = _.concat(Yr(t, e, u, n, i, s, o)));
  else {
    const b = f ? l : u;
    b && typeof b != "boolean" && (_ = _.concat(Yr(t, e, b, n, i, s, o)));
  }
  return _.length && (g = tn(c) ? _ : _.map((b) => e.mergeSchemas(c, b))), g.flatMap((b) => Yr(t, e, b, n, i, s, o));
}
function YO(t, e, r, n, s) {
  const { additionalProperties: o, patternProperties: i } = r, a = typeof o != "boolean" && o, l = o === !0 || a && Object.keys(o).length === 0;
  function u(c) {
    if (i !== void 0) {
      const f = $y(i, c);
      if (f.length > 0)
        return {
          ...Lr(t, e, { allOf: f }, n, s?.[c])
        };
    }
    if (a) {
      if (Vr in o)
        return {
          ...Lr(t, e, { $ref: o[Vr] }, n, s)
        };
      if ("type" in o)
        return { ...o };
      if (so in o || oo in o)
        return {
          type: "object",
          ...o
        };
    }
    if (l) {
      const f = s?.[c];
      if (f !== void 0) {
        const g = hi(f);
        return SO(g) ? { type: g } : {};
      }
    }
    return { type: "null" };
  }
  if (s !== void 0)
    for (const c of Object.keys(s)) {
      if (c in r.properties)
        continue;
      const f = u(c);
      f[Bl] = !0, r.properties[c] = f;
    }
  return r;
}
function XO(t, e, r, n, s, o, i, a) {
  const l = Py(t, e, r, n, s, o, i, a);
  if (l.length > 1 || l[0] !== r)
    return l;
  if (dy in r)
    return Oy(t, e, r, n, s, o, i).flatMap((c) => Yr(t, e, c, n, i, s, o));
  if (hy in r && Array.isArray(r.allOf)) {
    const u = r.allOf.filter((f) => typeof f != "boolean").map((f) => Yr(t, e, f, n, i, s, o));
    return ky(u).map((f) => ({
      ...r,
      allOf: f
    }));
  }
  return [r];
}
function Oy(t, e, r, n, s, o, i) {
  const { dependencies: a, ...l } = r;
  return JO(t, e, l, n, s, i).flatMap((c) => Cy(t, e, a, c, n, s, o, i));
}
function JO(t, e, r, n, s, o) {
  let i;
  const { oneOf: a, anyOf: l, ...u } = r;
  if (Array.isArray(a) ? i = a : Array.isArray(l) && (i = l), i) {
    const c = o === void 0 && s ? {} : o, f = Fs(r);
    i = i.map((b) => $s(e, b, n));
    const g = UO(t, c, i, n, f), _ = tn(u);
    if (s)
      return _ ? i : i.map((b) => e.mergeSchemas(u, b));
    r = _ ? i[g] : e.mergeSchemas(u, i[g]);
  }
  return [r];
}
function Cy(t, e, r, n, s, o, i, a) {
  let l = [n];
  for (const u in r) {
    if (!o && (!Be(a) || a[u] === void 0) || n.properties && !(u in n.properties))
      continue;
    const { [u]: c, ...f } = r;
    return Array.isArray(c) ? l[0] = e.mergeSchemas(n, {
      required: c
    }) : typeof c != "boolean" && c && (l = ZO(t, e, n, s, u, c, o, i, a)), l.flatMap((g) => Cy(t, e, f, g, s, o, i, a));
  }
  return l;
}
function ZO(t, e, r, n, s, o, i, a, l) {
  return Yr(t, e, o, n, l, i, a).flatMap((c) => {
    const { oneOf: f, ...g } = c, _ = tn(g) ? r : e.mergeSchemas(r, g);
    if (f === void 0)
      return _;
    const b = f.map((h) => typeof h == "boolean" || !(Vr in h) ? [h] : Py(t, e, h, n, i, a, l));
    return ky(b).flatMap((h) => QO(t, e, _, n, s, h, i, a, l));
  });
}
function QO(t, e, r, n, s, o, i, a, l) {
  const u = o.filter((c) => {
    if (typeof c == "boolean" || !c || !c.properties)
      return !1;
    const { [s]: f } = c.properties;
    if (f) {
      const g = {
        type: "object",
        properties: {
          [s]: f
        }
      };
      return t.isValid(g, n, l) || i;
    }
    return !1;
  });
  return !i && u.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [r]) : u.flatMap((c) => {
    const f = c, { [s]: g, ..._ } = f.properties, b = { ...f, properties: _ };
    return Yr(t, e, b, n, l, i, a).map((h) => e.mergeSchemas(r, h));
  });
}
function ky(t) {
  return t.reduce(
    (r, n) => n.length > 1 ? n.flatMap((s) => vO(r.length, (o) => [...r[o]].concat(s))) : (r.forEach((s) => s.push(n[0])), r),
    [[]]
    // Start with an empty list
  );
}
function $y(t, e) {
  const r = [];
  for (const [n, s] of Object.entries(t))
    new RegExp(n).test(e) && r.push(s);
  return r;
}
function Cd(t) {
  return t.const !== void 0 || Array.isArray(t.enum) && t.enum.length === 1;
}
function Ay(t) {
  const e = t.enum;
  if (Array.isArray(e) && e.length === 1)
    return e[0];
  const r = t.const;
  if (r !== void 0)
    return r;
  throw new Error("schema cannot be inferred as a constant");
}
function kd(t, e, r, n) {
  const s = Lr(t, e, r, n);
  if (Array.isArray(s.enum))
    return !0;
  const o = s.oneOf || s.anyOf;
  return Array.isArray(o) ? o.every((i) => typeof i != "boolean" && Cd(i)) : !1;
}
function eC({ enum: t, oneOf: e, anyOf: r }) {
  if (t !== void 0)
    return t;
  const n = e ?? r;
  if (n !== void 0)
    return n.map((s, o) => {
      if (!er(s))
        throw new Error(`Invalid enum definition in altSchema.${o}`);
      return Ay(s);
    });
}
function Ey(t, e, { items: r, uniqueItems: n }, s) {
  return n === !0 && Be(r) && kd(t, e, r, s);
}
function Ty(t) {
  const { items: e } = t;
  return Array.isArray(e) && e.length > 0 && e.every(Be);
}
function Rg(t) {
  return t == null;
}
function pi(t, e, r = !1, n = !1, s = !1) {
  if (Array.isArray(e)) {
    const o = Array.isArray(t) ? t : [], i = s ? o : e, a = s ? e : o, l = i.map((u, c) => a[c] !== void 0 ? pi(o[c], e[c], r, n, s) : u);
    return (r || s) && l.length < a.length && l.push(...a.slice(l.length)), l;
  }
  if (Be(e)) {
    const o = Object.assign({}, t), i = Be(t) ? t : {};
    for (const [a, l] of Object.entries(e)) {
      const u = a in i, c = i[a];
      if (Be(c) && Be(l) && !Object.values(c).some(Be)) {
        o[a] = {
          ...c,
          ...l
        };
        continue;
      }
      o[a] = pi(
        i[a],
        l,
        r,
        n,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        // CHANGED: key is always in form data, maybe this condition should be value === undefined
        // overrideFormDataWithDefaults &&
        //   (keyExistsInDefaults || !keyExistsInFormData)
        s && u
      );
    }
    return o;
  }
  return n && (t !== void 0 && Rg(e) || typeof e == "number" && isNaN(e)) || s && !Rg(e) ? t : e;
}
function Dy(t, e, r = !1) {
  const n = Object.assign({}, t);
  for (const [s, o] of Object.entries(e)) {
    const i = t ? t[s] : {};
    Be(i) && Be(o) ? n[s] = Dy(i, o, r) : r && Array.isArray(i) && Array.isArray(o) ? n[s] = i.concat(r === "preventDuplicates" ? o.filter((a) => !i.includes(a)) : o) : n[s] = o;
  }
  return n;
}
function My(t) {
  switch (t) {
    case "array":
      return [];
    case "object":
      return {};
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "null":
      return null;
    default:
      return;
  }
}
function tC(t, e, r, n = void 0, s = {}, o = !1, i = {}, a = !1) {
  const l = Lr(t, e, r, s, n), u = Gn(t, e, l, {
    rootSchema: s,
    includeUndefinedValues: o,
    experimental_defaultFormStateBehavior: i,
    rawFormData: n,
    parentDefaults: void 0,
    // CHANGED: We use `required: true` at the root instead of `requiredAsRoot`
    required: !0,
    isSchemaRoot: !0,
    stack: /* @__PURE__ */ new Set(),
    shouldMergeDefaultsIntoFormData: !0,
    initialDefaultsGenerated: a
  });
  if (l.type !== "object" && Be(l.default) && // CHANGED: Added those conditions for typesafety, while original intentions is unknown
  (u === void 0 || typeof u == "object") && (n === void 0 || typeof n == "object"))
    return {
      ...u,
      ...n
    };
  if (Be(n) || Array.isArray(n)) {
    const { mergeDefaultsIntoFormData: c } = i || {};
    return pi(
      u,
      n,
      !0,
      c === "useDefaultIfFormDataUndefined",
      !0
      // set to true to override formData with defaults if they exist.
    );
  }
  return u;
}
function Gn(t, e, r, n) {
  const { parentDefaults: s, rawFormData: o, rootSchema: i, includeUndefinedValues: a, stack: l, experimental_defaultFormStateBehavior: u, required: c, isSchemaRoot: f, shouldMergeDefaultsIntoFormData: g, initialDefaultsGenerated: _ } = n, b = Be(o), p = b ? o : {}, h = Be(r) ? r : {};
  let y = s, S = null, x = p, P = u, w = l;
  const { default: C, $ref: k, oneOf: $, anyOf: T, allOf: E } = h;
  if (Cd(h) && u.constAsDefaults !== "never")
    y = h.const ?? h.enum?.[0];
  else if (Be(y) && Be(C) && !T && !$ && !k)
    y = Dy(y, C);
  else if (C !== void 0 && $ === void 0 && T === void 0 && k === void 0)
    y = C;
  else if (k !== void 0) {
    l.has(k) || (w = new Set(l).add(k), S = Od(e, k, i));
    const F = tn(p);
    S && y === void 0 && F && (y = C), g && S && !b && (x = o);
  } else if (dy in h) {
    const F = {
      ...Ny(t, e, h, {
        ...n,
        rawFormData: p
      }, y),
      ...p
    };
    S = Oy(t, e, h, i, !1, /* @__PURE__ */ new Set(), F)[0];
  } else if (Ty(h))
    y = h.items.map((F, U) => Gn(t, e, F, {
      rootSchema: i,
      includeUndefinedValues: a,
      stack: l,
      experimental_defaultFormStateBehavior: u,
      parentDefaults: Array.isArray(s) ? s[U] : void 0,
      rawFormData: p,
      required: c,
      isSchemaRoot: !1,
      shouldMergeDefaultsIntoFormData: g,
      // CHANGED: this property is not provided in the original code
      initialDefaultsGenerated: _
    }));
  else if ($ !== void 0) {
    const { oneOf: F, ...U } = h;
    if ($.length === 0)
      return;
    const B = ql(h);
    (Array.isArray(B) ? B.every(Ig) : Ig(B)) && P?.constAsDefaults === "skipOneOf" && (P = {
      ...P,
      constAsDefaults: "never"
    });
    const R = $[gi(t, e, i, o ?? C, $.filter(er), 0, Fs(h))];
    if (typeof R == "boolean")
      return;
    S = tn(U) ? R : e.mergeSchemas(U, R);
  } else if (T !== void 0) {
    const { anyOf: F, ...U } = h;
    if (T.length === 0)
      return;
    const B = T[gi(t, e, i, o ?? C, T.filter(er), 0, Fs(h))];
    if (typeof B == "boolean")
      return;
    S = tn(U) ? B : e.mergeSchemas(U, B);
  }
  if (S)
    return Gn(t, e, S, {
      isSchemaRoot: f,
      rootSchema: i,
      includeUndefinedValues: a,
      stack: w,
      experimental_defaultFormStateBehavior: P,
      parentDefaults: y,
      rawFormData: o ?? x,
      required: c,
      shouldMergeDefaultsIntoFormData: g,
      initialDefaultsGenerated: _
    });
  y === void 0 && (y = h.default);
  let I = nC(t, e, h, n, y) ?? y;
  if (g) {
    const { arrayMinItems: F = {} } = u || {}, { mergeExtraDefaults: U } = F, B = rC(t, e, h, i, o, u);
    (!Be(o) || E !== void 0) && (I = pi(I, B, U, !0));
  }
  return I;
}
function rC(t, e, r, n, s, o) {
  let i = s;
  return s !== void 0 && !Cd(r) && kd(t, e, r, n) && (i = eC(r)?.some((f) => Ul(f, s)) ? s : void 0), r.const !== void 0 && o?.constAsDefaults === "always" && (i = r.const), i;
}
function Iy(t, e) {
  const { default: r, type: n } = t;
  return Array.isArray(n) && n.includes("null") && Oc(e) && r === null ? null : e;
}
function Vg(t, e, r, n, s, o, i, a, l, u) {
  const { emptyObjectFields: c = "populateAllDefaults" } = u;
  if (n === !0 || s)
    t.set(e, r);
  else if (n === "excludeObjectChildren")
    (o && r !== void 0 || (Array.isArray(r) ? r.length > 0 : !Ns(r) || !tn(r))) && t.set(e, r);
  else if (c !== "skipDefaults") {
    const f = i ? l.has(e) : a;
    Be(r) ? c === "skipEmptyDefaults" ? Oc(r) || t.set(e, r) : (!Oc(r) || l.has(e)) && (f || c !== "populateRequiredDefaults") && t.set(e, r) : (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field
      r !== void 0 && (c === "populateAllDefaults" || c === "skipEmptyDefaults" || f && l.has(e)) && t.set(e, r)
    );
  }
}
var po;
(function(t) {
  t[t.Ignore = 0] = "Ignore", t[t.Invert = 1] = "Invert", t[t.Fallback = 2] = "Fallback";
})(po || (po = {}));
function Iu(t, e = po.Ignore, r = -1) {
  if (r >= 0) {
    if (Array.isArray(t.items) && r < t.items.length) {
      const n = t.items[r];
      if (typeof n != "boolean")
        return n;
    }
  } else if (t.items && !Array.isArray(t.items) && typeof t.items != "boolean")
    return t.items;
  return e !== po.Ignore && Be(t.additionalItems) ? t.additionalItems : {};
}
function nC(t, e, r, n, s) {
  switch (go(r)) {
    // We need to recurse for object schema inner default values.
    case "object": {
      const { rawFormData: o } = n;
      return Ny(t, e, r, {
        ...n,
        rawFormData: Be(o) ? o : {}
      }, s);
    }
    case "array":
      return sC(t, e, r, n, Array.isArray(s) ? s : void 0);
    default:
      return;
  }
}
function Ny(t, e, r, { rootSchema: n, includeUndefinedValues: s, stack: o, experimental_defaultFormStateBehavior: i, required: a, isSchemaRoot: l, rawFormData: u, shouldMergeDefaultsIntoFormData: c, initialDefaultsGenerated: f }, g) {
  const b = i?.allOf === "populateDefaults" && hy in r || i?.emptyObjectFields !== "skipEmptyDefaults" && fy in r ? Lr(t, e, r, n, u) : r, p = new Set(b.required), h = Be(b.const) ? b.const : {}, y = /* @__PURE__ */ new Map(), S = b.properties, x = Be(g) ? g : void 0, P = Be(u) ? u : void 0;
  if (S !== void 0)
    for (const [C, k] of Object.entries(S)) {
      if (typeof k == "boolean")
        continue;
      const $ = Gn(t, e, k, {
        rootSchema: n,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        includeUndefinedValues: s === !0,
        parentDefaults: x?.[C],
        rawFormData: P?.[C],
        required: p.has(C),
        isSchemaRoot: !1,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      }), T = (k.const !== void 0 || h[C] !== void 0) && i.constAsDefaults !== "never";
      Vg(y, C, $, s, T, k.type === "null", l, a, new Set(b.required), i);
    }
  const w = b.additionalProperties;
  if (w !== void 0 && !f) {
    let C = new Set(Be(g) ? S === void 0 ? Object.keys(g) : Object.keys(g).filter((E) => !(E in S)) : void 0);
    const k = Object.keys(u), $ = new Set(S === void 0 ? k : k.filter((E) => !(E in S)));
    C = C.union($);
    const T = typeof w == "boolean" ? {} : w;
    C.forEach((E) => {
      const I = Gn(t, e, T, {
        rootSchema: n,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        includeUndefinedValues: s === !0,
        parentDefaults: x?.[E],
        rawFormData: P?.[E],
        required: p.has(E),
        isSchemaRoot: l,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      });
      Vg(y, E, I, s, !1, !1, l, a, $, {});
    });
  }
  return Iy(r, Object.fromEntries(y));
}
function sC(t, e, r, { rawFormData: n, rootSchema: s, stack: o, experimental_defaultFormStateBehavior: i, required: a, shouldMergeDefaultsIntoFormData: l, initialDefaultsGenerated: u }, c) {
  const { populate: f, mergeExtraDefaults: g, computeSkipPopulate: _ = () => !1 } = i?.arrayMinItems ?? {}, b = f === "never", p = f === "requiredOnly", h = f === "all" || !b && !p, S = i?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
  if (c !== void 0 && (c = c.map((w, C) => {
    const k = Iu(r, po.Fallback, C), $ = Array.isArray(n) ? n[C] : void 0;
    return Gn(t, e, k, {
      rootSchema: s,
      stack: o,
      experimental_defaultFormStateBehavior: i,
      parentDefaults: w,
      required: a,
      includeUndefinedValues: !1,
      rawFormData: $,
      isSchemaRoot: !1,
      shouldMergeDefaultsIntoFormData: l,
      initialDefaultsGenerated: u
    });
  })), Array.isArray(n)) {
    const w = Iu(r);
    if (b)
      c = n;
    else {
      const C = n.map(($, T) => Gn(t, e, w, {
        rootSchema: s,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        rawFormData: $,
        parentDefaults: c?.[T],
        required: a,
        includeUndefinedValues: !1,
        isSchemaRoot: !1,
        shouldMergeDefaultsIntoFormData: l,
        initialDefaultsGenerated: u
      }));
      c = pi(c, C, (p && a || h) && g === !0);
    }
  }
  if (r.const === void 0 || i.constAsDefaults === "never") {
    if (b)
      return c ?? S;
    if (p && !a)
      return c;
  }
  let x;
  const P = c?.length ?? 0;
  if (!r.minItems || Ey(t, e, r, s) || _(t, r, s) || r.minItems <= P)
    x = c || !a ? c : S;
  else {
    const w = Iu(r, po.Invert), C = w.default, k = Array.from({ length: r.minItems - P }, () => Gn(t, e, w, {
      parentDefaults: C,
      rootSchema: s,
      stack: o,
      experimental_defaultFormStateBehavior: i,
      includeUndefinedValues: !1,
      rawFormData: void 0,
      isSchemaRoot: !1,
      required: a,
      shouldMergeDefaultsIntoFormData: l,
      initialDefaultsGenerated: u
    }));
    x = P ? c.concat(k) : k;
  }
  return Iy(r, x);
}
const oC = (t) => t.length > 1 ? `properties '${t.join("', '")}'` : `property '${t[0]}'`;
function iC(t, e) {
  const r = Object.keys(t);
  if (e === void 0)
    return r;
  const n = e.filter((a) => a === "*" || t[a]), s = new Set(n), o = r.filter((a) => !s.has(a)), i = n.indexOf("*");
  if (i === -1) {
    if (o.length)
      throw new Error(`uiSchema order list does not contain ${oC(o)}`);
    return n;
  }
  if (i !== n.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  return n.splice(i, 1, ...o), n;
}
function aC(t, e) {
  const r = t[e];
  return typeof r == "boolean" || !r ? !1 : Bl in r;
}
function Fy({ type: t, format: e }) {
  return t === "string" && e === gy;
}
function lC(t, e, r, n) {
  const { items: s } = r;
  if (mO(s)) {
    const o = Lr(t, e, s, n);
    return Fy(o);
  }
  return !1;
}
function uC(t, e) {
  return (Be(t.additionalProperties) || t.patternProperties !== void 0) && Be(e) && (t.maxProperties === void 0 || Object.keys(e).length < t.maxProperties);
}
const qn = /* @__PURE__ */ Symbol("no Value");
function Wi(t, e, r, n, s) {
  return r[Vr] !== void 0 ? Lr(t, e, r, n, s) : r;
}
function cC(t, e, r, n, s, o, i) {
  const a = e.type, l = r.type;
  if (!a || a === l) {
    const u = t.maxItems ?? -1;
    return l === "object" ? i.reduce((c, f) => {
      const g = $d(n, s, o, r, e, f);
      return g !== void 0 && (u < 0 || c.length < u) && c.push(g), c;
    }, []) : u > 0 && i.length > u ? i.slice(0, u) : i;
  }
  return qn;
}
function $d(t, e, r, n, s, o) {
  let i;
  const a = n.properties, l = Be(o);
  if (a !== void 0) {
    const u = {}, c = s.properties;
    c !== void 0 && l && Object.keys(c).forEach((_) => {
      _ in o && (u[_] = void 0);
    });
    const f = Object.keys(a), g = {};
    f.forEach((_) => {
      const b = l ? o[_] : void 0, p = c?.[_];
      let h = typeof p == "object" ? p : {};
      const y = a?.[_];
      let S = typeof y == "object" ? y : {};
      h = Wi(t, e, h, r, b), S = Wi(t, e, S, r, b);
      const x = h.type, P = S.type;
      if (!x || x === P)
        if (_ in u && delete u[_], P === "object" || P === "array" && Array.isArray(b)) {
          const w = $d(t, e, r, S, h, b);
          (w !== void 0 || P === "array") && (g[_] = w);
        } else {
          const w = S.default ?? qn, C = h.default ?? qn;
          w !== qn && w !== b && (C === b ? u[_] = w : S.readOnly === !0 && (u[_] = void 0));
          const k = S.const ?? qn, $ = h.const ?? qn;
          k !== qn && k !== b && (u[_] = $ === b ? k : void 0);
        }
    }), i = {
      ...l ? o : void 0,
      ...u,
      ...g
    };
  } else if (s.type === "array" && n.type === "array" && Array.isArray(o)) {
    const u = s.items, c = n.items;
    if (Be(u) && Be(c)) {
      const f = cC(n, Wi(t, e, u, r, o), Wi(t, e, c, r, o), t, e, r, o);
      f !== qn && (i = f);
    } else typeof u == "boolean" && typeof c == "boolean" && u === c && (i = o);
  }
  return i;
}
function dC(t, e) {
  return Ka(t, (r) => {
    if (!er(r))
      return r;
    const n = r[Vr];
    return n !== void 0 && n.startsWith("#") && (r[Vr] = `${e}${n}`), r;
  });
}
function fC(t) {
  return t.split("/").slice(1).map((e) => e.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function hC(t, e) {
  const r = [];
  if (t === "")
    return r;
  const n = fC(t);
  let s = e;
  for (const o of n)
    if (Array.isArray(s) && /^\d+$/.test(o)) {
      const i = Number(o);
      r.push(i), s = s[i];
    } else
      r.push(o), s = s?.[o];
  return r;
}
function Lg(t, e, r, n, s, o) {
  function i(l, u, c, f) {
    const g = l.map((h) => typeof h == "boolean" ? h ? {} : { not: {} } : h), _ = gi(t, e, r, f, g, -1, Fs(u)), b = a(g[_], c, f);
    if (b !== void 0)
      return b;
    let p;
    for (const h of g) {
      if (!er(h))
        continue;
      const y = a(h, c, f);
      if (y !== void 0) {
        if (er(y))
          return y;
        p = y;
      }
    }
    return p;
  }
  function a(l, u, c) {
    for (let f = 0; f < u.length; f++) {
      if (l === void 0 || !er(l))
        return;
      if (l.$ref)
        return a(by(l.$ref, r), u.slice(f), c);
      if (l.allOf) {
        const p = e.mergeAllOf(l);
        if (!p.allOf)
          return a(p, u.slice(f), c);
      }
      const g = l.anyOf ?? l.oneOf ?? l.allOf;
      if (g) {
        const p = i(g, l, u.slice(f), c);
        if (p !== void 0)
          return p;
      }
      const _ = u[f], b = typeof _;
      if (b === "number") {
        const { items: p, additionalItems: h } = l;
        l = (Array.isArray(p) ? p[_] : p) ?? h, c = jO(c) ? c[_] : void 0;
        continue;
      }
      if (b === "string") {
        const { properties: p, patternProperties: h, additionalProperties: y, dependencies: S, then: x, else: P } = l;
        l = (p && p[_]) ?? (h && Object.entries(h).find(([w]) => new RegExp(w).test(_))?.[1]) ?? y ?? (S && i(Object.values(S).filter(Pc), l, u.slice(f), c)) ?? ((x || P) && i([x, P].filter(Pc), l, u.slice(f), c)), c = Be(c) ? c[_] : void 0;
        continue;
      }
      return;
    }
    return l;
  }
  return a(n, s, o);
}
const gC = [!0, !1];
function Nu(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function pC(t) {
  return typeof t?.$ref == "string";
}
function nl(t, e) {
  return pC(e) ? t["ui:definitions"]?.[e.$ref] : e;
}
function mC(t, e, r, n) {
  const s = r["ui:options"], o = s && n in s ? s[n] : t["ui:globalOptions"]?.[n];
  return typeof o == "string" && o.startsWith("registry:") ? e[o.substring(9)] : o;
}
function Ad(t, e, r) {
  let n = nl(t, e);
  for (let s = 0; s < r.length; s++) {
    if (n === void 0)
      return;
    const o = n.anyOf ?? n.oneOf;
    if (o) {
      let c;
      const f = r.slice(s);
      for (const g of o)
        if (c = Ad(t, g, f), c !== void 0)
          return c;
    }
    const i = r[s], { items: a, additionalItems: l, additionalProperties: u } = n;
    n = nl(t, n[i] ?? (Array.isArray(a) ? a[i] : a) ?? u ?? l);
  }
  return n;
}
function vC(t, e) {
  return Ad(t, t, e)?.["ui:options"]?.title;
}
class Ed extends Map {
  /** @type {Map<K, Source<number>>} */
  #e = /* @__PURE__ */ new Map();
  #t = /* @__PURE__ */ xe(0);
  #r = /* @__PURE__ */ xe(0);
  #n = On || -1;
  /**
   * @param {Iterable<readonly [K, V]> | null | undefined} [value]
   */
  constructor(e) {
    if (super(), e) {
      for (var [r, n] of e)
        super.set(r, n);
      this.#r.v = super.size;
    }
  }
  /**
   * If the source is being created inside the same reaction as the SvelteMap instance,
   * we use `state` so that it will not be a dependency of the reaction. Otherwise we
   * use `source` so it will be.
   *
   * @template T
   * @param {T} value
   * @returns {Source<T>}
   */
  #s(e) {
    return On === this.#n ? /* @__PURE__ */ xe(e) : Jn(e);
  }
  /** @param {K} key */
  has(e) {
    var r = this.#e, n = r.get(e);
    if (n === void 0) {
      var s = super.get(e);
      if (s !== void 0)
        n = this.#s(0), r.set(e, n);
      else
        return d(this.#t), !1;
    }
    return d(n), !0;
  }
  /**
   * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn
   * @param {any} [this_arg]
   */
  forEach(e, r) {
    this.#o(), super.forEach(e, r);
  }
  /** @param {K} key */
  get(e) {
    var r = this.#e, n = r.get(e);
    if (n === void 0) {
      var s = super.get(e);
      if (s !== void 0)
        n = this.#s(0), r.set(e, n);
      else {
        d(this.#t);
        return;
      }
    }
    return d(n), super.get(e);
  }
  /**
   * @param {K} key
   * @param {V} value
   * */
  set(e, r) {
    var n = this.#e, s = n.get(e), o = super.get(e), i = super.set(e, r), a = this.#t;
    if (s === void 0)
      s = this.#s(0), n.set(e, s), q(this.#r, super.size), Hr(a);
    else if (o !== r) {
      Hr(s);
      var l = a.reactions === null ? null : new Set(a.reactions), u = l === null || !s.reactions?.every(
        (c) => (
          /** @type {NonNullable<typeof v_reactions>} */
          l.has(c)
        )
      );
      u && Hr(a);
    }
    return i;
  }
  /** @param {K} key */
  delete(e) {
    var r = this.#e, n = r.get(e), s = super.delete(e);
    return n !== void 0 && (r.delete(e), q(this.#r, super.size), q(n, -1), Hr(this.#t)), s;
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var e = this.#e;
      q(this.#r, 0);
      for (var r of e.values())
        q(r, -1);
      Hr(this.#t), e.clear();
    }
  }
  #o() {
    d(this.#t);
    var e = this.#e;
    if (this.#r.v !== e.size) {
      for (var r of super.keys())
        if (!e.has(r)) {
          var n = this.#s(0);
          e.set(r, n);
        }
    }
    for ([, n] of this.#e)
      d(n);
  }
  keys() {
    return d(this.#t), super.keys();
  }
  values() {
    return this.#o(), super.values();
  }
  entries() {
    return this.#o(), super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return d(this.#r), super.size;
  }
}
class Kl {
}
let us = 0;
const yC = 1 << us++, bC = 1 << us++, _C = 1 << us++, wC = 1 << us++, SC = 1 << us++, xC = 1 << us++, PC = 1 << us++, Td = 1 << us++;
let $o = 0;
const OC = 1 << $o++, CC = 1 << $o++, sl = 1 << $o++, jg = 1 << $o++, Bg = 1 << $o++;
(1 << $o++) - 1;
function kC(t) {
  return "validateFieldValue" in t;
}
function $C(t) {
  return "validateFieldValueAsync" in t;
}
function AC(t) {
  return "validateAdditionalPropertyKey" in t;
}
function EC(t) {
  return "validateFileListAsync" in t;
}
const zg = "__sjsf_id_prefix", Ry = "root", Dd = "__sjsf_pseudo_element", Fu = Dd.length, kc = "S", $c = "N";
function Md(t) {
  return `${Dd}${typeof t == "string" ? kc : $c}${t}`;
}
function TC(t) {
  if (typeof t != "string" || !t.startsWith(Dd))
    return;
  const e = t.substring(Fu + 1);
  switch (t[Fu]) {
    case kc:
      return e;
    case $c:
      return Number(e);
    default:
      throw new Error(`Unexpected pseudo element suffix "${t[Fu]}", expected "${kc}" or "${$c}"`);
  }
}
function Vy(t) {
  return (e, r) => {
    const n = t(e, r);
    return n === void 0 ? `Label "${e}" is not translated` : typeof n == "string" ? n : n(r);
  };
}
function Ly(t, e, r, n = 0) {
  return t === void 0 && (t = {
    values: /* @__PURE__ */ new Map(),
    value: void 0
  }), e.length === n ? t.value = r : t.values.set(e[n], Ly(t.values.get(e[n]), e, r, n + 1)), t;
}
function jy(t, e) {
  let r = 0;
  for (; t !== void 0 && r < e.length; )
    t = t.values.get(e[r++]);
  return t;
}
const By = /* @__PURE__ */ Symbol("form-context"), Kn = /* @__PURE__ */ Symbol("form-value"), zy = /* @__PURE__ */ Symbol("form-id-prefix"), Ws = /* @__PURE__ */ Symbol("form-errors"), qy = /* @__PURE__ */ Symbol("form-id-from-path"), Wl = /* @__PURE__ */ Symbol("form-paths-trie-ref"), Uy = /* @__PURE__ */ Symbol("form-mark-schema-change"), Ac = /* @__PURE__ */ Symbol("form-keyed-arrays"), Id = /* @__PURE__ */ Symbol("form-fields-validation-mode"), Zt = /* @__PURE__ */ Symbol("form-schema"), Ec = /* @__PURE__ */ Symbol("form-retrieved-schema"), Hl = /* @__PURE__ */ Symbol("form-root-path"), Gl = /* @__PURE__ */ Symbol("form-ui-schema-root"), mo = /* @__PURE__ */ Symbol("form-ui-schema"), Ky = /* @__PURE__ */ Symbol("form-ui-options-registry"), Ao = /* @__PURE__ */ Symbol("form-ui-extra-options"), jr = /* @__PURE__ */ Symbol("form-validator"), sn = /* @__PURE__ */ Symbol("form-merger"), Wy = /* @__PURE__ */ Symbol("form-icons"), Hy = /* @__PURE__ */ Symbol("form-disabled"), Gy = /* @__PURE__ */ Symbol("form-data-url-to-blob"), Yy = /* @__PURE__ */ Symbol("form-translation"), Tc = /* @__PURE__ */ Symbol("form-translate"), Xy = /* @__PURE__ */ Symbol("form-resolver"), Dc = /* @__PURE__ */ Symbol("form-theme"), mi = /* @__PURE__ */ Symbol("form-fields-state-map"), Jy = /* @__PURE__ */ Symbol("form-schemas-cache");
function Yl(t, e) {
  const r = e, n = jy(t.current, e);
  if (n === void 0)
    t.current = Ly(t.current, e, r);
  else {
    const s = n.value;
    if (s !== void 0)
      return s;
    n.value = r;
  }
  return r;
}
function DC(t, e, r) {
  return ((t.get(e) ?? 0) & r) > 0;
}
class MC {
  ref;
  #e = new Ed();
  constructor(e) {
    this.ref = e;
  }
  assign(e) {
    this.#e.clear();
    for (const r of e) {
      let n = r[1];
      const s = new Set(n);
      n.length > s.size && (n = Array.from(s)), this.#e.set(r[0], {
        set: s,
        array: n
      });
    }
    return this;
  }
  updateErrors(e) {
    this.#e.clear();
    for (const { path: r, message: n } of e) {
      const s = Yl(this.ref, r), o = this.#e.get(s);
      if (o) {
        const i = o.set.size;
        o.set.add(n), i < o.set.size && o.array.push(n);
      } else {
        const i = [n];
        this.#e.set(s, {
          set: new Set(i),
          array: i
        });
      }
    }
    return this;
  }
  getFieldErrors(e) {
    return this.#e.get(e)?.array;
  }
  updateFieldErrors(e, r) {
    if (typeof r == "function") {
      const n = this.#e.get(e)?.array ?? [];
      r = r(n);
    }
    if (r.length > 0) {
      const n = new Set(r);
      this.#e.set(e, {
        set: n,
        array: r.length > n.size ? Array.from(n) : r
      });
    } else
      this.#e.delete(e);
    return r.length === 0;
  }
  hasErrors() {
    return this.#e.size > 0;
  }
  clear() {
    this.#e.clear();
  }
  *[Symbol.iterator]() {
    for (const e of this.#e)
      yield [e[0], e[1].array];
  }
}
function Ee() {
  return Is(By);
}
function Zy(t) {
  Po(By, t);
}
function mr(t, e) {
  return t[qy](e);
}
function Qy(t, e) {
  return Yl(t[Wl], e);
}
function* eb(t) {
  t.value !== void 0 && (yield t.value);
  for (const e of t.values.values())
    yield* eb(e);
}
function* tb(t, e) {
  const r = t[Wl].current, n = jy(r, e);
  n !== void 0 && (yield* eb(n));
}
function Xl(t, e, r) {
  return Qy(t, e.concat(r));
}
function Mi(t, e, r) {
  return Xl(t, e, Md(r));
}
function Rs(t, e, r) {
  return mr(t, Mi(t, e, r));
}
function qg(t, e) {
  return mr(t, Qy(t, e));
}
function IC(t, e) {
  return kd(t[jr], t[sn], e, t[Zt]);
}
function NC(t, e) {
  return Ey(t[jr], t[sn], e, t[Zt]);
}
function FC(t, e) {
  return lC(t[jr], t[sn], e, t[Zt]);
}
function Tr(t, e, r, n) {
  return Lr(t[jr], t[sn], e, t[Zt], r, n);
}
function RC(t, e, r, n) {
  return $d(t[jr], t[sn], t[Zt], e, r, n);
}
function VC(t, e, r, n, s) {
  return gi(t[jr], t[sn], t[Zt], e, r, n, s);
}
function Nd(t, e) {
  return t[sn].mergeFormDataAndSchemaDefaults(e);
}
function LC(t) {
  t[Uy]();
}
function rb(t, e) {
  return (r, n) => t(r, n) ?? e(r, n);
}
function Ii(t) {
  return (e) => t[e];
}
function Ug(t, e) {
  return rb(Ii(e), t);
}
function nb(t, e) {
  return rb(t, Ii(e));
}
function Yn(t, e) {
  return nl(t[Gl], e) ?? {};
}
function Eo(t, e, r) {
  return mC(t[Gl], t[Ky], e, r);
}
function Xr(t, e) {
  return Eo(t, e, "title");
}
function Nt(t, e, r) {
  return t[Ao]?.(r, e) ?? Eo(t, e.uiSchema, r);
}
function jC(t, e, r, n) {
  const s = t[Ao]?.(r, e);
  if (s) {
    const i = n(s);
    if (i !== void 0)
      return i;
  }
  const o = Eo(t, e.uiSchema, r);
  if (o !== void 0)
    return n(o);
}
function wt(t) {
  return (e, r, n) => Object.assign(e, Eo(n, r.uiSchema, t), n[Ao]?.(t, r));
}
function sb(t, e) {
  return (r, n, s) => {
    const o = Eo(s, n.uiSchema, t), i = s[Ao]?.(t, n);
    return Object.assign(r, o && e(o), i && e(i));
  };
}
function Vs(t, e) {
  let r = t[Yy];
  const n = Eo(t, e.uiSchema, "translations");
  r = n ? Ug(r, n) : r;
  const s = t[Ao]?.("translations", e);
  return r = s ? Ug(r, s) : r, Vy(r);
}
function vr(t, e, r) {
  const n = jC(t, e, "actions", (s) => s[r]);
  return n !== void 0 ? n : Nt(t, e, "action");
}
const BC = [];
function kt(t, e) {
  return t[Ws].getFieldErrors(e) ?? BC;
}
function ob(t, e) {
  const r = [];
  for (const n of e) {
    const s = t[Ws].getFieldErrors(n);
    if (s)
      for (let o = 0; o < s.length; o++)
        r.push(s[o]);
  }
  return r;
}
function zC(t, e) {
  ot(() => {
    t[Ws].updateErrors(e);
  });
}
function ui(t, e, r) {
  return ot(() => t[Ws].updateFieldErrors(e, r));
}
function ib(t) {
  return t[Id];
}
function Cr(t, e, r) {
  t.fieldsValidation.run(e, r);
}
function qC(t, e, r, n) {
  return ot(() => {
    const s = t[jr];
    if (!AC(s))
      return !0;
    const o = s.validateAdditionalPropertyKey(r, e.schema);
    return ui(t, n.path, o);
  });
}
async function Jl(t, e, r, n) {
  const s = await ot(() => {
    const o = e[jr];
    return EC(o) ? o.validateFileListAsync(t, n, r) : !0;
  });
  return s === !0 || ui(e, r.path, s);
}
function As(t, e, r) {
  const n = t[mi].get(e) ?? 0;
  t[mi].set(e, n | r);
}
const UC = [];
function un(t, e, r) {
  const n = /* @__PURE__ */ O(() => e().path);
  ko(() => {
    const c = d(n);
    return () => {
      t[mi].delete(c), t[Ws].updateFieldErrors(c, UC);
    };
  });
  const s = /* @__PURE__ */ O(() => t[Id]), o = /* @__PURE__ */ O(() => t[mi].get(d(n)) ?? 0), i = (c) => {
    if (!(!(d(s) & c) || d(s) & Td && !t.isSubmitted || d(s) & xC && !(d(o) & sl) || d(s) & PC && !(d(o) & jg)))
      return r;
  }, a = /* @__PURE__ */ O(() => i(yC)), l = /* @__PURE__ */ O(() => i(bC)), u = /* @__PURE__ */ O(() => i(_C));
  return {
    onfocus() {
      As(t, d(n), OC);
    },
    oninput() {
      As(t, d(n), CC), d(a)?.();
    },
    onchange() {
      As(t, d(n), sl), d(l)?.();
    },
    onblur() {
      As(t, d(n), jg), d(u)?.();
    }
  };
}
const KC = /* @__PURE__ */ new WeakMap(), cn = zl(KC, (t) => {
  const e = ry(), r = (n) => {
    const s = t.onfocus && Ye(n, "focus", t.onfocus), o = t.oninput && Ye(n, "input", t.oninput), i = t.onchange && Ye(n, "change", t.onchange), a = t.onblur && Ye(n, "blur", t.onblur);
    return () => {
      s?.(), o?.(), i?.(), a?.();
    };
  };
  return (n) => (n[e] = r, n);
});
function Ft(t, e, r, ...n) {
  for (let s = 0; s < n.length; s++)
    r = n[s](r, e, t);
  return r;
}
function WC(t) {
  return (e) => Object.assign(e, t);
}
function To(t, e, r) {
  return t.disabled ||= r[Hy], t;
}
const ab = [
  "description",
  "help",
  "errors"
], HC = ab.concat("examples");
function Hs(t, e, r) {
  return t["aria-invalid"] = r[Ws].getFieldErrors(e.path) !== void 0, t;
}
function Fd(t, e, r) {
  return t["aria-describedby"] = (Array.isArray(e.schema.examples) ? HC : ab).map((n) => Rs(r, e.path, n)).join(" "), t;
}
function GC(t, e, r) {
  return t["aria-readonly"] = e.schema.readOnly, t;
}
function YC(t, e, r) {
  return t["aria-required"] = e.required, t;
}
function XC(t) {
  switch (t) {
    case "date-time":
      return "datetime-local";
    case "uri":
      return "url";
    case "color":
    case "date":
    case "time":
    case "email":
      return t;
    default:
      return;
  }
}
function JC(t, e, r) {
  const { required: n, schema: s, path: o } = e, i = mr(r, o);
  t.id = i, t.name = i;
  const a = XC(s.format);
  return a !== void 0 && (t.type = a), t.required = n, t.minlength = s.minLength, t.maxlength = s.maxLength, t.pattern = s.pattern, t.min = s.minimum, t.max = s.maximum, t.step = s.multipleOf ?? (s.type === "number" ? "any" : void 0), t.list = Array.isArray(s.examples) ? Rs(r, e.path, "examples") : void 0, t.readonly = s.readOnly, t;
}
function ZC(t, e, r) {
  const { path: n, required: s, schema: o } = e, i = mr(r, n);
  return t.id = i, t.name = i, t.required = s, t.minlength = o.minLength, t.maxlength = o.maxLength, t.readonly = o.readOnly, t;
}
function QC(t, e, r) {
  return t.for = mr(r, e.path), t;
}
function Zl(t) {
  return (e, r, n) => (e.id = Rs(n, r.path, t), e);
}
function ek(t) {
  return (e) => (e.tabindex = t, e);
}
function tk(t) {
  return (e) => (e["data-layout"] = t, e);
}
function rk(t) {
  return (e) => (e.type = t, e);
}
function lb(t, e, r, n) {
  return Ft(t, e, n, Zl("description"), wt(r));
}
function ub(t, e, r, n) {
  return Ft(t, e, n, Zl("errors"), ek(-1), wt(r));
}
function cb(t, e, r, n, s) {
  return Ft(t, e, s, wt(r), WC(n));
}
function db(t, e, r, n) {
  return Ft(t, e, n, Zl("help"), wt(r));
}
function nk(t, e, r, n) {
  return Ft(t, e, n, QC, wt(r));
}
function Mc(t, e, r, n) {
  return Ft(t, e, n, Zl("title"), wt(r));
}
function fb(t, e, r, n, s, o) {
  return Ft(
    t,
    e,
    o,
    tk(s),
    wt(r),
    // @ts-expect-error Type `T` is resolved as `never` because this package
    // lacks suitable definitions for UI options,
    // but they are available in `theme` packages.
    sb(n, (i) => i[s])
  );
}
function sk(t, e, r, n, s) {
  return Ft(t, e, s, rk(n), wt(r), To);
}
function pr(t, e, r, n) {
  return Ft(t, e, n, wt(r), To, Hs, Fd, GC, YC);
}
function Ni(t, e, r, n, s) {
  return Ft(t, e, s, JC, cn(n), wt(r), To, Hs, Fd);
}
function hb(t, e, r, n, s) {
  return Ft(t, e, s, ZC, cn(n), wt(r), To, Hs, Fd);
}
async function gb(t, e, r, n) {
  const { name: s, blob: o } = await t[Gy](e, n);
  r.items.add(new File([o], s, { type: o.type }));
}
function ok(t, e, r, n) {
  const s = [];
  for (const o of n)
    s.push(gb(t, e, r, o));
  return Promise.all(s);
}
const ik = (t, e = he) => {
  var r = ak(), n = ge(r, !0);
  de(r), ke(() => Ie(n, e())), A(t, r);
};
function Kg(t) {
  return (e) => Rd(e, { message: t });
}
var ak = /* @__PURE__ */ ne('<pre style="color: red;"> </pre>');
function Rd(t, e) {
  W(e, !0);
  const r = v(e, "message", 7);
  var n = {
    get message() {
      return r();
    },
    set message(s) {
      r(s), m();
    }
  };
  return ik(t, r), H(n);
}
K(Rd, { message: {} }, [], [], { mode: "open" });
function Me(t, e, r) {
  const n = r.uiSchema["ui:components"]?.[e];
  switch (typeof n) {
    case "undefined":
      return t[Dc](e, r) ?? // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      Kg(t[Tc]("component-not-found", { type: e }));
    case "string":
      return t[Dc](n, r) ?? // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      Kg(t[Tc]("component-not-found", {
        // @ts-expect-error ts cannot infer type properly by some reason
        type: n
      }));
    default:
      return n;
  }
}
function vo(t, e) {
  return Me(t, t[Xy](e), e);
}
function lk(t, e, r, n) {
  let s = Number.MIN_SAFE_INTEGER;
  return () => {
    let o;
    const i = e();
    return i ? (o = t[Ac].get(i), o === void 0 && (o = n(i, () => s++), t[Ac].set(i, o))) : o = r(), o;
  };
}
function Ql(t, e) {
  const r = t[Jy], n = r.get(e.path);
  return xy(n, e) ? n : (r.set(e.path, e), e);
}
const vi = () => "abort", uk = ({ status: t }) => t !== "processing";
class ck {
  state;
  constructor(e) {
    this.state = e;
  }
}
class dk {
  state;
  constructor(e) {
    this.state = e;
  }
}
function yo(t) {
  const e = /* @__PURE__ */ O(() => t.delayedMs ?? 500), r = /* @__PURE__ */ O(() => t.timeoutMs ?? 8e3), n = /* @__PURE__ */ O(() => t.combinator ?? uk);
  let s = /* @__PURE__ */ xe({ status: "idle" }), o, i;
  function a() {
    clearTimeout(o), clearTimeout(i);
  }
  function l(b) {
    b.abortController.abort();
  }
  function u(b, p) {
    if (d(s).status === "failed")
      throw new dk(d(s));
    d(s).status === "processing" && d(s).promise === b && (a(), p());
  }
  function c(b) {
    if (d(s).status === "processing") {
      if (b !== "abort")
        return d(s).abortController;
      l(d(s));
    }
    return new AbortController();
  }
  async function f(b, p) {
    if (b === !1)
      throw new ck(d(s));
    const h = c(b), y = t.execute(h.signal, ...p);
    if (b === "untrack")
      return y;
    const S = y.then(
      (x) => (u(S, () => {
        q(s, { status: "success" }), t.onSuccess?.(x, ...p);
      }), x),
      (x) => (u(S, () => {
        q(s, { status: "failed", reason: "error", error: x }), t.onFailure?.(d(s), ...p);
      }), Promise.reject(x))
    );
    return q(s, {
      status: "processing",
      delayed: _.isDelayed,
      args: p,
      promise: S,
      abortController: h
    }), a(), o = setTimeout(
      () => {
        d(s).status !== "processing" || d(s).promise !== S || q(s, { ...d(s), delayed: !0 });
      },
      d(e)
    ), i = setTimeout(
      () => {
        d(s).status !== "processing" || d(s).promise !== S || (l(d(s)), q(s, { status: "failed", reason: "timeout" }), t.onFailure?.(d(s), ...p));
      },
      d(r)
    ), S;
  }
  function g(b) {
    return ot(() => f(d(n)(d(s)), b));
  }
  const _ = {
    get state() {
      return d(s);
    },
    get status() {
      return d(s).status;
    },
    get isSuccess() {
      return d(s).status === "success";
    },
    get isFailed() {
      return d(s).status === "failed";
    },
    get isProcessed() {
      return d(s).status === "processing";
    },
    get isDelayed() {
      return d(s).status === "processing" && d(s).delayed;
    },
    matches(b) {
      return d(s).status === b;
    },
    run(...b) {
      g(b).catch(my);
    },
    runAsync(...b) {
      return g(b);
    },
    abort() {
      ot(() => {
        if (d(s).status !== "processing") return;
        const { args: b } = d(s);
        l(d(s)), a(), q(s, { status: "failed", reason: "aborted" }), t.onFailure?.(d(s), ...b);
      });
    }
  };
  return _;
}
function fk([t, e]) {
  return {
    get current() {
      return t();
    },
    set current(r) {
      e(r);
    }
  };
}
function pb({
  initialOutput: t,
  getInput: e,
  setInput: r,
  toInput: n,
  toOutput: s,
  isEqual: o = Object.is
}) {
  let i;
  const a = yo({
    combinator: vi,
    execute: n,
    onSuccess(c) {
      i = c, r(c);
    }
  });
  let l = /* @__PURE__ */ xe(t);
  const u = yo({
    combinator: vi,
    execute: s,
    onSuccess(c) {
      q(l, c);
    }
  });
  return Xe(() => {
    const c = e();
    o(c, i) || (a.abort(), u.run(c));
  }), {
    get current() {
      return d(l);
    },
    set current(c) {
      u.abort(), q(l, c), a.run(c);
    },
    get inputProcessing() {
      return a.isProcessed;
    },
    get outputProcessing() {
      return u.isProcessed;
    }
  };
}
const Ic = "name=", Wg = "data:", Vd = ";base64,", hk = 8192;
function gk(t, e = "unknown") {
  if (!t.startsWith(Wg))
    throw new Error("File is invalid: URI must be a dataURI");
  const n = t.slice(Wg.length).split(Vd);
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [s, o] = n, i = s.split(";"), a = {
    mime: i[0],
    name: e,
    base64content: o
  };
  if (i.length > 1) {
    const l = i.slice(1).find((u) => u.startsWith(Ic));
    l !== void 0 && (a.name = decodeURIComponent(l.substring(Ic.length)));
  }
  return a;
}
function pk(t, e = hk) {
  return async (r, n) => {
    const { mime: s, base64content: o, name: i } = gk(n);
    try {
      const a = atob(o);
      await t({ signal: r });
      const l = new Uint8Array(a.length);
      for (let c = 0; c < a.length; c++)
        c % e === 0 && await t({ signal: r }), l[c] = a.charCodeAt(c);
      return { blob: new Blob([l], { type: s }), name: i };
    } catch (a) {
      throw a instanceof DOMException && a.name === "AbortError" ? a : new Error("File is invalid: " + a.message);
    }
  };
}
function mk(t) {
  return `;${Ic}${encodeURIComponent(t)}${Vd}`;
}
function vk(t, e) {
  const r = new FileReader(), n = () => {
    r.abort();
  };
  return t.addEventListener("abort", n), new Promise((s, o) => {
    r.onerror = o, r.onabort = o, r.onload = (i) => {
      let a = i.target?.result;
      if (typeof a != "string") {
        o(new Error("File is invalid: result must be a string"));
        return;
      }
      a = a.replace(Vd, mk(e.name)), s(a);
    }, r.readAsDataURL(e);
  }).finally(() => {
    t.removeEventListener("abort", n);
  });
}
const mb = vk, ro = /* @__PURE__ */ Symbol("unchanged");
function yk(t) {
  return function e(r, n) {
    if (r === n)
      return ro;
    if (typeof r == "object" && typeof n == "object") {
      const s = Array.isArray(r), o = Array.isArray(n);
      if (s && o) {
        const i = Math.min(r.length, n.length);
        let a = 0;
        for (; a < i; a++) {
          const l = e(r[a], n[a]);
          l !== ro && (r[a] = l);
        }
        if (r.length !== n.length) {
          const l = t.get(r) ?? r;
          for (; a < n.length; a++)
            l.push(n[a]);
          l.splice(n.length);
        }
        return ro;
      }
      if (!s && !o && r !== null && n !== null && fi(r) && fi(n)) {
        const i = Object.keys(r);
        let a = i.length;
        for (let u = 0; u < a; u++) {
          const c = i[u];
          c in n || delete r[c];
        }
        const l = Object.keys(n);
        a = l.length;
        for (let u = 0; u < a; u++) {
          const c = l[u], f = e(r[c], n[c]);
          f !== ro && (r[c] = f);
        }
        return ro;
      }
    }
    return n;
  };
}
const bk = "uiOptionsRegistry";
function _k(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
function vb(t) {
  const e = /* @__PURE__ */ O(() => t.idPrefix ?? Ry), r = /* @__PURE__ */ O(() => t.uiSchema ?? {}), n = /* @__PURE__ */ O(() => nl(d(r), t.uiSchema) ?? {}), s = /* @__PURE__ */ O(() => t[bk] ?? {}), o = /* @__PURE__ */ O(() => (t.schema, { current: void 0 })), i = /* @__PURE__ */ O(() => Yl(d(o), [])), a = /* @__PURE__ */ O(() => Nu(t.validator, {
    uiSchema: d(r),
    uiOptionsRegistry: d(s),
    schema: t.schema,
    merger: () => d(l)
  })), l = /* @__PURE__ */ O(() => Nu(t.merger, {
    validator: d(a),
    schema: t.schema,
    uiSchema: d(r),
    uiOptionsRegistry: d(s)
  })), u = /* @__PURE__ */ O(() => t.value ? fk(t.value) : _k(d(l).mergeFormDataAndSchemaDefaults({ formData: t.initialValue, schema: t.schema }))), c = /* @__PURE__ */ O(() => Nu(t.idBuilder, {
    idPrefix: d(e),
    schema: t.schema,
    uiSchema: d(r),
    uiOptionsRegistry: d(s),
    merger: d(l),
    validator: d(a),
    valueRef: d(u)
  })), f = /* @__PURE__ */ O(() => Lr(d(a), d(l), t.schema, t.schema, d(u).current)), g = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ O(() => zl(g, (j) => d(c).fromPath(j))), b = /* @__PURE__ */ O(() => {
    const j = new MC(d(o)), ee = t.initialErrors;
    return ee === void 0 ? j : Array.isArray(ee) ? j.updateErrors(ee) : j.assign(ee);
  }), p = /* @__PURE__ */ O(() => t.disabled ?? !1), h = /* @__PURE__ */ O(() => t.fieldsValidationMode ?? 0), y = /* @__PURE__ */ O(() => t.keyedArraysMap ?? /* @__PURE__ */ new WeakMap()), S = /* @__PURE__ */ O(() => yk(d(y))), x = /* @__PURE__ */ O(() => t.schedulerYield ?? (typeof scheduler < "u" && "yield" in scheduler) ? scheduler.yield.bind(scheduler) : ({ signal: j }) => new Promise((ee, L) => {
    setTimeout(
      () => {
        j.aborted ? L(j.reason) : ee();
      },
      0
    );
  })), P = /* @__PURE__ */ O(() => pk(d(x))), w = /* @__PURE__ */ O(() => Vy(t.translation)), C = new Ed(), k = /* @__PURE__ */ O(() => C.size > 0), $ = /* @__PURE__ */ O(() => DC(C, d(i), Bg));
  let T = !0, E = /* @__PURE__ */ O(() => {
    t.schema;
    const j = T;
    return T = !1, j;
  });
  const I = /* @__PURE__ */ O(() => "validateFormValueAsync" in d(a) ? (j, ee, L) => d(a).validateFormValueAsync(j, ee, L) : (j, ee, L) => Promise.resolve(d(a).validateFormValue(ee, L))), F = yo({
    async execute(j) {
      return As(Y, d(i), Bg), await d(I)(j, t.validateByRetrievedSchema ? d(f) : t.schema, xo(d(u).current));
    },
    onSuccess(j, ee) {
      if (zC(Y, j.errors ?? []), j.errors === void 0) {
        t.onSubmit?.(j.value, ee), C.clear();
        return;
      }
      t.onSubmitError?.(j, ee, Y);
    },
    onFailure(j, ee) {
      ui(Y, d(i), [d(w)("validation-process-error", { error: j })]), t.onSubmissionFailure?.(j, ee);
    },
    get combinator() {
      return t.submissionCombinator;
    },
    get delayedMs() {
      return t.submissionDelayedMs;
    },
    get timeoutMs() {
      return t.submissionTimeoutMs;
    }
  }), U = /* @__PURE__ */ O(() => $C(d(a)) ? (j, ee, L) => d(a).validateFieldValueAsync(j, ee, L) : kC(d(a)) ? (j, ee, L) => Promise.resolve(d(a).validateFieldValue(ee, L)) : () => Promise.resolve([])), B = yo({
    execute(j, ee, L) {
      const N = t.fieldsValidationDebounceMs ?? 300;
      if (N < 0)
        return d(U)(j, ee, L);
      const V = Promise.withResolvers(), G = setTimeout(
        () => {
          V.resolve(d(U)(j, ee, L));
        },
        N
      ), fe = () => {
        clearTimeout(G), V.reject(new DOMException("field validation has been aborted", "AbortError"));
      };
      return j.addEventListener("abort", fe), V.promise.finally(() => {
        j.removeEventListener("abort", fe);
      });
    },
    onSuccess(j, ee) {
      ui(Y, ee.path, j);
    },
    onFailure(j, ee, L) {
      j.reason !== "aborted" && ui(Y, ee.path, [d(w)("validation-process-error", { error: j })]), t.onFieldsValidationFailure?.(j, ee, L);
    },
    get combinator() {
      return t.fieldsValidationCombinator ?? vi;
    },
    get delayedMs() {
      return t.fieldsValidationDelayedMs;
    },
    get timeoutMs() {
      return t.fieldsValidationTimeoutMs;
    }
  });
  function R(j) {
    j.preventDefault(), F.run(j);
  }
  function Z(j) {
    j?.preventDefault(), C.clear(), d(b).clear(), d(u).current = d(l).mergeFormDataAndSchemaDefaults({ formData: t.initialValue, schema: t.schema }), t.onReset?.(j);
  }
  const Y = {
    submission: F,
    fieldsValidation: B,
    get isSubmitted() {
      return d($);
    },
    get isChanged() {
      return d(k);
    },
    submit: R,
    reset: Z,
    // INTERNALS
    [mi]: C,
    [Jy]: /* @__PURE__ */ new WeakMap(),
    get [zy]() {
      return d(e);
    },
    get [Ws]() {
      return d(b);
    },
    get [Wl]() {
      return d(o);
    },
    get [qy]() {
      return d(_);
    },
    get [Hl]() {
      return d(i);
    },
    get [Kn]() {
      return d(u).current;
    },
    set [Kn](j) {
      d(u).current = j;
    },
    get [Id]() {
      return d(h);
    },
    get [Gy]() {
      return d(P);
    },
    get [Ac]() {
      return d(y);
    },
    get [Zt]() {
      return t.schema;
    },
    get [Ec]() {
      return d(f);
    },
    get [Gl]() {
      return d(r);
    },
    get [mo]() {
      return d(n);
    },
    get [Ao]() {
      return t.extraUiOptions;
    },
    get [Ky]() {
      return d(s);
    },
    get [Hy]() {
      return d(p);
    },
    get [jr]() {
      return d(a);
    },
    get [sn]() {
      return d(l);
    },
    get [Xy]() {
      return d(X);
    },
    get [Dc]() {
      return t.theme;
    },
    get [Yy]() {
      return t.translation;
    },
    get [Tc]() {
      return d(w);
    },
    get [Wy]() {
      return t.icons;
    },
    [Uy]() {
      ae || (ae = !0, queueMicrotask(J));
    }
  }, X = /* @__PURE__ */ O(() => t.resolver(Y));
  let ae = !1;
  function J() {
    ae = !1;
    const j = d(l).mergeFormDataAndSchemaDefaults({
      formData: d(u).current,
      schema: t.schema,
      initialDefaultsGenerated: d(E)
    });
    q(E, !0);
    const ee = d(S)(d(u).current, j);
    ee !== ro && (d(u).current = ee);
  }
  return Y;
}
var wk = /* @__PURE__ */ ne('<input type="hidden"/>');
function yb(t, e) {
  W(e, !0);
  const r = v(e, "form", 7), n = v(e, "name", 7, zg);
  var s = {
    get form() {
      return r();
    },
    set form(i) {
      r(i), m();
    },
    get name() {
      return n();
    },
    set name(i = zg) {
      n(i), m();
    }
  }, o = wk();
  return iy(o), ke(() => {
    An(o, "name", n()), sO(o, r()[zy]);
  }), A(t, o), H(s);
}
K(yb, { form: {}, name: {} }, [], [], { mode: "open" });
var Sk = /* @__PURE__ */ ne("<!> <!>", 1);
function bb(t, e) {
  W(e, !0);
  const r = Ee(), n = /* @__PURE__ */ O(() => Ql(r, {
    path: r[Hl],
    title: Xr(r, r[mo]) ?? r[Ec].title ?? "",
    schema: r[Ec],
    uiSchema: r[mo],
    required: !0
  })), s = /* @__PURE__ */ O(() => vo(r, d(n)));
  var o = Sk(), i = D(o);
  yb(i, {
    get form() {
      return r;
    }
  });
  var a = be(i, 2);
  {
    let l = /* @__PURE__ */ O(() => Vs(r, d(n)));
    Q(a, () => d(s), (u, c) => {
      c(u, {
        type: "field",
        get config() {
          return d(n);
        },
        uiOption: (f) => Nt(r, d(n), f),
        get translate() {
          return d(l);
        },
        get value() {
          return r[Kn];
        },
        set value(f) {
          r[Kn] = f;
        }
      });
    });
  }
  A(t, o), H();
}
K(bb, {}, [], [], { mode: "open" });
function _n(t, e) {
  W(e, !0);
  const r = Ee(), n = v(e, "id", 7), s = v(e, "config", 7), o = v(e, "translate", 7), i = v(e, "args", 23, () => ({})), a = /* @__PURE__ */ O(() => o()(n(), i())), l = /* @__PURE__ */ O(() => ({
    config: s(),
    params: i(),
    translation: d(a)
  })), u = /* @__PURE__ */ O(() => r[Wy]?.(n(), d(
    //@ts-expect-error TODO: fix if possible
    l
  )));
  var c = {
    get id() {
      return n();
    },
    set id(p) {
      n(p), m();
    },
    get config() {
      return s();
    },
    set config(p) {
      s(p), m();
    },
    get translate() {
      return o();
    },
    set translate(p) {
      o(p), m();
    },
    get args() {
      return i();
    },
    set args(p = {}) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, () => d(u), () => d(l)), A(p, h);
    }, b = (p) => {
      var h = st();
      ke(() => Ie(h, d(a))), A(p, h);
    };
    ue(g, (p) => {
      d(u) ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(_n, { id: {}, config: {}, translate: {}, args: {} }, [], [], { mode: "open" });
function _b(t, e) {
  W(e, !0);
  const r = Ee(), n = /* @__PURE__ */ O(() => ({
    path: Mi(r, r[Hl], "submit"),
    title: "",
    schema: r[Zt],
    uiSchema: r[mo],
    required: !1
  })), s = /* @__PURE__ */ O(() => Me(r, "submitButton", d(n)));
  var o = M(), i = D(o);
  Q(i, () => d(s), (a, l) => {
    l(a, {
      get config() {
        return d(n);
      },
      children: (u, c) => {
        {
          let f = /* @__PURE__ */ O(() => Vs(r, d(n)));
          _n(u, {
            get config() {
              return d(n);
            },
            id: "submit",
            get translate() {
              return d(f);
            }
          });
        }
      },
      $$slots: { default: !0 }
    });
  }), A(t, o), H();
}
K(_b, {}, [], [], { mode: "open" });
function wb(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15), n = v(e, "children", 7), s = v(e, "attributes", 7);
  const o = Ee(), i = /* @__PURE__ */ O(() => ({
    path: Mi(o, o[Hl], "form"),
    title: "",
    schema: o[Zt],
    uiSchema: o[mo],
    required: !1
  })), a = /* @__PURE__ */ O(() => Me(o, "form", d(i)));
  var l = {
    get ref() {
      return r();
    },
    set ref(f) {
      r(f), m();
    },
    get children() {
      return n();
    },
    set children(f) {
      n(f), m();
    },
    get attributes() {
      return s();
    },
    set attributes(f) {
      s(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(a), (f, g) => {
    g(f, {
      get config() {
        return d(i);
      },
      get children() {
        return n();
      },
      get attributes() {
        return s();
      },
      get ref() {
        return r();
      },
      set ref(_) {
        r(_);
      }
    });
  }), A(t, u), H(l);
}
K(wb, { ref: {}, children: {}, attributes: {} }, [], [], { mode: "open" });
var xk = /* @__PURE__ */ ne("<!> <!>", 1);
function Ld(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15), n = v(e, "form", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "form"]);
  Zy(n());
  var o = {
    get ref() {
      return r();
    },
    set ref(i) {
      r(i), m();
    },
    get form() {
      return n();
    },
    set form(i) {
      n(i), m();
    }
  };
  return wb(t, {
    get attributes() {
      return s;
    },
    get ref() {
      return r();
    },
    set ref(i) {
      r(i);
    },
    children: (i, a) => {
      var l = xk(), u = D(l);
      bb(u, {});
      var c = be(u, 2);
      _b(c, {}), A(i, l);
    },
    $$slots: { default: !0 }
  }), H(o);
}
K(Ld, { ref: {}, form: {} }, [], [], { mode: "open" });
function Pk(t, e) {
  W(e, !0);
  const n = vb(/* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]));
  WP(() => {
    n.submission.abort(), n.fieldsValidation.abort();
  }), Ld(t, {
    get form() {
      return n;
    }
  }), H();
}
K(Pk, {}, [], [], { mode: "open" });
var Ok = /* @__PURE__ */ ne("<option></option>"), Ck = /* @__PURE__ */ ne("<datalist></datalist>");
function jd(t, e) {
  W(e, !0);
  const r = v(e, "id", 7), n = v(e, "config", 7), s = /* @__PURE__ */ O(() => {
    const { default: u, examples: c } = n().schema;
    if (!(!Array.isArray(c) || !r()))
      return u !== void 0 && !c.includes(u) ? [u].concat(c) : c;
  });
  var o = {
    get id() {
      return r();
    },
    set id(u) {
      r(u), m();
    },
    get config() {
      return n();
    },
    set config(u) {
      n(u), m();
    }
  }, i = M(), a = D(i);
  {
    var l = (u) => {
      var c = Ck();
      nt(c, 20, () => d(s), (f) => f, (f, g) => {
        var _ = Ok(), b = {};
        ke(() => {
          b !== (b = g) && (_.value = (_.__value = g) ?? "");
        }), A(f, _);
      }), de(c), ke(() => An(c, "id", r())), A(u, c);
    };
    ue(a, (u) => {
      d(s) && u(l);
    });
  }
  return A(t, i), H(o);
}
K(jd, { id: {}, config: {} }, [], [], { mode: "open" });
function kk(t, e) {
  W(e, !0);
  const r = v(e, "form", 7), n = v(e, "path", 7), s = v(e, "required", 7), o = v(e, "uiSchema", 7), i = v(e, "render", 7), a = /* @__PURE__ */ O(() => Yl(r()[Wl], n())), l = /* @__PURE__ */ O(() => {
    if (d(a).length === 0)
      return {
        get current() {
          return r()[Kn];
        },
        set current(E) {
          r()[Kn] = E;
        }
      };
    let C = r()[Kn], k = -1;
    const $ = d(a).length - 1;
    for (; Ns(C) && ++k < $; )
      C = C[d(a)[k]];
    if (k !== $)
      throw console.error("Current form state", xo(r()[Kn])), new Error(`Path "[${d(a).join(", ")}]" is not populated or invalid, check current form state`);
    const T = d(a)[$];
    return {
      get current() {
        return C[T];
      },
      set current(E) {
        C[T] = E;
      }
    };
  }), u = /* @__PURE__ */ O(() => {
    if (d(a).length < 2)
      return r()[Zt];
    const k = Lg(r()[jr], r()[sn], r()[Zt], r()[Zt], d(a).slice(0, -1), d(l).current);
    return k === void 0 || typeof k == "boolean" ? {} : k;
  }), c = /* @__PURE__ */ O(() => {
    if (d(a).length === 0)
      return r()[Zt];
    let C = d(l).current;
    const k = d(a).slice(0, -1);
    for (let T = 0; T < k.length && C !== void 0; T++) {
      const E = k[T];
      typeof E == "number" ? C = Array.isArray(C) ? C[E] : void 0 : C = Be(C) ? C[E] : void 0;
    }
    const $ = Lg(r()[jr], r()[sn], r()[Zt], d(u), d(a).slice(-1), C);
    return $ === void 0 || typeof $ == "boolean" ? {} : $;
  }), f = /* @__PURE__ */ O(() => Tr(r(), d(c), d(l).current)), g = /* @__PURE__ */ O(() => o() ?? Ad(r()[Gl], r()[mo], d(a)) ?? {}), _ = /* @__PURE__ */ O(() => {
    if (s() !== void 0)
      return s();
    if (d(a).length === 0)
      return !1;
    const C = d(a)[d(a).length - 1], { required: k, items: $, minItems: T } = d(u);
    if (Array.isArray(k))
      return k.includes(C);
    const E = Number(C);
    if (Number.isInteger(E) && E >= 0) {
      if (T !== void 0)
        return E < T;
      if (Array.isArray($))
        return E < $.length;
    }
    return !1;
  }), b = /* @__PURE__ */ O(() => ({
    path: d(a),
    title: Xr(r(), d(g)) ?? d(f).title ?? "",
    schema: d(f),
    uiSchema: d(g),
    required: d(_)
  })), p = /* @__PURE__ */ O(() => Vs(r(), d(b))), h = (C) => Nt(r(), d(b), C);
  Zy(r());
  var y = {
    get form() {
      return r();
    },
    set form(C) {
      r(C), m();
    },
    get path() {
      return n();
    },
    set path(C) {
      n(C), m();
    },
    get required() {
      return s();
    },
    set required(C) {
      s(C), m();
    },
    get uiSchema() {
      return o();
    },
    set uiSchema(C) {
      o(C), m();
    },
    get render() {
      return i();
    },
    set render(C) {
      i(C), m();
    }
  }, S = M(), x = D(S);
  {
    var P = (C) => {
      var k = M(), $ = D(k);
      te($, i, () => ({
        type: "field",
        config: d(b),
        translate: d(p),
        uiOption: h,
        valueRef: d(l)
      })), A(C, k);
    }, w = (C) => {
      const k = /* @__PURE__ */ O(() => vo(r(), d(b)));
      var $ = M(), T = D($);
      Q(T, () => d(k), (E, I) => {
        I(E, {
          type: "field",
          get config() {
            return d(b);
          },
          uiOption: h,
          get translate() {
            return d(p);
          },
          get value() {
            return d(l).current;
          },
          set value(F) {
            d(l).current = F;
          }
        });
      }), A(C, $);
    };
    ue(x, (C) => {
      i() ? C(P) : C(w, !1);
    });
  }
  return A(t, S), H(y);
}
K(kk, { form: {}, path: {}, required: {}, uiSchema: {}, render: {} }, [], [], { mode: "open" });
function $k(t) {
  Xe(() => Ye(window, "beforeunload", (e) => {
    t.isChanged && (e.preventDefault(), e.returnValue = "");
  }));
}
function Ak(t) {
  return typeof t == "function";
}
function Fi(t) {
  return t !== null && typeof t == "object";
}
const Ek = ["string", "number", "bigint", "boolean"];
function Nc(t) {
  return t == null || Ek.includes(typeof t) ? !0 : Array.isArray(t) ? t.every((e) => Nc(e)) : typeof t == "object" ? Object.getPrototypeOf(t) === Object.prototype : !1;
}
const bo = /* @__PURE__ */ Symbol("box"), eu = /* @__PURE__ */ Symbol("is-writable");
function z(t, e) {
  const r = /* @__PURE__ */ O(t);
  return e ? {
    [bo]: !0,
    [eu]: !0,
    get current() {
      return d(r);
    },
    set current(n) {
      e(n);
    }
  } : {
    [bo]: !0,
    get current() {
      return t();
    }
  };
}
function Ri(t) {
  return Fi(t) && bo in t;
}
function Bd(t) {
  return Ri(t) && eu in t;
}
function Sb(t) {
  return Ri(t) ? t : Ak(t) ? z(t) : Jr(t);
}
function Tk(t) {
  return Object.entries(t).reduce(
    (e, [r, n]) => Ri(n) ? (Bd(n) ? Object.defineProperty(e, r, {
      get() {
        return n.current;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(s) {
        n.current = s;
      }
    }) : Object.defineProperty(e, r, {
      get() {
        return n.current;
      }
    }), e) : Object.assign(e, { [r]: n }),
    {}
  );
}
function Dk(t) {
  return Bd(t) ? {
    [bo]: !0,
    get current() {
      return t.current;
    }
  } : t;
}
function Jr(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    [bo]: !0,
    [eu]: !0,
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
function Gs(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    [bo]: !0,
    [eu]: !0,
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
Gs.from = Sb;
Gs.with = z;
Gs.flatten = Tk;
Gs.readonly = Dk;
Gs.isBox = Ri;
Gs.isWritableBox = Bd;
function xb(...t) {
  return function(e) {
    for (const r of t)
      if (r) {
        if (e.defaultPrevented)
          return;
        typeof r == "function" ? r.call(this, e) : r.current?.call(this, e);
      }
  };
}
var Hg = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Mk = /\n/g, Ik = /^\s*/, Nk = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Fk = /^:\s*/, Rk = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Vk = /^[;\s]*/, Lk = /^\s+|\s+$/g, jk = `
`, Gg = "/", Yg = "*", Ps = "", Bk = "comment", zk = "declaration";
function qk(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var r = 1, n = 1;
  function s(b) {
    var p = b.match(Mk);
    p && (r += p.length);
    var h = b.lastIndexOf(jk);
    n = ~h ? b.length - h : n + b.length;
  }
  function o() {
    var b = { line: r, column: n };
    return function(p) {
      return p.position = new i(b), u(), p;
    };
  }
  function i(b) {
    this.start = b, this.end = { line: r, column: n }, this.source = e.source;
  }
  i.prototype.content = t;
  function a(b) {
    var p = new Error(
      e.source + ":" + r + ":" + n + ": " + b
    );
    if (p.reason = b, p.filename = e.source, p.line = r, p.column = n, p.source = t, !e.silent) throw p;
  }
  function l(b) {
    var p = b.exec(t);
    if (p) {
      var h = p[0];
      return s(h), t = t.slice(h.length), p;
    }
  }
  function u() {
    l(Ik);
  }
  function c(b) {
    var p;
    for (b = b || []; p = f(); )
      p !== !1 && b.push(p);
    return b;
  }
  function f() {
    var b = o();
    if (!(Gg != t.charAt(0) || Yg != t.charAt(1))) {
      for (var p = 2; Ps != t.charAt(p) && (Yg != t.charAt(p) || Gg != t.charAt(p + 1)); )
        ++p;
      if (p += 2, Ps === t.charAt(p - 1))
        return a("End of comment missing");
      var h = t.slice(2, p - 2);
      return n += 2, s(h), t = t.slice(p), n += 2, b({
        type: Bk,
        comment: h
      });
    }
  }
  function g() {
    var b = o(), p = l(Nk);
    if (p) {
      if (f(), !l(Fk)) return a("property missing ':'");
      var h = l(Rk), y = b({
        type: zk,
        property: Xg(p[0].replace(Hg, Ps)),
        value: h ? Xg(h[0].replace(Hg, Ps)) : Ps
      });
      return l(Vk), y;
    }
  }
  function _() {
    var b = [];
    c(b);
    for (var p; p = g(); )
      p !== !1 && (b.push(p), c(b));
    return b;
  }
  return u(), _();
}
function Xg(t) {
  return t ? t.replace(Lk, Ps) : Ps;
}
function Uk(t, e) {
  let r = null;
  if (!t || typeof t != "string")
    return r;
  const n = qk(t), s = typeof e == "function";
  return n.forEach((o) => {
    if (o.type !== "declaration")
      return;
    const { property: i, value: a } = o;
    s ? e(i, a, o) : a && (r = r || {}, r[i] = a);
  }), r;
}
const Kk = /\d/, Wk = ["-", "_", "/", "."];
function Hk(t = "") {
  if (!Kk.test(t))
    return t !== t.toLowerCase();
}
function Gk(t) {
  const e = [];
  let r = "", n, s;
  for (const o of t) {
    const i = Wk.includes(o);
    if (i === !0) {
      e.push(r), r = "", n = void 0;
      continue;
    }
    const a = Hk(o);
    if (s === !1) {
      if (n === !1 && a === !0) {
        e.push(r), r = o, n = a;
        continue;
      }
      if (n === !0 && a === !1 && r.length > 1) {
        const l = r.at(-1);
        e.push(r.slice(0, Math.max(0, r.length - 1))), r = l + o, n = a;
        continue;
      }
    }
    r += o, n = a, s = i;
  }
  return e.push(r), e;
}
function Pb(t) {
  return t ? Gk(t).map((e) => Xk(e)).join("") : "";
}
function Yk(t) {
  return Jk(Pb(t || ""));
}
function Xk(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
function Jk(t) {
  return t ? t[0].toLowerCase() + t.slice(1) : "";
}
function oi(t) {
  if (!t)
    return {};
  const e = {};
  function r(n, s) {
    if (n.startsWith("-moz-") || n.startsWith("-webkit-") || n.startsWith("-ms-") || n.startsWith("-o-")) {
      e[Pb(n)] = s;
      return;
    }
    if (n.startsWith("--")) {
      e[n] = s;
      return;
    }
    e[Yk(n)] = s;
  }
  return Uk(t, r), e;
}
function Ts(...t) {
  return (...e) => {
    for (const r of t)
      typeof r == "function" && r(...e);
  };
}
function Zk(t, e) {
  const r = RegExp(t, "g");
  return (n) => {
    if (typeof n != "string")
      throw new TypeError(`expected an argument of type string, but got ${typeof n}`);
    return n.match(r) ? n.replace(r, e) : n;
  };
}
const Qk = Zk(/[A-Z]/, (t) => `-${t.toLowerCase()}`);
function e$(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw new TypeError(`expected an argument of type object, but got ${typeof t}`);
  return Object.keys(t).map((e) => `${Qk(e)}: ${t[e]};`).join(`
`);
}
function tu(t = {}) {
  return e$(t).replace(`
`, " ");
}
const t$ = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
], r$ = new Set(t$);
function n$(t) {
  return r$.has(t);
}
function Ce(...t) {
  const e = { ...t[0] };
  for (let r = 1; r < t.length; r++) {
    const n = t[r];
    if (n) {
      for (const s of Object.keys(n)) {
        const o = e[s], i = n[s], a = typeof o == "function", l = typeof i == "function";
        if (a && n$(s)) {
          const u = o, c = i;
          e[s] = xb(u, c);
        } else if (a && l)
          e[s] = Ts(o, i);
        else if (s === "class") {
          const u = Nc(o), c = Nc(i);
          u && c ? e[s] = io(o, i) : u ? e[s] = io(o) : c && (e[s] = io(i));
        } else if (s === "style") {
          const u = typeof o == "object", c = typeof i == "object", f = typeof o == "string", g = typeof i == "string";
          if (u && c)
            e[s] = { ...o, ...i };
          else if (u && g) {
            const _ = oi(i);
            e[s] = { ...o, ..._ };
          } else if (f && c) {
            const _ = oi(o);
            e[s] = { ..._, ...i };
          } else if (f && g) {
            const _ = oi(o), b = oi(i);
            e[s] = { ..._, ...b };
          } else u ? e[s] = o : c ? e[s] = i : f ? e[s] = o : g && (e[s] = i);
        } else
          e[s] = i !== void 0 ? i : o;
      }
      for (const s of Object.getOwnPropertySymbols(n)) {
        const o = e[s], i = n[s];
        e[s] = i !== void 0 ? i : o;
      }
    }
  }
  return typeof e.style == "object" && (e.style = tu(e.style).replaceAll(`
`, " ")), e.hidden === !1 && (e.hidden = void 0, delete e.hidden), e.disabled === !1 && (e.disabled = void 0, delete e.disabled), e;
}
const Ob = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
}, Cb = tu(Ob), kb = typeof window < "u" ? window : void 0;
function s$(t) {
  let e = t.activeElement;
  for (; e?.shadowRoot; ) {
    const r = e.shadowRoot.activeElement;
    if (r === e)
      break;
    e = r;
  }
  return e;
}
class o$ {
  #e;
  #t;
  constructor(e = {}) {
    const { window: r = kb, document: n = r?.document } = e;
    r !== void 0 && (this.#e = n, this.#t = fd((s) => {
      const o = Ye(r, "focusin", s), i = Ye(r, "focusout", s);
      return () => {
        o(), i();
      };
    }));
  }
  get current() {
    return this.#t?.(), this.#e ? s$(this.#e) : null;
  }
}
new o$();
function i$(t) {
  return typeof t == "function";
}
class ht {
  #e;
  #t;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(e) {
    this.#e = e, this.#t = Symbol(e);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#t;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return uP(this.#t);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const e = Is(this.#t);
    if (e === void 0)
      throw new Error(`Context "${this.#e}" not found`);
    return e;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(e) {
    const r = Is(this.#t);
    return r === void 0 ? e : r;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(e) {
    return Po(this.#t, e);
  }
}
function a$(t, e) {
  switch (t) {
    case "post":
      Xe(e);
      break;
    case "pre":
      Co(e);
      break;
  }
}
function $b(t, e, r, n = {}) {
  const { lazy: s = !1 } = n;
  let o = !s, i = Array.isArray(t) ? [] : void 0;
  a$(e, () => {
    const a = Array.isArray(t) ? t.map((u) => u()) : t();
    if (!o) {
      o = !0, i = a;
      return;
    }
    const l = ot(() => r(a, i));
    return i = a, l;
  });
}
function Fe(t, e, r) {
  $b(t, "post", e, r);
}
function l$(t, e, r) {
  $b(t, "pre", e, r);
}
Fe.pre = l$;
function Jg(t) {
  return i$(t) ? t() : t;
}
class u$ {
  // no need to use `$state` here since we are using createSubscriber
  #e = { width: 0, height: 0 };
  #t = !1;
  #r;
  #n;
  #s;
  // we use a derived here to extract the width so that if the width doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #o = /* @__PURE__ */ O(() => (d(this.#a)?.(), this.getSize().width));
  // we use a derived here to extract the height so that if the height doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #i = /* @__PURE__ */ O(() => (d(this.#a)?.(), this.getSize().height));
  // we need to use a derived here because the class will be created before the node is bound to the ref
  #a = /* @__PURE__ */ O(() => {
    const e = Jg(this.#n);
    if (e)
      return fd((r) => {
        if (!this.#s) return;
        const n = new this.#s.ResizeObserver((s) => {
          this.#t = !0;
          for (const o of s) {
            const i = this.#r.box === "content-box" ? o.contentBoxSize : o.borderBoxSize, a = Array.isArray(i) ? i : [i];
            this.#e.width = a.reduce((l, u) => Math.max(l, u.inlineSize), 0), this.#e.height = a.reduce((l, u) => Math.max(l, u.blockSize), 0);
          }
          r();
        });
        return n.observe(e), () => {
          this.#t = !1, n.disconnect();
        };
      });
  });
  constructor(e, r = { box: "border-box" }) {
    this.#s = r.window ?? kb, this.#r = r, this.#n = e, this.#e = { width: 0, height: 0 };
  }
  calculateSize() {
    const e = Jg(this.#n);
    if (!e || !this.#s)
      return;
    const r = e.offsetWidth, n = e.offsetHeight;
    if (this.#r.box === "border-box")
      return { width: r, height: n };
    const s = this.#s.getComputedStyle(e), o = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight), i = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom), a = parseFloat(s.borderLeftWidth) + parseFloat(s.borderRightWidth), l = parseFloat(s.borderTopWidth) + parseFloat(s.borderBottomWidth), u = r - o - a, c = n - i - l;
    return { width: u, height: c };
  }
  getSize() {
    return this.#t ? this.#e : this.calculateSize() ?? this.#e;
  }
  get current() {
    return d(this.#a)?.(), this.getSize();
  }
  get width() {
    return d(this.#o);
  }
  get height() {
    return d(this.#i);
  }
}
class c$ {
  #e = () => {
  };
  #t = /* @__PURE__ */ O(() => this.#e());
  constructor(e, r) {
    let n;
    r !== void 0 && (n = r), this.#e = () => {
      try {
        return n;
      } finally {
        n = e();
      }
    };
  }
  get current() {
    return d(this.#t);
  }
}
function Ys(t) {
  Xe(() => () => {
    t();
  });
}
function zd(t) {
  Xe(() => ot(() => t()));
}
function qd(t, e) {
  return setTimeout(e, t);
}
function Jt(t) {
  Vl().then(t);
}
const d$ = 1, f$ = 9, h$ = 11;
function Fc(t) {
  return Fi(t) && t.nodeType === d$ && typeof t.nodeName == "string";
}
function Ab(t) {
  return Fi(t) && t.nodeType === f$;
}
function g$(t) {
  return Fi(t) && t.constructor?.name === "VisualViewport";
}
function p$(t) {
  return Fi(t) && t.nodeType !== void 0;
}
function Eb(t) {
  return p$(t) && t.nodeType === h$ && "host" in t;
}
function m$(t, e) {
  if (!t || !e || !Fc(t) || !Fc(e))
    return !1;
  const r = e.getRootNode?.();
  if (t === e || t.contains(e))
    return !0;
  if (r && Eb(r)) {
    let n = e;
    for (; n; ) {
      if (t === n)
        return !0;
      n = n.parentNode || n.host;
    }
  }
  return !1;
}
function Ud(t) {
  return Ab(t) ? t : g$(t) ? t.document : t?.ownerDocument ?? document;
}
function Tb(t) {
  return Eb(t) ? Tb(t.host) : Ab(t) ? t.defaultView ?? window : Fc(t) ? t.ownerDocument?.defaultView ?? window : window;
}
function v$(t) {
  let e = t.activeElement;
  for (; e?.shadowRoot; ) {
    const r = e.shadowRoot.activeElement;
    if (r === e)
      break;
    e = r;
  }
  return e;
}
class Fn {
  element;
  #e = /* @__PURE__ */ O(() => this.element.current ? this.element.current.getRootNode() ?? document : document);
  get root() {
    return d(this.#e);
  }
  set root(e) {
    q(this.#e, e);
  }
  constructor(e) {
    typeof e == "function" ? this.element = z(e) : this.element = e;
  }
  getDocument = () => Ud(this.root);
  getWindow = () => this.getDocument().defaultView ?? window;
  getActiveElement = () => v$(this.root);
  isActiveElement = (e) => e === this.getActiveElement();
  getElementById(e) {
    return this.root.getElementById(e);
  }
  querySelector = (e) => this.root ? this.root.querySelector(e) : null;
  querySelectorAll = (e) => this.root ? this.root.querySelectorAll(e) : [];
  setTimeout = (e, r) => this.getWindow().setTimeout(e, r);
  clearTimeout = (e) => this.getWindow().clearTimeout(e);
}
function Te(t, e) {
  return {
    [ry()]: (r) => Ri(t) ? (t.current = r, ot(() => e?.(r)), () => {
      "isConnected" in r && r.isConnected || (t.current = null, e?.(null));
    }) : (t(r), ot(() => e?.(r)), () => {
      "isConnected" in r && r.isConnected || (t(null), e?.(null));
    })
  };
}
function at(t) {
  return t ? "true" : "false";
}
function Kd(t) {
  return t ? "true" : void 0;
}
function Re(t) {
  return t ? "" : void 0;
}
function yi(t) {
  return t ? !0 : void 0;
}
function Vi(t) {
  return t ? "open" : "closed";
}
function y$(t) {
  return t ? "checked" : "unchecked";
}
function ru(t, e) {
  return e ? "mixed" : t ? "true" : "false";
}
class b$ {
  #e;
  #t;
  attrs;
  constructor(e) {
    this.#e = e.getVariant ? e.getVariant() : null, this.#t = this.#e ? `data-${this.#e}-` : `data-${e.component}-`, this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(e.parts.map((r) => [r, this.getAttr(r)]));
  }
  getAttr(e, r) {
    return r ? `data-${r}-${e}` : `${this.#t}${e}`;
  }
  selector(e, r) {
    return `[${this.getAttr(e, r)}]`;
  }
}
function tr(t) {
  const e = new b$(t);
  return {
    ...e.attrs,
    selector: e.selector,
    getAttr: e.getAttr
  };
}
const dr = "ArrowDown", cs = "ArrowLeft", ds = "ArrowRight", Qt = "ArrowUp", Do = "End", Br = "Enter", _$ = "Escape", Mo = "Home", Db = "PageDown", Mb = "PageUp", xr = " ", Zg = "Tab", w$ = "p", S$ = "n", x$ = "j", P$ = "k", O$ = "h", C$ = "l";
function k$(t) {
  return window.getComputedStyle(t).getPropertyValue("direction");
}
function $$(t = "ltr", e = "horizontal") {
  return {
    horizontal: t === "rtl" ? cs : ds,
    vertical: dr
  }[e];
}
function A$(t = "ltr", e = "horizontal") {
  return {
    horizontal: t === "rtl" ? ds : cs,
    vertical: Qt
  }[e];
}
function E$(t = "ltr", e = "horizontal") {
  return ["ltr", "rtl"].includes(t) || (t = "ltr"), ["horizontal", "vertical"].includes(e) || (e = "horizontal"), {
    nextKey: $$(t, e),
    prevKey: A$(t, e)
  };
}
const Li = typeof document < "u", Rc = T$();
function T$() {
  return Li && window?.navigator?.userAgent && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function Cn(t) {
  return t instanceof HTMLElement;
}
function ci(t) {
  return t instanceof Element;
}
function Wd(t) {
  return t instanceof Element || t instanceof SVGElement;
}
function ol(t) {
  return t.pointerType === "touch";
}
function D$(t) {
  return t !== null;
}
class Ib {
  #e;
  #t = Gs(null);
  constructor(e) {
    this.#e = e;
  }
  getCandidateNodes() {
    return this.#e.rootNode.current ? this.#e.candidateSelector ? Array.from(this.#e.rootNode.current.querySelectorAll(this.#e.candidateSelector)) : this.#e.candidateAttr ? Array.from(this.#e.rootNode.current.querySelectorAll(`[${this.#e.candidateAttr}]:not([data-disabled])`)) : [] : [];
  }
  focusFirstCandidate() {
    const e = this.getCandidateNodes();
    e.length && e[0]?.focus();
  }
  handleKeydown(e, r, n = !1) {
    const s = this.#e.rootNode.current;
    if (!s || !e)
      return;
    const o = this.getCandidateNodes();
    if (!o.length)
      return;
    const i = o.indexOf(e), a = k$(s), { nextKey: l, prevKey: u } = E$(a, this.#e.orientation.current), c = this.#e.loop.current, f = {
      [l]: i + 1,
      [u]: i - 1,
      [Mo]: 0,
      [Do]: o.length - 1
    };
    if (n) {
      const b = l === dr ? ds : dr, p = u === Qt ? cs : Qt;
      f[b] = i + 1, f[p] = i - 1;
    }
    let g = f[r.key];
    if (g === void 0)
      return;
    r.preventDefault(), g < 0 && c ? g = o.length - 1 : g === o.length && c && (g = 0);
    const _ = o[g];
    if (_)
      return _.focus(), this.#t.current = _.id, this.#e.onCandidateFocus?.(_), _;
  }
  getTabIndex(e) {
    const r = this.getCandidateNodes(), n = this.#t.current !== null;
    return e && !n && r[0] === e ? (this.#t.current = e.id, 0) : e?.id === this.#t.current ? 0 : -1;
  }
  setCurrentTabStopId(e) {
    this.#t.current = e;
  }
  focusCurrentTabStop() {
    const e = this.#t.current;
    if (!e)
      return;
    const r = this.#e.rootNode.current?.querySelector(`#${e}`);
    !r || !Cn(r) || r.focus();
  }
}
class M$ {
  #e;
  #t = null;
  constructor(e) {
    this.#e = e, Ys(() => this.#r());
  }
  #r() {
    this.#t && (window.cancelAnimationFrame(this.#t), this.#t = null);
  }
  run(e) {
    this.#r();
    const r = this.#e.ref.current;
    if (r) {
      if (typeof r.getAnimations != "function") {
        this.#n(e);
        return;
      }
      this.#t = window.requestAnimationFrame(() => {
        const n = r.getAnimations();
        if (n.length === 0) {
          this.#n(e);
          return;
        }
        Promise.allSettled(n.map((s) => s.finished)).then(() => {
          this.#n(e);
        });
      });
    }
  }
  #n(e) {
    const r = () => {
      e();
    };
    this.#e.afterTick ? Jt(r) : r();
  }
}
class bi {
  #e;
  #t;
  #r;
  #n = /* @__PURE__ */ xe(!1);
  constructor(e) {
    this.#e = e, q(this.#n, e.open.current, !0), this.#t = e.enabled ?? !0, this.#r = new M$({ ref: this.#e.ref, afterTick: this.#e.open }), Fe(() => this.#e.open.current, (r) => {
      r && q(this.#n, !0), this.#t && this.#r.run(() => {
        r === this.#e.open.current && (this.#e.open.current || q(this.#n, !1), this.#e.onComplete?.());
      });
    });
  }
  get shouldRender() {
    return d(this.#n);
  }
}
function _e() {
}
function me(t, e) {
  return `bits-${t}`;
}
const I$ = tr({
  component: "dialog",
  parts: [
    "content",
    "trigger",
    "overlay",
    "title",
    "description",
    "close",
    "cancel",
    "action"
  ]
}), Qn = new ht("Dialog.Root | AlertDialog.Root");
class Hd {
  static create(e) {
    const r = Qn.getOr(null);
    return Qn.set(new Hd(e, r));
  }
  opts;
  #e = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#e);
  }
  set triggerNode(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#t);
  }
  set contentNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get overlayNode() {
    return d(this.#r);
  }
  set overlayNode(e) {
    q(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ xe(null);
  get descriptionNode() {
    return d(this.#n);
  }
  set descriptionNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(void 0);
  get contentId() {
    return d(this.#s);
  }
  set contentId(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(void 0);
  get titleId() {
    return d(this.#o);
  }
  set titleId(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(void 0);
  get triggerId() {
    return d(this.#i);
  }
  set triggerId(e) {
    q(this.#i, e, !0);
  }
  #a = /* @__PURE__ */ xe(void 0);
  get descriptionId() {
    return d(this.#a);
  }
  set descriptionId(e) {
    q(this.#a, e, !0);
  }
  #u = /* @__PURE__ */ xe(null);
  get cancelNode() {
    return d(this.#u);
  }
  set cancelNode(e) {
    q(this.#u, e, !0);
  }
  #l = /* @__PURE__ */ xe(0);
  get nestedOpenCount() {
    return d(this.#l);
  }
  set nestedOpenCount(e) {
    q(this.#l, e, !0);
  }
  depth;
  parent;
  contentPresence;
  overlayPresence;
  constructor(e, r) {
    this.opts = e, this.parent = r, this.depth = r ? r.depth + 1 : 0, this.handleOpen = this.handleOpen.bind(this), this.handleClose = this.handleClose.bind(this), this.contentPresence = new bi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      enabled: !0,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), this.overlayPresence = new bi({
      ref: z(() => this.overlayNode),
      open: this.opts.open,
      enabled: !0
    }), Fe(
      () => this.opts.open.current,
      (n) => {
        this.parent && (n ? this.parent.incrementNested() : this.parent.decrementNested());
      },
      { lazy: !0 }
    ), Ys(() => {
      this.opts.open.current && this.parent?.decrementNested();
    });
  }
  handleOpen() {
    this.opts.open.current || (this.opts.open.current = !0);
  }
  handleClose() {
    this.opts.open.current && (this.opts.open.current = !1);
  }
  getBitsAttr = (e) => I$.getAttr(e, this.opts.variant.current);
  incrementNested() {
    this.nestedOpenCount++, this.parent?.incrementNested();
  }
  decrementNested() {
    this.nestedOpenCount !== 0 && (this.nestedOpenCount--, this.parent?.decrementNested());
  }
  #c = /* @__PURE__ */ O(() => ({ "data-state": Vi(this.opts.open.current) }));
  get sharedProps() {
    return d(this.#c);
  }
  set sharedProps(e) {
    q(this.#c, e);
  }
}
class Gd {
  static create(e) {
    return new Gd(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => {
      this.root.triggerNode = n, this.root.triggerId = n?.id;
    }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || e.button > 0 || this.root.handleOpen();
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === xr || e.key === Br) && (e.preventDefault(), this.root.handleOpen());
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-haspopup": "dialog",
    "aria-expanded": at(this.root.opts.open.current),
    "aria-controls": this.root.contentId,
    [this.root.getBitsAttr("trigger")]: "",
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    disabled: this.opts.disabled.current ? !0 : void 0,
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Yd {
  static create(e) {
    return new Yd(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || e.button > 0 || this.root.handleClose();
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === xr || e.key === Br) && (e.preventDefault(), this.root.handleClose());
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr(this.opts.variant.current)]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    disabled: this.opts.disabled.current ? !0 : void 0,
    tabindex: 0,
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Xd {
  static create(e) {
    return new Xd(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.root.titleId = this.opts.id.current, this.attachment = Te(this.opts.ref), Fe.pre(() => this.opts.id.current, (n) => {
      this.root.titleId = n;
    });
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "heading",
    "aria-level": this.opts.level.current,
    [this.root.getBitsAttr("title")]: "",
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Jd {
  static create(e) {
    return new Jd(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.root.descriptionId = this.opts.id.current, this.attachment = Te(this.opts.ref, (n) => {
      this.root.descriptionNode = n;
    }), Fe.pre(() => this.opts.id.current, (n) => {
      this.root.descriptionId = n;
    });
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr("description")]: "",
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Zd {
  static create(e) {
    return new Zd(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => {
      this.root.contentNode = n, this.root.contentId = n?.id;
    });
  }
  #e = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: this.root.opts.variant.current === "alert-dialog" ? "alertdialog" : "dialog",
    "aria-modal": "true",
    "aria-describedby": this.root.descriptionId,
    "aria-labelledby": this.root.titleId,
    [this.root.getBitsAttr("content")]: "",
    style: {
      pointerEvents: "auto",
      outline: this.root.opts.variant.current === "alert-dialog" ? "none" : void 0,
      "--bits-dialog-depth": this.root.depth,
      "--bits-dialog-nested-count": this.root.nestedOpenCount,
      contain: "layout style paint"
    },
    tabindex: this.root.opts.variant.current === "alert-dialog" ? -1 : void 0,
    "data-nested-open": Re(this.root.nestedOpenCount > 0),
    "data-nested": Re(this.root.parent !== null),
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
}
class Qd {
  static create(e) {
    return new Qd(e, Qn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.overlayNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr("overlay")]: "",
    style: {
      pointerEvents: "auto",
      "--bits-dialog-depth": this.root.depth,
      "--bits-dialog-nested-count": this.root.nestedOpenCount
    },
    "data-nested-open": Re(this.root.nestedOpenCount > 0),
    "data-nested": Re(this.root.parent !== null),
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  get shouldRender() {
    return this.root.overlayPresence.shouldRender;
  }
}
var N$ = /* @__PURE__ */ ne("<div><!></div>");
function Nb(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "level", 7, 2), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "level"
  ]);
  const u = Xd.create({
    id: z(() => n()),
    level: z(() => a()),
    ref: z(() => s(), (h) => s(h))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(h = me(r)) {
      n(h), m();
    },
    get ref() {
      return s();
    },
    set ref(h = null) {
      s(h), m();
    },
    get child() {
      return o();
    },
    set child(h) {
      o(h), m();
    },
    get children() {
      return i();
    },
    set children(h) {
      i(h), m();
    },
    get level() {
      return a();
    },
    set level(h = 2) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, o, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = N$();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => i() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      o() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(Nb, { id: {}, ref: {}, child: {}, children: {}, level: {} }, [], [], { mode: "open" });
function Fb(t, e) {
  W(e, !0);
  const r = v(e, "children", 7);
  var n = {
    get children() {
      return r();
    },
    set children(i) {
      r(i), m();
    }
  }, s = M(), o = D(s);
  return Ll(o, r, (i) => {
    var a = M(), l = D(a);
    te(l, () => r() ?? he), A(i, a);
  }), A(t, s), H(n);
}
K(Fb, { children: {} }, [], [], { mode: "open" });
const Vc = new ht("BitsConfig");
function F$() {
  const t = new Rb(null, {});
  return Vc.getOr(t).opts;
}
function R$(t) {
  return Vc.set(new Rb(Vc.getOr(null), t));
}
class Rb {
  opts;
  constructor(e, r) {
    const n = V$(e, r);
    this.opts = {
      defaultPortalTo: n((s) => s.defaultPortalTo),
      defaultLocale: n((s) => s.defaultLocale)
    };
  }
}
function V$(t, e) {
  return (r) => z(() => {
    const s = r(e)?.current;
    if (s !== void 0)
      return s;
    if (t !== null)
      return r(t.opts)?.current;
  });
}
function Vb(t, e) {
  return (r) => {
    const n = F$();
    return z(() => {
      const s = r();
      if (s !== void 0)
        return s;
      const o = t(n).current;
      return o !== void 0 ? o : e;
    });
  };
}
const Lb = Vb((t) => t.defaultLocale, "en"), L$ = Vb((t) => t.defaultPortalTo, "body");
function nu(t, e) {
  W(e, !0);
  let r = v(e, "to", 7), n = v(e, "children", 7), s = v(e, "disabled", 7);
  const o = L$(() => r()), i = cP();
  let a = /* @__PURE__ */ O(l);
  function l() {
    if (!Li || s()) return null;
    let p = null;
    return typeof o.current == "string" ? p = document.querySelector(o.current) : p = o.current, p;
  }
  let u;
  function c() {
    u && (ty(u), u = null);
  }
  Fe([() => d(a), () => s()], ([p, h]) => {
    if (!p || h) {
      c();
      return;
    }
    return u = bd(Fb, { target: p, props: { children: n() }, context: i }), () => {
      c();
    };
  });
  var f = {
    get to() {
      return r();
    },
    set to(p) {
      r(p), m();
    },
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get disabled() {
      return s();
    },
    set disabled(p) {
      s(p), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (p) => {
      var h = M(), y = D(h);
      te(y, () => n() ?? he), A(p, h);
    };
    ue(_, (p) => {
      s() && p(b);
    });
  }
  return A(t, g), H(f);
}
K(nu, { to: {}, children: {}, disabled: {} }, [], [], { mode: "open" });
function Qg(t, e = 500) {
  let r = null;
  const n = (...s) => {
    r !== null && clearTimeout(r), r = setTimeout(() => {
      t(...s);
    }, e);
  };
  return n.destroy = () => {
    r !== null && (clearTimeout(r), r = null);
  }, n;
}
function jb(t, e) {
  return t === e || t.contains(e);
}
function Bb(t) {
  return t?.ownerDocument ?? document;
}
function j$(t) {
  if (!t)
    return null;
  for (const e of t.childNodes)
    if (e.nodeType !== Node.COMMENT_NODE)
      return e;
  return null;
}
function B$(t, e) {
  const { clientX: r, clientY: n } = t, s = e.getBoundingClientRect();
  return r < s.left || r > s.right || n < s.top || n > s.bottom;
}
var zb = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"], il = /* @__PURE__ */ zb.join(","), qb = typeof Element > "u", Ls = qb ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, al = !qb && Element.prototype.getRootNode ? function(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
} : function(t) {
  return t?.ownerDocument;
}, ll = function(e, r) {
  var n;
  r === void 0 && (r = !0);
  var s = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "inert"), o = s === "" || s === "true", i = o || r && e && // closest does not exist on shadow roots, so we fall back to a manual
  // lookup upward, in case it is not defined.
  (typeof e.closest == "function" ? e.closest("[inert]") : ll(e.parentNode));
  return i;
}, z$ = function(e) {
  var r, n = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "contenteditable");
  return n === "" || n === "true";
}, Ub = function(e, r, n) {
  if (ll(e))
    return [];
  var s = Array.prototype.slice.apply(e.querySelectorAll(il));
  return r && Ls.call(e, il) && s.unshift(e), s = s.filter(n), s;
}, ul = function(e, r, n) {
  for (var s = [], o = Array.from(e); o.length; ) {
    var i = o.shift();
    if (!ll(i, !1))
      if (i.tagName === "SLOT") {
        var a = i.assignedElements(), l = a.length ? a : i.children, u = ul(l, !0, n);
        n.flatten ? s.push.apply(s, u) : s.push({
          scopeParent: i,
          candidates: u
        });
      } else {
        var c = Ls.call(i, il);
        c && n.filter(i) && (r || !e.includes(i)) && s.push(i);
        var f = i.shadowRoot || // check for an undisclosed shadow
        typeof n.getShadowRoot == "function" && n.getShadowRoot(i), g = !ll(f, !1) && (!n.shadowRootFilter || n.shadowRootFilter(i));
        if (f && g) {
          var _ = ul(f === !0 ? i.children : f.children, !0, n);
          n.flatten ? s.push.apply(s, _) : s.push({
            scopeParent: i,
            candidates: _
          });
        } else
          o.unshift.apply(o, i.children);
      }
  }
  return s;
}, Kb = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, Wb = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || z$(e)) && !Kb(e) ? 0 : e.tabIndex;
}, q$ = function(e, r) {
  var n = Wb(e);
  return n < 0 && r && !Kb(e) ? 0 : n;
}, U$ = function(e, r) {
  return e.tabIndex === r.tabIndex ? e.documentOrder - r.documentOrder : e.tabIndex - r.tabIndex;
}, Hb = function(e) {
  return e.tagName === "INPUT";
}, K$ = function(e) {
  return Hb(e) && e.type === "hidden";
}, W$ = function(e) {
  var r = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return r;
}, H$ = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (e[n].checked && e[n].form === r)
      return e[n];
}, G$ = function(e) {
  if (!e.name)
    return !0;
  var r = e.form || al(e), n = function(a) {
    return r.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, s;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    s = n(window.CSS.escape(e.name));
  else
    try {
      s = n(e.name);
    } catch (i) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", i.message), !1;
    }
  var o = H$(s, e.form);
  return !o || o === e;
}, Y$ = function(e) {
  return Hb(e) && e.type === "radio";
}, X$ = function(e) {
  return Y$(e) && !G$(e);
}, J$ = function(e) {
  var r, n = e && al(e), s = (r = n) === null || r === void 0 ? void 0 : r.host, o = !1;
  if (n && n !== e) {
    var i, a, l;
    for (o = !!((i = s) !== null && i !== void 0 && (a = i.ownerDocument) !== null && a !== void 0 && a.contains(s) || e != null && (l = e.ownerDocument) !== null && l !== void 0 && l.contains(e)); !o && s; ) {
      var u, c, f;
      n = al(s), s = (u = n) === null || u === void 0 ? void 0 : u.host, o = !!((c = s) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(s));
    }
  }
  return o;
}, ep = function(e) {
  var r = e.getBoundingClientRect(), n = r.width, s = r.height;
  return n === 0 && s === 0;
}, Z$ = function(e, r) {
  var n = r.displayCheck, s = r.getShadowRoot;
  if (n === "full-native" && "checkVisibility" in e) {
    var o = e.checkVisibility({
      // Checking opacity might be desirable for some use cases, but natively,
      // opacity zero elements _are_ focusable and tabbable.
      checkOpacity: !1,
      opacityProperty: !1,
      contentVisibilityAuto: !0,
      visibilityProperty: !0,
      // This is an alias for `visibilityProperty`. Contemporary browsers
      // support both. However, this alias has wider browser support (Chrome
      // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
      // we include it anyway.
      checkVisibilityCSS: !0
    });
    return !o;
  }
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var i = Ls.call(e, "details>summary:first-of-type"), a = i ? e.parentElement : e;
  if (Ls.call(a, "details:not([open]) *"))
    return !0;
  if (!n || n === "full" || // full-native can run this branch when it falls through in case
  // Element#checkVisibility is unsupported
  n === "full-native" || n === "legacy-full") {
    if (typeof s == "function") {
      for (var l = e; e; ) {
        var u = e.parentElement, c = al(e);
        if (u && !u.shadowRoot && s(u) === !0)
          return ep(e);
        e.assignedSlot ? e = e.assignedSlot : !u && c !== e.ownerDocument ? e = c.host : e = u;
      }
      e = l;
    }
    if (J$(e))
      return !e.getClientRects().length;
    if (n !== "legacy-full")
      return !0;
  } else if (n === "non-zero-area")
    return ep(e);
  return !1;
}, Q$ = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var r = e.parentElement; r; ) {
      if (r.tagName === "FIELDSET" && r.disabled) {
        for (var n = 0; n < r.children.length; n++) {
          var s = r.children.item(n);
          if (s.tagName === "LEGEND")
            return Ls.call(r, "fieldset[disabled] *") ? !0 : !s.contains(e);
        }
        return !0;
      }
      r = r.parentElement;
    }
  return !1;
}, cl = function(e, r) {
  return !(r.disabled || K$(r) || Z$(r, e) || // For a details element with a summary, the summary element gets the focus
  W$(r) || Q$(r));
}, Lc = function(e, r) {
  return !(X$(r) || Wb(r) < 0 || !cl(e, r));
}, eA = function(e) {
  var r = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(r) || r >= 0);
}, Gb = function(e) {
  var r = [], n = [];
  return e.forEach(function(s, o) {
    var i = !!s.scopeParent, a = i ? s.scopeParent : s, l = q$(a, i), u = i ? Gb(s.candidates) : a;
    l === 0 ? i ? r.push.apply(r, u) : r.push(a) : n.push({
      documentOrder: o,
      tabIndex: l,
      item: s,
      isScope: i,
      content: u
    });
  }), n.sort(U$).reduce(function(s, o) {
    return o.isScope ? s.push.apply(s, o.content) : s.push(o.content), s;
  }, []).concat(r);
}, tA = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = ul([e], r.includeContainer, {
    filter: Lc.bind(null, r),
    flatten: !1,
    getShadowRoot: r.getShadowRoot,
    shadowRootFilter: eA
  }) : n = Ub(e, r.includeContainer, Lc.bind(null, r)), Gb(n);
}, rA = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = ul([e], r.includeContainer, {
    filter: cl.bind(null, r),
    flatten: !0,
    getShadowRoot: r.getShadowRoot
  }) : n = Ub(e, r.includeContainer, cl.bind(null, r)), n;
}, nA = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return Ls.call(e, il) === !1 ? !1 : Lc(r, e);
}, sA = /* @__PURE__ */ zb.concat("iframe:not([inert]):not([inert] *)").join(","), oA = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return Ls.call(e, sA) === !1 ? !1 : cl(r, e);
};
function iA(t, e) {
  const r = [];
  for (let n = 0; n < t.length; n += e)
    r.push(t.slice(n, n + e));
  return r;
}
function Wa(t, e) {
  return t >= 0 && t < e.length;
}
function aA(t, e, r = !0) {
  if (!(t.length === 0 || e < 0 || e >= t.length))
    return t.length === 1 && e === 0 ? t[0] : e === t.length - 1 ? r ? t[0] : void 0 : t[e + 1];
}
function lA(t, e, r = !0) {
  if (!(t.length === 0 || e < 0 || e >= t.length))
    return t.length === 1 && e === 0 ? t[0] : e === 0 ? r ? t[t.length - 1] : void 0 : t[e - 1];
}
function uA(t, e, r, n = !0) {
  if (t.length === 0 || e < 0 || e >= t.length)
    return;
  let s = e + r;
  return n ? s = (s % t.length + t.length) % t.length : s = Math.max(0, Math.min(s, t.length - 1)), t[s];
}
function cA(t, e, r, n = !0) {
  if (t.length === 0 || e < 0 || e >= t.length)
    return;
  let s = e - r;
  return n ? s = (s % t.length + t.length) % t.length : s = Math.max(0, Math.min(s, t.length - 1)), t[s];
}
function ef(t, e, r) {
  const n = e.toLowerCase();
  if (n.endsWith(" ")) {
    const f = n.slice(0, -1);
    if (t.filter((p) => p.toLowerCase().startsWith(f)).length <= 1)
      return ef(t, f, r);
    const _ = r?.toLowerCase();
    if (_ && _.startsWith(f) && _.charAt(f.length) === " " && e.trim() === f)
      return r;
    const b = t.filter((p) => p.toLowerCase().startsWith(n));
    if (b.length > 0) {
      const p = r ? t.indexOf(r) : -1;
      return tp(b, Math.max(p, 0)).find((S) => S !== r) || r;
    }
  }
  const o = e.length > 1 && Array.from(e).every((f) => f === e[0]) ? e[0] : e, i = o.toLowerCase(), a = r ? t.indexOf(r) : -1;
  let l = tp(t, Math.max(a, 0));
  o.length === 1 && (l = l.filter((f) => f !== r));
  const c = l.find((f) => f?.toLowerCase().startsWith(i));
  return c !== r ? c : void 0;
}
function tp(t, e) {
  return t.map((r, n) => t[(e + n) % t.length]);
}
const dA = { afterMs: 1e4, onChange: _e };
function Yb(t, e) {
  const { afterMs: r, onChange: n, getWindow: s } = { ...dA, ...e };
  let o = null, i = /* @__PURE__ */ xe(Pt(t));
  function a() {
    return s().setTimeout(
      () => {
        q(i, t, !0), n?.(t);
      },
      r
    );
  }
  return Xe(() => () => {
    o && s().clearTimeout(o);
  }), z(() => d(i), (l) => {
    q(i, l, !0), n?.(l), o && s().clearTimeout(o), o = a();
  });
}
class fA {
  #e;
  #t;
  #r = /* @__PURE__ */ O(() => this.#e.onMatch ? this.#e.onMatch : (e) => e.focus());
  #n = /* @__PURE__ */ O(() => this.#e.getCurrentItem ? this.#e.getCurrentItem : this.#e.getActiveElement);
  constructor(e) {
    this.#e = e, this.#t = Yb("", { afterMs: 1e3, getWindow: e.getWindow }), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(e, r) {
    if (!r.length) return;
    this.#t.current = this.#t.current + e;
    const n = d(this.#n)(), s = r.find((l) => l === n)?.textContent?.trim() ?? "", o = r.map((l) => l.textContent?.trim() ?? ""), i = ef(o, this.#t.current, s), a = r.find((l) => l.textContent?.trim() === i);
    return a && d(this.#r)(a), a;
  }
  resetTypeahead() {
    this.#t.current = "";
  }
  get search() {
    return this.#t.current;
  }
}
const hA = "data-context-menu-trigger", gA = "data-context-menu-content";
tr({
  component: "menu",
  parts: [
    "trigger",
    "content",
    "sub-trigger",
    "item",
    "group",
    "group-heading",
    "checkbox-group",
    "checkbox-item",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "arrow"
  ]
});
globalThis.bitsDismissableLayers ??= /* @__PURE__ */ new Map();
class tf {
  static create(e) {
    return new tf(e);
  }
  opts;
  #e;
  #t;
  #r = { pointerdown: !1 };
  #n = !1;
  #s = !1;
  #o = void 0;
  #i;
  #a = _e;
  constructor(e) {
    this.opts = e, this.#t = e.interactOutsideBehavior, this.#e = e.onInteractOutside, this.#i = e.onFocusOutside, Xe(() => {
      this.#o = Bb(this.opts.ref.current);
    });
    let r = _e;
    const n = () => {
      this.#h(), globalThis.bitsDismissableLayers.delete(this), this.#d.destroy(), r();
    };
    Fe([() => this.opts.enabled.current, () => this.opts.ref.current], () => {
      if (!(!this.opts.enabled.current || !this.opts.ref.current))
        return qd(1, () => {
          this.opts.ref.current && (globalThis.bitsDismissableLayers.set(this, this.#t), r(), r = this.#l());
        }), n;
    }), Ys(() => {
      this.#h.destroy(), globalThis.bitsDismissableLayers.delete(this), this.#d.destroy(), this.#a(), r();
    });
  }
  #u = (e) => {
    e.defaultPrevented || this.opts.ref.current && Jt(() => {
      !this.opts.ref.current || this.#f(e.target) || e.target && !this.#s && this.#i.current?.(e);
    });
  };
  #l() {
    return Ts(
      /**
       * CAPTURE INTERACTION START
       * mark interaction-start event as intercepted.
       * mark responsible layer during interaction start
       * to avoid checking if is responsible layer during interaction end
       * when a new floating element may have been opened.
       */
      Ye(this.#o, "pointerdown", Ts(this.#g, this.#p), { capture: !0 }),
      /**
       * BUBBLE INTERACTION START
       * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
       * to avoid prematurely checking if other events were intercepted.
       */
      Ye(this.#o, "pointerdown", Ts(this.#m, this.#d)),
      /**
       * HANDLE FOCUS OUTSIDE
       */
      Ye(this.#o, "focusin", this.#u)
    );
  }
  #c = (e) => {
    let r = e;
    r.defaultPrevented && (r = rp(e)), this.#e.current(e);
  };
  #d = Qg(
    (e) => {
      if (!this.opts.ref.current) {
        this.#a();
        return;
      }
      const r = this.opts.isValidEvent.current(e, this.opts.ref.current) || vA(e, this.opts.ref.current);
      if (!this.#n || this.#b() || !r) {
        this.#a();
        return;
      }
      let n = e;
      if (n.defaultPrevented && (n = rp(n)), this.#t.current !== "close" && this.#t.current !== "defer-otherwise-close") {
        this.#a();
        return;
      }
      e.pointerType === "touch" ? (this.#a(), this.#a = Ye(this.#o, "click", this.#c, { once: !0 })) : this.#e.current(n);
    },
    10
  );
  #g = (e) => {
    this.#r[e.type] = !0;
  };
  #m = (e) => {
    this.#r[e.type] = !1;
  };
  #p = () => {
    this.opts.ref.current && (this.#n = mA(this.opts.ref.current));
  };
  #f = (e) => this.opts.ref.current ? jb(this.opts.ref.current, e) : !1;
  #h = Qg(
    () => {
      for (const e in this.#r)
        this.#r[e] = !1;
      this.#n = !1;
    },
    20
  );
  #b() {
    return Object.values(this.#r).some(Boolean);
  }
  #y = () => {
    this.#s = !0;
  };
  #v = () => {
    this.#s = !1;
  };
  props = {
    onfocuscapture: this.#y,
    onblurcapture: this.#v
  };
}
function pA(t = [...globalThis.bitsDismissableLayers]) {
  return t.findLast(([e, { current: r }]) => r === "close" || r === "ignore");
}
function mA(t) {
  const e = [...globalThis.bitsDismissableLayers], r = pA(e);
  if (r) return r[0].opts.ref.current === t;
  const [n] = e[0];
  return n.opts.ref.current === t;
}
function vA(t, e) {
  const r = t.target;
  if (!Wd(r)) return !1;
  const n = !!r.closest(`[${hA}]`);
  if ("button" in t && t.button > 0 && !n) return !1;
  if ("button" in t && t.button === 0 && n) return !0;
  const s = !!e.closest(`[${gA}]`);
  return n && s ? !1 : Bb(r).documentElement.contains(r) && !jb(e, r) && B$(t, e);
}
function rp(t) {
  const e = t.currentTarget, r = t.target;
  let n;
  t instanceof PointerEvent ? n = new PointerEvent(t.type, t) : n = new PointerEvent("pointerdown", t);
  let s = !1;
  return new Proxy(n, {
    get: (i, a) => a === "currentTarget" ? e : a === "target" ? r : a === "preventDefault" ? () => {
      s = !0, typeof i.preventDefault == "function" && i.preventDefault();
    } : a === "defaultPrevented" ? s : a in i ? i[a] : t[a]
  });
}
function rf(t, e) {
  W(e, !0);
  let r = v(e, "interactOutsideBehavior", 7, "close"), n = v(e, "onInteractOutside", 7, _e), s = v(e, "onFocusOutside", 7, _e), o = v(e, "id", 7), i = v(e, "children", 7), a = v(e, "enabled", 7), l = v(e, "isValidEvent", 7, () => !1), u = v(e, "ref", 7);
  const c = tf.create({
    id: z(() => o()),
    interactOutsideBehavior: z(() => r()),
    onInteractOutside: z(() => n()),
    enabled: z(() => a()),
    onFocusOutside: z(() => s()),
    isValidEvent: z(() => l()),
    ref: u()
  });
  var f = {
    get interactOutsideBehavior() {
      return r();
    },
    set interactOutsideBehavior(b = "close") {
      r(b), m();
    },
    get onInteractOutside() {
      return n();
    },
    set onInteractOutside(b = _e) {
      n(b), m();
    },
    get onFocusOutside() {
      return s();
    },
    set onFocusOutside(b = _e) {
      s(b), m();
    },
    get id() {
      return o();
    },
    set id(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get enabled() {
      return a();
    },
    set enabled(b) {
      a(b), m();
    },
    get isValidEvent() {
      return l();
    },
    set isValidEvent(b = () => !1) {
      l(b), m();
    },
    get ref() {
      return u();
    },
    set ref(b) {
      u(b), m();
    }
  }, g = M(), _ = D(g);
  return te(_, () => i() ?? he, () => ({ props: c.props })), A(t, g), H(f);
}
K(
  rf,
  {
    interactOutsideBehavior: {},
    onInteractOutside: {},
    onFocusOutside: {},
    id: {},
    children: {},
    enabled: {},
    isValidEvent: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsEscapeLayers ??= /* @__PURE__ */ new Map();
class nf {
  static create(e) {
    return new nf(e);
  }
  opts;
  domContext;
  constructor(e) {
    this.opts = e, this.domContext = new Fn(this.opts.ref);
    let r = _e;
    Fe(() => e.enabled.current, (n) => (n && (globalThis.bitsEscapeLayers.set(this, e.escapeKeydownBehavior), r = this.#e()), () => {
      r(), globalThis.bitsEscapeLayers.delete(this);
    }));
  }
  #e = () => Ye(this.domContext.getDocument(), "keydown", this.#t, { passive: !1 });
  #t = (e) => {
    if (e.key !== _$ || !yA(this)) return;
    const r = new KeyboardEvent(e.type, e);
    e.preventDefault();
    const n = this.opts.escapeKeydownBehavior.current;
    n !== "close" && n !== "defer-otherwise-close" || this.opts.onEscapeKeydown.current(r);
  };
}
function yA(t) {
  const e = [...globalThis.bitsEscapeLayers], r = e.findLast(([s, { current: o }]) => o === "close" || o === "ignore");
  if (r) return r[0] === t;
  const [n] = e[0];
  return n === t;
}
function sf(t, e) {
  W(e, !0);
  let r = v(e, "escapeKeydownBehavior", 7, "close"), n = v(e, "onEscapeKeydown", 7, _e), s = v(e, "children", 7), o = v(e, "enabled", 7), i = v(e, "ref", 7);
  nf.create({
    escapeKeydownBehavior: z(() => r()),
    onEscapeKeydown: z(() => n()),
    enabled: z(() => o()),
    ref: i()
  });
  var a = {
    get escapeKeydownBehavior() {
      return r();
    },
    set escapeKeydownBehavior(c = "close") {
      r(c), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(c = _e) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get enabled() {
      return o();
    },
    set enabled(c) {
      o(c), m();
    },
    get ref() {
      return i();
    },
    set ref(c) {
      i(c), m();
    }
  }, l = M(), u = D(l);
  return te(u, () => s() ?? he), A(t, l), H(a);
}
K(
  sf,
  {
    escapeKeydownBehavior: {},
    onEscapeKeydown: {},
    children: {},
    enabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
class of {
  static instance;
  #e = Jr([]);
  #t = /* @__PURE__ */ new WeakMap();
  #r = /* @__PURE__ */ new WeakMap();
  static getInstance() {
    return this.instance || (this.instance = new of()), this.instance;
  }
  register(e) {
    const r = this.getActive();
    r && r !== e && r.pause();
    const n = document.activeElement;
    n && n !== document.body && this.#r.set(e, n), this.#e.current = this.#e.current.filter((s) => s !== e), this.#e.current.unshift(e);
  }
  unregister(e) {
    this.#e.current = this.#e.current.filter((n) => n !== e);
    const r = this.getActive();
    r && r.resume();
  }
  getActive() {
    return this.#e.current[0];
  }
  setFocusMemory(e, r) {
    this.#t.set(e, r);
  }
  getFocusMemory(e) {
    return this.#t.get(e);
  }
  isActiveScope(e) {
    return this.getActive() === e;
  }
  setPreFocusMemory(e, r) {
    this.#r.set(e, r);
  }
  getPreFocusMemory(e) {
    return this.#r.get(e);
  }
  clearPreFocusMemory(e) {
    this.#r.delete(e);
  }
}
class af {
  #e = !1;
  #t = null;
  #r = of.getInstance();
  #n = [];
  #s;
  constructor(e) {
    this.#s = e;
  }
  get paused() {
    return this.#e;
  }
  pause() {
    this.#e = !0;
  }
  resume() {
    this.#e = !1;
  }
  #o() {
    for (const e of this.#n)
      e();
    this.#n = [];
  }
  mount(e) {
    this.#t && this.unmount(), this.#t = e, this.#r.register(this), this.#u(), this.#i();
  }
  unmount() {
    this.#t && (this.#o(), this.#a(), this.#r.unregister(this), this.#r.clearPreFocusMemory(this), this.#t = null);
  }
  #i() {
    if (!this.#t) return;
    const e = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: !1, cancelable: !0 });
    this.#s.onOpenAutoFocus.current(e), e.defaultPrevented || requestAnimationFrame(() => {
      if (!this.#t) return;
      const r = this.#c();
      r ? (r.focus(), this.#r.setFocusMemory(this, r)) : this.#t.focus();
    });
  }
  #a() {
    const e = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: !1, cancelable: !0 });
    if (this.#s.onCloseAutoFocus.current?.(e), !e.defaultPrevented) {
      const r = this.#r.getPreFocusMemory(this);
      if (r && document.contains(r))
        try {
          r.focus();
        } catch {
          document.body.focus();
        }
    }
  }
  #u() {
    if (!this.#t || !this.#s.trap.current) return;
    const e = this.#t, r = e.ownerDocument, n = (i) => {
      if (this.#e || !this.#r.isActiveScope(this)) return;
      const a = i.target;
      if (!a) return;
      if (e.contains(a))
        this.#r.setFocusMemory(this, a);
      else {
        const u = this.#r.getFocusMemory(this);
        if (u && e.contains(u) && oA(u))
          i.preventDefault(), u.focus();
        else {
          const c = this.#c(), f = this.#d()[0];
          (c || f || e).focus();
        }
      }
    }, s = (i) => {
      if (!this.#s.loop || this.#e || i.key !== "Tab" || !this.#r.isActiveScope(this)) return;
      const a = this.#l();
      if (a.length === 0) return;
      const l = a[0], u = a[a.length - 1];
      !i.shiftKey && r.activeElement === u ? (i.preventDefault(), l.focus()) : i.shiftKey && r.activeElement === l && (i.preventDefault(), u.focus());
    };
    this.#n.push(Ye(r, "focusin", n, { capture: !0 }), Ye(e, "keydown", s));
    const o = new MutationObserver(() => {
      const i = this.#r.getFocusMemory(this);
      if (i && !e.contains(i)) {
        const a = this.#c(), l = this.#d()[0], u = a || l;
        u ? (u.focus(), this.#r.setFocusMemory(this, u)) : e.focus();
      }
    });
    o.observe(e, { childList: !0, subtree: !0 }), this.#n.push(() => o.disconnect());
  }
  #l() {
    return this.#t ? tA(this.#t, { includeContainer: !1, getShadowRoot: !0 }) : [];
  }
  #c() {
    return this.#l()[0] || null;
  }
  #d() {
    return this.#t ? rA(this.#t, { includeContainer: !1, getShadowRoot: !0 }) : [];
  }
  static use(e) {
    let r = null;
    return Fe([() => e.ref.current, () => e.enabled.current], ([n, s]) => {
      n && s ? (r || (r = new af(e)), r.mount(n)) : r && (r.unmount(), r = null);
    }), Ys(() => {
      r?.unmount();
    }), {
      get props() {
        return { tabindex: -1 };
      }
    };
  }
}
function lf(t, e) {
  W(e, !0);
  let r = v(e, "enabled", 7, !1), n = v(e, "trapFocus", 7, !1), s = v(e, "loop", 7, !1), o = v(e, "onCloseAutoFocus", 7, _e), i = v(e, "onOpenAutoFocus", 7, _e), a = v(e, "focusScope", 7), l = v(e, "ref", 7);
  const u = af.use({
    enabled: z(() => r()),
    trap: z(() => n()),
    loop: s(),
    onCloseAutoFocus: z(() => o()),
    onOpenAutoFocus: z(() => i()),
    ref: l()
  });
  var c = {
    get enabled() {
      return r();
    },
    set enabled(_ = !1) {
      r(_), m();
    },
    get trapFocus() {
      return n();
    },
    set trapFocus(_ = !1) {
      n(_), m();
    },
    get loop() {
      return s();
    },
    set loop(_ = !1) {
      s(_), m();
    },
    get onCloseAutoFocus() {
      return o();
    },
    set onCloseAutoFocus(_ = _e) {
      o(_), m();
    },
    get onOpenAutoFocus() {
      return i();
    },
    set onOpenAutoFocus(_ = _e) {
      i(_), m();
    },
    get focusScope() {
      return a();
    },
    set focusScope(_) {
      a(_), m();
    },
    get ref() {
      return l();
    },
    set ref(_) {
      l(_), m();
    }
  }, f = M(), g = D(f);
  return te(g, () => a() ?? he, () => ({ props: u.props })), A(t, f), H(c);
}
K(
  lf,
  {
    enabled: {},
    trapFocus: {},
    loop: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    focusScope: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsTextSelectionLayers ??= /* @__PURE__ */ new Map();
class uf {
  static create(e) {
    return new uf(e);
  }
  opts;
  domContext;
  #e = _e;
  constructor(e) {
    this.opts = e, this.domContext = new Fn(e.ref);
    let r = _e;
    Fe(() => this.opts.enabled.current, (n) => (n && (globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled), r(), r = this.#t()), () => {
      r(), this.#n(), globalThis.bitsTextSelectionLayers.delete(this);
    }));
  }
  #t() {
    return Ts(Ye(this.domContext.getDocument(), "pointerdown", this.#r), Ye(this.domContext.getDocument(), "pointerup", xb(this.#n, this.opts.onPointerUp.current)));
  }
  #r = (e) => {
    const r = this.opts.ref.current, n = e.target;
    !Cn(r) || !Cn(n) || !this.opts.enabled.current || !_A(this) || !m$(r, n) || (this.opts.onPointerDown.current(e), !e.defaultPrevented && (this.#e = bA(r, this.domContext.getDocument().body)));
  };
  #n = () => {
    this.#e(), this.#e = _e;
  };
}
const np = (t) => t.style.userSelect || t.style.webkitUserSelect;
function bA(t, e) {
  const r = np(e), n = np(t);
  return Hi(e, "none"), Hi(t, "text"), () => {
    Hi(e, r), Hi(t, n);
  };
}
function Hi(t, e) {
  t.style.userSelect = e, t.style.webkitUserSelect = e;
}
function _A(t) {
  const e = [...globalThis.bitsTextSelectionLayers];
  if (!e.length) return !1;
  const r = e.at(-1);
  return r ? r[0] === t : !1;
}
function cf(t, e) {
  W(e, !0);
  let r = v(e, "preventOverflowTextSelection", 7, !0), n = v(e, "onPointerDown", 7, _e), s = v(e, "onPointerUp", 7, _e), o = v(e, "id", 7), i = v(e, "children", 7), a = v(e, "enabled", 7), l = v(e, "ref", 7);
  uf.create({
    id: z(() => o()),
    onPointerDown: z(() => n()),
    onPointerUp: z(() => s()),
    enabled: z(() => a() && r()),
    ref: l()
  });
  var u = {
    get preventOverflowTextSelection() {
      return r();
    },
    set preventOverflowTextSelection(g = !0) {
      r(g), m();
    },
    get onPointerDown() {
      return n();
    },
    set onPointerDown(g = _e) {
      n(g), m();
    },
    get onPointerUp() {
      return s();
    },
    set onPointerUp(g = _e) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g) {
      o(g), m();
    },
    get children() {
      return i();
    },
    set children(g) {
      i(g), m();
    },
    get enabled() {
      return a();
    },
    set enabled(g) {
      a(g), m();
    },
    get ref() {
      return l();
    },
    set ref(g) {
      l(g), m();
    }
  }, c = M(), f = D(c);
  return te(f, () => i() ?? he), A(t, c), H(u);
}
K(
  cf,
  {
    preventOverflowTextSelection: {},
    onPointerDown: {},
    onPointerUp: {},
    id: {},
    children: {},
    enabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsIdCounter ??= { current: 0 };
function En(t = "bits") {
  return globalThis.bitsIdCounter.current++, `${t}-${globalThis.bitsIdCounter.current}`;
}
class wA {
  #e;
  #t = 0;
  #r = /* @__PURE__ */ xe();
  #n;
  constructor(e) {
    this.#e = e;
  }
  #s() {
    this.#t -= 1, this.#n && this.#t <= 0 && (this.#n(), q(this.#r, void 0), this.#n = void 0);
  }
  get(...e) {
    return this.#t += 1, d(this.#r) === void 0 && (this.#n = Fv(() => {
      q(this.#r, this.#e(...e), !0);
    })), Xe(() => () => {
      this.#s();
    }), d(this.#r);
  }
}
const Ha = new Ed();
let Gi = /* @__PURE__ */ xe(null), Ru = null, Xo = null, Jo = !1;
const sp = z(() => {
  for (const t of Ha.values())
    if (t) return !0;
  return !1;
});
let Vu = null;
const SA = new wA(() => {
  function t() {
    document.body.setAttribute("style", d(Gi) ?? ""), document.body.style.removeProperty("--scrollbar-width"), Rc && Ru?.(), q(Gi, null);
  }
  function e() {
    Xo !== null && (window.clearTimeout(Xo), Xo = null);
  }
  function r(s, o) {
    e(), Jo = !0, Vu = Date.now();
    const i = Vu, a = () => {
      Xo = null, Vu === i && (Xb(Ha) ? Jo = !1 : (Jo = !1, o()));
    }, l = s === null ? 24 : s;
    Xo = window.setTimeout(a, l);
  }
  function n() {
    d(Gi) === null && Ha.size === 0 && !Jo && q(Gi, document.body.getAttribute("style"), !0);
  }
  return Fe(() => sp.current, () => {
    if (!sp.current) return;
    n(), Jo = !1;
    const s = getComputedStyle(document.documentElement), o = getComputedStyle(document.body), i = s.scrollbarGutter?.includes("stable") || o.scrollbarGutter?.includes("stable"), a = window.innerWidth - document.documentElement.clientWidth, u = {
      padding: Number.parseInt(o.paddingRight ?? "0", 10) + a,
      margin: Number.parseInt(o.marginRight ?? "0", 10)
    };
    a > 0 && !i && (document.body.style.paddingRight = `${u.padding}px`, document.body.style.marginRight = `${u.margin}px`, document.body.style.setProperty("--scrollbar-width", `${a}px`)), document.body.style.overflow = "hidden", Rc && (Ru = Ye(
      document,
      "touchmove",
      (c) => {
        c.target === document.documentElement && (c.touches.length > 1 || c.preventDefault());
      },
      { passive: !1 }
    )), Jt(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }), Ys(() => () => {
    Ru?.();
  }), {
    get lockMap() {
      return Ha;
    },
    resetBodyStyle: t,
    scheduleCleanupIfNoNewLocks: r,
    cancelPendingCleanup: e,
    ensureInitialStyleCaptured: n
  };
});
class xA {
  #e = En();
  #t;
  #r = () => null;
  #n;
  locked;
  constructor(e, r = () => null) {
    this.#t = e, this.#r = r, this.#n = SA.get(), this.#n && (this.#n.cancelPendingCleanup(), this.#n.ensureInitialStyleCaptured(), this.#n.lockMap.set(this.#e, this.#t ?? !1), this.locked = z(() => this.#n.lockMap.get(this.#e) ?? !1, (n) => this.#n.lockMap.set(this.#e, n)), Ys(() => {
      if (this.#n.lockMap.delete(this.#e), Xb(this.#n.lockMap)) return;
      const n = this.#r();
      this.#n.scheduleCleanupIfNoNewLocks(n, () => {
        this.#n.resetBodyStyle();
      });
    }));
  }
}
function Xb(t) {
  for (const [e, r] of t)
    if (r) return !0;
  return !1;
}
function _i(t, e) {
  W(e, !0);
  let r = v(e, "preventScroll", 7, !0), n = v(e, "restoreScrollDelay", 7, null);
  r() && new xA(r(), () => n());
  var s = {
    get preventScroll() {
      return r();
    },
    set preventScroll(o = !0) {
      r(o), m();
    },
    get restoreScrollDelay() {
      return n();
    },
    set restoreScrollDelay(o = null) {
      n(o), m();
    }
  };
  return H(s);
}
K(_i, { preventScroll: {}, restoreScrollDelay: {} }, [], [], { mode: "open" });
var PA = /* @__PURE__ */ ne("<div><!></div>");
function Jb(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "forceMount", 7, !1), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "ref", 15, null), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "forceMount",
    "child",
    "children",
    "ref"
  ]);
  const u = Qd.create({
    id: z(() => n()),
    ref: z(() => a(), (p) => a(p))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get forceMount() {
      return s();
    },
    set forceMount(p = !1) {
      s(p), m();
    },
    get child() {
      return o();
    },
    set child(p) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    },
    get ref() {
      return a();
    },
    set ref(p = null) {
      a(p), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (p) => {
      var h = M(), y = D(h);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          {
            let k = /* @__PURE__ */ O(() => ({
              props: Ce(d(c)),
              ...u.snippetProps
            }));
            te(C, o, () => d(k));
          }
          A(P, w);
        }, x = (P) => {
          var w = PA();
          ve(w, (k) => ({ ...k }), [() => Ce(d(c))]);
          var C = ge(w);
          te(C, () => i() ?? he, () => u.snippetProps), de(w), A(P, w);
        };
        ue(y, (P) => {
          o() ? P(S) : P(x, !1);
        });
      }
      A(p, h);
    };
    ue(_, (p) => {
      (u.shouldRender || s()) && p(b);
    });
  }
  return A(t, g), H(f);
}
K(Jb, { id: {}, forceMount: {}, child: {}, children: {}, ref: {} }, [], [], { mode: "open" });
var OA = /* @__PURE__ */ ne("<button><!></button>");
function Zb(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = v(e, "disabled", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child",
    "disabled"
  ]);
  const u = Gd.create({
    id: z(() => n()),
    ref: z(() => s(), (h) => s(h)),
    disabled: z(() => !!a())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(h = me(r)) {
      n(h), m();
    },
    get ref() {
      return s();
    },
    set ref(h = null) {
      s(h), m();
    },
    get children() {
      return o();
    },
    set children(h) {
      o(h), m();
    },
    get child() {
      return i();
    },
    set child(h) {
      i(h), m();
    },
    get disabled() {
      return a();
    },
    set disabled(h = !1) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, i, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = OA();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => o() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      i() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(Zb, { id: {}, ref: {}, children: {}, child: {}, disabled: {} }, [], [], { mode: "open" });
var CA = /* @__PURE__ */ ne("<div><!></div>");
function Qb(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "ref"
  ]);
  const l = Jd.create({
    id: z(() => n()),
    ref: z(() => i(), (p) => i(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    },
    get child() {
      return o();
    },
    set child(p) {
      o(p), m();
    },
    get ref() {
      return i();
    },
    set ref(p = null) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, o, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = CA();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => s() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      o() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Qb, { id: {}, children: {}, child: {}, ref: {} }, [], [], { mode: "open" });
function e_(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "defaultPortalTo", 7), s = v(e, "defaultLocale", 7);
  R$({
    defaultPortalTo: z(() => n()),
    defaultLocale: z(() => s())
  });
  var o = {
    get children() {
      return r();
    },
    set children(l) {
      r(l), m();
    },
    get defaultPortalTo() {
      return n();
    },
    set defaultPortalTo(l) {
      n(l), m();
    },
    get defaultLocale() {
      return s();
    },
    set defaultLocale(l) {
      s(l), m();
    }
  }, i = M(), a = D(i);
  return te(a, () => r() ?? he), A(t, i), H(o);
}
K(e_, { children: {}, defaultPortalTo: {}, defaultLocale: {} }, [], [], { mode: "open" });
function Lu(t, e) {
  return t - e * Math.floor(t / e);
}
const t_ = 1721426;
function Yi(t, e, r, n) {
  e = df(t, e);
  let s = e - 1, o = -2;
  return r <= 2 ? o = 0 : Ga(e) && (o = -1), t_ - 1 + 365 * s + Math.floor(s / 4) - Math.floor(s / 100) + Math.floor(s / 400) + Math.floor((367 * r - 362) / 12 + o + n);
}
function Ga(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function df(t, e) {
  return t === "BC" ? 1 - e : e;
}
function kA(t) {
  let e = "AD";
  return t <= 0 && (e = "BC", t = 1 - t), [
    e,
    t
  ];
}
const $A = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class _o {
  fromJulianDay(e) {
    let r = e, n = r - t_, s = Math.floor(n / 146097), o = Lu(n, 146097), i = Math.floor(o / 36524), a = Lu(o, 36524), l = Math.floor(a / 1461), u = Lu(a, 1461), c = Math.floor(u / 365), f = s * 400 + i * 100 + l * 4 + c + (i !== 4 && c !== 4 ? 1 : 0), [g, _] = kA(f), b = r - Yi(g, _, 1, 1), p = 2;
    r < Yi(g, _, 3, 1) ? p = 0 : Ga(_) && (p = 1);
    let h = Math.floor(((b + p) * 12 + 373) / 367), y = r - Yi(g, _, h, 1) + 1;
    return new rs(g, _, h, y);
  }
  toJulianDay(e) {
    return Yi(e.era, e.year, e.month, e.day);
  }
  getDaysInMonth(e) {
    return $A[Ga(e.year) ? "leapyear" : "standard"][e.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(e) {
    return 12;
  }
  getDaysInYear(e) {
    return Ga(e.year) ? 366 : 365;
  }
  getMaximumMonthsInYear() {
    return 12;
  }
  getMaximumDaysInMonth() {
    return 31;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(e) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(e) {
    return e.era === "BC";
  }
  balanceDate(e) {
    e.year <= 0 && (e.era = e.era === "BC" ? "AD" : "BC", e.year = 1 - e.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const AA = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function bt(t, e) {
  return e = fr(e, t.calendar), t.era === e.era && t.year === e.year && t.month === e.month && t.day === e.day;
}
function Io(t, e) {
  return e = fr(e, t.calendar), t = jc(t), e = jc(e), t.era === e.era && t.year === e.year && t.month === e.month;
}
function r_(t, e) {
  return n_(t.calendar, e.calendar) && Io(t, e);
}
function n_(t, e) {
  var r, n, s, o;
  return (o = (s = (r = t.isEqual) === null || r === void 0 ? void 0 : r.call(t, e)) !== null && s !== void 0 ? s : (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && o !== void 0 ? o : t.identifier === e.identifier;
}
function s_(t, e) {
  return bt(t, TA(e));
}
function o_(t, e, r) {
  let n = t.calendar.toJulianDay(t), s = NA(e), o = Math.ceil(n + 1 - s) % 7;
  return o < 0 && (o += 7), o;
}
function EA(t) {
  return Zr(Date.now(), t);
}
function TA(t) {
  return VA(EA(t));
}
function i_(t, e) {
  return t.calendar.toJulianDay(t) - e.calendar.toJulianDay(e);
}
function DA(t, e) {
  return op(t) - op(e);
}
function op(t) {
  return t.hour * 36e5 + t.minute * 6e4 + t.second * 1e3 + t.millisecond;
}
let ju = null;
function ft() {
  return ju == null && (ju = new Intl.DateTimeFormat().resolvedOptions().timeZone), ju;
}
function jc(t) {
  return t.subtract({
    days: t.day - 1
  });
}
function MA(t) {
  return t.add({
    days: t.calendar.getDaysInMonth(t) - t.day
  });
}
const ip = /* @__PURE__ */ new Map(), Bu = /* @__PURE__ */ new Map();
function IA(t) {
  if (Intl.Locale) {
    let r = ip.get(t);
    return r || (r = new Intl.Locale(t).maximize().region, r && ip.set(t, r)), r;
  }
  let e = t.split("-")[1];
  return e === "u" ? void 0 : e;
}
function NA(t) {
  let e = Bu.get(t);
  if (!e) {
    if (Intl.Locale) {
      let n = new Intl.Locale(t);
      if ("getWeekInfo" in n && (e = n.getWeekInfo(), e))
        return Bu.set(t, e), e.firstDay;
    }
    let r = IA(t);
    if (t.includes("-fw-")) {
      let n = t.split("-fw-")[1].split("-")[0];
      n === "mon" ? e = {
        firstDay: 1
      } : n === "tue" ? e = {
        firstDay: 2
      } : n === "wed" ? e = {
        firstDay: 3
      } : n === "thu" ? e = {
        firstDay: 4
      } : n === "fri" ? e = {
        firstDay: 5
      } : n === "sat" ? e = {
        firstDay: 6
      } : e = {
        firstDay: 0
      };
    } else t.includes("-ca-iso8601") ? e = {
      firstDay: 1
    } : e = {
      firstDay: r && AA[r] || 0
    };
    Bu.set(t, e);
  }
  return e.firstDay;
}
function es(t) {
  t = fr(t, new _o());
  let e = df(t.era, t.year);
  return a_(e, t.month, t.day, t.hour, t.minute, t.second, t.millisecond);
}
function a_(t, e, r, n, s, o, i) {
  let a = /* @__PURE__ */ new Date();
  return a.setUTCHours(n, s, o, i), a.setUTCFullYear(t, e - 1, r), a.getTime();
}
function wi(t, e) {
  if (e === "UTC") return 0;
  if (t > 0 && e === ft()) return new Date(t).getTimezoneOffset() * -6e4;
  let { year: r, month: n, day: s, hour: o, minute: i, second: a } = l_(t, e);
  return a_(r, n, s, o, i, a, 0) - Math.floor(t / 1e3) * 1e3;
}
const ap = /* @__PURE__ */ new Map();
function l_(t, e) {
  let r = ap.get(e);
  r || (r = new Intl.DateTimeFormat("en-US", {
    timeZone: e,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), ap.set(e, r));
  let n = r.formatToParts(new Date(t)), s = {};
  for (let o of n) o.type !== "literal" && (s[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: s.era === "BC" || s.era === "B" ? -s.year + 1 : +s.year,
    month: +s.month,
    day: +s.day,
    hour: s.hour === "24" ? 0 : +s.hour,
    minute: +s.minute,
    second: +s.second
  };
}
const dl = 864e5;
function FA(t, e) {
  let r = es(t), n = r - wi(r - dl, e), s = r - wi(r + dl, e);
  return u_(t, e, n, s);
}
function u_(t, e, r, n) {
  return (r === n ? [
    r
  ] : [
    r,
    n
  ]).filter((o) => RA(t, e, o));
}
function RA(t, e, r) {
  let n = l_(r, e);
  return t.year === n.year && t.month === n.month && t.day === n.day && t.hour === n.hour && t.minute === n.minute && t.second === n.second;
}
function Gr(t, e, r = "compatible") {
  let n = ts(t);
  if (e === "UTC") return es(n);
  if (e === ft() && r === "compatible") {
    n = fr(n, new _o());
    let l = /* @__PURE__ */ new Date(), u = df(n.era, n.year);
    return l.setFullYear(u, n.month - 1, n.day), l.setHours(n.hour, n.minute, n.second, n.millisecond), l.getTime();
  }
  let s = es(n), o = wi(s - dl, e), i = wi(s + dl, e), a = u_(n, e, s - o, s - i);
  if (a.length === 1) return a[0];
  if (a.length > 1) switch (r) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return a[0];
    case "later":
      return a[a.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (r) {
    case "earlier":
      return Math.min(s - o, s - i);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(s - o, s - i);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function c_(t, e, r = "compatible") {
  return new Date(Gr(t, e, r));
}
function Zr(t, e) {
  let r = wi(t, e), n = new Date(t + r), s = n.getUTCFullYear(), o = n.getUTCMonth() + 1, i = n.getUTCDate(), a = n.getUTCHours(), l = n.getUTCMinutes(), u = n.getUTCSeconds(), c = n.getUTCMilliseconds();
  return new on(s < 1 ? "BC" : "AD", s < 1 ? -s + 1 : s, o, i, e, r, a, l, u, c);
}
function VA(t) {
  return new rs(t.calendar, t.era, t.year, t.month, t.day);
}
function ts(t, e) {
  let r = 0, n = 0, s = 0, o = 0;
  if ("timeZone" in t) ({ hour: r, minute: n, second: s, millisecond: o } = t);
  else if ("hour" in t && !e) return t;
  return e && ({ hour: r, minute: n, second: s, millisecond: o } = e), new Tn(t.calendar, t.era, t.year, t.month, t.day, r, n, s, o);
}
function fr(t, e) {
  if (n_(t.calendar, e)) return t;
  let r = e.fromJulianDay(t.calendar.toJulianDay(t)), n = t.copy();
  return n.calendar = e, n.era = r.era, n.year = r.year, n.month = r.month, n.day = r.day, js(n), n;
}
function LA(t, e, r) {
  if (t instanceof on)
    return t.timeZone === e ? t : BA(t, e);
  let n = Gr(t, e, r);
  return Zr(n, e);
}
function jA(t) {
  let e = es(t) - t.offset;
  return new Date(e);
}
function BA(t, e) {
  let r = es(t) - t.offset;
  return fr(Zr(r, e), t.calendar);
}
const Zo = 36e5;
function su(t, e) {
  let r = t.copy(), n = "hour" in r ? KA(r, e) : 0;
  Bc(r, e.years || 0), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, t), r.month += e.months || 0, zc(r), d_(r), r.day += (e.weeks || 0) * 7, r.day += e.days || 0, r.day += n, zA(r), r.calendar.balanceDate && r.calendar.balanceDate(r), r.year < 1 && (r.year = 1, r.month = 1, r.day = 1);
  let s = r.calendar.getYearsInEra(r);
  if (r.year > s) {
    var o, i;
    let l = (o = (i = r.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(i, r);
    r.year = s, r.month = l ? 1 : r.calendar.getMonthsInYear(r), r.day = l ? 1 : r.calendar.getDaysInMonth(r);
  }
  r.month < 1 && (r.month = 1, r.day = 1);
  let a = r.calendar.getMonthsInYear(r);
  return r.month > a && (r.month = a, r.day = r.calendar.getDaysInMonth(r)), r.day = Math.max(1, Math.min(r.calendar.getDaysInMonth(r), r.day)), r;
}
function Bc(t, e) {
  var r, n;
  !((r = (n = t.calendar).isInverseEra) === null || r === void 0) && r.call(n, t) && (e = -e), t.year += e;
}
function zc(t) {
  for (; t.month < 1; )
    Bc(t, -1), t.month += t.calendar.getMonthsInYear(t);
  let e = 0;
  for (; t.month > (e = t.calendar.getMonthsInYear(t)); )
    t.month -= e, Bc(t, 1);
}
function zA(t) {
  for (; t.day < 1; )
    t.month--, zc(t), t.day += t.calendar.getDaysInMonth(t);
  for (; t.day > t.calendar.getDaysInMonth(t); )
    t.day -= t.calendar.getDaysInMonth(t), t.month++, zc(t);
}
function d_(t) {
  t.month = Math.max(1, Math.min(t.calendar.getMonthsInYear(t), t.month)), t.day = Math.max(1, Math.min(t.calendar.getDaysInMonth(t), t.day));
}
function js(t) {
  t.calendar.constrainDate && t.calendar.constrainDate(t), t.year = Math.max(1, Math.min(t.calendar.getYearsInEra(t), t.year)), d_(t);
}
function f_(t) {
  let e = {};
  for (let r in t) typeof t[r] == "number" && (e[r] = -t[r]);
  return e;
}
function h_(t, e) {
  return su(t, f_(e));
}
function ff(t, e) {
  let r = t.copy();
  return e.era != null && (r.era = e.era), e.year != null && (r.year = e.year), e.month != null && (r.month = e.month), e.day != null && (r.day = e.day), js(r), r;
}
function fl(t, e) {
  let r = t.copy();
  return e.hour != null && (r.hour = e.hour), e.minute != null && (r.minute = e.minute), e.second != null && (r.second = e.second), e.millisecond != null && (r.millisecond = e.millisecond), UA(r), r;
}
function qA(t) {
  t.second += Math.floor(t.millisecond / 1e3), t.millisecond = Xi(t.millisecond, 1e3), t.minute += Math.floor(t.second / 60), t.second = Xi(t.second, 60), t.hour += Math.floor(t.minute / 60), t.minute = Xi(t.minute, 60);
  let e = Math.floor(t.hour / 24);
  return t.hour = Xi(t.hour, 24), e;
}
function UA(t) {
  t.millisecond = Math.max(0, Math.min(t.millisecond, 1e3)), t.second = Math.max(0, Math.min(t.second, 59)), t.minute = Math.max(0, Math.min(t.minute, 59)), t.hour = Math.max(0, Math.min(t.hour, 23));
}
function Xi(t, e) {
  let r = t % e;
  return r < 0 && (r += e), r;
}
function KA(t, e) {
  return t.hour += e.hours || 0, t.minute += e.minutes || 0, t.second += e.seconds || 0, t.millisecond += e.milliseconds || 0, qA(t);
}
function hf(t, e, r, n) {
  let s = t.copy();
  switch (e) {
    case "era": {
      let a = t.calendar.getEras(), l = a.indexOf(t.era);
      if (l < 0) throw new Error("Invalid era: " + t.era);
      l = wn(l, r, 0, a.length - 1, n?.round), s.era = a[l], js(s);
      break;
    }
    case "year":
      var o, i;
      !((o = (i = s.calendar).isInverseEra) === null || o === void 0) && o.call(i, s) && (r = -r), s.year = wn(t.year, r, -1 / 0, 9999, n?.round), s.year === -1 / 0 && (s.year = 1), s.calendar.balanceYearMonth && s.calendar.balanceYearMonth(s, t);
      break;
    case "month":
      s.month = wn(t.month, r, 1, t.calendar.getMonthsInYear(t), n?.round);
      break;
    case "day":
      s.day = wn(t.day, r, 1, t.calendar.getDaysInMonth(t), n?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return t.calendar.balanceDate && t.calendar.balanceDate(s), js(s), s;
}
function g_(t, e, r, n) {
  let s = t.copy();
  switch (e) {
    case "hour": {
      let o = t.hour, i = 0, a = 23;
      if (n?.hourCycle === 12) {
        let l = o >= 12;
        i = l ? 12 : 0, a = l ? 23 : 11;
      }
      s.hour = wn(o, r, i, a, n?.round);
      break;
    }
    case "minute":
      s.minute = wn(t.minute, r, 0, 59, n?.round);
      break;
    case "second":
      s.second = wn(t.second, r, 0, 59, n?.round);
      break;
    case "millisecond":
      s.millisecond = wn(t.millisecond, r, 0, 999, n?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return s;
}
function wn(t, e, r, n, s = !1) {
  if (s) {
    t += Math.sign(e), t < r && (t = n);
    let o = Math.abs(e);
    e > 0 ? t = Math.ceil(t / o) * o : t = Math.floor(t / o) * o, t > n && (t = r);
  } else
    t += e, t < r ? t = n - (r - t - 1) : t > n && (t = r + (t - n - 1));
  return t;
}
function p_(t, e) {
  let r;
  if (e.years != null && e.years !== 0 || e.months != null && e.months !== 0 || e.weeks != null && e.weeks !== 0 || e.days != null && e.days !== 0) {
    let s = su(ts(t), {
      years: e.years,
      months: e.months,
      weeks: e.weeks,
      days: e.days
    });
    r = Gr(s, t.timeZone);
  } else
    r = es(t) - t.offset;
  r += e.milliseconds || 0, r += (e.seconds || 0) * 1e3, r += (e.minutes || 0) * 6e4, r += (e.hours || 0) * 36e5;
  let n = Zr(r, t.timeZone);
  return fr(n, t.calendar);
}
function WA(t, e) {
  return p_(t, f_(e));
}
function HA(t, e, r, n) {
  switch (e) {
    case "hour": {
      let s = 0, o = 23;
      if (n?.hourCycle === 12) {
        let b = t.hour >= 12;
        s = b ? 12 : 0, o = b ? 23 : 11;
      }
      let i = ts(t), a = fr(fl(i, {
        hour: s
      }), new _o()), l = [
        Gr(a, t.timeZone, "earlier"),
        Gr(a, t.timeZone, "later")
      ].filter((b) => Zr(b, t.timeZone).day === a.day)[0], u = fr(fl(i, {
        hour: o
      }), new _o()), c = [
        Gr(u, t.timeZone, "earlier"),
        Gr(u, t.timeZone, "later")
      ].filter((b) => Zr(b, t.timeZone).day === u.day).pop(), f = es(t) - t.offset, g = Math.floor(f / Zo), _ = f % Zo;
      return f = wn(g, r, Math.floor(l / Zo), Math.floor(c / Zo), n?.round) * Zo + _, fr(Zr(f, t.timeZone), t.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return g_(t, e, r, n);
    case "era":
    case "year":
    case "month":
    case "day": {
      let s = hf(ts(t), e, r, n), o = Gr(s, t.timeZone);
      return fr(Zr(o, t.timeZone), t.calendar);
    }
    default:
      throw new Error("Unsupported field " + e);
  }
}
function GA(t, e, r) {
  let n = ts(t), s = fl(ff(n, e), e);
  if (s.compare(n) === 0) return t;
  let o = Gr(s, t.timeZone, r);
  return fr(Zr(o, t.timeZone), t.calendar);
}
const YA = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})$/, XA = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/, JA = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?(?::?(\d{2}))?)?\[(.*?)\]$/, m_ = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
function Si(t) {
  let e = t.match(YA);
  if (!e)
    throw m_.test(t) ? new Error(`Invalid ISO 8601 date string: ${t}. Use parseAbsolute() instead.`) : new Error("Invalid ISO 8601 date string: " + t);
  let r = new rs(mt(e[1], 0, 9999), mt(e[2], 1, 12), 1);
  return r.day = mt(e[3], 1, r.calendar.getDaysInMonth(r)), r;
}
function v_(t) {
  let e = t.match(XA);
  if (!e)
    throw m_.test(t) ? new Error(`Invalid ISO 8601 date time string: ${t}. Use parseAbsolute() instead.`) : new Error("Invalid ISO 8601 date time string: " + t);
  let r = mt(e[1], -9999, 9999), n = r < 1 ? "BC" : "AD", s = new Tn(n, r < 1 ? -r + 1 : r, mt(e[2], 1, 12), 1, e[4] ? mt(e[4], 0, 23) : 0, e[5] ? mt(e[5], 0, 59) : 0, e[6] ? mt(e[6], 0, 59) : 0, e[7] ? mt(e[7], 0, 1 / 0) * 1e3 : 0);
  return s.day = mt(e[3], 0, s.calendar.getDaysInMonth(s)), s;
}
function y_(t, e) {
  let r = t.match(JA);
  if (!r) throw new Error("Invalid ISO 8601 date time string: " + t);
  let n = mt(r[1], -9999, 9999), s = n < 1 ? "BC" : "AD", o = new on(s, n < 1 ? -n + 1 : n, mt(r[2], 1, 12), 1, r[11], 0, r[4] ? mt(r[4], 0, 23) : 0, r[5] ? mt(r[5], 0, 59) : 0, r[6] ? mt(r[6], 0, 59) : 0, r[7] ? mt(r[7], 0, 1 / 0) * 1e3 : 0);
  o.day = mt(r[3], 0, o.calendar.getDaysInMonth(o));
  let i = ts(o), a;
  if (r[8]) {
    let c = mt(r[8], -23, 23);
    var l, u;
    if (o.offset = Math.sign(c) * (Math.abs(c) * 36e5 + mt((l = r[9]) !== null && l !== void 0 ? l : "0", 0, 59) * 6e4 + mt((u = r[10]) !== null && u !== void 0 ? u : "0", 0, 59) * 1e3), a = es(o) - o.offset, !FA(i, o.timeZone).includes(a)) throw new Error(`Offset ${__(o.offset)} is invalid for ${gf(o)} in ${o.timeZone}`);
  } else
    a = Gr(ts(i), o.timeZone, e);
  return Zr(a, o.timeZone);
}
function mt(t, e, r) {
  let n = Number(t);
  if (n < e || n > r) throw new RangeError(`Value out of range: ${e} <= ${n} <= ${r}`);
  return n;
}
function ZA(t) {
  return `${String(t.hour).padStart(2, "0")}:${String(t.minute).padStart(2, "0")}:${String(t.second).padStart(2, "0")}${t.millisecond ? String(t.millisecond / 1e3).slice(1) : ""}`;
}
function b_(t) {
  let e = fr(t, new _o()), r;
  return e.era === "BC" ? r = e.year === 1 ? "0000" : "-" + String(Math.abs(1 - e.year)).padStart(6, "00") : r = String(e.year).padStart(4, "0"), `${r}-${String(e.month).padStart(2, "0")}-${String(e.day).padStart(2, "0")}`;
}
function gf(t) {
  return `${b_(t)}T${ZA(t)}`;
}
function __(t) {
  let e = Math.sign(t) < 0 ? "-" : "+";
  t = Math.abs(t);
  let r = Math.floor(t / 36e5), n = Math.floor(t % 36e5 / 6e4), s = Math.floor(t % 36e5 % 6e4 / 1e3), o = `${e}${String(r).padStart(2, "0")}:${String(n).padStart(2, "0")}`;
  return s !== 0 && (o += `:${String(s).padStart(2, "0")}`), o;
}
function QA(t) {
  return `${gf(t)}${__(t.offset)}[${t.timeZone}]`;
}
function eE(t, e) {
  if (e.has(t))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function pf(t, e, r) {
  eE(t, e), e.set(t, r);
}
function mf(t) {
  let e = typeof t[0] == "object" ? t.shift() : new _o(), r;
  if (typeof t[0] == "string") r = t.shift();
  else {
    let i = e.getEras();
    r = i[i.length - 1];
  }
  let n = t.shift(), s = t.shift(), o = t.shift();
  return [
    e,
    r,
    n,
    s,
    o
  ];
}
var tE = /* @__PURE__ */ new WeakMap();
class rs {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new rs(this.calendar, this.era, this.year, this.month, this.day) : new rs(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(e) {
    return su(this, e);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(e) {
    return h_(this, e);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return ff(this, e);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    return hf(this, e, r, n);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(e) {
    return c_(this, e);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return b_(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return i_(this, e);
  }
  constructor(...e) {
    pf(this, tE, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = mf(e);
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, js(this);
  }
}
var rE = /* @__PURE__ */ new WeakMap();
class Tn {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Tn(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Tn(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(e) {
    return su(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return h_(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return ff(fl(this, e), e);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    switch (e) {
      case "era":
      case "year":
      case "month":
      case "day":
        return hf(this, e, r, n);
      default:
        return g_(this, e, r, n);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(e, r) {
    return c_(this, e, r);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return gf(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    let r = i_(this, e);
    return r === 0 ? DA(this, ts(e)) : r;
  }
  constructor(...e) {
    pf(this, rE, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = mf(e);
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, js(this);
  }
}
var nE = /* @__PURE__ */ new WeakMap();
class on {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new on(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new on(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(e) {
    return p_(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return WA(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e, r) {
    return GA(this, e, r);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    return HA(this, e, r, n);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return jA(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return QA(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return this.toDate().getTime() - LA(e, this.timeZone).toDate().getTime();
  }
  constructor(...e) {
    pf(this, nE, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = mf(e), a = e.shift(), l = e.shift();
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, this.timeZone = a, this.offset = l, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, js(this);
  }
}
let zu = /* @__PURE__ */ new Map();
class jt {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(e) {
    return this.formatter.format(e);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(e) {
    return this.formatter.formatToParts(e);
  }
  /** Formats a date range as a string. */
  formatRange(e, r) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(e, r);
    if (r < e) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(e)} â€“ ${this.formatter.format(r)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(e, r) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(e, r);
    if (r < e) throw new RangeError("End date must be >= start date");
    let n = this.formatter.formatToParts(e), s = this.formatter.formatToParts(r);
    return [
      ...n.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " â€“ ",
        source: "shared"
      },
      ...s.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let e = this.formatter.resolvedOptions();
    return iE() && (this.resolvedHourCycle || (this.resolvedHourCycle = aE(e.locale, this.options)), e.hourCycle = this.resolvedHourCycle, e.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), e.calendar === "ethiopic-amete-alem" && (e.calendar = "ethioaa"), e;
  }
  constructor(e, r = {}) {
    this.formatter = w_(e, r), this.options = r;
  }
}
const sE = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function w_(t, e = {}) {
  if (typeof e.hour12 == "boolean" && oE()) {
    e = {
      ...e
    };
    let s = sE[String(e.hour12)][t.split("-")[0]], o = e.hour12 ? "h12" : "h23";
    e.hourCycle = s ?? o, delete e.hour12;
  }
  let r = t + (e ? Object.entries(e).sort((s, o) => s[0] < o[0] ? -1 : 1).join() : "");
  if (zu.has(r)) return zu.get(r);
  let n = new Intl.DateTimeFormat(t, e);
  return zu.set(r, n), n;
}
let qu = null;
function oE() {
  return qu == null && (qu = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), qu;
}
let Uu = null;
function iE() {
  return Uu == null && (Uu = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), Uu;
}
function aE(t, e) {
  if (!e.timeStyle && !e.hour) return;
  t = t.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), t += (t.includes("-u-") ? "" : "-u") + "-nu-latn";
  let r = w_(t, {
    ...e,
    timeZone: void 0
    // use local timezone
  }), n = parseInt(r.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), s = parseInt(r.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (n === 0 && s === 23) return "h23";
  if (n === 24 && s === 23) return "h24";
  if (n === 0 && s === 11) return "h11";
  if (n === 12 && s === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function lE(t) {
  if (!Li || !t)
    return null;
  let e = t.querySelector("[data-bits-announcer]");
  const r = (s) => {
    const o = t.createElement("div");
    return o.role = "log", o.ariaLive = s, o.setAttribute("aria-relevant", "additions"), o;
  };
  if (!Cn(e)) {
    const s = t.createElement("div");
    s.style.cssText = Cb, s.setAttribute("data-bits-announcer", ""), s.appendChild(r("assertive")), s.appendChild(r("polite")), e = s, t.body.insertBefore(e, t.body.firstChild);
  }
  return {
    getLog: (s) => {
      if (!Cn(e))
        return null;
      const o = e.querySelector(`[aria-live="${s}"]`);
      return Cn(o) ? o : null;
    }
  };
}
function hl(t) {
  const e = lE(t);
  function r(n, s = "assertive", o = 7500) {
    if (!e || !Li || !t)
      return;
    const i = e.getLog(s), a = t.createElement("div");
    return typeof n == "number" ? n = n.toString() : n === null ? n = "Empty" : n = n.trim(), a.innerText = n, s === "assertive" ? i?.replaceChildren(a) : i?.appendChild(a), setTimeout(() => {
      a.remove();
    }, o);
  }
  return {
    announce: r
  };
}
const uE = {
  defaultValue: void 0,
  granularity: "day"
};
function S_(t) {
  const e = { ...uE, ...t }, { defaultValue: r, granularity: n, minValue: s, maxValue: o } = e;
  if (Array.isArray(r) && r.length)
    return r[r.length - 1];
  if (r && !Array.isArray(r))
    return r;
  {
    let i = /* @__PURE__ */ new Date();
    s && i < s.toDate(ft()) ? i = s.toDate(ft()) : o && i > o.toDate(ft()) && (i = o.toDate(ft()));
    const a = i.getFullYear(), l = i.getMonth() + 1, u = i.getDate();
    return ["hour", "minute", "second"].includes(n ?? "day") ? new Tn(a, l, u, 0, 0, 0) : new rs(a, l, u);
  }
}
function x_(t, e) {
  let r;
  return e instanceof on ? r = y_(t) : e instanceof Tn ? r = v_(t) : r = Si(t), r.calendar !== e.calendar ? fr(r, e.calendar) : r;
}
function _r(t, e = ft()) {
  return t instanceof on ? t.toDate() : t.toDate(e);
}
function P_(t) {
  if (t instanceof rs)
    return "date";
  if (t instanceof Tn)
    return "datetime";
  if (t instanceof on)
    return "zoneddatetime";
  throw new Error("Unknown date type");
}
function cE(t, e) {
  switch (e) {
    case "date":
      return Si(t);
    case "datetime":
      return v_(t);
    case "zoneddatetime":
      return y_(t);
    default:
      throw new Error(`Unknown date type: ${e}`);
  }
}
function dE(t) {
  return t instanceof Tn;
}
function O_(t) {
  return t instanceof on;
}
function qc(t) {
  return dE(t) || O_(t);
}
function fE(t) {
  if (t instanceof Date) {
    const e = t.getFullYear(), r = t.getMonth() + 1;
    return new Date(e, r, 0).getDate();
  } else
    return t.set({ day: 100 }).day;
}
function Bt(t, e) {
  return t.compare(e) < 0;
}
function C_(t, e) {
  return t.compare(e) > 0;
}
function hE(t, e) {
  return t.compare(e) <= 0;
}
function gE(t, e) {
  return t.compare(e) >= 0;
}
function k_(t, e, r) {
  return gE(t, e) && hE(t, r);
}
function lp(t, e, r) {
  const n = o_(t, r);
  return e > n ? t.subtract({ days: n + 7 - e }) : e === n ? t : t.subtract({ days: n - e });
}
function up(t, e, r) {
  const n = o_(t, r), s = e === 0 ? 6 : e - 1;
  return n === s ? t : n > s ? t.add({ days: 7 - n + s }) : t.add({ days: s - n });
}
function pE(t, e, r, n) {
  if (r === void 0 && n === void 0)
    return !0;
  let s = t.add({ days: 1 });
  if (n?.(s) || r?.(s))
    return !1;
  const o = e;
  for (; s.compare(o) < 0; )
    if (s = s.add({ days: 1 }), n?.(s) || r?.(s))
      return !1;
  return !0;
}
const mE = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function $_(t) {
  let e = t.initialLocale;
  function r(_) {
    e = _;
  }
  function n() {
    return e;
  }
  function s(_, b) {
    return new jt(e, b).format(_);
  }
  function o(_, b = !0) {
    return qc(_) && b ? s(_r(_), {
      dateStyle: "long",
      timeStyle: "long"
    }) : s(_r(_), {
      dateStyle: "long"
    });
  }
  function i(_) {
    if (typeof t.monthFormat.current != "function" && typeof t.yearFormat.current != "function")
      return new jt(e, {
        month: t.monthFormat.current,
        year: t.yearFormat.current
      }).format(_);
    const b = typeof t.monthFormat.current == "function" ? t.monthFormat.current(_.getMonth() + 1) : new jt(e, { month: t.monthFormat.current }).format(_), p = typeof t.yearFormat.current == "function" ? t.yearFormat.current(_.getFullYear()) : new jt(e, { year: t.yearFormat.current }).format(_);
    return `${b} ${p}`;
  }
  function a(_) {
    return new jt(e, { month: "long" }).format(_);
  }
  function l(_) {
    return new jt(e, { year: "numeric" }).format(_);
  }
  function u(_, b) {
    return O_(_) ? new jt(e, {
      ...b,
      timeZone: _.timeZone
    }).formatToParts(_r(_)) : new jt(e, b).formatToParts(_r(_));
  }
  function c(_, b = "narrow") {
    return new jt(e, { weekday: b }).format(_);
  }
  function f(_, b = void 0) {
    return new jt(e, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: b === 24 ? "h23" : void 0
    }).formatToParts(_).find((y) => y.type === "dayPeriod")?.value === "PM" ? "PM" : "AM";
  }
  function g(_, b, p = {}) {
    const h = { ...mE, ...p }, S = u(_, h).find((x) => x.type === b);
    return S ? S.value : "";
  }
  return {
    setLocale: r,
    getLocale: n,
    fullMonth: a,
    fullYear: l,
    fullMonthAndYear: i,
    toParts: u,
    custom: s,
    part: g,
    dayPeriod: f,
    selectedDate: o,
    dayOfWeek: c
  };
}
function vE(t) {
  return !(!Cn(t) || !t.hasAttribute("data-bits-day"));
}
function cp(t, e) {
  const r = [];
  let n = t.add({ days: 1 });
  const s = e;
  for (; n.compare(s) < 0; )
    r.push(n), n = n.add({ days: 1 });
  return r;
}
function Ku(t) {
  const { dateObj: e, weekStartsOn: r, fixedWeeks: n, locale: s } = t, o = fE(e), i = Array.from({ length: o }, (h, y) => e.set({ day: y + 1 })), a = jc(e), l = MA(e), u = r !== void 0 ? lp(a, r, "en-US") : lp(a, 0, s), c = r !== void 0 ? up(l, r, "en-US") : up(l, 0, s), f = cp(u.subtract({ days: 1 }), a), g = cp(l, c.add({ days: 1 })), _ = f.length + i.length + g.length;
  if (n && _ < 42) {
    const h = 42 - _;
    let y = g[g.length - 1];
    y || (y = e.add({ months: 1 }).set({ day: 1 }));
    let S = h;
    g.length === 0 && (S = h - 1, g.push(y));
    const x = Array.from({ length: S }, (P, w) => {
      const C = w + 1;
      return y.add({ days: C });
    });
    g.push(...x);
  }
  const b = f.concat(i, g), p = iA(b, 7);
  return { value: e, dates: b, weeks: p };
}
function No(t) {
  const { numberOfMonths: e, dateObj: r, ...n } = t, s = [];
  if (!e || e === 1)
    return s.push(Ku({ ...n, dateObj: r })), s;
  s.push(Ku({ ...n, dateObj: r }));
  for (let o = 1; o < e; o++) {
    const i = r.add({ months: o });
    s.push(Ku({ ...n, dateObj: i }));
  }
  return s;
}
function Wu(t) {
  return t ? Array.from(t.querySelectorAll("[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])")).filter((r) => Cn(r)) : [];
}
function dp(t, e) {
  const r = t.getAttribute("data-value");
  r && (e.current = x_(r, e.current));
}
function A_({
  node: t,
  add: e,
  placeholder: r,
  calendarNode: n,
  isPrevButtonDisabled: s,
  isNextButtonDisabled: o,
  months: i,
  numberOfMonths: a
}) {
  const l = Wu(n);
  if (!l.length) return;
  const c = l.indexOf(t) + e;
  if (Wa(c, l)) {
    const f = l[c];
    return dp(f, r), f.focus();
  }
  if (c < 0) {
    if (s) return;
    const f = i[0]?.value;
    if (!f) return;
    r.current = f.subtract({ months: a }), Jt(() => {
      const g = Wu(n);
      if (!g.length) return;
      const _ = g.length - Math.abs(c);
      if (Wa(_, g)) {
        const b = g[_];
        return dp(b, r), b.focus();
      }
    });
  }
  if (c >= l.length) {
    if (o) return;
    const f = i[0]?.value;
    if (!f) return;
    r.current = f.add({ months: a }), Jt(() => {
      const g = Wu(n);
      if (!g.length) return;
      const _ = c - l.length;
      if (Wa(_, g))
        return g[_].focus();
    });
  }
}
const fp = [
  dr,
  Qt,
  cs,
  ds
], hp = [Br, xr];
function E_({ event: t, handleCellClick: e, shiftFocus: r, placeholderValue: n }) {
  const s = t.target;
  if (!vE(s) || !fp.includes(t.key) && !hp.includes(t.key)) return;
  t.preventDefault();
  const o = {
    [dr]: 7,
    [Qt]: -7,
    [cs]: -1,
    [ds]: 1
  };
  if (fp.includes(t.key)) {
    const i = o[t.key];
    i !== void 0 && r(s, i);
  }
  if (hp.includes(t.key)) {
    const i = s.getAttribute("data-value");
    if (!i) return;
    e(t, x_(i, n));
  }
}
function T_({
  months: t,
  setMonths: e,
  numberOfMonths: r,
  pagedNavigation: n,
  weekStartsOn: s,
  locale: o,
  fixedWeeks: i,
  setPlaceholder: a
}) {
  const l = t[0]?.value;
  if (l)
    if (n)
      a(l.add({ months: r }));
    else {
      const u = l.add({ months: 1 }), c = No({
        dateObj: u,
        weekStartsOn: s,
        locale: o,
        fixedWeeks: i,
        numberOfMonths: r
      });
      a(u), e(c);
    }
}
function D_({
  months: t,
  setMonths: e,
  numberOfMonths: r,
  pagedNavigation: n,
  weekStartsOn: s,
  locale: o,
  fixedWeeks: i,
  setPlaceholder: a
}) {
  const l = t[0]?.value;
  if (l)
    if (n)
      a(l.subtract({ months: r }));
    else {
      const u = l.subtract({ months: 1 }), c = No({
        dateObj: u,
        weekStartsOn: s,
        locale: o,
        fixedWeeks: i,
        numberOfMonths: r
      });
      a(u), e(c);
    }
}
function M_({ months: t, formatter: e, weekdayFormat: r }) {
  if (!t.length) return [];
  const s = t[0].weeks[0];
  return s ? s.map((o) => e.dayOfWeek(_r(o), r)) : [];
}
function I_(t) {
  Xe(() => {
    const e = t.weekStartsOn.current, r = t.locale.current, n = t.fixedWeeks.current, s = t.numberOfMonths.current;
    ot(() => {
      const o = t.placeholder.current;
      if (!o) return;
      const i = { weekStartsOn: e, locale: r, fixedWeeks: n, numberOfMonths: s };
      t.setMonths(No({ ...i, dateObj: o }));
    });
  });
}
function yE({ calendarNode: t, label: e, accessibleHeadingId: r }) {
  const n = Ud(t), s = n.createElement("div");
  s.style.cssText = tu({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const o = n.createElement("div");
  return o.textContent = e, o.id = r, o.role = "heading", o.ariaLevel = "2", t.insertBefore(s, t.firstChild), s.appendChild(o), () => {
    const i = n.getElementById(r);
    i && (s.parentElement?.removeChild(s), i.remove());
  };
}
function N_({
  placeholder: t,
  getVisibleMonths: e,
  weekStartsOn: r,
  locale: n,
  fixedWeeks: s,
  numberOfMonths: o,
  setMonths: i
}) {
  Xe(() => {
    t.current, ot(() => {
      if (e().some((l) => Io(l, t.current)))
        return;
      const a = {
        weekStartsOn: r.current,
        locale: n.current,
        fixedWeeks: s.current,
        numberOfMonths: o.current
      };
      i(No({ ...a, dateObj: t.current }));
    });
  });
}
function F_({ maxValue: t, months: e, disabled: r }) {
  if (!t || !e.length) return !1;
  if (r) return !0;
  const n = e[e.length - 1]?.value;
  if (!n) return !1;
  const s = n.add({ months: 1 }).set({ day: 1 });
  return C_(s, t);
}
function R_({ minValue: t, months: e, disabled: r }) {
  if (!t || !e.length) return !1;
  if (r) return !0;
  const n = e[0]?.value;
  if (!n) return !1;
  const s = n.subtract({ months: 1 }).set({ day: 35 });
  return Bt(s, t);
}
function V_({ months: t, locale: e, formatter: r }) {
  if (!t.length) return "";
  if (e !== r.getLocale() && r.setLocale(e), t.length === 1) {
    const c = _r(t[0].value);
    return `${r.fullMonthAndYear(c)}`;
  }
  const n = _r(t[0].value), s = _r(t[t.length - 1].value), o = r.fullMonth(n), i = r.fullMonth(s), a = r.fullYear(n), l = r.fullYear(s);
  return a === l ? `${o} - ${i} ${l}` : `${o} ${a} - ${i} ${l}`;
}
function L_({ fullCalendarLabel: t, id: e, isInvalid: r, disabled: n, readonly: s }) {
  return {
    id: e,
    role: "application",
    "aria-label": t,
    "data-invalid": Re(r),
    "data-disabled": Re(n),
    "data-readonly": Re(s)
  };
}
function bE(t) {
  if (!Li) return;
  const e = Array.from(t.querySelectorAll("[data-bits-day]:not([aria-disabled=true])"));
  if (e.length === 0) return;
  const r = e[0], n = r?.getAttribute("data-value"), s = r?.getAttribute("data-type");
  if (!(!n || !s))
    return cE(n, s);
}
function j_({
  ref: t,
  placeholder: e,
  defaultPlaceholder: r,
  minValue: n,
  maxValue: s,
  isDateDisabled: o
}) {
  function i(a) {
    return !!(o.current(a) || n.current && Bt(a, n.current) || s.current && Bt(s.current, a));
  }
  Fe(() => t.current, () => {
    t.current && e.current && bt(e.current, r) && i(r) && (e.current = bE(t.current) ?? r);
  });
}
function _E(t, e) {
  return !t || !e ? t : qc(t) && qc(e) ? t.set({
    hour: e.hour,
    minute: e.minute,
    millisecond: e.millisecond,
    second: e.second
  }) : t;
}
const B_ = tr({
  component: "calendar",
  parts: [
    "root",
    "grid",
    "cell",
    "next-button",
    "prev-button",
    "day",
    "grid-body",
    "grid-head",
    "grid-row",
    "head-cell",
    "header",
    "heading",
    "month-select",
    "year-select"
  ]
});
function z_(t) {
  const e = (/* @__PURE__ */ new Date()).getFullYear(), r = Math.max(t.placeholderYear, e);
  let n, s;
  if (t.minValue)
    n = t.minValue.year;
  else {
    const i = r - 100;
    n = t.placeholderYear < i ? t.placeholderYear - 10 : i;
  }
  t.maxValue ? s = t.maxValue.year : s = r + 10, n > s && (n = s);
  const o = s - n + 1;
  return Array.from({ length: o }, (i, a) => n + a);
}
const Ut = new ht("Calendar.Root | RangeCalender.Root");
class vf {
  static create(e) {
    return Ut.set(new vf(e));
  }
  opts;
  #e = /* @__PURE__ */ O(() => this.months.map((e) => e.value));
  get visibleMonths() {
    return d(this.#e);
  }
  set visibleMonths(e) {
    q(this.#e, e);
  }
  formatter;
  accessibleHeadingId = En();
  domContext;
  attachment;
  #t = /* @__PURE__ */ xe(Pt([]));
  get months() {
    return d(this.#t);
  }
  set months(e) {
    q(this.#t, e, !0);
  }
  announcer;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.domContext = new Fn(e.ref), this.announcer = hl(null), this.formatter = $_({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    }), this.setMonths = this.setMonths.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.prevYear = this.prevYear.bind(this), this.nextYear = this.nextYear.bind(this), this.setYear = this.setYear.bind(this), this.setMonth = this.setMonth.bind(this), this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this), this.isDateDisabled = this.isDateDisabled.bind(this), this.isDateSelected = this.isDateSelected.bind(this), this.shiftFocus = this.shiftFocus.bind(this), this.handleCellClick = this.handleCellClick.bind(this), this.handleMultipleUpdate = this.handleMultipleUpdate.bind(this), this.handleSingleUpdate = this.handleSingleUpdate.bind(this), this.onkeydown = this.onkeydown.bind(this), this.getBitsAttr = this.getBitsAttr.bind(this), ko(() => {
      this.announcer = hl(this.domContext.getDocument());
    }), this.months = No({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    }), this.#o(), this.#i(), this.#a(), N_({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: (r) => this.months = r
    }), I_({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    }), Fe(() => this.fullCalendarLabel, (r) => {
      const n = this.domContext.getElementById(this.accessibleHeadingId);
      n && (n.textContent = r);
    }), Fe(() => this.opts.value.current, () => {
      const r = this.opts.value.current;
      if (Array.isArray(r) && r.length) {
        const n = r[r.length - 1];
        n && this.opts.placeholder.current !== n && (this.opts.placeholder.current = n);
      } else !Array.isArray(r) && r && this.opts.placeholder.current !== r && (this.opts.placeholder.current = r);
    }), j_({
      placeholder: e.placeholder,
      defaultPlaceholder: e.defaultPlaceholder,
      isDateDisabled: e.isDateDisabled,
      maxValue: e.maxValue,
      minValue: e.minValue,
      ref: e.ref
    });
  }
  setMonths(e) {
    this.months = e;
  }
  #r = /* @__PURE__ */ O(
    /**
     * This derived state holds an array of localized day names for the current
     * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,
     * updating its content when the option changes. Using this state to render the
     * calendar's days of the week is strongly recommended, as it guarantees that
     * the days are correctly formatted for the current locale and calendar view.
     */
    () => M_({
      months: this.months,
      formatter: this.formatter,
      weekdayFormat: this.opts.weekdayFormat.current
    })
  );
  get weekdays() {
    return d(this.#r);
  }
  set weekdays(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ot(() => this.opts.placeholder.current.year));
  get initialPlaceholderYear() {
    return d(this.#n);
  }
  set initialPlaceholderYear(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => z_({
    minValue: this.opts.minValue.current,
    maxValue: this.opts.maxValue.current,
    placeholderYear: this.initialPlaceholderYear
  }));
  get defaultYears() {
    return d(this.#s);
  }
  set defaultYears(e) {
    q(this.#s, e);
  }
  #o() {
    Xe(() => {
      if (ot(() => this.opts.initialFocus.current)) {
        const r = this.opts.ref.current?.querySelector("[data-focused]");
        r && r.focus();
      }
    });
  }
  #i() {
    Xe(() => this.opts.ref.current ? yE({
      calendarNode: this.opts.ref.current,
      label: this.fullCalendarLabel,
      accessibleHeadingId: this.accessibleHeadingId
    }) : void 0);
  }
  #a() {
    Co(() => {
      this.formatter.getLocale() !== this.opts.locale.current && this.formatter.setLocale(this.opts.locale.current);
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    T_({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    D_({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year: e });
  }
  setMonth(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month: e });
  }
  #u = /* @__PURE__ */ O(() => F_({
    maxValue: this.opts.maxValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isNextButtonDisabled() {
    return d(this.#u);
  }
  set isNextButtonDisabled(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => R_({
    minValue: this.opts.minValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isPrevButtonDisabled() {
    return d(this.#l);
  }
  set isPrevButtonDisabled(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => {
    const e = this.opts.value.current, r = this.opts.isDateDisabled.current, n = this.opts.isDateUnavailable.current;
    if (Array.isArray(e)) {
      if (!e.length) return !1;
      for (const s of e)
        if (r(s) || n(s)) return !0;
    } else {
      if (!e) return !1;
      if (r(e) || n(e)) return !0;
    }
    return !1;
  });
  get isInvalid() {
    return d(this.#c);
  }
  set isInvalid(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => (this.opts.monthFormat.current, this.opts.yearFormat.current, V_({
    months: this.months,
    formatter: this.formatter,
    locale: this.opts.locale.current
  })));
  get headingValue() {
    return d(this.#d);
  }
  set headingValue(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => `${this.opts.calendarLabel.current} ${this.headingValue}`);
  get fullCalendarLabel() {
    return d(this.#g);
  }
  set fullCalendarLabel(e) {
    q(this.#g, e);
  }
  isOutsideVisibleMonths(e) {
    return !this.visibleMonths.some((r) => Io(e, r));
  }
  isDateDisabled(e) {
    if (this.opts.isDateDisabled.current(e) || this.opts.disabled.current) return !0;
    const r = this.opts.minValue.current, n = this.opts.maxValue.current;
    return !!(r && Bt(e, r) || n && Bt(n, e));
  }
  isDateSelected(e) {
    const r = this.opts.value.current;
    return Array.isArray(r) ? r.some((n) => bt(n, e)) : r ? bt(r, e) : !1;
  }
  shiftFocus(e, r) {
    return A_({
      node: e,
      add: r,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #m(e) {
    if (this.opts.type.current !== "multiple" || !this.opts.maxDays.current) return !0;
    const r = e.length;
    return !(this.opts.maxDays.current && r > this.opts.maxDays.current);
  }
  handleCellClick(e, r) {
    if (this.opts.readonly.current || this.opts.isDateDisabled.current?.(r) || this.opts.isDateUnavailable.current?.(r))
      return;
    const n = this.opts.value.current;
    if (this.opts.type.current === "multiple")
      (Array.isArray(n) || n === void 0) && (this.opts.value.current = this.handleMultipleUpdate(n, r));
    else if (!Array.isArray(n)) {
      const o = this.handleSingleUpdate(n, r);
      o ? this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(o, !1)}`, "polite") : this.announcer.announce("Selected date is now empty.", "polite", 5e3), this.opts.value.current = _E(o, n), o !== void 0 && this.opts.onDateSelect?.current?.();
    }
  }
  handleMultipleUpdate(e, r) {
    if (!e) {
      const o = [r];
      return this.#m(o) ? o : [r];
    }
    if (!Array.isArray(e))
      return;
    const n = e.findIndex((o) => bt(o, r)), s = this.opts.preventDeselect.current;
    if (n === -1) {
      const o = [...e, r];
      return this.#m(o) ? o : [r];
    } else {
      if (s)
        return e;
      {
        const o = e.filter((i) => !bt(i, r));
        if (!o.length) {
          this.opts.placeholder.current = r;
          return;
        }
        return o;
      }
    }
  }
  handleSingleUpdate(e, r) {
    if (!e) return r;
    if (!this.opts.preventDeselect.current && bt(e, r)) {
      this.opts.placeholder.current = r;
      return;
    }
    return r;
  }
  onkeydown(e) {
    E_({
      event: e,
      handleCellClick: this.handleCellClick,
      shiftFocus: this.shiftFocus,
      placeholderValue: this.opts.placeholder.current
    });
  }
  #p = /* @__PURE__ */ O(() => ({ months: this.months, weekdays: this.weekdays }));
  get snippetProps() {
    return d(this.#p);
  }
  set snippetProps(e) {
    q(this.#p, e);
  }
  getBitsAttr = (e) => B_.getAttr(e);
  #f = /* @__PURE__ */ O(() => ({
    ...L_({
      fullCalendarLabel: this.fullCalendarLabel,
      id: this.opts.id.current,
      isInvalid: this.isInvalid,
      disabled: this.opts.disabled.current,
      readonly: this.opts.readonly.current
    }),
    [this.getBitsAttr("root")]: "",
    //
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#f);
  }
  set props(e) {
    q(this.#f, e);
  }
}
class yf {
  static create(e) {
    return new yf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-hidden": Kd(!0),
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("heading")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
const q_ = new ht("Calendar.Cell | RangeCalendar.Cell");
class bf {
  static create(e) {
    return q_.set(new bf(e, Ut.get()));
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => _r(this.opts.date.current));
  get cellDate() {
    return d(this.#e);
  }
  set cellDate(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.root.opts.isDateUnavailable.current(this.opts.date.current));
  get isUnavailable() {
    return d(this.#t);
  }
  set isUnavailable(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => s_(this.opts.date.current, ft()));
  get isDateToday() {
    return d(this.#r);
  }
  set isDateToday(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => !Io(this.opts.date.current, this.opts.month.current));
  get isOutsideMonth() {
    return d(this.#n);
  }
  set isOutsideMonth(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.root.isOutsideVisibleMonths(this.opts.date.current));
  get isOutsideVisibleMonths() {
    return d(this.#s);
  }
  set isOutsideVisibleMonths(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current);
  get isDisabled() {
    return d(this.#o);
  }
  set isDisabled(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => bt(this.opts.date.current, this.root.opts.placeholder.current));
  get isFocusedDate() {
    return d(this.#i);
  }
  set isFocusedDate(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => this.root.isDateSelected(this.opts.date.current));
  get isSelectedDate() {
    return d(this.#a);
  }
  set isSelectedDate(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => this.root.formatter.custom(this.cellDate, {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  }));
  get labelText() {
    return d(this.#u);
  }
  set labelText(e) {
    q(this.#u, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #l = /* @__PURE__ */ O(() => ({
    disabled: this.isDisabled,
    unavailable: this.isUnavailable,
    selected: this.isSelectedDate,
    day: `${this.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#l);
  }
  set snippetProps(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable);
  get ariaDisabled() {
    return d(this.#c);
  }
  set ariaDisabled(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => ({
    "data-unavailable": Re(this.isUnavailable),
    "data-today": this.isDateToday ? "" : void 0,
    "data-outside-month": this.isOutsideMonth ? "" : void 0,
    "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
    "data-focused": this.isFocusedDate ? "" : void 0,
    "data-selected": Re(this.isSelectedDate),
    "data-value": this.opts.date.current.toString(),
    "data-type": P_(this.opts.date.current),
    "data-disabled": Re(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
  }));
  get sharedDataAttrs() {
    return d(this.#d);
  }
  set sharedDataAttrs(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "gridcell",
    "aria-selected": at(this.isSelectedDate),
    "aria-disabled": at(this.ariaDisabled),
    ...this.sharedDataAttrs,
    [this.root.getBitsAttr("cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#g);
  }
  set props(e) {
    q(this.#g, e);
  }
}
class _f {
  static create(e) {
    return new _f(e, q_.get());
  }
  opts;
  cell;
  attachment;
  constructor(e, r) {
    this.opts = e, this.cell = r, this.onclick = this.onclick.bind(this), this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1);
  onclick(e) {
    this.cell.isDisabled || this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  #t = /* @__PURE__ */ O(() => ({
    disabled: this.cell.isDisabled,
    unavailable: this.cell.isUnavailable,
    selected: this.cell.isSelectedDate,
    day: `${this.cell.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#t);
  }
  set snippetProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    "aria-label": this.cell.labelText,
    "aria-disabled": at(this.cell.ariaDisabled),
    ...this.cell.sharedDataAttrs,
    tabindex: d(this.#e),
    [this.cell.root.getBitsAttr("day")]: "",
    "data-bits-day": "",
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
class wf {
  static create(e) {
    return new wf(e, Ut.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => this.root.isNextButtonDisabled);
  get isDisabled() {
    return d(this.#e);
  }
  set isDisabled(e) {
    q(this.#e, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onclick = this.onclick.bind(this), this.attachment = Te(this.opts.ref);
  }
  onclick(e) {
    this.isDisabled || this.root.nextPage();
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    type: "button",
    "aria-label": "Next",
    "aria-disabled": at(this.isDisabled),
    "data-disabled": Re(this.isDisabled),
    disabled: this.isDisabled,
    [this.root.getBitsAttr("next-button")]: "",
    //
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Sf {
  static create(e) {
    return new Sf(e, Ut.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => this.root.isPrevButtonDisabled);
  get isDisabled() {
    return d(this.#e);
  }
  set isDisabled(e) {
    q(this.#e, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onclick = this.onclick.bind(this), this.attachment = Te(this.opts.ref);
  }
  onclick(e) {
    this.isDisabled || this.root.prevPage();
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    type: "button",
    "aria-label": "Previous",
    "aria-disabled": at(this.isDisabled),
    "data-disabled": Re(this.isDisabled),
    disabled: this.isDisabled,
    [this.root.getBitsAttr("prev-button")]: "",
    //
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class xf {
  static create(e) {
    return new xf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    tabindex: -1,
    role: "grid",
    "aria-readonly": at(this.root.opts.readonly.current),
    "aria-disabled": at(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    "data-disabled": Re(this.root.opts.disabled.current),
    [this.root.getBitsAttr("grid")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Pf {
  static create(e) {
    return new Pf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-body")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Of {
  static create(e) {
    return new Of(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-head")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Cf {
  static create(e) {
    return new Cf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-row")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class kf {
  static create(e) {
    return new kf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("head-cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class $f {
  static create(e) {
    return new $f(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-readonly": Re(this.root.opts.readonly.current),
    [this.root.getBitsAttr("header")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Af {
  static create(e) {
    return new Af(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onchange = this.onchange.bind(this), this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => {
    this.root.opts.locale.current;
    const e = this.opts.months.current, r = this.opts.monthFormat.current, n = [];
    for (const s of e) {
      const o = this.root.opts.placeholder.current.set({ month: s });
      let i;
      typeof r == "function" ? i = r(s) : i = this.root.formatter.custom(_r(o), { month: r }), n.push({ value: s, label: i });
    }
    return n;
  });
  get monthItems() {
    return d(this.#e);
  }
  set monthItems(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.root.opts.placeholder.current.month);
  get currentMonth() {
    return d(this.#t);
  }
  set currentMonth(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.opts.disabled.current || this.opts.disabled.current);
  get isDisabled() {
    return d(this.#r);
  }
  set isDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ({
    monthItems: this.monthItems,
    selectedMonthItem: this.monthItems.find((e) => e.value === this.currentMonth)
  }));
  get snippetProps() {
    return d(this.#n);
  }
  set snippetProps(e) {
    q(this.#n, e);
  }
  onchange(e) {
    if (this.isDisabled) return;
    const r = e.target, n = parseInt(r.value, 10);
    isNaN(n) || (this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ month: n }));
  }
  #s = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    value: this.currentMonth,
    disabled: this.isDisabled,
    "data-disabled": Re(this.isDisabled),
    [this.root.getBitsAttr("month-select")]: "",
    //
    onchange: this.onchange,
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class Ef {
  static create(e) {
    return new Ef(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onchange = this.onchange.bind(this), this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => this.opts.years.current && this.opts.years.current.length ? this.opts.years.current : this.root.defaultYears);
  get years() {
    return d(this.#e);
  }
  set years(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => {
    this.root.opts.locale.current;
    const e = this.opts.yearFormat.current, r = [];
    for (const n of this.years) {
      const s = this.root.opts.placeholder.current.set({ year: n });
      let o;
      typeof e == "function" ? o = e(n) : o = this.root.formatter.custom(_r(s), { year: e }), r.push({ value: n, label: o });
    }
    return r;
  });
  get yearItems() {
    return d(this.#t);
  }
  set yearItems(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.opts.placeholder.current.year);
  get currentYear() {
    return d(this.#r);
  }
  set currentYear(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.root.opts.disabled.current || this.opts.disabled.current);
  get isDisabled() {
    return d(this.#n);
  }
  set isDisabled(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => ({
    yearItems: this.yearItems,
    selectedYearItem: this.yearItems.find((e) => e.value === this.currentYear)
  }));
  get snippetProps() {
    return d(this.#s);
  }
  set snippetProps(e) {
    q(this.#s, e);
  }
  onchange(e) {
    if (this.isDisabled) return;
    const r = e.target, n = parseInt(r.value, 10);
    isNaN(n) || (this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ year: n }));
  }
  #o = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    value: this.currentYear,
    disabled: this.isDisabled,
    "data-disabled": Re(this.isDisabled),
    [this.root.getBitsAttr("year-select")]: "",
    //
    onchange: this.onchange,
    ...this.attachment
  }));
  get props() {
    return d(this.#o);
  }
  set props(e) {
    q(this.#o, e);
  }
}
var wE = /* @__PURE__ */ ne("<div><!></div>");
function U_(t, e) {
  W(e, !0);
  let r = v(e, "child", 7), n = v(e, "children", 7), s = v(e, "id", 23, En), o = v(e, "ref", 15, null), i = v(e, "value", 15), a = v(e, "onValueChange", 7, _e), l = v(e, "placeholder", 15), u = v(e, "onPlaceholderChange", 7, _e), c = v(e, "weekdayFormat", 7, "narrow"), f = v(e, "weekStartsOn", 7), g = v(e, "pagedNavigation", 7, !1), _ = v(e, "isDateDisabled", 7, () => !1), b = v(e, "isDateUnavailable", 7, () => !1), p = v(e, "fixedWeeks", 7, !1), h = v(e, "numberOfMonths", 7, 1), y = v(e, "locale", 7), S = v(e, "calendarLabel", 7, "Event"), x = v(e, "disabled", 7, !1), P = v(e, "readonly", 7, !1), w = v(e, "minValue", 7, void 0), C = v(e, "maxValue", 7, void 0), k = v(e, "preventDeselect", 7, !1), $ = v(e, "type", 7), T = v(e, "disableDaysOutsideMonth", 7, !0), E = v(e, "initialFocus", 7, !1), I = v(e, "maxDays", 7), F = v(e, "monthFormat", 7, "long"), U = v(e, "yearFormat", 7, "numeric"), B = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "type",
    "disableDaysOutsideMonth",
    "initialFocus",
    "maxDays",
    "monthFormat",
    "yearFormat"
  ]);
  const R = S_({
    defaultValue: i(),
    minValue: w(),
    maxValue: C()
  });
  function Z() {
    l() === void 0 && l(R);
  }
  Z(), Fe.pre(() => l(), () => {
    Z();
  });
  function Y() {
    i() === void 0 && i($() === "single" ? void 0 : []);
  }
  Y(), Fe.pre(() => i(), () => {
    Y();
  });
  const X = vf.create({
    id: z(() => s()),
    ref: z(() => o(), (V) => o(V)),
    weekdayFormat: z(() => c()),
    weekStartsOn: z(() => f()),
    pagedNavigation: z(() => g()),
    isDateDisabled: z(() => _()),
    isDateUnavailable: z(() => b()),
    fixedWeeks: z(() => p()),
    numberOfMonths: z(() => h()),
    locale: Lb(() => y()),
    calendarLabel: z(() => S()),
    readonly: z(() => P()),
    disabled: z(() => x()),
    minValue: z(() => w()),
    maxValue: z(() => C()),
    disableDaysOutsideMonth: z(() => T()),
    initialFocus: z(() => E()),
    maxDays: z(() => I()),
    placeholder: z(() => l(), (V) => {
      l(V), u()(V);
    }),
    preventDeselect: z(() => k()),
    value: z(() => i(), (V) => {
      i(V), a()(V);
    }),
    type: z(() => $()),
    monthFormat: z(() => F()),
    yearFormat: z(() => U()),
    defaultPlaceholder: R
  }), ae = /* @__PURE__ */ O(() => Ce(B, X.props));
  var J = {
    get child() {
      return r();
    },
    set child(V) {
      r(V), m();
    },
    get children() {
      return n();
    },
    set children(V) {
      n(V), m();
    },
    get id() {
      return s();
    },
    set id(V = En()) {
      s(V), m();
    },
    get ref() {
      return o();
    },
    set ref(V = null) {
      o(V), m();
    },
    get value() {
      return i();
    },
    set value(V) {
      i(V), m();
    },
    get onValueChange() {
      return a();
    },
    set onValueChange(V = _e) {
      a(V), m();
    },
    get placeholder() {
      return l();
    },
    set placeholder(V) {
      l(V), m();
    },
    get onPlaceholderChange() {
      return u();
    },
    set onPlaceholderChange(V = _e) {
      u(V), m();
    },
    get weekdayFormat() {
      return c();
    },
    set weekdayFormat(V = "narrow") {
      c(V), m();
    },
    get weekStartsOn() {
      return f();
    },
    set weekStartsOn(V) {
      f(V), m();
    },
    get pagedNavigation() {
      return g();
    },
    set pagedNavigation(V = !1) {
      g(V), m();
    },
    get isDateDisabled() {
      return _();
    },
    set isDateDisabled(V = () => !1) {
      _(V), m();
    },
    get isDateUnavailable() {
      return b();
    },
    set isDateUnavailable(V = () => !1) {
      b(V), m();
    },
    get fixedWeeks() {
      return p();
    },
    set fixedWeeks(V = !1) {
      p(V), m();
    },
    get numberOfMonths() {
      return h();
    },
    set numberOfMonths(V = 1) {
      h(V), m();
    },
    get locale() {
      return y();
    },
    set locale(V) {
      y(V), m();
    },
    get calendarLabel() {
      return S();
    },
    set calendarLabel(V = "Event") {
      S(V), m();
    },
    get disabled() {
      return x();
    },
    set disabled(V = !1) {
      x(V), m();
    },
    get readonly() {
      return P();
    },
    set readonly(V = !1) {
      P(V), m();
    },
    get minValue() {
      return w();
    },
    set minValue(V = void 0) {
      w(V), m();
    },
    get maxValue() {
      return C();
    },
    set maxValue(V = void 0) {
      C(V), m();
    },
    get preventDeselect() {
      return k();
    },
    set preventDeselect(V = !1) {
      k(V), m();
    },
    get type() {
      return $();
    },
    set type(V) {
      $(V), m();
    },
    get disableDaysOutsideMonth() {
      return T();
    },
    set disableDaysOutsideMonth(V = !0) {
      T(V), m();
    },
    get initialFocus() {
      return E();
    },
    set initialFocus(V = !1) {
      E(V), m();
    },
    get maxDays() {
      return I();
    },
    set maxDays(V) {
      I(V), m();
    },
    get monthFormat() {
      return F();
    },
    set monthFormat(V = "long") {
      F(V), m();
    },
    get yearFormat() {
      return U();
    },
    set yearFormat(V = "numeric") {
      U(V), m();
    }
  }, j = M(), ee = D(j);
  {
    var L = (V) => {
      var G = M(), fe = D(G);
      {
        let se = /* @__PURE__ */ O(() => ({ props: d(ae), ...X.snippetProps }));
        te(fe, r, () => d(se));
      }
      A(V, G);
    }, N = (V) => {
      var G = wE();
      ve(G, () => ({ ...d(ae) }));
      var fe = ge(G);
      te(fe, () => n() ?? he, () => X.snippetProps), de(G), A(V, G);
    };
    ue(ee, (V) => {
      r() ? V(L) : V(N, !1);
    });
  }
  return A(t, j), H(J);
}
K(
  U_,
  {
    child: {},
    children: {},
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    placeholder: {},
    onPlaceholderChange: {},
    weekdayFormat: {},
    weekStartsOn: {},
    pagedNavigation: {},
    isDateDisabled: {},
    isDateUnavailable: {},
    fixedWeeks: {},
    numberOfMonths: {},
    locale: {},
    calendarLabel: {},
    disabled: {},
    readonly: {},
    minValue: {},
    maxValue: {},
    preventDeselect: {},
    type: {},
    disableDaysOutsideMonth: {},
    initialFocus: {},
    maxDays: {},
    monthFormat: {},
    yearFormat: {}
  },
  [],
  [],
  { mode: "open" }
);
var SE = /* @__PURE__ */ ne("<div><!></div>");
function K_(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = _f.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      {
        let S = /* @__PURE__ */ O(() => ({ props: d(u), ...l.snippetProps }));
        te(y, s, () => d(S));
      }
      A(p, h);
    }, b = (p) => {
      var h = SE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, () => n() ?? he, () => l.snippetProps), A(P, w);
        }, x = (P) => {
          var w = st();
          ke(() => Ie(w, l.cell.opts.date.current.day)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(K_, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var xE = /* @__PURE__ */ ne("<table><!></table>");
function Tf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = xf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = xE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Tf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var PE = /* @__PURE__ */ ne("<tbody><!></tbody>");
function Df(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Pf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = PE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Df, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var OE = /* @__PURE__ */ ne("<td><!></td>");
function W_(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "date", 7), l = v(e, "month", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "date",
    "month"
  ]);
  const c = bf.create({
    id: z(() => i()),
    ref: z(() => o(), (y) => o(y)),
    date: z(() => a()),
    month: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var g = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get ref() {
      return o();
    },
    set ref(y = null) {
      o(y), m();
    },
    get id() {
      return i();
    },
    set id(y = me(r)) {
      i(y), m();
    },
    get date() {
      return a();
    },
    set date(y) {
      a(y), m();
    },
    get month() {
      return l();
    },
    set month(y) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({ props: d(f), ...c.snippetProps }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = OE();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => n() ?? he, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(p) : y(h, !1);
    });
  }
  return A(t, _), H(g);
}
K(
  W_,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    date: {},
    month: {}
  },
  [],
  [],
  { mode: "open" }
);
var CE = /* @__PURE__ */ ne("<thead><!></thead>");
function Mf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Of.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = CE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Mf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var kE = /* @__PURE__ */ ne("<th><!></th>");
function If(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = kf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = kE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(If, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var $E = /* @__PURE__ */ ne("<tr><!></tr>");
function Nf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Cf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = $E();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Nf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var AE = /* @__PURE__ */ ne("<header><!></header>");
function Ff(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = $f.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = AE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Ff, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var EE = /* @__PURE__ */ ne("<div><!></div>");
function Rf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = yf.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({
        props: d(u),
        headingValue: l.root.headingValue
      })), A(p, h);
    }, b = (p) => {
      var h = EE();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, () => n() ?? he, () => ({ headingValue: l.root.headingValue })), A(P, w);
        }, x = (P) => {
          var w = st();
          ke(() => Ie(w, l.root.headingValue)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(Rf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var TE = /* @__PURE__ */ ne("<option> </option>"), DE = /* @__PURE__ */ ne("<!>", 1), ME = /* @__PURE__ */ ne("<select><!></select>");
function Vf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "months", 23, () => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), l = v(e, "monthFormat", 7, "long"), u = v(e, "disabled", 7, !1), c = v(e, "aria-label", 7, "Select a month"), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "months",
    "monthFormat",
    "disabled",
    "aria-label"
  ]);
  const g = Af.create({
    id: z(() => i()),
    ref: z(() => o(), (x) => o(x)),
    months: z(() => a()),
    monthFormat: z(() => l()),
    disabled: z(() => !!u())
  }), _ = /* @__PURE__ */ O(() => Ce(f, g.props, { "aria-label": c() }));
  var b = {
    get children() {
      return n();
    },
    set children(x) {
      n(x), m();
    },
    get child() {
      return s();
    },
    set child(x) {
      s(x), m();
    },
    get ref() {
      return o();
    },
    set ref(x = null) {
      o(x), m();
    },
    get id() {
      return i();
    },
    set id(x = me(r)) {
      i(x), m();
    },
    get months() {
      return a();
    },
    set months(x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) {
      a(x), m();
    },
    get monthFormat() {
      return l();
    },
    set monthFormat(x = "long") {
      l(x), m();
    },
    get disabled() {
      return u();
    },
    set disabled(x = !1) {
      u(x), m();
    },
    get "aria-label"() {
      return c();
    },
    set "aria-label"(x = "Select a month") {
      c(x), m();
    }
  }, p = M(), h = D(p);
  {
    var y = (x) => {
      var P = M(), w = D(P);
      {
        let C = /* @__PURE__ */ O(() => ({ props: d(_), ...g.snippetProps }));
        te(w, s, () => d(C));
      }
      A(x, P);
    }, S = (x) => {
      var P = ME();
      ve(P, () => ({ ...d(_) })), ly(P, () => {
        var w = ge(P), C = DE(), k = D(C);
        {
          var $ = (E) => {
            var I = M(), F = D(I);
            te(F, () => n() ?? he, () => g.snippetProps), A(E, I);
          }, T = (E) => {
            var I = M(), F = D(I);
            nt(F, 17, () => g.monthItems, (U) => U.value, (U, B) => {
              var R = TE(), Z = ge(R, !0);
              de(R);
              var Y = {};
              ke(() => {
                Ks(R, d(B).value === g.currentMonth), Ie(Z, d(B).label), Y !== (Y = d(B).value) && (R.value = (R.__value = d(B).value) ?? "");
              }), A(U, R);
            }), A(E, I);
          };
          ue(k, (E) => {
            n() ? E($) : E(T, !1);
          });
        }
        A(w, C);
      }), A(x, P);
    };
    ue(h, (x) => {
      s() ? x(y) : x(S, !1);
    });
  }
  return A(t, p), H(b);
}
K(
  Vf,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    months: {},
    monthFormat: {},
    disabled: {},
    "aria-label": {}
  },
  [],
  [],
  { mode: "open" }
);
var IE = /* @__PURE__ */ ne("<button><!></button>");
function Lf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "tabindex", 7, 0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const u = wf.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { tabindex: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get tabindex() {
      return a();
    },
    set tabindex(h = 0) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = IE();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(Lf, { children: {}, child: {}, id: {}, ref: {}, tabindex: {} }, [], [], { mode: "open" });
var NE = /* @__PURE__ */ ne("<button><!></button>");
function jf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "tabindex", 7, 0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const u = Sf.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { tabindex: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get tabindex() {
      return a();
    },
    set tabindex(h = 0) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = NE();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(jf, { children: {}, child: {}, id: {}, ref: {}, tabindex: {} }, [], [], { mode: "open" });
var FE = /* @__PURE__ */ ne("<option> </option>"), RE = /* @__PURE__ */ ne("<!>", 1), VE = /* @__PURE__ */ ne("<select><!></select>");
function Bf(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "years", 7), l = v(e, "yearFormat", 7, "numeric"), u = v(e, "disabled", 7, !1), c = v(e, "aria-label", 7, "Select a year"), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "years",
    "yearFormat",
    "disabled",
    "aria-label"
  ]);
  const g = Ef.create({
    id: z(() => i()),
    ref: z(() => o(), (x) => o(x)),
    years: z(() => a()),
    yearFormat: z(() => l()),
    disabled: z(() => !!u())
  }), _ = /* @__PURE__ */ O(() => Ce(f, g.props, { "aria-label": c() }));
  var b = {
    get children() {
      return n();
    },
    set children(x) {
      n(x), m();
    },
    get child() {
      return s();
    },
    set child(x) {
      s(x), m();
    },
    get ref() {
      return o();
    },
    set ref(x = null) {
      o(x), m();
    },
    get id() {
      return i();
    },
    set id(x = me(r)) {
      i(x), m();
    },
    get years() {
      return a();
    },
    set years(x) {
      a(x), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(x = "numeric") {
      l(x), m();
    },
    get disabled() {
      return u();
    },
    set disabled(x = !1) {
      u(x), m();
    },
    get "aria-label"() {
      return c();
    },
    set "aria-label"(x = "Select a year") {
      c(x), m();
    }
  }, p = M(), h = D(p);
  {
    var y = (x) => {
      var P = M(), w = D(P);
      {
        let C = /* @__PURE__ */ O(() => ({ props: d(_), ...g.snippetProps }));
        te(w, s, () => d(C));
      }
      A(x, P);
    }, S = (x) => {
      var P = VE();
      ve(P, () => ({ ...d(_) })), ly(P, () => {
        var w = ge(P), C = RE(), k = D(C);
        {
          var $ = (E) => {
            var I = M(), F = D(I);
            te(F, () => n() ?? he, () => g.snippetProps), A(E, I);
          }, T = (E) => {
            var I = M(), F = D(I);
            nt(F, 17, () => g.yearItems, (U) => U.value, (U, B) => {
              var R = FE(), Z = ge(R, !0);
              de(R);
              var Y = {};
              ke(() => {
                Ks(R, d(B).value === g.currentYear), Ie(Z, d(B).label), Y !== (Y = d(B).value) && (R.value = (R.__value = d(B).value) ?? "");
              }), A(U, R);
            }), A(E, I);
          };
          ue(k, (E) => {
            n() ? E($) : E(T, !1);
          });
        }
        A(w, C);
      }), A(x, P);
    };
    ue(h, (x) => {
      s() ? x(y) : x(S, !1);
    });
  }
  return A(t, p), H(b);
}
K(
  Bf,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    years: {},
    yearFormat: {},
    disabled: {},
    "aria-label": {}
  },
  [],
  [],
  { mode: "open" }
);
const LE = tr({
  component: "checkbox",
  parts: ["root", "group", "group-label", "input"]
}), jE = new ht("Checkbox.Group"), H_ = new ht("Checkbox.Root");
class zf {
  static create(e, r = null) {
    return H_.set(new zf(e, r));
  }
  opts;
  group;
  #e = /* @__PURE__ */ O(() => this.group && this.group.opts.name.current ? this.group.opts.name.current : this.opts.name.current);
  get trueName() {
    return d(this.#e);
  }
  set trueName(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.group && this.group.opts.required.current ? !0 : this.opts.required.current);
  get trueRequired() {
    return d(this.#t);
  }
  set trueRequired(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.group && this.group.opts.disabled.current ? !0 : this.opts.disabled.current);
  get trueDisabled() {
    return d(this.#r);
  }
  set trueDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.group && this.group.opts.readonly.current ? !0 : this.opts.readonly.current);
  get trueReadonly() {
    return d(this.#n);
  }
  set trueReadonly(e) {
    q(this.#n, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(this.opts.ref), this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this), Fe.pre(
      [
        () => xo(this.group?.opts.value.current),
        () => this.opts.value.current
      ],
      ([n, s]) => {
        !n || !s || (this.opts.checked.current = n.includes(s));
      }
    ), Fe.pre(() => this.opts.checked.current, (n) => {
      this.group && (n ? this.group?.addValue(this.opts.value.current) : this.group?.removeValue(this.opts.value.current));
    });
  }
  onkeydown(e) {
    if (!(this.trueDisabled || this.trueReadonly)) {
      if (e.key === Br) {
        e.preventDefault(), this.opts.type.current === "submit" && e.currentTarget.closest("form")?.requestSubmit();
        return;
      }
      e.key === xr && (e.preventDefault(), this.#s());
    }
  }
  #s() {
    this.opts.indeterminate.current ? (this.opts.indeterminate.current = !1, this.opts.checked.current = !0) : this.opts.checked.current = !this.opts.checked.current;
  }
  onclick(e) {
    if (!(this.trueDisabled || this.trueReadonly)) {
      if (this.opts.type.current === "submit") {
        this.#s();
        return;
      }
      e.preventDefault(), this.#s();
    }
  }
  #o = /* @__PURE__ */ O(() => ({
    checked: this.opts.checked.current,
    indeterminate: this.opts.indeterminate.current
  }));
  get snippetProps() {
    return d(this.#o);
  }
  set snippetProps(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "checkbox",
    type: this.opts.type.current,
    disabled: this.trueDisabled,
    "aria-checked": ru(this.opts.checked.current, this.opts.indeterminate.current),
    "aria-required": at(this.trueRequired),
    "aria-readonly": at(this.trueReadonly),
    "data-disabled": Re(this.trueDisabled),
    "data-readonly": Re(this.trueReadonly),
    "data-state": BE(this.opts.checked.current, this.opts.indeterminate.current),
    [LE.root]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#i);
  }
  set props(e) {
    q(this.#i, e);
  }
}
class qf {
  static create() {
    return new qf(H_.get());
  }
  root;
  #e = /* @__PURE__ */ O(() => this.root.group ? !!(this.root.opts.value.current !== void 0 && this.root.group.opts.value.current.includes(this.root.opts.value.current)) : this.root.opts.checked.current);
  get trueChecked() {
    return d(this.#e);
  }
  set trueChecked(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => !!this.root.trueName);
  get shouldRender() {
    return d(this.#t);
  }
  set shouldRender(e) {
    q(this.#t, e);
  }
  constructor(e) {
    this.root = e, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    Cn(this.root.opts.ref.current) && this.root.opts.ref.current.focus();
  }
  #r = /* @__PURE__ */ O(() => ({
    type: "checkbox",
    checked: this.root.opts.checked.current === !0,
    disabled: this.root.trueDisabled,
    required: this.root.trueRequired,
    name: this.root.trueName,
    value: this.root.opts.value.current,
    readonly: this.root.trueReadonly,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
function BE(t, e) {
  return e ? "indeterminate" : t ? "checked" : "unchecked";
}
aP();
var zE = /* @__PURE__ */ ne("<input/>"), qE = /* @__PURE__ */ ne("<input/>");
function ji(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  const s = /* @__PURE__ */ O(() => Ce(n, {
    "aria-hidden": "true",
    tabindex: -1,
    style: Cb
  }));
  var o = {
    get value() {
      return r();
    },
    set value(c) {
      r(c), m();
    }
  }, i = M(), a = D(i);
  {
    var l = (c) => {
      var f = zE();
      ve(f, () => ({ ...d(s), value: r() }), void 0, void 0, void 0, void 0, !0), A(c, f);
    }, u = (c) => {
      var f = qE();
      ve(f, () => ({ ...d(s) }), void 0, void 0, void 0, void 0, !0), Di(f, r), A(c, f);
    };
    ue(a, (c) => {
      d(s).type === "checkbox" ? c(l) : c(u, !1);
    });
  }
  return A(t, i), H(o);
}
K(ji, { value: {} }, [], [], { mode: "open" });
function G_(t, e) {
  W(e, !1);
  const r = qf.create();
  wd();
  var n = M(), s = D(n);
  {
    var o = (i) => {
      ji(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), H();
}
K(G_, {}, [], [], { mode: "open" });
var UE = /* @__PURE__ */ ne("<button><!></button>"), KE = /* @__PURE__ */ ne("<!> <!>", 1);
function Y_(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "checked", 15, !1), s = v(e, "ref", 15, null), o = v(e, "onCheckedChange", 7), i = v(e, "children", 7), a = v(e, "disabled", 7, !1), l = v(e, "required", 7, !1), u = v(e, "name", 7, void 0), c = v(e, "value", 7, "on"), f = v(e, "id", 23, () => me(r)), g = v(e, "indeterminate", 15, !1), _ = v(e, "onIndeterminateChange", 7), b = v(e, "child", 7), p = v(e, "type", 7, "button"), h = v(e, "readonly", 7), y = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "checked",
    "ref",
    "onCheckedChange",
    "children",
    "disabled",
    "required",
    "name",
    "value",
    "id",
    "indeterminate",
    "onIndeterminateChange",
    "child",
    "type",
    "readonly"
  ]);
  const S = jE.getOr(null);
  S && c() && (S.opts.value.current.includes(c()) ? n(!0) : n(!1)), Fe.pre(() => c(), () => {
    S && c() && (S.opts.value.current.includes(c()) ? n(!0) : n(!1));
  });
  const x = zf.create(
    {
      checked: z(() => n(), (I) => {
        n(I), o()?.(I);
      }),
      disabled: z(() => a() ?? !1),
      required: z(() => l()),
      name: z(() => u()),
      value: z(() => c()),
      id: z(() => f()),
      ref: z(() => s(), (I) => s(I)),
      indeterminate: z(() => g(), (I) => {
        g(I), _()?.(I);
      }),
      type: z(() => p()),
      readonly: z(() => !!h())
    },
    S
  ), P = /* @__PURE__ */ O(() => Ce({ ...y }, x.props));
  var w = {
    get checked() {
      return n();
    },
    set checked(I = !1) {
      n(I), m();
    },
    get ref() {
      return s();
    },
    set ref(I = null) {
      s(I), m();
    },
    get onCheckedChange() {
      return o();
    },
    set onCheckedChange(I) {
      o(I), m();
    },
    get children() {
      return i();
    },
    set children(I) {
      i(I), m();
    },
    get disabled() {
      return a();
    },
    set disabled(I = !1) {
      a(I), m();
    },
    get required() {
      return l();
    },
    set required(I = !1) {
      l(I), m();
    },
    get name() {
      return u();
    },
    set name(I = void 0) {
      u(I), m();
    },
    get value() {
      return c();
    },
    set value(I = "on") {
      c(I), m();
    },
    get id() {
      return f();
    },
    set id(I = me(r)) {
      f(I), m();
    },
    get indeterminate() {
      return g();
    },
    set indeterminate(I = !1) {
      g(I), m();
    },
    get onIndeterminateChange() {
      return _();
    },
    set onIndeterminateChange(I) {
      _(I), m();
    },
    get child() {
      return b();
    },
    set child(I) {
      b(I), m();
    },
    get type() {
      return p();
    },
    set type(I = "button") {
      p(I), m();
    },
    get readonly() {
      return h();
    },
    set readonly(I) {
      h(I), m();
    }
  }, C = KE(), k = D(C);
  {
    var $ = (I) => {
      var F = M(), U = D(F);
      {
        let B = /* @__PURE__ */ O(() => ({ props: d(P), ...x.snippetProps }));
        te(U, b, () => d(B));
      }
      A(I, F);
    }, T = (I) => {
      var F = UE();
      ve(F, () => ({ ...d(P) }));
      var U = ge(F);
      te(U, () => i() ?? he, () => x.snippetProps), de(F), A(I, F);
    };
    ue(k, (I) => {
      b() ? I($) : I(T, !1);
    });
  }
  var E = be(k, 2);
  return G_(E, {}), A(t, C), H(w);
}
K(
  Y_,
  {
    checked: {},
    ref: {},
    onCheckedChange: {},
    children: {},
    disabled: {},
    required: {},
    name: {},
    value: {},
    id: {},
    indeterminate: {},
    onIndeterminateChange: {},
    child: {},
    type: {},
    readonly: {}
  },
  [],
  [],
  { mode: "open" }
);
const WE = ["top", "right", "bottom", "left"], ns = Math.min, cr = Math.max, gl = Math.round, Ji = Math.floor, rn = (t) => ({
  x: t,
  y: t
}), HE = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, GE = {
  start: "end",
  end: "start"
};
function Uc(t, e, r) {
  return cr(t, ns(e, r));
}
function Dn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Mn(t) {
  return t.split("-")[0];
}
function Fo(t) {
  return t.split("-")[1];
}
function Uf(t) {
  return t === "x" ? "y" : "x";
}
function Kf(t) {
  return t === "y" ? "height" : "width";
}
const YE = /* @__PURE__ */ new Set(["top", "bottom"]);
function Qr(t) {
  return YE.has(Mn(t)) ? "y" : "x";
}
function Wf(t) {
  return Uf(Qr(t));
}
function XE(t, e, r) {
  r === void 0 && (r = !1);
  const n = Fo(t), s = Wf(t), o = Kf(s);
  let i = s === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (i = pl(i)), [i, pl(i)];
}
function JE(t) {
  const e = pl(t);
  return [Kc(t), e, Kc(e)];
}
function Kc(t) {
  return t.replace(/start|end/g, (e) => GE[e]);
}
const gp = ["left", "right"], pp = ["right", "left"], ZE = ["top", "bottom"], QE = ["bottom", "top"];
function e7(t, e, r) {
  switch (t) {
    case "top":
    case "bottom":
      return r ? e ? pp : gp : e ? gp : pp;
    case "left":
    case "right":
      return e ? ZE : QE;
    default:
      return [];
  }
}
function t7(t, e, r, n) {
  const s = Fo(t);
  let o = e7(Mn(t), r === "start", n);
  return s && (o = o.map((i) => i + "-" + s), e && (o = o.concat(o.map(Kc)))), o;
}
function pl(t) {
  return t.replace(/left|right|bottom|top/g, (e) => HE[e]);
}
function r7(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function X_(t) {
  return typeof t != "number" ? r7(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function ml(t) {
  const {
    x: e,
    y: r,
    width: n,
    height: s
  } = t;
  return {
    width: n,
    height: s,
    top: r,
    left: e,
    right: e + n,
    bottom: r + s,
    x: e,
    y: r
  };
}
function mp(t, e, r) {
  let {
    reference: n,
    floating: s
  } = t;
  const o = Qr(e), i = Wf(e), a = Kf(i), l = Mn(e), u = o === "y", c = n.x + n.width / 2 - s.width / 2, f = n.y + n.height / 2 - s.height / 2, g = n[a] / 2 - s[a] / 2;
  let _;
  switch (l) {
    case "top":
      _ = {
        x: c,
        y: n.y - s.height
      };
      break;
    case "bottom":
      _ = {
        x: c,
        y: n.y + n.height
      };
      break;
    case "right":
      _ = {
        x: n.x + n.width,
        y: f
      };
      break;
    case "left":
      _ = {
        x: n.x - s.width,
        y: f
      };
      break;
    default:
      _ = {
        x: n.x,
        y: n.y
      };
  }
  switch (Fo(e)) {
    case "start":
      _[i] -= g * (r && u ? -1 : 1);
      break;
    case "end":
      _[i] += g * (r && u ? -1 : 1);
      break;
  }
  return _;
}
async function n7(t, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: n,
    y: s,
    platform: o,
    rects: i,
    elements: a,
    strategy: l
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: g = !1,
    padding: _ = 0
  } = Dn(e, t), b = X_(_), h = a[g ? f === "floating" ? "reference" : "floating" : f], y = ml(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(h))) == null || r ? h : h.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), S = f === "floating" ? {
    x: n,
    y: s,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), P = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = ml(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: S,
    offsetParent: x,
    strategy: l
  }) : S);
  return {
    top: (y.top - w.top + b.top) / P.y,
    bottom: (w.bottom - y.bottom + b.bottom) / P.y,
    left: (y.left - w.left + b.left) / P.x,
    right: (w.right - y.right + b.right) / P.x
  };
}
const s7 = async (t, e, r) => {
  const {
    placement: n = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: i
  } = r, a = o.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(e));
  let u = await i.getElementRects({
    reference: t,
    floating: e,
    strategy: s
  }), {
    x: c,
    y: f
  } = mp(u, n, l), g = n, _ = {}, b = 0;
  for (let h = 0; h < a.length; h++) {
    var p;
    const {
      name: y,
      fn: S
    } = a[h], {
      x,
      y: P,
      data: w,
      reset: C
    } = await S({
      x: c,
      y: f,
      initialPlacement: n,
      placement: g,
      strategy: s,
      middlewareData: _,
      rects: u,
      platform: {
        ...i,
        detectOverflow: (p = i.detectOverflow) != null ? p : n7
      },
      elements: {
        reference: t,
        floating: e
      }
    });
    c = x ?? c, f = P ?? f, _ = {
      ..._,
      [y]: {
        ..._[y],
        ...w
      }
    }, C && b <= 50 && (b++, typeof C == "object" && (C.placement && (g = C.placement), C.rects && (u = C.rects === !0 ? await i.getElementRects({
      reference: t,
      floating: e,
      strategy: s
    }) : C.rects), {
      x: c,
      y: f
    } = mp(u, g, l)), h = -1);
  }
  return {
    x: c,
    y: f,
    placement: g,
    strategy: s,
    middlewareData: _
  };
}, o7 = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: r,
      y: n,
      placement: s,
      rects: o,
      platform: i,
      elements: a,
      middlewareData: l
    } = e, {
      element: u,
      padding: c = 0
    } = Dn(t, e) || {};
    if (u == null)
      return {};
    const f = X_(c), g = {
      x: r,
      y: n
    }, _ = Wf(s), b = Kf(_), p = await i.getDimensions(u), h = _ === "y", y = h ? "top" : "left", S = h ? "bottom" : "right", x = h ? "clientHeight" : "clientWidth", P = o.reference[b] + o.reference[_] - g[_] - o.floating[b], w = g[_] - o.reference[_], C = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u));
    let k = C ? C[x] : 0;
    (!k || !await (i.isElement == null ? void 0 : i.isElement(C))) && (k = a.floating[x] || o.floating[b]);
    const $ = P / 2 - w / 2, T = k / 2 - p[b] / 2 - 1, E = ns(f[y], T), I = ns(f[S], T), F = E, U = k - p[b] - I, B = k / 2 - p[b] / 2 + $, R = Uc(F, B, U), Z = !l.arrow && Fo(s) != null && B !== R && o.reference[b] / 2 - (B < F ? E : I) - p[b] / 2 < 0, Y = Z ? B < F ? B - F : B - U : 0;
    return {
      [_]: g[_] + Y,
      data: {
        [_]: R,
        centerOffset: B - R - Y,
        ...Z && {
          alignmentOffset: Y
        }
      },
      reset: Z
    };
  }
}), i7 = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var r, n;
      const {
        placement: s,
        middlewareData: o,
        rects: i,
        initialPlacement: a,
        platform: l,
        elements: u
      } = e, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: g,
        fallbackStrategy: _ = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: p = !0,
        ...h
      } = Dn(t, e);
      if ((r = o.arrow) != null && r.alignmentOffset)
        return {};
      const y = Mn(s), S = Qr(a), x = Mn(a) === a, P = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), w = g || (x || !p ? [pl(a)] : JE(a)), C = b !== "none";
      !g && C && w.push(...t7(a, p, b, P));
      const k = [a, ...w], $ = await l.detectOverflow(e, h), T = [];
      let E = ((n = o.flip) == null ? void 0 : n.overflows) || [];
      if (c && T.push($[y]), f) {
        const B = XE(s, i, P);
        T.push($[B[0]], $[B[1]]);
      }
      if (E = [...E, {
        placement: s,
        overflows: T
      }], !T.every((B) => B <= 0)) {
        var I, F;
        const B = (((I = o.flip) == null ? void 0 : I.index) || 0) + 1, R = k[B];
        if (R && (!(f === "alignment" ? S !== Qr(R) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        E.every((X) => Qr(X.placement) === S ? X.overflows[0] > 0 : !0)))
          return {
            data: {
              index: B,
              overflows: E
            },
            reset: {
              placement: R
            }
          };
        let Z = (F = E.filter((Y) => Y.overflows[0] <= 0).sort((Y, X) => Y.overflows[1] - X.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!Z)
          switch (_) {
            case "bestFit": {
              var U;
              const Y = (U = E.filter((X) => {
                if (C) {
                  const ae = Qr(X.placement);
                  return ae === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ae === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((ae) => ae > 0).reduce((ae, J) => ae + J, 0)]).sort((X, ae) => X[1] - ae[1])[0]) == null ? void 0 : U[0];
              Y && (Z = Y);
              break;
            }
            case "initialPlacement":
              Z = a;
              break;
          }
        if (s !== Z)
          return {
            reset: {
              placement: Z
            }
          };
      }
      return {};
    }
  };
};
function vp(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function yp(t) {
  return WE.some((e) => t[e] >= 0);
}
const a7 = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: r,
        platform: n
      } = e, {
        strategy: s = "referenceHidden",
        ...o
      } = Dn(t, e);
      switch (s) {
        case "referenceHidden": {
          const i = await n.detectOverflow(e, {
            ...o,
            elementContext: "reference"
          }), a = vp(i, r.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: yp(a)
            }
          };
        }
        case "escaped": {
          const i = await n.detectOverflow(e, {
            ...o,
            altBoundary: !0
          }), a = vp(i, r.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: yp(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, J_ = /* @__PURE__ */ new Set(["left", "top"]);
async function l7(t, e) {
  const {
    placement: r,
    platform: n,
    elements: s
  } = t, o = await (n.isRTL == null ? void 0 : n.isRTL(s.floating)), i = Mn(r), a = Fo(r), l = Qr(r) === "y", u = J_.has(i) ? -1 : 1, c = o && l ? -1 : 1, f = Dn(e, t);
  let {
    mainAxis: g,
    crossAxis: _,
    alignmentAxis: b
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return a && typeof b == "number" && (_ = a === "end" ? b * -1 : b), l ? {
    x: _ * c,
    y: g * u
  } : {
    x: g * u,
    y: _ * c
  };
}
const u7 = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var r, n;
      const {
        x: s,
        y: o,
        placement: i,
        middlewareData: a
      } = e, l = await l7(e, t);
      return i === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: s + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: i
        }
      };
    }
  };
}, c7 = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: r,
        y: n,
        placement: s,
        platform: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: a = !1,
        limiter: l = {
          fn: (y) => {
            let {
              x: S,
              y: x
            } = y;
            return {
              x: S,
              y: x
            };
          }
        },
        ...u
      } = Dn(t, e), c = {
        x: r,
        y: n
      }, f = await o.detectOverflow(e, u), g = Qr(Mn(s)), _ = Uf(g);
      let b = c[_], p = c[g];
      if (i) {
        const y = _ === "y" ? "top" : "left", S = _ === "y" ? "bottom" : "right", x = b + f[y], P = b - f[S];
        b = Uc(x, b, P);
      }
      if (a) {
        const y = g === "y" ? "top" : "left", S = g === "y" ? "bottom" : "right", x = p + f[y], P = p - f[S];
        p = Uc(x, p, P);
      }
      const h = l.fn({
        ...e,
        [_]: b,
        [g]: p
      });
      return {
        ...h,
        data: {
          x: h.x - r,
          y: h.y - n,
          enabled: {
            [_]: i,
            [g]: a
          }
        }
      };
    }
  };
}, d7 = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: r,
        y: n,
        placement: s,
        rects: o,
        middlewareData: i
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: u = !0
      } = Dn(t, e), c = {
        x: r,
        y: n
      }, f = Qr(s), g = Uf(f);
      let _ = c[g], b = c[f];
      const p = Dn(a, e), h = typeof p == "number" ? {
        mainAxis: p,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...p
      };
      if (l) {
        const x = g === "y" ? "height" : "width", P = o.reference[g] - o.floating[x] + h.mainAxis, w = o.reference[g] + o.reference[x] - h.mainAxis;
        _ < P ? _ = P : _ > w && (_ = w);
      }
      if (u) {
        var y, S;
        const x = g === "y" ? "width" : "height", P = J_.has(Mn(s)), w = o.reference[f] - o.floating[x] + (P && ((y = i.offset) == null ? void 0 : y[f]) || 0) + (P ? 0 : h.crossAxis), C = o.reference[f] + o.reference[x] + (P ? 0 : ((S = i.offset) == null ? void 0 : S[f]) || 0) - (P ? h.crossAxis : 0);
        b < w ? b = w : b > C && (b = C);
      }
      return {
        [g]: _,
        [f]: b
      };
    }
  };
}, f7 = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var r, n;
      const {
        placement: s,
        rects: o,
        platform: i,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...u
      } = Dn(t, e), c = await i.detectOverflow(e, u), f = Mn(s), g = Fo(s), _ = Qr(s) === "y", {
        width: b,
        height: p
      } = o.floating;
      let h, y;
      f === "top" || f === "bottom" ? (h = f, y = g === (await (i.isRTL == null ? void 0 : i.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (y = f, h = g === "end" ? "top" : "bottom");
      const S = p - c.top - c.bottom, x = b - c.left - c.right, P = ns(p - c[h], S), w = ns(b - c[y], x), C = !e.middlewareData.shift;
      let k = P, $ = w;
      if ((r = e.middlewareData.shift) != null && r.enabled.x && ($ = x), (n = e.middlewareData.shift) != null && n.enabled.y && (k = S), C && !g) {
        const E = cr(c.left, 0), I = cr(c.right, 0), F = cr(c.top, 0), U = cr(c.bottom, 0);
        _ ? $ = b - 2 * (E !== 0 || I !== 0 ? E + I : cr(c.left, c.right)) : k = p - 2 * (F !== 0 || U !== 0 ? F + U : cr(c.top, c.bottom));
      }
      await l({
        ...e,
        availableWidth: $,
        availableHeight: k
      });
      const T = await i.getDimensions(a.floating);
      return b !== T.width || p !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ou() {
  return typeof window < "u";
}
function Ro(t) {
  return Z_(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function gr(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function dn(t) {
  var e;
  return (e = (Z_(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function Z_(t) {
  return ou() ? t instanceof Node || t instanceof gr(t).Node : !1;
}
function zr(t) {
  return ou() ? t instanceof Element || t instanceof gr(t).Element : !1;
}
function an(t) {
  return ou() ? t instanceof HTMLElement || t instanceof gr(t).HTMLElement : !1;
}
function bp(t) {
  return !ou() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof gr(t).ShadowRoot;
}
const h7 = /* @__PURE__ */ new Set(["inline", "contents"]);
function Bi(t) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: n,
    display: s
  } = qr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !h7.has(s);
}
const g7 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function p7(t) {
  return g7.has(Ro(t));
}
const m7 = [":popover-open", ":modal"];
function iu(t) {
  return m7.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const v7 = ["transform", "translate", "scale", "rotate", "perspective"], y7 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], b7 = ["paint", "layout", "strict", "content"];
function Hf(t) {
  const e = Gf(), r = zr(t) ? qr(t) : t;
  return v7.some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || y7.some((n) => (r.willChange || "").includes(n)) || b7.some((n) => (r.contain || "").includes(n));
}
function _7(t) {
  let e = ss(t);
  for (; an(e) && !wo(e); ) {
    if (Hf(e))
      return e;
    if (iu(e))
      return null;
    e = ss(e);
  }
  return null;
}
function Gf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const w7 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function wo(t) {
  return w7.has(Ro(t));
}
function qr(t) {
  return gr(t).getComputedStyle(t);
}
function au(t) {
  return zr(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function ss(t) {
  if (Ro(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    bp(t) && t.host || // Fallback.
    dn(t)
  );
  return bp(e) ? e.host : e;
}
function Q_(t) {
  const e = ss(t);
  return wo(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : an(e) && Bi(e) ? e : Q_(e);
}
function xi(t, e, r) {
  var n;
  e === void 0 && (e = []), r === void 0 && (r = !0);
  const s = Q_(t), o = s === ((n = t.ownerDocument) == null ? void 0 : n.body), i = gr(s);
  if (o) {
    const a = Wc(i);
    return e.concat(i, i.visualViewport || [], Bi(s) ? s : [], a && r ? xi(a) : []);
  }
  return e.concat(s, xi(s, [], r));
}
function Wc(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function e0(t) {
  const e = qr(t);
  let r = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const s = an(t), o = s ? t.offsetWidth : r, i = s ? t.offsetHeight : n, a = gl(r) !== o || gl(n) !== i;
  return a && (r = o, n = i), {
    width: r,
    height: n,
    $: a
  };
}
function Yf(t) {
  return zr(t) ? t : t.contextElement;
}
function ao(t) {
  const e = Yf(t);
  if (!an(e))
    return rn(1);
  const r = e.getBoundingClientRect(), {
    width: n,
    height: s,
    $: o
  } = e0(e);
  let i = (o ? gl(r.width) : r.width) / n, a = (o ? gl(r.height) : r.height) / s;
  return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: i,
    y: a
  };
}
const S7 = /* @__PURE__ */ rn(0);
function t0(t) {
  const e = gr(t);
  return !Gf() || !e.visualViewport ? S7 : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function x7(t, e, r) {
  return e === void 0 && (e = !1), !r || e && r !== gr(t) ? !1 : e;
}
function Bs(t, e, r, n) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  const s = t.getBoundingClientRect(), o = Yf(t);
  let i = rn(1);
  e && (n ? zr(n) && (i = ao(n)) : i = ao(t));
  const a = x7(o, r, n) ? t0(o) : rn(0);
  let l = (s.left + a.x) / i.x, u = (s.top + a.y) / i.y, c = s.width / i.x, f = s.height / i.y;
  if (o) {
    const g = gr(o), _ = n && zr(n) ? gr(n) : n;
    let b = g, p = Wc(b);
    for (; p && n && _ !== b; ) {
      const h = ao(p), y = p.getBoundingClientRect(), S = qr(p), x = y.left + (p.clientLeft + parseFloat(S.paddingLeft)) * h.x, P = y.top + (p.clientTop + parseFloat(S.paddingTop)) * h.y;
      l *= h.x, u *= h.y, c *= h.x, f *= h.y, l += x, u += P, b = gr(p), p = Wc(b);
    }
  }
  return ml({
    width: c,
    height: f,
    x: l,
    y: u
  });
}
function lu(t, e) {
  const r = au(t).scrollLeft;
  return e ? e.left + r : Bs(dn(t)).left + r;
}
function r0(t, e) {
  const r = t.getBoundingClientRect(), n = r.left + e.scrollLeft - lu(t, r), s = r.top + e.scrollTop;
  return {
    x: n,
    y: s
  };
}
function P7(t) {
  let {
    elements: e,
    rect: r,
    offsetParent: n,
    strategy: s
  } = t;
  const o = s === "fixed", i = dn(n), a = e ? iu(e.floating) : !1;
  if (n === i || a && o)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = rn(1);
  const c = rn(0), f = an(n);
  if ((f || !f && !o) && ((Ro(n) !== "body" || Bi(i)) && (l = au(n)), an(n))) {
    const _ = Bs(n);
    u = ao(n), c.x = _.x + n.clientLeft, c.y = _.y + n.clientTop;
  }
  const g = i && !f && !o ? r0(i, l) : rn(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + g.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + g.y
  };
}
function O7(t) {
  return Array.from(t.getClientRects());
}
function C7(t) {
  const e = dn(t), r = au(t), n = t.ownerDocument.body, s = cr(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), o = cr(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let i = -r.scrollLeft + lu(t);
  const a = -r.scrollTop;
  return qr(n).direction === "rtl" && (i += cr(e.clientWidth, n.clientWidth) - s), {
    width: s,
    height: o,
    x: i,
    y: a
  };
}
const _p = 25;
function k7(t, e) {
  const r = gr(t), n = dn(t), s = r.visualViewport;
  let o = n.clientWidth, i = n.clientHeight, a = 0, l = 0;
  if (s) {
    o = s.width, i = s.height;
    const c = Gf();
    (!c || c && e === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  const u = lu(n);
  if (u <= 0) {
    const c = n.ownerDocument, f = c.body, g = getComputedStyle(f), _ = c.compatMode === "CSS1Compat" && parseFloat(g.marginLeft) + parseFloat(g.marginRight) || 0, b = Math.abs(n.clientWidth - f.clientWidth - _);
    b <= _p && (o -= b);
  } else u <= _p && (o += u);
  return {
    width: o,
    height: i,
    x: a,
    y: l
  };
}
const $7 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function A7(t, e) {
  const r = Bs(t, !0, e === "fixed"), n = r.top + t.clientTop, s = r.left + t.clientLeft, o = an(t) ? ao(t) : rn(1), i = t.clientWidth * o.x, a = t.clientHeight * o.y, l = s * o.x, u = n * o.y;
  return {
    width: i,
    height: a,
    x: l,
    y: u
  };
}
function wp(t, e, r) {
  let n;
  if (e === "viewport")
    n = k7(t, r);
  else if (e === "document")
    n = C7(dn(t));
  else if (zr(e))
    n = A7(e, r);
  else {
    const s = t0(t);
    n = {
      x: e.x - s.x,
      y: e.y - s.y,
      width: e.width,
      height: e.height
    };
  }
  return ml(n);
}
function n0(t, e) {
  const r = ss(t);
  return r === e || !zr(r) || wo(r) ? !1 : qr(r).position === "fixed" || n0(r, e);
}
function E7(t, e) {
  const r = e.get(t);
  if (r)
    return r;
  let n = xi(t, [], !1).filter((a) => zr(a) && Ro(a) !== "body"), s = null;
  const o = qr(t).position === "fixed";
  let i = o ? ss(t) : t;
  for (; zr(i) && !wo(i); ) {
    const a = qr(i), l = Hf(i);
    !l && a.position === "fixed" && (s = null), (o ? !l && !s : !l && a.position === "static" && !!s && $7.has(s.position) || Bi(i) && !l && n0(t, i)) ? n = n.filter((c) => c !== i) : s = a, i = ss(i);
  }
  return e.set(t, n), n;
}
function T7(t) {
  let {
    element: e,
    boundary: r,
    rootBoundary: n,
    strategy: s
  } = t;
  const i = [...r === "clippingAncestors" ? iu(e) ? [] : E7(e, this._c) : [].concat(r), n], a = i[0], l = i.reduce((u, c) => {
    const f = wp(e, c, s);
    return u.top = cr(f.top, u.top), u.right = ns(f.right, u.right), u.bottom = ns(f.bottom, u.bottom), u.left = cr(f.left, u.left), u;
  }, wp(e, a, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function D7(t) {
  const {
    width: e,
    height: r
  } = e0(t);
  return {
    width: e,
    height: r
  };
}
function M7(t, e, r) {
  const n = an(e), s = dn(e), o = r === "fixed", i = Bs(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = rn(0);
  function u() {
    l.x = lu(s);
  }
  if (n || !n && !o)
    if ((Ro(e) !== "body" || Bi(s)) && (a = au(e)), n) {
      const _ = Bs(e, !0, o, e);
      l.x = _.x + e.clientLeft, l.y = _.y + e.clientTop;
    } else s && u();
  o && !n && s && u();
  const c = s && !n && !o ? r0(s, a) : rn(0), f = i.left + a.scrollLeft - l.x - c.x, g = i.top + a.scrollTop - l.y - c.y;
  return {
    x: f,
    y: g,
    width: i.width,
    height: i.height
  };
}
function Hu(t) {
  return qr(t).position === "static";
}
function Sp(t, e) {
  if (!an(t) || qr(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let r = t.offsetParent;
  return dn(t) === r && (r = r.ownerDocument.body), r;
}
function s0(t, e) {
  const r = gr(t);
  if (iu(t))
    return r;
  if (!an(t)) {
    let s = ss(t);
    for (; s && !wo(s); ) {
      if (zr(s) && !Hu(s))
        return s;
      s = ss(s);
    }
    return r;
  }
  let n = Sp(t, e);
  for (; n && p7(n) && Hu(n); )
    n = Sp(n, e);
  return n && wo(n) && Hu(n) && !Hf(n) ? r : n || _7(t) || r;
}
const I7 = async function(t) {
  const e = this.getOffsetParent || s0, r = this.getDimensions, n = await r(t.floating);
  return {
    reference: M7(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function N7(t) {
  return qr(t).direction === "rtl";
}
const F7 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: P7,
  getDocumentElement: dn,
  getClippingRect: T7,
  getOffsetParent: s0,
  getElementRects: I7,
  getClientRects: O7,
  getDimensions: D7,
  getScale: ao,
  isElement: zr,
  isRTL: N7
};
function o0(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function R7(t, e) {
  let r = null, n;
  const s = dn(t);
  function o() {
    var a;
    clearTimeout(n), (a = r) == null || a.disconnect(), r = null;
  }
  function i(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const u = t.getBoundingClientRect(), {
      left: c,
      top: f,
      width: g,
      height: _
    } = u;
    if (a || e(), !g || !_)
      return;
    const b = Ji(f), p = Ji(s.clientWidth - (c + g)), h = Ji(s.clientHeight - (f + _)), y = Ji(c), x = {
      rootMargin: -b + "px " + -p + "px " + -h + "px " + -y + "px",
      threshold: cr(0, ns(1, l)) || 1
    };
    let P = !0;
    function w(C) {
      const k = C[0].intersectionRatio;
      if (k !== l) {
        if (!P)
          return i();
        k ? i(!1, k) : n = setTimeout(() => {
          i(!1, 1e-7);
        }, 1e3);
      }
      k === 1 && !o0(u, t.getBoundingClientRect()) && i(), P = !1;
    }
    try {
      r = new IntersectionObserver(w, {
        ...x,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(w, x);
    }
    r.observe(t);
  }
  return i(!0), o;
}
function V7(t, e, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, u = Yf(t), c = s || o ? [...u ? xi(u) : [], ...xi(e)] : [];
  c.forEach((y) => {
    s && y.addEventListener("scroll", r, {
      passive: !0
    }), o && y.addEventListener("resize", r);
  });
  const f = u && a ? R7(u, r) : null;
  let g = -1, _ = null;
  i && (_ = new ResizeObserver((y) => {
    let [S] = y;
    S && S.target === u && _ && (_.unobserve(e), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var x;
      (x = _) == null || x.observe(e);
    })), r();
  }), u && !l && _.observe(u), _.observe(e));
  let b, p = l ? Bs(t) : null;
  l && h();
  function h() {
    const y = Bs(t);
    p && !o0(p, y) && r(), p = y, b = requestAnimationFrame(h);
  }
  return r(), () => {
    var y;
    c.forEach((S) => {
      s && S.removeEventListener("scroll", r), o && S.removeEventListener("resize", r);
    }), f?.(), (y = _) == null || y.disconnect(), _ = null, l && cancelAnimationFrame(b);
  };
}
const L7 = u7, j7 = c7, B7 = i7, z7 = f7, q7 = a7, U7 = o7, K7 = d7, W7 = (t, e, r) => {
  const n = /* @__PURE__ */ new Map(), s = {
    platform: F7,
    ...r
  }, o = {
    ...s.platform,
    _c: n
  };
  return s7(t, e, {
    ...s,
    platform: o
  });
};
function bs(t) {
  return typeof t == "function" ? t() : t;
}
function i0(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function xp(t, e) {
  const r = i0(t);
  return Math.round(e * r) / r;
}
function Hc(t) {
  return {
    [`--bits-${t}-content-transform-origin`]: "var(--bits-floating-transform-origin)",
    [`--bits-${t}-content-available-width`]: "var(--bits-floating-available-width)",
    [`--bits-${t}-content-available-height`]: "var(--bits-floating-available-height)",
    [`--bits-${t}-anchor-width`]: "var(--bits-floating-anchor-width)",
    [`--bits-${t}-anchor-height`]: "var(--bits-floating-anchor-height)"
  };
}
function H7(t) {
  const e = t.whileElementsMounted, r = /* @__PURE__ */ O(() => bs(t.open) ?? !0), n = /* @__PURE__ */ O(() => bs(t.middleware)), s = /* @__PURE__ */ O(() => bs(t.transform) ?? !0), o = /* @__PURE__ */ O(() => bs(t.placement) ?? "bottom"), i = /* @__PURE__ */ O(() => bs(t.strategy) ?? "absolute"), a = /* @__PURE__ */ O(() => bs(t.sideOffset) ?? 0), l = /* @__PURE__ */ O(() => bs(t.alignOffset) ?? 0), u = t.reference;
  let c = /* @__PURE__ */ xe(0), f = /* @__PURE__ */ xe(0);
  const g = Jr(null);
  let _ = /* @__PURE__ */ xe(Pt(d(i))), b = /* @__PURE__ */ xe(Pt(d(o))), p = /* @__PURE__ */ xe(Pt({})), h = /* @__PURE__ */ xe(!1);
  const y = /* @__PURE__ */ O(() => {
    const k = g.current ? xp(g.current, d(c)) : d(c), $ = g.current ? xp(g.current, d(f)) : d(f);
    return d(s) ? {
      position: d(_),
      left: "0",
      top: "0",
      transform: `translate(${k}px, ${$}px)`,
      ...g.current && i0(g.current) >= 1.5 && { willChange: "transform" }
    } : {
      position: d(_),
      left: `${k}px`,
      top: `${$}px`
    };
  });
  let S;
  function x() {
    u.current === null || g.current === null || W7(u.current, g.current, {
      middleware: d(n),
      placement: d(o),
      strategy: d(i)
    }).then((k) => {
      if (!d(r) && d(c) !== 0 && d(f) !== 0) {
        const $ = Math.max(Math.abs(d(a)), Math.abs(d(l)), 15);
        if (k.x <= $ && k.y <= $) return;
      }
      q(c, k.x, !0), q(f, k.y, !0), q(_, k.strategy, !0), q(b, k.placement, !0), q(p, k.middlewareData, !0), q(h, !0);
    });
  }
  function P() {
    typeof S == "function" && (S(), S = void 0);
  }
  function w() {
    if (P(), e === void 0) {
      x();
      return;
    }
    u.current === null || g.current === null || (S = e(u.current, g.current, x));
  }
  function C() {
    d(r) || q(h, !1);
  }
  return Xe(x), Xe(w), Xe(C), Xe(() => P), {
    floating: g,
    reference: u,
    get strategy() {
      return d(_);
    },
    get placement() {
      return d(b);
    },
    get middlewareData() {
      return d(p);
    },
    get isPositioned() {
      return d(h);
    },
    get floatingStyles() {
      return d(y);
    },
    get update() {
      return x;
    }
  };
}
const G7 = { top: "bottom", right: "left", bottom: "top", left: "right" }, Xf = new ht("Floating.Root"), Pp = new ht("Floating.Content"), Jf = new ht("Floating.Root");
class vl {
  static create(e = !1) {
    return e ? Jf.set(new vl()) : Xf.set(new vl());
  }
  anchorNode = Jr(null);
  customAnchorNode = Jr(null);
  triggerNode = Jr(null);
  constructor() {
    Xe(() => {
      this.customAnchorNode.current ? typeof this.customAnchorNode.current == "string" ? this.anchorNode.current = document.querySelector(this.customAnchorNode.current) : this.anchorNode.current = this.customAnchorNode.current : this.anchorNode.current = this.triggerNode.current;
    });
  }
}
class yl {
  static create(e, r = !1) {
    return r ? Pp.set(new yl(e, Jf.get())) : Pp.set(new yl(e, Xf.get()));
  }
  opts;
  root;
  // nodes
  contentRef = Jr(null);
  wrapperRef = Jr(null);
  arrowRef = Jr(null);
  contentAttachment = Te(this.contentRef);
  wrapperAttachment = Te(this.wrapperRef);
  arrowAttachment = Te(this.arrowRef);
  // ids
  arrowId = Jr(En());
  #e = /* @__PURE__ */ O(() => {
    if (typeof this.opts.style == "string") return oi(this.opts.style);
    if (!this.opts.style) return {};
  });
  #t = void 0;
  #r = new u$(() => this.arrowRef.current ?? void 0);
  #n = /* @__PURE__ */ O(() => this.#r?.width ?? 0);
  #s = /* @__PURE__ */ O(() => this.#r?.height ?? 0);
  #o = /* @__PURE__ */ O(() => this.opts.side?.current + (this.opts.align.current !== "center" ? `-${this.opts.align.current}` : ""));
  #i = /* @__PURE__ */ O(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current]);
  #a = /* @__PURE__ */ O(() => d(this.#i).length > 0);
  get hasExplicitBoundaries() {
    return d(this.#a);
  }
  set hasExplicitBoundaries(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => ({
    padding: this.opts.collisionPadding.current,
    boundary: d(this.#i).filter(D$),
    altBoundary: this.hasExplicitBoundaries
  }));
  get detectOverflowOptions() {
    return d(this.#u);
  }
  set detectOverflowOptions(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ xe(void 0);
  #c = /* @__PURE__ */ xe(void 0);
  #d = /* @__PURE__ */ xe(void 0);
  #g = /* @__PURE__ */ xe(void 0);
  #m = /* @__PURE__ */ O(() => [
    L7({
      mainAxis: this.opts.sideOffset.current + d(this.#s),
      alignmentAxis: this.opts.alignOffset.current
    }),
    this.opts.avoidCollisions.current && j7({
      mainAxis: !0,
      crossAxis: !1,
      limiter: this.opts.sticky.current === "partial" ? K7() : void 0,
      ...this.detectOverflowOptions
    }),
    this.opts.avoidCollisions.current && B7({ ...this.detectOverflowOptions }),
    z7({
      ...this.detectOverflowOptions,
      apply: ({ rects: e, availableWidth: r, availableHeight: n }) => {
        const { width: s, height: o } = e.reference;
        q(this.#l, r, !0), q(this.#c, n, !0), q(this.#d, s, !0), q(this.#g, o, !0);
      }
    }),
    this.arrowRef.current && U7({
      element: this.arrowRef.current,
      padding: this.opts.arrowPadding.current
    }),
    Y7({
      arrowWidth: d(this.#n),
      arrowHeight: d(this.#s)
    }),
    this.opts.hideWhenDetached.current && q7({ strategy: "referenceHidden", ...this.detectOverflowOptions })
  ].filter(Boolean));
  get middleware() {
    return d(this.#m);
  }
  set middleware(e) {
    q(this.#m, e);
  }
  floating;
  #p = /* @__PURE__ */ O(() => X7(this.floating.placement));
  get placedSide() {
    return d(this.#p);
  }
  set placedSide(e) {
    q(this.#p, e);
  }
  #f = /* @__PURE__ */ O(() => J7(this.floating.placement));
  get placedAlign() {
    return d(this.#f);
  }
  set placedAlign(e) {
    q(this.#f, e);
  }
  #h = /* @__PURE__ */ O(() => this.floating.middlewareData.arrow?.x ?? 0);
  get arrowX() {
    return d(this.#h);
  }
  set arrowX(e) {
    q(this.#h, e);
  }
  #b = /* @__PURE__ */ O(() => this.floating.middlewareData.arrow?.y ?? 0);
  get arrowY() {
    return d(this.#b);
  }
  set arrowY(e) {
    q(this.#b, e);
  }
  #y = /* @__PURE__ */ O(() => this.floating.middlewareData.arrow?.centerOffset !== 0);
  get cannotCenterArrow() {
    return d(this.#y);
  }
  set cannotCenterArrow(e) {
    q(this.#y, e);
  }
  #v = /* @__PURE__ */ xe();
  get contentZIndex() {
    return d(this.#v);
  }
  set contentZIndex(e) {
    q(this.#v, e, !0);
  }
  #S = /* @__PURE__ */ O(() => G7[this.placedSide]);
  get arrowBaseSide() {
    return d(this.#S);
  }
  set arrowBaseSide(e) {
    q(this.#S, e);
  }
  #w = /* @__PURE__ */ O(() => ({
    id: this.opts.wrapperId.current,
    "data-bits-floating-content-wrapper": "",
    style: {
      ...this.floating.floatingStyles,
      transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: this.contentZIndex,
      "--bits-floating-transform-origin": `${this.floating.middlewareData.transformOrigin?.x} ${this.floating.middlewareData.transformOrigin?.y}`,
      "--bits-floating-available-width": `${d(this.#l)}px`,
      "--bits-floating-available-height": `${d(this.#c)}px`,
      "--bits-floating-anchor-width": `${d(this.#d)}px`,
      "--bits-floating-anchor-height": `${d(this.#g)}px`,
      ...this.floating.middlewareData.hide?.referenceHidden && { visibility: "hidden", "pointer-events": "none" },
      ...d(this.#e)
    },
    dir: this.opts.dir.current,
    ...this.wrapperAttachment
  }));
  get wrapperProps() {
    return d(this.#w);
  }
  set wrapperProps(e) {
    q(this.#w, e);
  }
  #x = /* @__PURE__ */ O(() => ({
    "data-side": this.placedSide,
    "data-align": this.placedAlign,
    style: tu({ ...d(this.#e) }),
    ...this.contentAttachment
  }));
  get props() {
    return d(this.#x);
  }
  set props(e) {
    q(this.#x, e);
  }
  #_ = /* @__PURE__ */ O(() => ({
    position: "absolute",
    left: this.arrowX ? `${this.arrowX}px` : void 0,
    top: this.arrowY ? `${this.arrowY}px` : void 0,
    [this.arrowBaseSide]: 0,
    "transform-origin": { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[this.placedSide],
    transform: {
      top: "translateY(100%)",
      right: "translateY(50%) rotate(90deg) translateX(-50%)",
      bottom: "rotate(180deg)",
      left: "translateY(50%) rotate(-90deg) translateX(50%)"
    }[this.placedSide],
    visibility: this.cannotCenterArrow ? "hidden" : void 0
  }));
  get arrowStyle() {
    return d(this.#_);
  }
  set arrowStyle(e) {
    q(this.#_, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, e.customAnchor && (this.root.customAnchorNode.current = e.customAnchor.current), Fe(() => e.customAnchor.current, (n) => {
      this.root.customAnchorNode.current = n;
    }), this.floating = H7({
      strategy: () => this.opts.strategy.current,
      placement: () => d(this.#o),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...n) => V7(...n, {
        animationFrame: this.#t?.current === "always"
      }),
      open: () => this.opts.enabled.current,
      sideOffset: () => this.opts.sideOffset.current,
      alignOffset: () => this.opts.alignOffset.current
    }), Xe(() => {
      this.floating.isPositioned && this.opts.onPlaced?.current();
    }), Fe(() => this.contentRef.current, (n) => {
      if (!n) return;
      const s = Tb(n);
      this.contentZIndex = s.getComputedStyle(n).zIndex;
    }), Xe(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
}
class bl {
  static create(e, r = !1) {
    return r ? new bl(e, Jf.get()) : new bl(e, Xf.get());
  }
  opts;
  root;
  constructor(e, r) {
    this.opts = e, this.root = r, e.virtualEl && e.virtualEl.current ? r.triggerNode = Sb(e.virtualEl.current) : r.triggerNode = e.ref;
  }
}
function Y7(t) {
  return {
    name: "transformOrigin",
    options: t,
    fn(e) {
      const { placement: r, rects: n, middlewareData: s } = e, i = s.arrow?.centerOffset !== 0, a = i ? 0 : t.arrowWidth, l = i ? 0 : t.arrowHeight, [u, c] = Zf(r), f = { start: "0%", center: "50%", end: "100%" }[c], g = (s.arrow?.x ?? 0) + a / 2, _ = (s.arrow?.y ?? 0) + l / 2;
      let b = "", p = "";
      return u === "bottom" ? (b = i ? f : `${g}px`, p = `${-l}px`) : u === "top" ? (b = i ? f : `${g}px`, p = `${n.floating.height + l}px`) : u === "right" ? (b = `${-l}px`, p = i ? f : `${_}px`) : u === "left" && (b = `${n.floating.width + l}px`, p = i ? f : `${_}px`), { data: { x: b, y: p } };
    }
  };
}
function Zf(t) {
  const [e, r = "center"] = t.split("-");
  return [e, r];
}
function X7(t) {
  return Zf(t)[0];
}
function J7(t) {
  return Zf(t)[1];
}
function Qf(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "tooltip", 7, !1);
  vl.create(n());
  var s = {
    get children() {
      return r();
    },
    set children(a) {
      r(a), m();
    },
    get tooltip() {
      return n();
    },
    set tooltip(a = !1) {
      n(a), m();
    }
  }, o = M(), i = D(o);
  return te(i, () => r() ?? he), A(t, o), H(s);
}
K(Qf, { children: {}, tooltip: {} }, [], [], { mode: "open" });
class Z7 {
  #e;
  #t = /* @__PURE__ */ O(() => this.#e.candidateValues());
  #r;
  constructor(e) {
    this.#e = e, this.#r = Yb("", { afterMs: 1e3, getWindow: this.#e.getWindow }), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(e) {
    if (!this.#e.enabled() || !d(this.#t).length) return;
    this.#r.current = this.#r.current + e;
    const r = this.#e.getCurrentItem(), n = d(this.#t).find((a) => a === r) ?? "", s = d(this.#t).map((a) => a ?? ""), o = ef(s, this.#r.current, n), i = d(this.#t).find((a) => a === o);
    return i && this.#e.onMatch(i), i;
  }
  resetTypeahead() {
    this.#r.current = "";
  }
}
const Q7 = [dr, Mb, Mo], e2 = [Qt, Db, Do], t2 = [...Q7, ...e2], r2 = tr({
  component: "select",
  parts: [
    "trigger",
    "content",
    "item",
    "viewport",
    "scroll-up-button",
    "scroll-down-button",
    "group",
    "group-label",
    "separator",
    "arrow",
    "input",
    "content-wrapper",
    "item-text",
    "value"
  ]
}), Vo = new ht("Select.Root | Combobox.Root"), a0 = new ht("Select.Group | Combobox.Group"), uu = new ht("Select.Content | Combobox.Content");
class l0 {
  opts;
  #e = /* @__PURE__ */ xe(!1);
  get touchedInput() {
    return d(this.#e);
  }
  set touchedInput(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(null);
  get inputNode() {
    return d(this.#t);
  }
  set inputNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#r);
  }
  set contentNode(e) {
    q(this.#r, e, !0);
  }
  contentPresence;
  #n = /* @__PURE__ */ xe(null);
  get viewportNode() {
    return d(this.#n);
  }
  set viewportNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#s);
  }
  set triggerNode(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe("");
  get valueId() {
    return d(this.#o);
  }
  set valueId(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(null);
  get highlightedNode() {
    return d(this.#i);
  }
  set highlightedNode(e) {
    q(this.#i, e, !0);
  }
  #a = /* @__PURE__ */ O(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-value") : null);
  get highlightedValue() {
    return d(this.#a);
  }
  set highlightedValue(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => {
    if (this.highlightedNode)
      return this.highlightedNode.id;
  });
  get highlightedId() {
    return d(this.#u);
  }
  set highlightedId(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-label") : null);
  get highlightedLabel() {
    return d(this.#l);
  }
  set highlightedLabel(e) {
    q(this.#l, e);
  }
  isUsingKeyboard = !1;
  isCombobox = !1;
  domContext = new Fn(() => null);
  constructor(e) {
    this.opts = e, this.isCombobox = e.isCombobox, this.contentPresence = new bi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), Co(() => {
      this.opts.open.current || this.setHighlightedNode(null);
    });
  }
  setHighlightedNode(e, r = !1) {
    this.highlightedNode = e, e && (this.isUsingKeyboard || r) && e.scrollIntoView({ block: this.opts.scrollAlignment.current });
  }
  getCandidateNodes() {
    const e = this.contentNode;
    return e ? Array.from(e.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`)) : [];
  }
  setHighlightedToFirstCandidate(e = !1) {
    this.setHighlightedNode(null);
    let r = this.getCandidateNodes();
    if (r.length) {
      if (this.viewportNode) {
        const n = this.viewportNode.getBoundingClientRect();
        r = r.filter((s) => {
          if (!this.viewportNode) return !1;
          const o = s.getBoundingClientRect();
          return o.right < n.right && o.left > n.left && o.bottom < n.bottom && o.top > n.top;
        });
      }
      this.setHighlightedNode(r[0], e);
    }
  }
  getNodeByValue(e) {
    return this.getCandidateNodes().find((n) => n.dataset.value === e) ?? null;
  }
  setOpen(e) {
    this.opts.open.current = e;
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleOpen() {
    this.setOpen(!0);
  }
  handleClose() {
    this.setHighlightedNode(null), this.setOpen(!1);
  }
  toggleMenu() {
    this.toggleOpen();
  }
  getBitsAttr = (e) => r2.getAttr(e, this.isCombobox ? "combobox" : void 0);
}
class n2 extends l0 {
  opts;
  isMulti = !1;
  #e = /* @__PURE__ */ O(() => this.opts.value.current !== "");
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.opts.items.current.length ? this.opts.items.current.find((e) => e.value === this.opts.value.current)?.label ?? "" : "");
  get currentLabel() {
    return d(this.#t);
  }
  set currentLabel(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.opts.items.current.length ? this.opts.items.current.filter((r) => !r.disabled).map((r) => r.label) : []);
  get candidateLabels() {
    return d(this.#r);
  }
  set candidateLabels(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => !(this.isMulti || this.opts.items.current.length === 0));
  get dataTypeaheadEnabled() {
    return d(this.#n);
  }
  set dataTypeaheadEnabled(e) {
    q(this.#n, e);
  }
  constructor(e) {
    super(e), this.opts = e, Xe(() => {
      !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null);
    }), Fe(() => this.opts.open.current, () => {
      this.opts.open.current && this.setInitialHighlightedNode();
    });
  }
  includesItem(e) {
    return this.opts.value.current === e;
  }
  toggleItem(e, r = e) {
    const n = this.includesItem(e) ? "" : e;
    this.opts.value.current = n, n !== "" && (this.opts.inputValue.current = r);
  }
  setInitialHighlightedNode() {
    Jt(() => {
      if (!(this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode))) {
        if (this.opts.value.current !== "") {
          const e = this.getNodeByValue(this.opts.value.current);
          if (e) {
            this.setHighlightedNode(e, !0);
            return;
          }
        }
        this.setHighlightedToFirstCandidate(!0);
      }
    });
  }
}
class s2 extends l0 {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ O(() => this.opts.value.current.length > 0);
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e, Xe(() => {
      !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null);
    }), Fe(() => this.opts.open.current, () => {
      this.opts.open.current && this.setInitialHighlightedNode();
    });
  }
  includesItem(e) {
    return this.opts.value.current.includes(e);
  }
  toggleItem(e, r = e) {
    this.includesItem(e) ? this.opts.value.current = this.opts.value.current.filter((n) => n !== e) : this.opts.value.current = [...this.opts.value.current, e], this.opts.inputValue.current = r;
  }
  setInitialHighlightedNode() {
    Jt(() => {
      if (this.domContext && !(this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode))) {
        if (this.opts.value.current.length && this.opts.value.current[0] !== "") {
          const e = this.getNodeByValue(this.opts.value.current[0]);
          if (e) {
            this.setHighlightedNode(e, !0);
            return;
          }
        }
        this.setHighlightedToFirstCandidate(!0);
      }
    });
  }
}
class o2 {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new n2(n) : new s2(n);
    return Vo.set(s);
  }
}
class eh {
  static create(e) {
    return new eh(e, Vo.get());
  }
  opts;
  root;
  attachment;
  #e;
  #t;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref, (n) => this.root.triggerNode = n), this.root.domContext = new Fn(e.ref), this.#e = new fA({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (n) => {
        this.root.setHighlightedNode(n);
      },
      getActiveElement: () => this.root.domContext.getActiveElement(),
      getWindow: () => this.root.domContext.getWindow()
    }), this.#t = new Z7({
      getCurrentItem: () => this.root.isMulti ? "" : this.root.currentLabel,
      onMatch: (n) => {
        if (this.root.isMulti || !this.root.opts.items.current) return;
        const s = this.root.opts.items.current.find((o) => o.label === n);
        s && (this.root.opts.value.current = s.value);
      },
      enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled,
      candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels,
      getWindow: () => this.root.domContext.getWindow()
    }), this.onkeydown = this.onkeydown.bind(this), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onclick = this.onclick.bind(this);
  }
  #r() {
    this.root.opts.open.current = !0, this.#t.resetTypeahead(), this.#e.resetTypeahead();
  }
  #n(e) {
    this.#r();
  }
  /**
   * Logic used to handle keyboard selection/deselection.
   *
   * If it returns true, it means the item was selected and whatever is calling
   * this function should return early
   *
   */
  #s() {
    const e = this.root.highlightedValue === this.root.opts.value.current;
    return !this.root.opts.allowDeselect.current && e && !this.root.isMulti ? (this.root.handleClose(), !0) : (this.root.highlightedValue !== null && this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0), !this.root.isMulti && !e ? (this.root.handleClose(), !0) : !1);
  }
  onkeydown(e) {
    if (this.root.isUsingKeyboard = !0, (e.key === Qt || e.key === dr) && e.preventDefault(), !this.root.opts.open.current) {
      if (e.key === Br || e.key === xr || e.key === dr || e.key === Qt)
        e.preventDefault(), this.root.handleOpen();
      else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
        this.#t.handleTypeaheadSearch(e.key);
        return;
      }
      if (this.root.hasValue) return;
      const i = this.root.getCandidateNodes();
      if (!i.length) return;
      if (e.key === dr) {
        const a = i[0];
        this.root.setHighlightedNode(a);
      } else if (e.key === Qt) {
        const a = i[i.length - 1];
        this.root.setHighlightedNode(a);
      }
      return;
    }
    if (e.key === Zg) {
      this.root.handleClose();
      return;
    }
    if ((e.key === Br || // if we're currently "typing ahead", we don't want to select the item
    // just yet as the item the user is trying to get to may have a space in it,
    // so we defer handling the close for this case until further down
    e.key === xr && this.#e.search === "") && !e.isComposing && (e.preventDefault(), this.#s()))
      return;
    if (e.key === Qt && e.altKey && this.root.handleClose(), t2.includes(e.key)) {
      e.preventDefault();
      const i = this.root.getCandidateNodes(), a = this.root.highlightedNode, l = a ? i.indexOf(a) : -1, u = this.root.opts.loop.current;
      let c;
      if (e.key === dr ? c = aA(i, l, u) : e.key === Qt ? c = lA(i, l, u) : e.key === Db ? c = uA(i, l, 10, u) : e.key === Mb ? c = cA(i, l, 10, u) : e.key === Mo ? c = i[0] : e.key === Do && (c = i[i.length - 1]), !c) return;
      this.root.setHighlightedNode(c);
      return;
    }
    const r = e.ctrlKey || e.altKey || e.metaKey, n = e.key.length === 1, s = e.key === xr, o = this.root.getCandidateNodes();
    if (e.key !== Zg) {
      if (!r && (n || s)) {
        !this.#e.handleTypeaheadSearch(e.key, o) && s && (e.preventDefault(), this.#s());
        return;
      }
      this.root.highlightedNode || this.root.setHighlightedToFirstCandidate();
    }
  }
  onclick(e) {
    e.currentTarget.focus();
  }
  onpointerdown(e) {
    if (this.root.opts.disabled.current) return;
    if (e.pointerType === "touch") return e.preventDefault();
    const r = e.target;
    r?.hasPointerCapture(e.pointerId) && r?.releasePointerCapture(e.pointerId), e.button === 0 && e.ctrlKey === !1 && (this.root.opts.open.current === !1 ? this.#n(e) : this.root.handleClose());
  }
  onpointerup(e) {
    this.root.opts.disabled.current || (e.preventDefault(), e.pointerType === "touch" && (this.root.opts.open.current === !1 ? this.#n(e) : this.root.handleClose()));
  }
  #o = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    disabled: this.root.opts.disabled.current ? !0 : void 0,
    "aria-haspopup": "listbox",
    "aria-expanded": at(this.root.opts.open.current),
    "aria-activedescendant": this.root.highlightedId,
    "data-state": Vi(this.root.opts.open.current),
    "data-disabled": Re(this.root.opts.disabled.current),
    "data-placeholder": this.root.hasValue ? void 0 : "",
    [this.root.getBitsAttr("trigger")]: "",
    onpointerdown: this.onpointerdown,
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    onpointerup: this.onpointerup,
    ...this.attachment
  }));
  get props() {
    return d(this.#o);
  }
  set props(e) {
    q(this.#o, e);
  }
}
class th {
  static create(e) {
    return uu.set(new th(e, Vo.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ xe(!1);
  get isPositioned() {
    return d(this.#e);
  }
  set isPositioned(e) {
    q(this.#e, e, !0);
  }
  domContext;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref, (n) => this.root.contentNode = n), this.domContext = new Fn(this.opts.ref), this.root.domContext === null && (this.root.domContext = this.domContext), Ys(() => {
      this.root.contentNode = null, this.isPositioned = !1;
    }), Fe(() => this.root.opts.open.current, () => {
      this.root.opts.open.current || (this.isPositioned = !1);
    }), this.onpointermove = this.onpointermove.bind(this);
  }
  onpointermove(e) {
    this.root.isUsingKeyboard = !1;
  }
  #t = /* @__PURE__ */ O(() => Hc(this.root.isCombobox ? "combobox" : "select"));
  onInteractOutside = (e) => {
    if (e.target === this.root.triggerNode || e.target === this.root.inputNode) {
      e.preventDefault();
      return;
    }
    this.opts.onInteractOutside.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  #r = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#r);
  }
  set snippetProps(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "listbox",
    "aria-multiselectable": this.root.isMulti ? "true" : void 0,
    "data-state": Vi(this.root.opts.open.current),
    [this.root.getBitsAttr("content")]: "",
    style: {
      display: "flex",
      flexDirection: "column",
      outline: "none",
      boxSizing: "border-box",
      pointerEvents: "auto",
      ...d(this.#t)
    },
    onpointermove: this.onpointermove,
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onOpenAutoFocus: this.onOpenAutoFocus,
    onCloseAutoFocus: this.onCloseAutoFocus,
    trapFocus: !1,
    loop: !1,
    onPlaced: () => {
      this.root.opts.open.current && (this.isPositioned = !0);
    }
  };
}
class rh {
  static create(e) {
    return new rh(e, Vo.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root.includesItem(this.opts.value.current));
  get isSelected() {
    return d(this.#e);
  }
  set isSelected(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.root.highlightedValue === this.opts.value.current);
  get isHighlighted() {
    return d(this.#t);
  }
  set isHighlighted(e) {
    q(this.#t, e);
  }
  prevHighlighted = new c$(() => this.isHighlighted);
  #r = /* @__PURE__ */ xe(!1);
  get mounted() {
    return d(this.#r);
  }
  set mounted(e) {
    q(this.#r, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref), Fe([() => this.isHighlighted, () => this.prevHighlighted.current], () => {
      this.isHighlighted ? this.opts.onHighlight.current() : this.prevHighlighted.current && this.opts.onUnhighlight.current();
    }), Fe(() => this.mounted, () => {
      this.mounted && this.root.setInitialHighlightedNode();
    }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onpointermove = this.onpointermove.bind(this);
  }
  handleSelect() {
    if (this.opts.disabled.current) return;
    const e = this.opts.value.current === this.root.opts.value.current;
    if (!this.root.opts.allowDeselect.current && e && !this.root.isMulti) {
      this.root.handleClose();
      return;
    }
    this.root.toggleItem(this.opts.value.current, this.opts.label.current), !this.root.isMulti && !e && this.root.handleClose();
  }
  #n = /* @__PURE__ */ O(() => ({ selected: this.isSelected, highlighted: this.isHighlighted }));
  get snippetProps() {
    return d(this.#n);
  }
  set snippetProps(e) {
    q(this.#n, e);
  }
  onpointerdown(e) {
    e.preventDefault();
  }
  /**
   * Using `pointerup` instead of `click` allows power users to pointerdown
   * the trigger, then release pointerup on an item to select it vs having to do
   * multiple clicks.
   */
  onpointerup(e) {
    if (!(e.defaultPrevented || !this.opts.ref.current)) {
      if (e.pointerType === "touch" && !Rc) {
        Ye(
          this.opts.ref.current,
          "click",
          () => {
            this.handleSelect(), this.root.setHighlightedNode(this.opts.ref.current);
          },
          { once: !0 }
        );
        return;
      }
      e.preventDefault(), this.handleSelect(), e.pointerType === "touch" && this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  onpointermove(e) {
    e.pointerType !== "touch" && this.root.highlightedNode !== this.opts.ref.current && this.root.setHighlightedNode(this.opts.ref.current);
  }
  #s = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "option",
    "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0,
    "data-value": this.opts.value.current,
    "data-disabled": Re(this.opts.disabled.current),
    "data-highlighted": this.root.highlightedValue === this.opts.value.current && !this.opts.disabled.current ? "" : void 0,
    "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0,
    "data-label": this.opts.label.current,
    [this.root.getBitsAttr("item")]: "",
    onpointermove: this.onpointermove,
    onpointerdown: this.onpointerdown,
    onpointerup: this.onpointerup,
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class nh {
  static create(e) {
    return a0.set(new nh(e, Vo.get()));
  }
  opts;
  root;
  #e = /* @__PURE__ */ xe(null);
  get labelNode() {
    return d(this.#e);
  }
  set labelNode(e) {
    q(this.#e, e, !0);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "group",
    [this.root.getBitsAttr("group")]: "",
    "aria-labelledby": this.labelNode?.id ?? void 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class sh {
  static create(e) {
    return new sh(e, a0.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(e.ref, (n) => this.group.labelNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [this.group.root.getBitsAttr("group-label")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class oh {
  static create(e) {
    return new oh(e, Vo.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ O(() => this.root.opts.name.current !== "");
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    e.preventDefault(), this.root.isCombobox ? this.root.inputNode?.focus() : this.root.triggerNode?.focus();
  }
  #t = /* @__PURE__ */ O(() => ({
    disabled: yi(this.root.opts.disabled.current),
    required: yi(this.root.opts.required.current),
    name: this.root.opts.name.current,
    value: this.opts.value.current,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class ih {
  static create(e) {
    return new ih(e, uu.get());
  }
  opts;
  content;
  root;
  attachment;
  #e = /* @__PURE__ */ xe(0);
  get prevScrollTop() {
    return d(this.#e);
  }
  set prevScrollTop(e) {
    q(this.#e, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.content = r, this.root = r.root, this.attachment = Te(e.ref, (n) => {
      this.root.viewportNode = n;
    });
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "presentation",
    [this.root.getBitsAttr("viewport")]: "",
    style: {
      // we use position: 'relative' here on the `viewport` so that when we call
      // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
      // (independent of the scrollUpButton).
      position: "relative",
      flex: 1,
      overflow: "auto"
    },
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class u0 {
  opts;
  content;
  root;
  attachment;
  autoScrollTimer = null;
  userScrollTimer = -1;
  isUserScrolling = !1;
  onAutoScroll = _e;
  #e = /* @__PURE__ */ xe(!1);
  get mounted() {
    return d(this.#e);
  }
  set mounted(e) {
    q(this.#e, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.content = r, this.root = r.root, this.attachment = Te(e.ref), Fe([() => this.mounted], () => {
      if (!this.mounted) {
        this.isUserScrolling = !1;
        return;
      }
      this.isUserScrolling;
    }), Xe(() => {
      this.mounted || this.clearAutoScrollInterval();
    }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointermove = this.onpointermove.bind(this), this.onpointerleave = this.onpointerleave.bind(this);
  }
  handleUserScroll() {
    this.content.domContext.clearTimeout(this.userScrollTimer), this.isUserScrolling = !0, this.userScrollTimer = this.content.domContext.setTimeout(
      () => {
        this.isUserScrolling = !1;
      },
      200
    );
  }
  clearAutoScrollInterval() {
    this.autoScrollTimer !== null && (this.content.domContext.clearTimeout(this.autoScrollTimer), this.autoScrollTimer = null);
  }
  onpointerdown(e) {
    if (this.autoScrollTimer !== null) return;
    const r = (n) => {
      this.onAutoScroll(), this.autoScrollTimer = this.content.domContext.setTimeout(() => r(n + 1), this.opts.delay.current(n));
    };
    this.autoScrollTimer = this.content.domContext.setTimeout(() => r(1), this.opts.delay.current(0));
  }
  onpointermove(e) {
    this.onpointerdown(e);
  }
  onpointerleave(e) {
    this.clearAutoScrollInterval();
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-hidden": Kd(!0),
    style: { flexShrink: 0 },
    onpointerdown: this.onpointerdown,
    onpointermove: this.onpointermove,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class ah {
  static create(e) {
    return new ah(new u0(e, uu.get()));
  }
  scrollButtonState;
  content;
  root;
  #e = /* @__PURE__ */ xe(!1);
  get canScrollDown() {
    return d(this.#e);
  }
  set canScrollDown(e) {
    q(this.#e, e, !0);
  }
  scrollIntoViewTimer = null;
  constructor(e) {
    this.scrollButtonState = e, this.content = e.content, this.root = e.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, Fe(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!(!this.root.viewportNode || !this.content.isPositioned))
          return this.handleScroll(!0), Ye(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    ), Fe(
      [
        () => this.root.opts.inputValue.current,
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        !this.root.viewportNode || !this.content.isPositioned || this.handleScroll(!0);
      }
    ), Fe(() => this.scrollButtonState.mounted, () => {
      this.scrollButtonState.mounted && (this.scrollIntoViewTimer && clearTimeout(this.scrollIntoViewTimer), this.scrollIntoViewTimer = qd(5, () => {
        this.root.highlightedNode?.scrollIntoView({ block: this.root.opts.scrollAlignment.current });
      }));
    });
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (e = !1) => {
    if (e || this.scrollButtonState.handleUserScroll(), !this.root.viewportNode) return;
    const r = this.root.viewportNode.scrollHeight - this.root.viewportNode.clientHeight, n = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
    this.canScrollDown = Math.ceil(this.root.viewportNode.scrollTop) < r - n;
  };
  handleAutoScroll = () => {
    const e = this.root.viewportNode, r = this.root.highlightedNode;
    !e || !r || (e.scrollTop = e.scrollTop + r.offsetHeight);
  };
  #t = /* @__PURE__ */ O(() => ({
    ...this.scrollButtonState.props,
    [this.root.getBitsAttr("scroll-down-button")]: ""
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class lh {
  static create(e) {
    return new lh(new u0(e, uu.get()));
  }
  scrollButtonState;
  content;
  root;
  #e = /* @__PURE__ */ xe(!1);
  get canScrollUp() {
    return d(this.#e);
  }
  set canScrollUp(e) {
    q(this.#e, e, !0);
  }
  constructor(e) {
    this.scrollButtonState = e, this.content = e.content, this.root = e.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, Fe(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!(!this.root.viewportNode || !this.content.isPositioned))
          return this.handleScroll(!0), Ye(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    );
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (e = !1) => {
    if (e || this.scrollButtonState.handleUserScroll(), !this.root.viewportNode) return;
    const r = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
    this.canScrollUp = this.root.viewportNode.scrollTop - r > 0.1;
  };
  handleAutoScroll = () => {
    !this.root.viewportNode || !this.root.highlightedNode || (this.root.viewportNode.scrollTop = this.root.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight);
  };
  #t = /* @__PURE__ */ O(() => ({
    ...this.scrollButtonState.props,
    [this.root.getBitsAttr("scroll-up-button")]: ""
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function Ya(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "autocomplete", 7);
  const s = oh.create({ value: z(() => r()) });
  var o = {
    get value() {
      return r();
    },
    set value(u) {
      r(u), m();
    },
    get autocomplete() {
      return n();
    },
    set autocomplete(u) {
      n(u), m();
    }
  }, i = M(), a = D(i);
  {
    var l = (u) => {
      ji(u, ce(() => s.props, {
        get autocomplete() {
          return n();
        },
        get value() {
          return r();
        },
        set value(c) {
          r(c);
        }
      }));
    };
    ue(a, (u) => {
      s.shouldRender && u(l);
    });
  }
  return A(t, i), H(o);
}
K(Ya, { value: {}, autocomplete: {} }, [], [], { mode: "open" });
function uh(t, e) {
  W(e, !0);
  let r = v(e, "id", 7), n = v(e, "children", 7), s = v(e, "virtualEl", 7), o = v(e, "ref", 7), i = v(e, "tooltip", 7, !1);
  bl.create(
    {
      id: z(() => r()),
      virtualEl: z(() => s()),
      ref: o()
    },
    i()
  );
  var a = {
    get id() {
      return r();
    },
    set id(c) {
      r(c), m();
    },
    get children() {
      return n();
    },
    set children(c) {
      n(c), m();
    },
    get virtualEl() {
      return s();
    },
    set virtualEl(c) {
      s(c), m();
    },
    get ref() {
      return o();
    },
    set ref(c) {
      o(c), m();
    },
    get tooltip() {
      return i();
    },
    set tooltip(c = !1) {
      i(c), m();
    }
  }, l = M(), u = D(l);
  return te(u, () => n() ?? he), A(t, l), H(a);
}
K(uh, { id: {}, children: {}, virtualEl: {}, ref: {}, tooltip: {} }, [], [], { mode: "open" });
function c0(t, e) {
  W(e, !0);
  let r = v(e, "content", 7), n = v(e, "side", 7, "bottom"), s = v(e, "sideOffset", 7, 0), o = v(e, "align", 7, "center"), i = v(e, "alignOffset", 7, 0), a = v(e, "id", 7), l = v(e, "arrowPadding", 7, 0), u = v(e, "avoidCollisions", 7, !0), c = v(e, "collisionBoundary", 23, () => []), f = v(e, "collisionPadding", 7, 0), g = v(e, "hideWhenDetached", 7, !1), _ = v(e, "onPlaced", 7, () => {
  }), b = v(e, "sticky", 7, "partial"), p = v(e, "updatePositionStrategy", 7, "optimized"), h = v(e, "strategy", 7, "fixed"), y = v(e, "dir", 7, "ltr"), S = v(e, "style", 23, () => ({})), x = v(e, "wrapperId", 23, En), P = v(e, "customAnchor", 7, null), w = v(e, "enabled", 7), C = v(e, "tooltip", 7, !1);
  const k = yl.create(
    {
      side: z(() => n()),
      sideOffset: z(() => s()),
      align: z(() => o()),
      alignOffset: z(() => i()),
      id: z(() => a()),
      arrowPadding: z(() => l()),
      avoidCollisions: z(() => u()),
      collisionBoundary: z(() => c()),
      collisionPadding: z(() => f()),
      hideWhenDetached: z(() => g()),
      onPlaced: z(() => _()),
      sticky: z(() => b()),
      updatePositionStrategy: z(() => p()),
      strategy: z(() => h()),
      dir: z(() => y()),
      style: z(() => S()),
      enabled: z(() => w()),
      wrapperId: z(() => x()),
      customAnchor: z(() => P())
    },
    C()
  ), $ = /* @__PURE__ */ O(() => Ce(k.wrapperProps, { style: { pointerEvents: "auto" } }));
  var T = {
    get content() {
      return r();
    },
    set content(F) {
      r(F), m();
    },
    get side() {
      return n();
    },
    set side(F = "bottom") {
      n(F), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(F = 0) {
      s(F), m();
    },
    get align() {
      return o();
    },
    set align(F = "center") {
      o(F), m();
    },
    get alignOffset() {
      return i();
    },
    set alignOffset(F = 0) {
      i(F), m();
    },
    get id() {
      return a();
    },
    set id(F) {
      a(F), m();
    },
    get arrowPadding() {
      return l();
    },
    set arrowPadding(F = 0) {
      l(F), m();
    },
    get avoidCollisions() {
      return u();
    },
    set avoidCollisions(F = !0) {
      u(F), m();
    },
    get collisionBoundary() {
      return c();
    },
    set collisionBoundary(F = []) {
      c(F), m();
    },
    get collisionPadding() {
      return f();
    },
    set collisionPadding(F = 0) {
      f(F), m();
    },
    get hideWhenDetached() {
      return g();
    },
    set hideWhenDetached(F = !1) {
      g(F), m();
    },
    get onPlaced() {
      return _();
    },
    set onPlaced(F = () => {
    }) {
      _(F), m();
    },
    get sticky() {
      return b();
    },
    set sticky(F = "partial") {
      b(F), m();
    },
    get updatePositionStrategy() {
      return p();
    },
    set updatePositionStrategy(F = "optimized") {
      p(F), m();
    },
    get strategy() {
      return h();
    },
    set strategy(F = "fixed") {
      h(F), m();
    },
    get dir() {
      return y();
    },
    set dir(F = "ltr") {
      y(F), m();
    },
    get style() {
      return S();
    },
    set style(F = {}) {
      S(F), m();
    },
    get wrapperId() {
      return x();
    },
    set wrapperId(F = En()) {
      x(F), m();
    },
    get customAnchor() {
      return P();
    },
    set customAnchor(F = null) {
      P(F), m();
    },
    get enabled() {
      return w();
    },
    set enabled(F) {
      w(F), m();
    },
    get tooltip() {
      return C();
    },
    set tooltip(F = !1) {
      C(F), m();
    }
  }, E = M(), I = D(E);
  return te(I, () => r() ?? he, () => ({ props: k.props, wrapperProps: d($) })), A(t, E), H(T);
}
K(
  c0,
  {
    content: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    id: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    hideWhenDetached: {},
    onPlaced: {},
    sticky: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    style: {},
    wrapperId: {},
    customAnchor: {},
    enabled: {},
    tooltip: {}
  },
  [],
  [],
  { mode: "open" }
);
function d0(t, e) {
  W(e, !0);
  let r = v(e, "content", 7), n = v(e, "onPlaced", 7);
  ko(() => {
    n()?.();
  });
  var s = {
    get content() {
      return r();
    },
    set content(a) {
      r(a), m();
    },
    get onPlaced() {
      return n();
    },
    set onPlaced(a) {
      n(a), m();
    }
  }, o = M(), i = D(o);
  return te(i, () => r() ?? he, () => ({ props: {}, wrapperProps: {} })), A(t, o), H(s);
}
K(d0, { content: {}, onPlaced: {} }, [], [], { mode: "open" });
const i2 = tr({ component: "separator", parts: ["root"] });
class ch {
  static create(e) {
    return new ch(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: this.opts.decorative.current ? "none" : "separator",
    "aria-orientation": this.opts.orientation.current,
    "aria-hidden": Kd(this.opts.decorative.current),
    "data-orientation": this.opts.orientation.current,
    [i2.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var a2 = /* @__PURE__ */ ne("<div><!></div>");
function f0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "decorative", 7, !1), l = v(e, "orientation", 7, "horizontal"), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "decorative",
    "orientation"
  ]);
  const c = ch.create({
    ref: z(() => s(), (y) => s(y)),
    id: z(() => n()),
    decorative: z(() => a()),
    orientation: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var g = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get ref() {
      return s();
    },
    set ref(y = null) {
      s(y), m();
    },
    get child() {
      return o();
    },
    set child(y) {
      o(y), m();
    },
    get children() {
      return i();
    },
    set children(y) {
      i(y), m();
    },
    get decorative() {
      return a();
    },
    set decorative(y = !1) {
      a(y), m();
    },
    get orientation() {
      return l();
    },
    set orientation(y = "horizontal") {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      te(x, o, () => ({ props: d(f) })), A(y, S);
    }, h = (y) => {
      var S = a2();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => i() ?? he), de(S), A(y, S);
    };
    ue(b, (y) => {
      o() ? y(p) : y(h, !1);
    });
  }
  return A(t, _), H(g);
}
K(
  f0,
  {
    id: {},
    ref: {},
    child: {},
    children: {},
    decorative: {},
    orientation: {}
  },
  [],
  [],
  { mode: "open" }
);
function h0(t, e) {
  W(e, !0);
  let r = v(e, "content", 7), n = v(e, "isStatic", 7, !1), s = v(e, "onPlaced", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "content",
    "isStatic",
    "onPlaced"
  ]);
  var i = {
    get content() {
      return r();
    },
    set content(f) {
      r(f), m();
    },
    get isStatic() {
      return n();
    },
    set isStatic(f = !1) {
      n(f), m();
    },
    get onPlaced() {
      return s();
    },
    set onPlaced(f) {
      s(f), m();
    }
  }, a = M(), l = D(a);
  {
    var u = (f) => {
      d0(f, {
        get content() {
          return r();
        },
        get onPlaced() {
          return s();
        }
      });
    }, c = (f) => {
      c0(f, ce(
        {
          get content() {
            return r();
          },
          get onPlaced() {
            return s();
          }
        },
        () => o
      ));
    };
    ue(l, (f) => {
      n() ? f(u) : f(c, !1);
    });
  }
  return A(t, a), H(i);
}
K(h0, { content: {}, isStatic: {}, onPlaced: {} }, [], [], { mode: "open" });
var l2 = /* @__PURE__ */ ne("<!> <!>", 1);
function dh(t, e) {
  W(e, !0);
  let r = v(e, "popper", 7), n = v(e, "onEscapeKeydown", 7), s = v(e, "escapeKeydownBehavior", 7), o = v(e, "preventOverflowTextSelection", 7), i = v(e, "id", 7), a = v(e, "onPointerDown", 7), l = v(e, "onPointerUp", 7), u = v(e, "side", 7), c = v(e, "sideOffset", 7), f = v(e, "align", 7), g = v(e, "alignOffset", 7), _ = v(e, "arrowPadding", 7), b = v(e, "avoidCollisions", 7), p = v(e, "collisionBoundary", 7), h = v(e, "collisionPadding", 7), y = v(e, "sticky", 7), S = v(e, "hideWhenDetached", 7), x = v(e, "updatePositionStrategy", 7), P = v(e, "strategy", 7), w = v(e, "dir", 7), C = v(e, "preventScroll", 7), k = v(e, "wrapperId", 7), $ = v(e, "style", 7), T = v(e, "onPlaced", 7), E = v(e, "onInteractOutside", 7), I = v(e, "onCloseAutoFocus", 7), F = v(e, "onOpenAutoFocus", 7), U = v(e, "onFocusOutside", 7), B = v(e, "interactOutsideBehavior", 7, "close"), R = v(e, "loop", 7), Z = v(e, "trapFocus", 7, !0), Y = v(e, "isValidEvent", 7, () => !1), X = v(e, "customAnchor", 7, null), ae = v(e, "isStatic", 7, !1), J = v(e, "enabled", 7), j = v(e, "ref", 7), ee = v(e, "tooltip", 7, !1), L = v(e, "contentPointerEvents", 7, "auto"), N = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled",
    "ref",
    "tooltip",
    "contentPointerEvents"
  ]);
  var V = {
    get popper() {
      return r();
    },
    set popper(G) {
      r(G), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(G) {
      n(G), m();
    },
    get escapeKeydownBehavior() {
      return s();
    },
    set escapeKeydownBehavior(G) {
      s(G), m();
    },
    get preventOverflowTextSelection() {
      return o();
    },
    set preventOverflowTextSelection(G) {
      o(G), m();
    },
    get id() {
      return i();
    },
    set id(G) {
      i(G), m();
    },
    get onPointerDown() {
      return a();
    },
    set onPointerDown(G) {
      a(G), m();
    },
    get onPointerUp() {
      return l();
    },
    set onPointerUp(G) {
      l(G), m();
    },
    get side() {
      return u();
    },
    set side(G) {
      u(G), m();
    },
    get sideOffset() {
      return c();
    },
    set sideOffset(G) {
      c(G), m();
    },
    get align() {
      return f();
    },
    set align(G) {
      f(G), m();
    },
    get alignOffset() {
      return g();
    },
    set alignOffset(G) {
      g(G), m();
    },
    get arrowPadding() {
      return _();
    },
    set arrowPadding(G) {
      _(G), m();
    },
    get avoidCollisions() {
      return b();
    },
    set avoidCollisions(G) {
      b(G), m();
    },
    get collisionBoundary() {
      return p();
    },
    set collisionBoundary(G) {
      p(G), m();
    },
    get collisionPadding() {
      return h();
    },
    set collisionPadding(G) {
      h(G), m();
    },
    get sticky() {
      return y();
    },
    set sticky(G) {
      y(G), m();
    },
    get hideWhenDetached() {
      return S();
    },
    set hideWhenDetached(G) {
      S(G), m();
    },
    get updatePositionStrategy() {
      return x();
    },
    set updatePositionStrategy(G) {
      x(G), m();
    },
    get strategy() {
      return P();
    },
    set strategy(G) {
      P(G), m();
    },
    get dir() {
      return w();
    },
    set dir(G) {
      w(G), m();
    },
    get preventScroll() {
      return C();
    },
    set preventScroll(G) {
      C(G), m();
    },
    get wrapperId() {
      return k();
    },
    set wrapperId(G) {
      k(G), m();
    },
    get style() {
      return $();
    },
    set style(G) {
      $(G), m();
    },
    get onPlaced() {
      return T();
    },
    set onPlaced(G) {
      T(G), m();
    },
    get onInteractOutside() {
      return E();
    },
    set onInteractOutside(G) {
      E(G), m();
    },
    get onCloseAutoFocus() {
      return I();
    },
    set onCloseAutoFocus(G) {
      I(G), m();
    },
    get onOpenAutoFocus() {
      return F();
    },
    set onOpenAutoFocus(G) {
      F(G), m();
    },
    get onFocusOutside() {
      return U();
    },
    set onFocusOutside(G) {
      U(G), m();
    },
    get interactOutsideBehavior() {
      return B();
    },
    set interactOutsideBehavior(G = "close") {
      B(G), m();
    },
    get loop() {
      return R();
    },
    set loop(G) {
      R(G), m();
    },
    get trapFocus() {
      return Z();
    },
    set trapFocus(G = !0) {
      Z(G), m();
    },
    get isValidEvent() {
      return Y();
    },
    set isValidEvent(G = () => !1) {
      Y(G), m();
    },
    get customAnchor() {
      return X();
    },
    set customAnchor(G = null) {
      X(G), m();
    },
    get isStatic() {
      return ae();
    },
    set isStatic(G = !1) {
      ae(G), m();
    },
    get enabled() {
      return J();
    },
    set enabled(G) {
      J(G), m();
    },
    get ref() {
      return j();
    },
    set ref(G) {
      j(G), m();
    },
    get tooltip() {
      return ee();
    },
    set tooltip(G = !1) {
      ee(G), m();
    },
    get contentPointerEvents() {
      return L();
    },
    set contentPointerEvents(G = "auto") {
      L(G), m();
    }
  };
  return h0(t, {
    get isStatic() {
      return ae();
    },
    get id() {
      return i();
    },
    get side() {
      return u();
    },
    get sideOffset() {
      return c();
    },
    get align() {
      return f();
    },
    get alignOffset() {
      return g();
    },
    get arrowPadding() {
      return _();
    },
    get avoidCollisions() {
      return b();
    },
    get collisionBoundary() {
      return p();
    },
    get collisionPadding() {
      return h();
    },
    get sticky() {
      return y();
    },
    get hideWhenDetached() {
      return S();
    },
    get updatePositionStrategy() {
      return x();
    },
    get strategy() {
      return P();
    },
    get dir() {
      return w();
    },
    get wrapperId() {
      return k();
    },
    get style() {
      return $();
    },
    get onPlaced() {
      return T();
    },
    get customAnchor() {
      return X();
    },
    get enabled() {
      return J();
    },
    get tooltip() {
      return ee();
    },
    content: (fe, se) => {
      let we = () => se?.().props, le = () => se?.().wrapperProps;
      var re = l2(), oe = D(re);
      {
        var pe = (Oe) => {
          _i(Oe, {
            get preventScroll() {
              return C();
            }
          });
        }, ye = (Oe) => {
          var Ve = M(), Ke = D(Ve);
          {
            var Le = (je) => {
              _i(je, {
                get preventScroll() {
                  return C();
                }
              });
            };
            ue(
              Ke,
              (je) => {
                e.forceMount || je(Le);
              },
              !0
            );
          }
          A(Oe, Ve);
        };
        ue(oe, (Oe) => {
          e.forceMount && J() ? Oe(pe) : Oe(ye, !1);
        });
      }
      var Pe = be(oe, 2);
      lf(Pe, {
        get onOpenAutoFocus() {
          return F();
        },
        get onCloseAutoFocus() {
          return I();
        },
        get loop() {
          return R();
        },
        get enabled() {
          return J();
        },
        get trapFocus() {
          return Z();
        },
        get forceMount() {
          return e.forceMount;
        },
        get ref() {
          return j();
        },
        focusScope: (Ve, Ke) => {
          let Le = () => Ke?.().props;
          sf(Ve, {
            get onEscapeKeydown() {
              return n();
            },
            get escapeKeydownBehavior() {
              return s();
            },
            get enabled() {
              return J();
            },
            get ref() {
              return j();
            },
            children: (je, We) => {
              rf(je, {
                get id() {
                  return i();
                },
                get onInteractOutside() {
                  return E();
                },
                get onFocusOutside() {
                  return U();
                },
                get interactOutsideBehavior() {
                  return B();
                },
                get isValidEvent() {
                  return Y();
                },
                get enabled() {
                  return J();
                },
                get ref() {
                  return j();
                },
                children: (Ze, $t) => {
                  let lt = () => $t?.().props;
                  cf(Ze, {
                    get id() {
                      return i();
                    },
                    get preventOverflowTextSelection() {
                      return o();
                    },
                    get onPointerDown() {
                      return a();
                    },
                    get onPointerUp() {
                      return l();
                    },
                    get enabled() {
                      return J();
                    },
                    get ref() {
                      return j();
                    },
                    children: (ct, pt) => {
                      var Kt = M(), vt = D(Kt);
                      {
                        let Vt = /* @__PURE__ */ O(() => ({
                          props: Ce(N, we(), lt(), Le(), { style: { pointerEvents: L() } }),
                          wrapperProps: le()
                        }));
                        te(vt, () => r() ?? he, () => d(Vt));
                      }
                      A(ct, Kt);
                    },
                    $$slots: { default: !0 }
                  });
                },
                $$slots: { default: !0 }
              });
            },
            $$slots: { default: !0 }
          });
        },
        $$slots: { focusScope: !0 }
      }), A(fe, re);
    },
    $$slots: { content: !0 }
  }), H(V);
}
K(
  dh,
  {
    popper: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    enabled: {},
    ref: {},
    tooltip: {},
    contentPointerEvents: {}
  },
  [],
  [],
  { mode: "open" }
);
function fh(t, e) {
  W(e, !0);
  let r = v(e, "popper", 7), n = v(e, "open", 7), s = v(e, "onEscapeKeydown", 7), o = v(e, "escapeKeydownBehavior", 7), i = v(e, "preventOverflowTextSelection", 7), a = v(e, "id", 7), l = v(e, "onPointerDown", 7), u = v(e, "onPointerUp", 7), c = v(e, "side", 7), f = v(e, "sideOffset", 7), g = v(e, "align", 7), _ = v(e, "alignOffset", 7), b = v(e, "arrowPadding", 7), p = v(e, "avoidCollisions", 7), h = v(e, "collisionBoundary", 7), y = v(e, "collisionPadding", 7), S = v(e, "sticky", 7), x = v(e, "hideWhenDetached", 7), P = v(e, "updatePositionStrategy", 7), w = v(e, "strategy", 7), C = v(e, "dir", 7), k = v(e, "preventScroll", 7), $ = v(e, "wrapperId", 7), T = v(e, "style", 7), E = v(e, "onPlaced", 7), I = v(e, "onInteractOutside", 7), F = v(e, "onCloseAutoFocus", 7), U = v(e, "onOpenAutoFocus", 7), B = v(e, "onFocusOutside", 7), R = v(e, "interactOutsideBehavior", 7, "close"), Z = v(e, "loop", 7), Y = v(e, "trapFocus", 7, !0), X = v(e, "isValidEvent", 7, () => !1), ae = v(e, "customAnchor", 7, null), J = v(e, "isStatic", 7, !1), j = v(e, "ref", 7), ee = v(e, "shouldRender", 7), L = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "open",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "ref",
    "shouldRender"
  ]);
  var N = {
    get popper() {
      return r();
    },
    set popper(se) {
      r(se), m();
    },
    get open() {
      return n();
    },
    set open(se) {
      n(se), m();
    },
    get onEscapeKeydown() {
      return s();
    },
    set onEscapeKeydown(se) {
      s(se), m();
    },
    get escapeKeydownBehavior() {
      return o();
    },
    set escapeKeydownBehavior(se) {
      o(se), m();
    },
    get preventOverflowTextSelection() {
      return i();
    },
    set preventOverflowTextSelection(se) {
      i(se), m();
    },
    get id() {
      return a();
    },
    set id(se) {
      a(se), m();
    },
    get onPointerDown() {
      return l();
    },
    set onPointerDown(se) {
      l(se), m();
    },
    get onPointerUp() {
      return u();
    },
    set onPointerUp(se) {
      u(se), m();
    },
    get side() {
      return c();
    },
    set side(se) {
      c(se), m();
    },
    get sideOffset() {
      return f();
    },
    set sideOffset(se) {
      f(se), m();
    },
    get align() {
      return g();
    },
    set align(se) {
      g(se), m();
    },
    get alignOffset() {
      return _();
    },
    set alignOffset(se) {
      _(se), m();
    },
    get arrowPadding() {
      return b();
    },
    set arrowPadding(se) {
      b(se), m();
    },
    get avoidCollisions() {
      return p();
    },
    set avoidCollisions(se) {
      p(se), m();
    },
    get collisionBoundary() {
      return h();
    },
    set collisionBoundary(se) {
      h(se), m();
    },
    get collisionPadding() {
      return y();
    },
    set collisionPadding(se) {
      y(se), m();
    },
    get sticky() {
      return S();
    },
    set sticky(se) {
      S(se), m();
    },
    get hideWhenDetached() {
      return x();
    },
    set hideWhenDetached(se) {
      x(se), m();
    },
    get updatePositionStrategy() {
      return P();
    },
    set updatePositionStrategy(se) {
      P(se), m();
    },
    get strategy() {
      return w();
    },
    set strategy(se) {
      w(se), m();
    },
    get dir() {
      return C();
    },
    set dir(se) {
      C(se), m();
    },
    get preventScroll() {
      return k();
    },
    set preventScroll(se) {
      k(se), m();
    },
    get wrapperId() {
      return $();
    },
    set wrapperId(se) {
      $(se), m();
    },
    get style() {
      return T();
    },
    set style(se) {
      T(se), m();
    },
    get onPlaced() {
      return E();
    },
    set onPlaced(se) {
      E(se), m();
    },
    get onInteractOutside() {
      return I();
    },
    set onInteractOutside(se) {
      I(se), m();
    },
    get onCloseAutoFocus() {
      return F();
    },
    set onCloseAutoFocus(se) {
      F(se), m();
    },
    get onOpenAutoFocus() {
      return U();
    },
    set onOpenAutoFocus(se) {
      U(se), m();
    },
    get onFocusOutside() {
      return B();
    },
    set onFocusOutside(se) {
      B(se), m();
    },
    get interactOutsideBehavior() {
      return R();
    },
    set interactOutsideBehavior(se = "close") {
      R(se), m();
    },
    get loop() {
      return Z();
    },
    set loop(se) {
      Z(se), m();
    },
    get trapFocus() {
      return Y();
    },
    set trapFocus(se = !0) {
      Y(se), m();
    },
    get isValidEvent() {
      return X();
    },
    set isValidEvent(se = () => !1) {
      X(se), m();
    },
    get customAnchor() {
      return ae();
    },
    set customAnchor(se = null) {
      ae(se), m();
    },
    get isStatic() {
      return J();
    },
    set isStatic(se = !1) {
      J(se), m();
    },
    get ref() {
      return j();
    },
    set ref(se) {
      j(se), m();
    },
    get shouldRender() {
      return ee();
    },
    set shouldRender(se) {
      ee(se), m();
    }
  }, V = M(), G = D(V);
  {
    var fe = (se) => {
      dh(se, ce(
        {
          get popper() {
            return r();
          },
          get onEscapeKeydown() {
            return s();
          },
          get escapeKeydownBehavior() {
            return o();
          },
          get preventOverflowTextSelection() {
            return i();
          },
          get id() {
            return a();
          },
          get onPointerDown() {
            return l();
          },
          get onPointerUp() {
            return u();
          },
          get side() {
            return c();
          },
          get sideOffset() {
            return f();
          },
          get align() {
            return g();
          },
          get alignOffset() {
            return _();
          },
          get arrowPadding() {
            return b();
          },
          get avoidCollisions() {
            return p();
          },
          get collisionBoundary() {
            return h();
          },
          get collisionPadding() {
            return y();
          },
          get sticky() {
            return S();
          },
          get hideWhenDetached() {
            return x();
          },
          get updatePositionStrategy() {
            return P();
          },
          get strategy() {
            return w();
          },
          get dir() {
            return C();
          },
          get preventScroll() {
            return k();
          },
          get wrapperId() {
            return $();
          },
          get style() {
            return T();
          },
          get onPlaced() {
            return E();
          },
          get customAnchor() {
            return ae();
          },
          get isStatic() {
            return J();
          },
          get enabled() {
            return n();
          },
          get onInteractOutside() {
            return I();
          },
          get onCloseAutoFocus() {
            return F();
          },
          get onOpenAutoFocus() {
            return U();
          },
          get interactOutsideBehavior() {
            return R();
          },
          get loop() {
            return Z();
          },
          get trapFocus() {
            return Y();
          },
          get isValidEvent() {
            return X();
          },
          get onFocusOutside() {
            return B();
          },
          forceMount: !1,
          get ref() {
            return j();
          }
        },
        () => L
      ));
    };
    ue(G, (se) => {
      ee() && se(fe);
    });
  }
  return A(t, V), H(N);
}
K(
  fh,
  {
    popper: {},
    open: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    ref: {},
    shouldRender: {}
  },
  [],
  [],
  { mode: "open" }
);
function hh(t, e) {
  W(e, !0);
  let r = v(e, "popper", 7), n = v(e, "onEscapeKeydown", 7), s = v(e, "escapeKeydownBehavior", 7), o = v(e, "preventOverflowTextSelection", 7), i = v(e, "id", 7), a = v(e, "onPointerDown", 7), l = v(e, "onPointerUp", 7), u = v(e, "side", 7), c = v(e, "sideOffset", 7), f = v(e, "align", 7), g = v(e, "alignOffset", 7), _ = v(e, "arrowPadding", 7), b = v(e, "avoidCollisions", 7), p = v(e, "collisionBoundary", 7), h = v(e, "collisionPadding", 7), y = v(e, "sticky", 7), S = v(e, "hideWhenDetached", 7), x = v(e, "updatePositionStrategy", 7), P = v(e, "strategy", 7), w = v(e, "dir", 7), C = v(e, "preventScroll", 7), k = v(e, "wrapperId", 7), $ = v(e, "style", 7), T = v(e, "onPlaced", 7), E = v(e, "onInteractOutside", 7), I = v(e, "onCloseAutoFocus", 7), F = v(e, "onOpenAutoFocus", 7), U = v(e, "onFocusOutside", 7), B = v(e, "interactOutsideBehavior", 7, "close"), R = v(e, "loop", 7), Z = v(e, "trapFocus", 7, !0), Y = v(e, "isValidEvent", 7, () => !1), X = v(e, "customAnchor", 7, null), ae = v(e, "isStatic", 7, !1), J = v(e, "enabled", 7), j = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled"
  ]);
  var ee = {
    get popper() {
      return r();
    },
    set popper(L) {
      r(L), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(L) {
      n(L), m();
    },
    get escapeKeydownBehavior() {
      return s();
    },
    set escapeKeydownBehavior(L) {
      s(L), m();
    },
    get preventOverflowTextSelection() {
      return o();
    },
    set preventOverflowTextSelection(L) {
      o(L), m();
    },
    get id() {
      return i();
    },
    set id(L) {
      i(L), m();
    },
    get onPointerDown() {
      return a();
    },
    set onPointerDown(L) {
      a(L), m();
    },
    get onPointerUp() {
      return l();
    },
    set onPointerUp(L) {
      l(L), m();
    },
    get side() {
      return u();
    },
    set side(L) {
      u(L), m();
    },
    get sideOffset() {
      return c();
    },
    set sideOffset(L) {
      c(L), m();
    },
    get align() {
      return f();
    },
    set align(L) {
      f(L), m();
    },
    get alignOffset() {
      return g();
    },
    set alignOffset(L) {
      g(L), m();
    },
    get arrowPadding() {
      return _();
    },
    set arrowPadding(L) {
      _(L), m();
    },
    get avoidCollisions() {
      return b();
    },
    set avoidCollisions(L) {
      b(L), m();
    },
    get collisionBoundary() {
      return p();
    },
    set collisionBoundary(L) {
      p(L), m();
    },
    get collisionPadding() {
      return h();
    },
    set collisionPadding(L) {
      h(L), m();
    },
    get sticky() {
      return y();
    },
    set sticky(L) {
      y(L), m();
    },
    get hideWhenDetached() {
      return S();
    },
    set hideWhenDetached(L) {
      S(L), m();
    },
    get updatePositionStrategy() {
      return x();
    },
    set updatePositionStrategy(L) {
      x(L), m();
    },
    get strategy() {
      return P();
    },
    set strategy(L) {
      P(L), m();
    },
    get dir() {
      return w();
    },
    set dir(L) {
      w(L), m();
    },
    get preventScroll() {
      return C();
    },
    set preventScroll(L) {
      C(L), m();
    },
    get wrapperId() {
      return k();
    },
    set wrapperId(L) {
      k(L), m();
    },
    get style() {
      return $();
    },
    set style(L) {
      $(L), m();
    },
    get onPlaced() {
      return T();
    },
    set onPlaced(L) {
      T(L), m();
    },
    get onInteractOutside() {
      return E();
    },
    set onInteractOutside(L) {
      E(L), m();
    },
    get onCloseAutoFocus() {
      return I();
    },
    set onCloseAutoFocus(L) {
      I(L), m();
    },
    get onOpenAutoFocus() {
      return F();
    },
    set onOpenAutoFocus(L) {
      F(L), m();
    },
    get onFocusOutside() {
      return U();
    },
    set onFocusOutside(L) {
      U(L), m();
    },
    get interactOutsideBehavior() {
      return B();
    },
    set interactOutsideBehavior(L = "close") {
      B(L), m();
    },
    get loop() {
      return R();
    },
    set loop(L) {
      R(L), m();
    },
    get trapFocus() {
      return Z();
    },
    set trapFocus(L = !0) {
      Z(L), m();
    },
    get isValidEvent() {
      return Y();
    },
    set isValidEvent(L = () => !1) {
      Y(L), m();
    },
    get customAnchor() {
      return X();
    },
    set customAnchor(L = null) {
      X(L), m();
    },
    get isStatic() {
      return ae();
    },
    set isStatic(L = !1) {
      ae(L), m();
    },
    get enabled() {
      return J();
    },
    set enabled(L) {
      J(L), m();
    }
  };
  return dh(t, ce(
    {
      get popper() {
        return r();
      },
      get onEscapeKeydown() {
        return n();
      },
      get escapeKeydownBehavior() {
        return s();
      },
      get preventOverflowTextSelection() {
        return o();
      },
      get id() {
        return i();
      },
      get onPointerDown() {
        return a();
      },
      get onPointerUp() {
        return l();
      },
      get side() {
        return u();
      },
      get sideOffset() {
        return c();
      },
      get align() {
        return f();
      },
      get alignOffset() {
        return g();
      },
      get arrowPadding() {
        return _();
      },
      get avoidCollisions() {
        return b();
      },
      get collisionBoundary() {
        return p();
      },
      get collisionPadding() {
        return h();
      },
      get sticky() {
        return y();
      },
      get hideWhenDetached() {
        return S();
      },
      get updatePositionStrategy() {
        return x();
      },
      get strategy() {
        return P();
      },
      get dir() {
        return w();
      },
      get preventScroll() {
        return C();
      },
      get wrapperId() {
        return k();
      },
      get style() {
        return $();
      },
      get onPlaced() {
        return T();
      },
      get customAnchor() {
        return X();
      },
      get isStatic() {
        return ae();
      },
      get enabled() {
        return J();
      },
      get onInteractOutside() {
        return E();
      },
      get onCloseAutoFocus() {
        return I();
      },
      get onOpenAutoFocus() {
        return F();
      },
      get interactOutsideBehavior() {
        return B();
      },
      get loop() {
        return R();
      },
      get trapFocus() {
        return Z();
      },
      get isValidEvent() {
        return Y();
      },
      get onFocusOutside() {
        return U();
      }
    },
    () => j,
    { forceMount: !0 }
  )), H(ee);
}
K(
  hh,
  {
    popper: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    enabled: {}
  },
  [],
  [],
  { mode: "open" }
);
var u2 = /* @__PURE__ */ ne("<div><div><!></div></div>"), c2 = /* @__PURE__ */ ne("<div><div><!></div></div>");
function g0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "forceMount", 7, !1), i = v(e, "side", 7, "bottom"), a = v(e, "onInteractOutside", 7, _e), l = v(e, "onEscapeKeydown", 7, _e), u = v(e, "children", 7), c = v(e, "child", 7), f = v(e, "preventScroll", 7, !1), g = v(e, "style", 7), _ = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "forceMount",
    "side",
    "onInteractOutside",
    "onEscapeKeydown",
    "children",
    "child",
    "preventScroll",
    "style"
  ]);
  const b = th.create({
    id: z(() => n()),
    ref: z(() => s(), (w) => s(w)),
    onInteractOutside: z(() => a()),
    onEscapeKeydown: z(() => l())
  }), p = /* @__PURE__ */ O(() => Ce(_, b.props));
  var h = {
    get id() {
      return n();
    },
    set id(w = me(r)) {
      n(w), m();
    },
    get ref() {
      return s();
    },
    set ref(w = null) {
      s(w), m();
    },
    get forceMount() {
      return o();
    },
    set forceMount(w = !1) {
      o(w), m();
    },
    get side() {
      return i();
    },
    set side(w = "bottom") {
      i(w), m();
    },
    get onInteractOutside() {
      return a();
    },
    set onInteractOutside(w = _e) {
      a(w), m();
    },
    get onEscapeKeydown() {
      return l();
    },
    set onEscapeKeydown(w = _e) {
      l(w), m();
    },
    get children() {
      return u();
    },
    set children(w) {
      u(w), m();
    },
    get child() {
      return c();
    },
    set child(w) {
      c(w), m();
    },
    get preventScroll() {
      return f();
    },
    set preventScroll(w = !1) {
      f(w), m();
    },
    get style() {
      return g();
    },
    set style(w) {
      g(w), m();
    }
  }, y = M(), S = D(y);
  {
    var x = (w) => {
      hh(w, ce(() => d(p), () => b.popperProps, {
        get ref() {
          return b.opts.ref;
        },
        get side() {
          return i();
        },
        get enabled() {
          return b.root.opts.open.current;
        },
        get id() {
          return n();
        },
        get preventScroll() {
          return f();
        },
        forceMount: !0,
        get shouldRender() {
          return b.shouldRender;
        },
        popper: (k, $) => {
          let T = () => $?.().props, E = () => $?.().wrapperProps;
          const I = /* @__PURE__ */ O(() => Ce(T(), { style: b.props.style }, { style: g() }));
          var F = M(), U = D(F);
          {
            var B = (Z) => {
              var Y = M(), X = D(Y);
              {
                let ae = /* @__PURE__ */ O(() => ({
                  props: d(I),
                  wrapperProps: E(),
                  ...b.snippetProps
                }));
                te(X, c, () => d(ae));
              }
              A(Z, Y);
            }, R = (Z) => {
              var Y = u2();
              ve(Y, () => ({ ...E() }));
              var X = ge(Y);
              ve(X, () => ({ ...d(I) }));
              var ae = ge(X);
              te(ae, () => u() ?? he), de(X), de(Y), A(Z, Y);
            };
            ue(U, (Z) => {
              c() ? Z(B) : Z(R, !1);
            });
          }
          A(k, F);
        },
        $$slots: { popper: !0 }
      }));
    }, P = (w) => {
      var C = M(), k = D(C);
      {
        var $ = (T) => {
          fh(T, ce(() => d(p), () => b.popperProps, {
            get ref() {
              return b.opts.ref;
            },
            get side() {
              return i();
            },
            get open() {
              return b.root.opts.open.current;
            },
            get id() {
              return n();
            },
            get preventScroll() {
              return f();
            },
            forceMount: !1,
            get shouldRender() {
              return b.shouldRender;
            },
            popper: (I, F) => {
              let U = () => F?.().props, B = () => F?.().wrapperProps;
              const R = /* @__PURE__ */ O(() => Ce(U(), { style: b.props.style }, { style: g() }));
              var Z = M(), Y = D(Z);
              {
                var X = (J) => {
                  var j = M(), ee = D(j);
                  {
                    let L = /* @__PURE__ */ O(() => ({
                      props: d(R),
                      wrapperProps: B(),
                      ...b.snippetProps
                    }));
                    te(ee, c, () => d(L));
                  }
                  A(J, j);
                }, ae = (J) => {
                  var j = c2();
                  ve(j, () => ({ ...B() }));
                  var ee = ge(j);
                  ve(ee, () => ({ ...d(R) }));
                  var L = ge(ee);
                  te(L, () => u() ?? he), de(ee), de(j), A(J, j);
                };
                ue(Y, (J) => {
                  c() ? J(X) : J(ae, !1);
                });
              }
              A(I, Z);
            },
            $$slots: { popper: !0 }
          }));
        };
        ue(
          k,
          (T) => {
            o() || T($);
          },
          !0
        );
      }
      A(w, C);
    };
    ue(S, (w) => {
      o() ? w(x) : w(P, !1);
    });
  }
  return A(t, y), H(h);
}
K(
  g0,
  {
    id: {},
    ref: {},
    forceMount: {},
    side: {},
    onInteractOutside: {},
    onEscapeKeydown: {},
    children: {},
    child: {},
    preventScroll: {},
    style: {}
  },
  [],
  [],
  { mode: "open" }
);
function cu(t, e) {
  W(e, !0);
  let r = v(e, "mounted", 15, !1), n = v(e, "onMountedChange", 7, _e);
  zd(() => (r(!0), n()(!0), () => {
    r(!1), n()(!1);
  }));
  var s = {
    get mounted() {
      return r();
    },
    set mounted(o = !1) {
      r(o), m();
    },
    get onMountedChange() {
      return n();
    },
    set onMountedChange(o = _e) {
      n(o), m();
    }
  };
  return H(s);
}
K(cu, { mounted: {}, onMountedChange: {} }, [], [], { mode: "open" });
var d2 = /* @__PURE__ */ ne("<div><!></div>"), f2 = /* @__PURE__ */ ne("<!> <!>", 1);
function p0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7), i = v(e, "label", 23, o), a = v(e, "disabled", 7, !1), l = v(e, "children", 7), u = v(e, "child", 7), c = v(e, "onHighlight", 7, _e), f = v(e, "onUnhighlight", 7, _e), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "label",
    "disabled",
    "children",
    "child",
    "onHighlight",
    "onUnhighlight"
  ]);
  const _ = rh.create({
    id: z(() => n()),
    ref: z(() => s(), (w) => s(w)),
    value: z(() => o()),
    disabled: z(() => a()),
    label: z(() => i()),
    onHighlight: z(() => c()),
    onUnhighlight: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(g, _.props));
  var p = {
    get id() {
      return n();
    },
    set id(w = me(r)) {
      n(w), m();
    },
    get ref() {
      return s();
    },
    set ref(w = null) {
      s(w), m();
    },
    get value() {
      return o();
    },
    set value(w) {
      o(w), m();
    },
    get label() {
      return i();
    },
    set label(w = o) {
      i(w), m();
    },
    get disabled() {
      return a();
    },
    set disabled(w = !1) {
      a(w), m();
    },
    get children() {
      return l();
    },
    set children(w) {
      l(w), m();
    },
    get child() {
      return u();
    },
    set child(w) {
      u(w), m();
    },
    get onHighlight() {
      return c();
    },
    set onHighlight(w = _e) {
      c(w), m();
    },
    get onUnhighlight() {
      return f();
    },
    set onUnhighlight(w = _e) {
      f(w), m();
    }
  }, h = f2(), y = D(h);
  {
    var S = (w) => {
      var C = M(), k = D(C);
      {
        let $ = /* @__PURE__ */ O(() => ({ props: d(b), ..._.snippetProps }));
        te(k, u, () => d($));
      }
      A(w, C);
    }, x = (w) => {
      var C = d2();
      ve(C, () => ({ ...d(b) }));
      var k = ge(C);
      te(k, () => l() ?? he, () => _.snippetProps), de(C), A(w, C);
    };
    ue(y, (w) => {
      u() ? w(S) : w(x, !1);
    });
  }
  var P = be(y, 2);
  return cu(P, {
    get mounted() {
      return _.mounted;
    },
    set mounted(w) {
      _.mounted = w;
    }
  }), A(t, h), H(p);
}
K(
  p0,
  {
    id: {},
    ref: {},
    value: {},
    label: {},
    disabled: {},
    children: {},
    child: {},
    onHighlight: {},
    onUnhighlight: {}
  },
  [],
  [],
  { mode: "open" }
);
var h2 = /* @__PURE__ */ ne("<div><!></div>");
function m0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = nh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = h2();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => o() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(m0, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var g2 = /* @__PURE__ */ ne("<div><!></div>");
function v0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children"
  ]);
  const l = sh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get child() {
      return o();
    },
    set child(p) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, o, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = g2();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => i() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      o() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(v0, { id: {}, ref: {}, child: {}, children: {} }, [], [], { mode: "open" });
var p2 = /* @__PURE__ */ ne("<div><!></div>");
const m2 = {
  hash: "svelte-18zq11a",
  code: `
	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */[data-select-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport]::-webkit-scrollbar {display:none !important;}[data-select-viewport]::-webkit-scrollbar {display:none !important;}`
};
function y0(t, e) {
  const r = De();
  W(e, !0), ZP(t, m2);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = ih.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = p2();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => o() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(y0, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var v2 = /* @__PURE__ */ ne("<div><!></div>"), y2 = /* @__PURE__ */ ne("<!> <!>", 1);
function b0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "delay", 7, () => 50), i = v(e, "child", 7), a = v(e, "children", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const u = ah.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    delay: z(() => o())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get delay() {
      return o();
    },
    set delay(p = () => 50) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    },
    get children() {
      return a();
    },
    set children(p) {
      a(p), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (p) => {
      var h = y2(), y = D(h);
      cu(y, {
        get mounted() {
          return u.scrollButtonState.mounted;
        },
        set mounted(w) {
          u.scrollButtonState.mounted = w;
        }
      });
      var S = be(y, 2);
      {
        var x = (w) => {
          var C = M(), k = D(C);
          te(k, i, () => ({ props: l })), A(w, C);
        }, P = (w) => {
          var C = v2();
          ve(C, () => ({ ...d(c) }));
          var k = ge(C);
          te(k, () => a() ?? he), de(C), A(w, C);
        };
        ue(S, (w) => {
          i() ? w(x) : w(P, !1);
        });
      }
      A(p, h);
    };
    ue(_, (p) => {
      u.canScrollDown && p(b);
    });
  }
  return A(t, g), H(f);
}
K(b0, { id: {}, ref: {}, delay: {}, child: {}, children: {} }, [], [], { mode: "open" });
var b2 = /* @__PURE__ */ ne("<div><!></div>"), _2 = /* @__PURE__ */ ne("<!> <!>", 1);
function _0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "delay", 7, () => 50), i = v(e, "child", 7), a = v(e, "children", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const u = lh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    delay: z(() => o())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get delay() {
      return o();
    },
    set delay(p = () => 50) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    },
    get children() {
      return a();
    },
    set children(p) {
      a(p), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (p) => {
      var h = _2(), y = D(h);
      cu(y, {
        get mounted() {
          return u.scrollButtonState.mounted;
        },
        set mounted(w) {
          u.scrollButtonState.mounted = w;
        }
      });
      var S = be(y, 2);
      {
        var x = (w) => {
          var C = M(), k = D(C);
          te(k, i, () => ({ props: l })), A(w, C);
        }, P = (w) => {
          var C = b2();
          ve(C, () => ({ ...d(c) }));
          var k = ge(C);
          te(k, () => a() ?? he), de(C), A(w, C);
        };
        ue(S, (w) => {
          i() ? w(x) : w(P, !1);
        });
      }
      A(p, h);
    };
    ue(_, (p) => {
      u.canScrollUp && p(b);
    });
  }
  return A(t, g), H(f);
}
K(_0, { id: {}, ref: {}, delay: {}, child: {}, children: {} }, [], [], { mode: "open" });
function w2(t, e) {
  let r = t.nextElementSibling;
  for (; r; ) {
    if (r.matches(e))
      return r;
    r = r.nextElementSibling;
  }
}
function S2(t, e) {
  let r = t.previousElementSibling;
  for (; r; ) {
    if (r.matches(e))
      return r;
    r = r.previousElementSibling;
  }
}
function w0(t) {
  if (typeof CSS < "u" && typeof CSS.escape == "function")
    return CSS.escape(t);
  const e = t.length;
  let r = -1, n, s = "";
  const o = t.charCodeAt(0);
  if (e === 1 && o === 45)
    return "\\" + t;
  for (; ++r < e; ) {
    if (n = t.charCodeAt(r), n === 0) {
      s += "ï¿½";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is U+007F
      n >= 1 && n <= 31 || n === 127 || // If the character is the first character and is in the range [0-9] (U+0030 to U+0039)
      r === 0 && n >= 48 && n <= 57 || // If the character is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D)
      r === 1 && n >= 48 && n <= 57 && o === 45
    ) {
      s += "\\" + n.toString(16) + " ";
      continue;
    }
    if (n >= 128 || n === 45 || n === 95 || n >= 48 && n <= 57 || n >= 65 && n <= 90 || n >= 97 && n <= 122) {
      s += t.charAt(r);
      continue;
    }
    s += "\\" + t.charAt(r);
  }
  return s;
}
const Os = "data-value", Rt = tr({
  component: "command",
  parts: [
    "root",
    "list",
    "input",
    "separator",
    "loading",
    "empty",
    "group",
    "group-items",
    "group-heading",
    "item",
    "viewport",
    "input-label"
  ]
}), Zs = Rt.selector("group"), Gu = Rt.selector("group-items"), Op = Rt.selector("group-heading"), S0 = Rt.selector("item"), Yu = `${Rt.selector("item")}:not([aria-disabled="true"])`, fs = new ht("Command.Root"), x2 = new ht("Command.List"), Pi = new ht("Command.Group"), Cp = {
  search: "",
  value: "",
  filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() }
};
class gh {
  static create(e) {
    return fs.set(new gh(e));
  }
  opts;
  attachment;
  #e = !1;
  #t = !0;
  sortAfterTick = !1;
  sortAndFilterAfterTick = !1;
  allItems = /* @__PURE__ */ new Set();
  allGroups = /* @__PURE__ */ new Map();
  allIds = /* @__PURE__ */ new Map();
  #r = (
    // attempt to prevent the harsh delay when user is typing fast
    /* @__PURE__ */ xe(0)
  );
  get key() {
    return d(this.#r);
  }
  set key(e) {
    q(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ xe(null);
  get viewportNode() {
    return d(this.#n);
  }
  set viewportNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(null);
  get inputNode() {
    return d(this.#s);
  }
  set inputNode(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(null);
  get labelNode() {
    return d(this.#o);
  }
  set labelNode(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(Cp);
  get commandState() {
    return d(this.#i);
  }
  set commandState(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ xe(Pt(Cp));
  get _commandState() {
    return d(this.#a);
  }
  set _commandState(e) {
    q(this.#a, e, !0);
  }
  #u() {
    return xo(this._commandState);
  }
  #l() {
    this.#e || (this.#e = !0, Jt(() => {
      this.#e = !1;
      const e = this.#u();
      !Object.is(this.commandState, e) && (this.commandState = e, this.opts.onStateChange?.current?.(e));
    }));
  }
  setState(e, r, n) {
    Object.is(this._commandState[e], r) || (this._commandState[e] = r, e === "search" ? (this.#p(), this.#d()) : e === "value" && (n || this.#h()), this.#l());
  }
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref);
    const r = { ...this._commandState, value: this.opts.value.current ?? "" };
    this._commandState = r, this.commandState = r, this.onkeydown = this.onkeydown.bind(this);
  }
  /**
   * Calculates score for an item based on search text and keywords.
   * Higher score = better match.
   *
   * @param value - Item's display text
   * @param keywords - Optional keywords to boost scoring
   * @returns Score from 0-1, where 0 = no match
   */
  #c(e, r) {
    const n = this.opts.filter.current ?? Yc;
    return e ? n(e, this._commandState.search, r) : 0;
  }
  /**
   * Sorts items and groups based on search scores.
   * Groups are sorted by their highest scoring item.
   * When no search active, selects first item.
   */
  #d() {
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      !this._commandState.value || !this.#t ? this.#g() : this.#t && this._commandState.value && this.#m();
      return;
    }
    const e = this._commandState.filtered.items, r = [];
    for (const i of this._commandState.filtered.groups) {
      const a = this.allGroups.get(i);
      let l = 0;
      if (!a) {
        r.push([i, l]);
        continue;
      }
      for (const u of a) {
        const c = e.get(u);
        l = Math.max(c ?? 0, l);
      }
      r.push([i, l]);
    }
    const n = this.viewportNode, s = this.getValidItems().sort((i, a) => {
      const l = i.getAttribute("data-value"), u = a.getAttribute("data-value"), c = e.get(l) ?? 0;
      return (e.get(u) ?? 0) - c;
    });
    for (const i of s) {
      const a = i.closest(Gu);
      if (a) {
        const l = i.parentElement === a ? i : i.closest(`${Gu} > *`);
        l && a.appendChild(l);
      } else {
        const l = i.parentElement === n ? i : i.closest(`${Gu} > *`);
        l && n?.appendChild(l);
      }
    }
    const o = r.sort((i, a) => a[1] - i[1]);
    for (const i of o) {
      const a = n?.querySelector(`${Zs}[${Os}="${w0(i[0])}"]`);
      a?.parentElement?.appendChild(a);
    }
    this.#g();
  }
  /**
   * Sets current value and triggers re-render if cleared.
   *
   * @param value - New value to set
   */
  setValue(e, r) {
    e !== this.opts.value.current && e === "" && Jt(() => {
      this.key++;
    }), this.setState("value", e, r), this.opts.value.current = e;
  }
  /**
   * Selects first non-disabled item on next tick.
   */
  #g() {
    Jt(() => {
      const r = this.getValidItems().find((s) => s.getAttribute("aria-disabled") !== "true")?.getAttribute(Os), n = this.#t && this.opts.disableInitialScroll.current;
      this.setValue(r ?? "", n), this.#t = !1;
    });
  }
  /**
   * Scrolls the initial value into view if it exists and is not the first item.
   * Called during initial mount when a value is provided.
   */
  #m() {
    Jt(() => {
      this.opts.disableInitialScroll.current || this.#h(), this.#t = !1;
    });
  }
  /**
   * Updates filtered items/groups based on search.
   * Recalculates scores and filtered count.
   */
  #p() {
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      this._commandState.filtered.count = this.allItems.size;
      return;
    }
    this._commandState.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (const r of this.allItems) {
      const n = this.allIds.get(r)?.value ?? "", s = this.allIds.get(r)?.keywords ?? [], o = this.#c(n, s);
      this._commandState.filtered.items.set(r, o), o > 0 && e++;
    }
    for (const [r, n] of this.allGroups)
      for (const s of n) {
        const o = this._commandState.filtered.items.get(s);
        if (o && o > 0) {
          this._commandState.filtered.groups.add(r);
          break;
        }
      }
    this._commandState.filtered.count = e;
  }
  /**
   * Gets all non-disabled, visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getValidItems() {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Yu)).filter((n) => !!n) : [];
  }
  /**
   * Gets all visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getVisibleItems() {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(S0)).filter((n) => !!n) : [];
  }
  /** Returns all visible items in a matrix structure
   *
   * @remarks Returns empty if the command isn't configured as a grid
   *
   * @returns
   */
  get itemsGrid() {
    if (!this.isGrid) return [];
    const e = this.opts.columns.current ?? 1, r = this.getVisibleItems(), n = [[]];
    let s = r[0]?.getAttribute("data-group"), o = 0, i = 0;
    for (let a = 0; a < r.length; a++) {
      const l = r[a], u = l?.getAttribute("data-group");
      s !== u ? (s = u, o = 1, i++, n.push([{ index: a, firstRowOfGroup: !0, ref: l }])) : (o++, o > e && (i++, o = 1, n.push([])), n[i]?.push({
        index: a,
        firstRowOfGroup: n[i]?.[0]?.firstRowOfGroup ?? a === 0,
        ref: l
      }));
    }
    return n;
  }
  /**
   * Gets currently selected command item.
   *
   * @returns Selected element or undefined
   */
  #f() {
    const e = this.opts.ref.current;
    if (!e) return;
    const r = e.querySelector(`${Yu}[data-selected]`);
    if (r)
      return r;
  }
  /**
   * Scrolls selected item into view.
   * Special handling for first items in groups.
   */
  #h() {
    Jt(() => {
      const e = this.#f();
      if (!e) return;
      const r = e.parentElement?.parentElement;
      if (r) {
        if (this.isGrid) {
          const n = this.#b(e);
          if (e.scrollIntoView({ block: "nearest" }), n) {
            e?.closest(Zs)?.querySelector(Op)?.scrollIntoView({ block: "nearest" });
            return;
          }
        } else {
          const n = j$(r);
          if (n && n.dataset?.value === e.dataset?.value) {
            e?.closest(Zs)?.querySelector(Op)?.scrollIntoView({ block: "nearest" });
            return;
          }
        }
        e.scrollIntoView({ block: "nearest" });
      }
    });
  }
  #b(e) {
    const r = this.itemsGrid;
    if (r.length === 0) return !1;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s !== void 0)
        for (let o = 0; o < s.length; o++) {
          const i = s[o];
          if (!(i === void 0 || i.ref !== e))
            return i.firstRowOfGroup;
        }
    }
    return !1;
  }
  /**
   * Sets selection to item at specified index in valid items array.
   * If index is out of bounds, does nothing.
   *
   * @param index - Zero-based index of item to select
   * @remarks
   * Uses `getValidItems()` to get selectable items, filtering out disabled/hidden ones.
   * Access valid items directly via `getValidItems()` to check bounds before calling.
   *
   * @example
   * // get valid items length for bounds check
   * const items = getValidItems()
   * if (index < items.length) {
   *   updateSelectedToIndex(index)
   * }
   */
  updateSelectedToIndex(e) {
    const r = this.getValidItems()[e];
    r && this.setValue(r.getAttribute(Os) ?? "");
  }
  /**
   * Updates selected item by moving up/down relative to current selection.
   * Handles wrapping when loop option is enabled.
   *
   * @param change - Direction to move: 1 for next item, -1 for previous item
   * @remarks
   * The loop behavior wraps:
   * - From last item to first when moving next
   * - From first item to last when moving previous
   *
   * Uses `getValidItems()` to get all selectable items, which filters out disabled/hidden items.
   * You can call `getValidItems()` directly to get the current valid items array.
   *
   * @example
   * // select next item
   * updateSelectedByItem(1)
   *
   * // get all valid items
   * const items = getValidItems()
   */
  updateSelectedByItem(e) {
    const r = this.#f(), n = this.getValidItems(), s = n.findIndex((i) => i === r);
    let o = n[s + e];
    this.opts.loop.current && (o = s + e < 0 ? n[n.length - 1] : s + e === n.length ? n[0] : n[s + e]), o && this.setValue(o.getAttribute(Os) ?? "");
  }
  /**
   * Moves selection to the first valid item in the next/previous group.
   * If no group is found, falls back to selecting the next/previous item globally.
   *
   * @param change - Direction to move: 1 for next group, -1 for previous group
   * @example
   * // move to first item in next group
   * updateSelectedByGroup(1)
   *
   * // move to first item in previous group
   * updateSelectedByGroup(-1)
   */
  updateSelectedByGroup(e) {
    let n = this.#f()?.closest(Zs), s;
    for (; n && !s; )
      n = e > 0 ? w2(n, Zs) : S2(n, Zs), s = n?.querySelector(Yu);
    s ? this.setValue(s.getAttribute(Os) ?? "") : this.updateSelectedByItem(e);
  }
  /**
   * Maps item id to display value and search keywords.
   * Returns cleanup function to remove mapping.
   *
   * @param id - Unique item identifier
   * @param value - Display text
   * @param keywords - Optional search boost terms
   * @returns Cleanup function
   */
  registerValue(e, r) {
    return e && e === this.allIds.get(e)?.value || this.allIds.set(e, { value: e, keywords: r }), this._commandState.filtered.items.set(e, this.#c(e, r)), this.sortAfterTick || (this.sortAfterTick = !0, Jt(() => {
      this.#d(), this.sortAfterTick = !1;
    })), () => {
      this.allIds.delete(e);
    };
  }
  /**
   * Registers item in command list and its group.
   * Handles filtering, sorting and selection updates.
   *
   * @param id - Item identifier
   * @param groupId - Optional group to add item to
   * @returns Cleanup function that handles selection
   */
  registerItem(e, r) {
    return this.allItems.add(e), r && (this.allGroups.has(r) ? this.allGroups.get(r).add(e) : this.allGroups.set(r, /* @__PURE__ */ new Set([e]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Jt(() => {
      this.#p(), this.#d(), this.sortAndFilterAfterTick = !1;
    })), this.#l(), () => {
      const n = this.#f();
      this.allItems.delete(e), this.commandState.filtered.items.delete(e), this.#p(), n?.getAttribute("id") === e && this.#g(), this.#l();
    };
  }
  /**
   * Creates empty group if not exists.
   *
   * @param id - Group identifier
   * @returns Cleanup function
   */
  registerGroup(e) {
    return this.allGroups.has(e) || this.allGroups.set(e, /* @__PURE__ */ new Set()), () => {
      this.allIds.delete(e), this.allGroups.delete(e);
    };
  }
  get isGrid() {
    return this.opts.columns.current !== null;
  }
  /**
   * Selects last valid item.
   */
  #y() {
    return this.updateSelectedToIndex(this.getValidItems().length - 1);
  }
  /**
   * Handles next item selection:
   * - Meta: Jump to last
   * - Alt: Next group
   * - Default: Next item
   *
   * @param e - Keyboard event
   */
  #v(e) {
    e.preventDefault(), e.metaKey ? this.#y() : e.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1);
  }
  #S(e) {
    this.opts.columns.current !== null && (e.preventDefault(), e.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(this.#x(e)));
  }
  #w(e, r) {
    if (r.length === 0) return null;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s !== void 0)
        for (let o = 0; o < s.length; o++) {
          const i = s[o];
          if (!(i === void 0 || i.ref !== e))
            return { columnIndex: o, rowIndex: n };
        }
    }
    return null;
  }
  #x(e) {
    const r = this.itemsGrid, n = this.#f();
    if (!n) return 0;
    const s = this.#w(n, r);
    if (!s) return 0;
    let o = null;
    const i = e.altKey ? 1 : 0;
    if (e.altKey && s.rowIndex === r.length - 2 && !this.opts.loop.current)
      o = this.#_({
        start: r.length - 1,
        end: r.length,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    else if (s.rowIndex === r.length - 1) {
      if (!this.opts.loop.current) return 0;
      o = this.#_({
        start: 0 + i,
        end: s.rowIndex,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    } else
      o = this.#_({
        start: s.rowIndex + 1 + i,
        end: r.length,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }), o === null && this.opts.loop.current && (o = this.#_({
        start: 0,
        end: s.rowIndex,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }));
    return this.#C(n, o);
  }
  /** Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   *
   * @param param0
   * @returns
   */
  #_({ start: e, end: r, grid: n, expectedColumnIndex: s }) {
    let o = null;
    for (let i = e; i < r; i++) {
      const a = n[i];
      if (o = a[s]?.ref ?? null, o !== null && Zi(o)) {
        o = null;
        continue;
      }
      if (o === null)
        for (let l = a.length - 1; l >= 0; l--) {
          const u = a[a.length - 1];
          if (!(u === void 0 || Zi(u.ref))) {
            o = u.ref;
            break;
          }
        }
      break;
    }
    return o;
  }
  #C(e, r) {
    if (r === null) return 0;
    const n = this.getValidItems(), s = n.findIndex((i) => i === e);
    return n.findIndex((i) => i === r) - s;
  }
  #k(e) {
    this.opts.columns.current !== null && (e.preventDefault(), e.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(this.#A(e)));
  }
  #A(e) {
    const r = this.itemsGrid, n = this.#f();
    if (n === void 0) return 0;
    const s = this.#w(n, r);
    if (s === null) return 0;
    let o = null;
    const i = e.altKey ? 1 : 0;
    if (e.altKey && s.rowIndex === 1 && this.opts.loop.current === !1)
      o = this.#P({
        start: 0,
        end: 0,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    else if (s.rowIndex === 0) {
      if (this.opts.loop.current === !1) return 0;
      o = this.#P({
        start: r.length - 1 - i,
        end: s.rowIndex + 1,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    } else
      o = this.#P({
        start: s.rowIndex - 1 - i,
        end: 0,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }), o === null && this.opts.loop.current && (o = this.#P({
        start: r.length - 1,
        end: s.rowIndex + 1,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }));
    return this.#C(n, o);
  }
  /**
   * Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   */
  #P({ start: e, end: r, grid: n, expectedColumnIndex: s }) {
    let o = null;
    for (let i = e; i >= r; i--) {
      const a = n[i];
      if (a !== void 0) {
        if (o = a[s]?.ref ?? null, o !== null && Zi(o)) {
          o = null;
          continue;
        }
        if (o === null)
          for (let l = a.length - 1; l >= 0; l--) {
            const u = a[a.length - 1];
            if (!(u === void 0 || Zi(u.ref))) {
              o = u.ref;
              break;
            }
          }
        break;
      }
    }
    return o;
  }
  /**
   * Handles previous item selection:
   * - Meta: Jump to first
   * - Alt: Previous group
   * - Default: Previous item
   *
   * @param e - Keyboard event
   */
  #O(e) {
    e.preventDefault(), e.metaKey ? this.updateSelectedToIndex(0) : e.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1);
  }
  onkeydown(e) {
    const r = this.opts.vimBindings.current && e.ctrlKey;
    switch (e.key) {
      case S$:
      case x$: {
        r && (this.isGrid ? this.#S(e) : this.#v(e));
        break;
      }
      case C$: {
        r && this.isGrid && this.#v(e);
        break;
      }
      case dr:
        this.isGrid ? this.#S(e) : this.#v(e);
        break;
      case ds:
        if (!this.isGrid) break;
        this.#v(e);
        break;
      case w$:
      case P$: {
        r && (this.isGrid ? this.#k(e) : this.#O(e));
        break;
      }
      case O$: {
        r && this.isGrid && this.#O(e);
        break;
      }
      case Qt:
        this.isGrid ? this.#k(e) : this.#O(e);
        break;
      case cs:
        if (!this.isGrid) break;
        this.#O(e);
        break;
      case Mo:
        e.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case Do:
        e.preventDefault(), this.#y();
        break;
      case Br:
        if (!e.isComposing && e.keyCode !== 229) {
          e.preventDefault();
          const n = this.#f();
          n && n?.click();
        }
    }
  }
  #$ = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "application",
    [Rt.root]: "",
    tabindex: -1,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#$);
  }
  set props(e) {
    q(this.#$, e);
  }
}
function Zi(t) {
  return t.getAttribute("aria-disabled") === "true";
}
class ph {
  static create(e) {
    return new ph(e, fs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root._commandState.filtered.count === 0 && this.#t === !1 || this.opts.forceMount.current);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  #t = !0;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), Co(() => {
      this.#t = !1;
    });
  }
  #r = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "presentation",
    [Rt.empty]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
class mh {
  static create(e) {
    return Pi.set(new mh(e, fs.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue));
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ xe(null);
  get headingNode() {
    return d(this.#t);
  }
  set headingNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe("");
  get trueValue() {
    return d(this.#r);
  }
  set trueValue(e) {
    q(this.#r, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.trueValue = e.value.current ?? e.id.current, Fe(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Xe(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)));
  }
  #n = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "presentation",
    hidden: this.shouldRender ? void 0 : !0,
    "data-value": this.trueValue,
    [Rt.group]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
}
class vh {
  static create(e) {
    return new vh(e, Pi.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(this.opts.ref, (n) => this.group.headingNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [Rt["group-heading"]]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class yh {
  static create(e) {
    return new yh(e, Pi.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "group",
    [Rt["group-items"]]: "",
    "aria-labelledby": this.group.headingNode?.id ?? void 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class bh {
  static create(e) {
    return new bh(e, fs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => {
    const e = this.root.viewportNode?.querySelector(`${S0}[${Os}="${w0(this.root.opts.value.current)}"]`);
    if (e != null)
      return e.getAttribute("id") ?? void 0;
  });
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.inputNode = n), Fe(() => this.opts.ref.current, () => {
      const n = this.opts.ref.current;
      n && this.opts.autofocus.current && qd(10, () => n.focus());
    }), Fe(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current);
    });
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    type: "text",
    [Rt.input]: "",
    autocomplete: "off",
    autocorrect: "off",
    spellcheck: !1,
    "aria-autocomplete": "list",
    role: "combobox",
    "aria-expanded": at(!0),
    "aria-controls": this.root.viewportNode?.id ?? void 0,
    "aria-labelledby": this.root.labelNode?.id ?? void 0,
    "aria-activedescendant": d(this.#e),
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class du {
  static create(e) {
    const r = Pi.getOr(null);
    return new du({ ...e, group: r }, fs.get());
  }
  opts;
  root;
  attachment;
  #e = null;
  #t = /* @__PURE__ */ O(() => this.opts.forceMount.current || this.#e?.opts.forceMount.current === !0);
  #r = /* @__PURE__ */ O(() => {
    if (this.opts.ref.current, d(this.#t) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search)
      return !0;
    const e = this.root.commandState.filtered.items.get(this.trueValue);
    return e === void 0 ? !1 : e > 0;
  });
  get shouldRender() {
    return d(this.#r);
  }
  set shouldRender(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.root.opts.value.current === this.trueValue && this.trueValue !== "");
  get isSelected() {
    return d(this.#n);
  }
  set isSelected(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ xe("");
  get trueValue() {
    return d(this.#s);
  }
  set trueValue(e) {
    q(this.#s, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.#e = Pi.getOr(null), this.trueValue = e.value.current, this.attachment = Te(this.opts.ref), Fe(
      [
        () => this.trueValue,
        () => this.#e?.trueValue,
        () => this.opts.forceMount.current
      ],
      () => {
        if (!(this.opts.forceMount.current || !this.trueValue))
          return this.root.registerItem(this.trueValue, this.#e?.trueValue);
      }
    ), Fe([() => this.opts.value.current, () => this.opts.ref.current], () => {
      this.opts.value.current ? this.trueValue = this.opts.value.current : this.opts.ref.current?.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, e.keywords.current.map((n) => n.trim())), this.opts.ref.current?.setAttribute(Os, this.trueValue));
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this);
  }
  #o() {
    this.opts.disabled.current || (this.#i(), this.opts.onSelect?.current());
  }
  #i() {
    this.opts.disabled.current || this.root.setValue(this.trueValue, !0);
  }
  onpointermove(e) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || this.#i();
  }
  onclick(e) {
    this.opts.disabled.current || this.#o();
  }
  #a = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-disabled": at(this.opts.disabled.current),
    "aria-selected": at(this.isSelected),
    "data-disabled": Re(this.opts.disabled.current),
    "data-selected": Re(this.isSelected),
    "data-value": this.trueValue,
    "data-group": this.#e?.trueValue,
    [Rt.item]: "",
    role: "option",
    onpointermove: this.onpointermove,
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
class _h {
  static create(e) {
    return new _h(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "progressbar",
    "aria-valuenow": this.opts.progress.current,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-label": "Loading...",
    [Rt.loading]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class wh {
  static create(e) {
    return new wh(e, fs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => !this.root._commandState.search || this.opts.forceMount.current);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    // role="separator" cannot belong to a role="listbox"
    "aria-hidden": "true",
    [Rt.separator]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Sh {
  static create(e) {
    return x2.set(new Sh(e, fs.get()));
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "listbox",
    "aria-label": this.opts.ariaLabel.current,
    [Rt.list]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class xh {
  static create(e) {
    return new xh(e, fs.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.labelNode = n);
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [Rt["input-label"]]: "",
    for: this.opts.for?.current,
    style: Ob,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var P2 = /* @__PURE__ */ ne("<label><!></label>");
function x0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children"
  ]);
  const a = xh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g))
  }), l = /* @__PURE__ */ O(() => Ce(i, a.props));
  var u = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    }
  }, c = P2();
  ve(c, () => ({ ...d(l) }));
  var f = ge(c);
  return te(f, () => o() ?? he), de(c), A(t, c), H(u);
}
K(x0, { id: {}, ref: {}, children: {} }, [], [], { mode: "open" });
var O2 = /* @__PURE__ */ ne("<!> <!>", 1), C2 = /* @__PURE__ */ ne("<div><!> <!></div>");
function P0(t, e) {
  const r = De();
  W(e, !0);
  const n = (R) => {
    x0(R, {
      children: (Z, Y) => {
        St();
        var X = st();
        ke(() => Ie(X, g())), A(Z, X);
      },
      $$slots: { default: !0 }
    });
  };
  let s = v(e, "id", 23, () => me(r)), o = v(e, "ref", 15, null), i = v(e, "value", 15, ""), a = v(e, "onValueChange", 7, _e), l = v(e, "onStateChange", 7, _e), u = v(e, "loop", 7, !1), c = v(e, "shouldFilter", 7, !0), f = v(e, "filter", 7, Yc), g = v(e, "label", 7, ""), _ = v(e, "vimBindings", 7, !0), b = v(e, "disablePointerSelection", 7, !1), p = v(e, "disableInitialScroll", 7, !1), h = v(e, "columns", 7, null), y = v(e, "children", 7), S = v(e, "child", 7), x = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "onValueChange",
    "onStateChange",
    "loop",
    "shouldFilter",
    "filter",
    "label",
    "vimBindings",
    "disablePointerSelection",
    "disableInitialScroll",
    "columns",
    "children",
    "child"
  ]);
  const P = gh.create({
    id: z(() => s()),
    ref: z(() => o(), (R) => o(R)),
    filter: z(() => f()),
    shouldFilter: z(() => c()),
    loop: z(() => u()),
    value: z(() => i(), (R) => {
      i() !== R && (i(R), a()(R));
    }),
    vimBindings: z(() => _()),
    disablePointerSelection: z(() => b()),
    disableInitialScroll: z(() => p()),
    onStateChange: z(() => l()),
    columns: z(() => h())
  }), w = (R) => P.updateSelectedToIndex(R), C = (R) => P.updateSelectedByGroup(R), k = (R) => P.updateSelectedByItem(R), $ = () => P.getValidItems(), T = /* @__PURE__ */ O(() => Ce(x, P.props));
  var E = {
    updateSelectedToIndex: w,
    updateSelectedByGroup: C,
    updateSelectedByItem: k,
    getValidItems: $,
    get id() {
      return s();
    },
    set id(R = me(r)) {
      s(R), m();
    },
    get ref() {
      return o();
    },
    set ref(R = null) {
      o(R), m();
    },
    get value() {
      return i();
    },
    set value(R = "") {
      i(R), m();
    },
    get onValueChange() {
      return a();
    },
    set onValueChange(R = _e) {
      a(R), m();
    },
    get onStateChange() {
      return l();
    },
    set onStateChange(R = _e) {
      l(R), m();
    },
    get loop() {
      return u();
    },
    set loop(R = !1) {
      u(R), m();
    },
    get shouldFilter() {
      return c();
    },
    set shouldFilter(R = !0) {
      c(R), m();
    },
    get filter() {
      return f();
    },
    set filter(R = Yc) {
      f(R), m();
    },
    get label() {
      return g();
    },
    set label(R = "") {
      g(R), m();
    },
    get vimBindings() {
      return _();
    },
    set vimBindings(R = !0) {
      _(R), m();
    },
    get disablePointerSelection() {
      return b();
    },
    set disablePointerSelection(R = !1) {
      b(R), m();
    },
    get disableInitialScroll() {
      return p();
    },
    set disableInitialScroll(R = !1) {
      p(R), m();
    },
    get columns() {
      return h();
    },
    set columns(R = null) {
      h(R), m();
    },
    get children() {
      return y();
    },
    set children(R) {
      y(R), m();
    },
    get child() {
      return S();
    },
    set child(R) {
      S(R), m();
    }
  }, I = M(), F = D(I);
  {
    var U = (R) => {
      var Z = O2(), Y = D(Z);
      n(Y);
      var X = be(Y, 2);
      te(X, S, () => ({ props: d(T) })), A(R, Z);
    }, B = (R) => {
      var Z = C2();
      ve(Z, () => ({ ...d(T) }));
      var Y = ge(Z);
      n(Y);
      var X = be(Y, 2);
      te(X, () => y() ?? he), de(Z), A(R, Z);
    };
    ue(F, (R) => {
      S() ? R(U) : R(B, !1);
    });
  }
  return A(t, I), H(E);
}
K(
  P0,
  {
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    onStateChange: {},
    loop: {},
    shouldFilter: {},
    filter: {},
    label: {},
    vimBindings: {},
    disablePointerSelection: {},
    disableInitialScroll: {},
    columns: {},
    children: {},
    child: {}
  },
  [],
  [
    "updateSelectedToIndex",
    "updateSelectedByGroup",
    "updateSelectedByItem",
    "getValidItems"
  ],
  { mode: "open" }
);
var k2 = /* @__PURE__ */ ne("<div><!></div>");
function O0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = v(e, "forceMount", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child",
    "forceMount"
  ]);
  const u = ph.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    forceMount: z(() => a())
  }), c = /* @__PURE__ */ O(() => Ce(u.props, l));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(p = !1) {
      a(p), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (p) => {
      var h = M(), y = D(h);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, i, () => ({ props: d(c) })), A(P, w);
        }, x = (P) => {
          var w = k2();
          ve(w, () => ({ ...d(c) }));
          var C = ge(w);
          te(C, () => o() ?? he), de(w), A(P, w);
        };
        ue(y, (P) => {
          i() ? P(S) : P(x, !1);
        });
      }
      A(p, h);
    };
    ue(_, (p) => {
      u.shouldRender && p(b);
    });
  }
  return A(t, g), H(f);
}
K(O0, { id: {}, ref: {}, children: {}, child: {}, forceMount: {} }, [], [], { mode: "open" });
var $2 = /* @__PURE__ */ ne("<div><!></div>");
function C0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "forceMount", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "forceMount",
    "children",
    "child"
  ]);
  const c = mh.create({
    id: z(() => n()),
    ref: z(() => s(), (y) => s(y)),
    forceMount: z(() => i()),
    value: z(() => o())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var g = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get ref() {
      return s();
    },
    set ref(y = null) {
      s(y), m();
    },
    get value() {
      return o();
    },
    set value(y = "") {
      o(y), m();
    },
    get forceMount() {
      return i();
    },
    set forceMount(y = !1) {
      i(y), m();
    },
    get children() {
      return a();
    },
    set children(y) {
      a(y), m();
    },
    get child() {
      return l();
    },
    set child(y) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      te(x, l, () => ({ props: d(f) })), A(y, S);
    }, h = (y) => {
      var S = $2();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => a() ?? he), de(S), A(y, S);
    };
    ue(b, (y) => {
      l() ? y(p) : y(h, !1);
    });
  }
  return A(t, _), H(g);
}
K(
  C0,
  {
    id: {},
    ref: {},
    value: {},
    forceMount: {},
    children: {},
    child: {}
  },
  [],
  [],
  { mode: "open" }
);
var A2 = /* @__PURE__ */ ne("<div><!></div>");
function k0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = vh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = A2();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => o() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(k0, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var E2 = /* @__PURE__ */ ne("<div><!></div>"), T2 = /* @__PURE__ */ ne('<div style="display: contents;"><!></div>');
function $0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = yh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    },
    get child() {
      return i();
    },
    set child(p) {
      i(p), m();
    }
  }, f = T2(), g = ge(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = E2();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => o() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      i() ? p(_) : p(b, !1);
    });
  }
  return de(f), A(t, f), H(c);
}
K($0, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var D2 = /* @__PURE__ */ ne("<input/>");
function A0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "value", 15, ""), s = v(e, "autofocus", 7, !1), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "value",
    "autofocus",
    "id",
    "ref",
    "child"
  ]);
  const u = bh.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h)),
    value: z(() => n(), (h) => {
      n(h);
    }),
    autofocus: z(() => s() ?? !1)
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get value() {
      return n();
    },
    set value(h = "") {
      n(h), m();
    },
    get autofocus() {
      return s();
    },
    set autofocus(h = !1) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get child() {
      return a();
    },
    set child(h) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, a, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = D2();
      ve(y, () => ({ ...d(c) }), void 0, void 0, void 0, void 0, !0), Di(y, n), A(h, y);
    };
    ue(_, (h) => {
      a() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(A0, { value: {}, autofocus: {}, id: {}, ref: {}, child: {} }, [], [], { mode: "open" });
var M2 = /* @__PURE__ */ ne("<div><!></div>"), I2 = /* @__PURE__ */ ne('<div style="display: contents;" data-item-wrapper=""><!></div>');
function E0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "disabled", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = v(e, "onSelect", 7, _e), c = v(e, "forceMount", 7, !1), f = v(e, "keywords", 23, () => []), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const _ = du.create({
    id: z(() => n()),
    ref: z(() => s(), (S) => s(S)),
    value: z(() => o()),
    disabled: z(() => i()),
    onSelect: z(() => u()),
    forceMount: z(() => c()),
    keywords: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(g, _.props));
  var p = {
    get id() {
      return n();
    },
    set id(S = me(r)) {
      n(S), m();
    },
    get ref() {
      return s();
    },
    set ref(S = null) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S = "") {
      o(S), m();
    },
    get disabled() {
      return i();
    },
    set disabled(S = !1) {
      i(S), m();
    },
    get children() {
      return a();
    },
    set children(S) {
      a(S), m();
    },
    get child() {
      return l();
    },
    set child(S) {
      l(S), m();
    },
    get onSelect() {
      return u();
    },
    set onSelect(S = _e) {
      u(S), m();
    },
    get forceMount() {
      return c();
    },
    set forceMount(S = !1) {
      c(S), m();
    },
    get keywords() {
      return f();
    },
    set keywords(S = []) {
      f(S), m();
    }
  }, h = M(), y = D(h);
  return Ll(y, () => _.root.key, (S) => {
    var x = I2(), P = ge(x);
    {
      var w = (C) => {
        var k = M(), $ = D(k);
        {
          var T = (I) => {
            var F = M(), U = D(F);
            te(U, l, () => ({ props: d(b) })), A(I, F);
          }, E = (I) => {
            var F = M2();
            ve(F, () => ({ ...d(b) }));
            var U = ge(F);
            te(U, () => a() ?? he), de(F), A(I, F);
          };
          ue($, (I) => {
            l() ? I(T) : I(E, !1);
          });
        }
        A(C, k);
      };
      ue(P, (C) => {
        _.shouldRender && C(w);
      });
    }
    de(x), ke(() => An(x, "data-value", _.trueValue)), A(S, x);
  }), A(t, h), H(p);
}
K(
  E0,
  {
    id: {},
    ref: {},
    value: {},
    disabled: {},
    children: {},
    child: {},
    onSelect: {},
    forceMount: {},
    keywords: {}
  },
  [],
  [],
  { mode: "open" }
);
var N2 = /* @__PURE__ */ ne("<a><!></a>"), F2 = /* @__PURE__ */ ne('<div style="display: contents;"><!></div>');
function T0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "disabled", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = v(e, "onSelect", 7, _e), c = v(e, "forceMount", 7, !1), f = v(e, "keywords", 23, () => []), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const _ = du.create({
    id: z(() => n()),
    ref: z(() => s(), (S) => s(S)),
    value: z(() => o()),
    disabled: z(() => i()),
    onSelect: z(() => u()),
    forceMount: z(() => c()),
    keywords: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(g, _.props));
  var p = {
    get id() {
      return n();
    },
    set id(S = me(r)) {
      n(S), m();
    },
    get ref() {
      return s();
    },
    set ref(S = null) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S = "") {
      o(S), m();
    },
    get disabled() {
      return i();
    },
    set disabled(S = !1) {
      i(S), m();
    },
    get children() {
      return a();
    },
    set children(S) {
      a(S), m();
    },
    get child() {
      return l();
    },
    set child(S) {
      l(S), m();
    },
    get onSelect() {
      return u();
    },
    set onSelect(S = _e) {
      u(S), m();
    },
    get forceMount() {
      return c();
    },
    set forceMount(S = !1) {
      c(S), m();
    },
    get keywords() {
      return f();
    },
    set keywords(S = []) {
      f(S), m();
    }
  }, h = M(), y = D(h);
  return Ll(y, () => _.root.key, (S) => {
    var x = F2(), P = ge(x);
    {
      var w = (C) => {
        var k = M(), $ = D(k);
        {
          var T = (I) => {
            var F = M(), U = D(F);
            te(U, l, () => ({ props: d(b) })), A(I, F);
          }, E = (I) => {
            var F = N2();
            ve(F, () => ({ ...d(b) }));
            var U = ge(F);
            te(U, () => a() ?? he), de(F), A(I, F);
          };
          ue($, (I) => {
            l() ? I(T) : I(E, !1);
          });
        }
        A(C, k);
      };
      ue(P, (C) => {
        _.shouldRender && C(w);
      });
    }
    de(x), A(S, x);
  }), A(t, h), H(p);
}
K(
  T0,
  {
    id: {},
    ref: {},
    value: {},
    disabled: {},
    children: {},
    child: {},
    onSelect: {},
    forceMount: {},
    keywords: {}
  },
  [],
  [],
  { mode: "open" }
);
var R2 = /* @__PURE__ */ ne("<div><!></div>");
function D0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "aria-label", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "aria-label"
  ]);
  const u = Sh.create({
    id: z(() => n()),
    ref: z(() => s(), (b) => s(b)),
    ariaLabel: z(() => a() ?? "Suggestions...")
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(b = me(r)) {
      n(b), m();
    },
    get ref() {
      return s();
    },
    set ref(b = null) {
      s(b), m();
    },
    get child() {
      return o();
    },
    set child(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get "aria-label"() {
      return a();
    },
    set "aria-label"(b) {
      a(b), m();
    }
  }, g = M(), _ = D(g);
  return Ll(_, () => u.root._commandState.search === "", (b) => {
    var p = M(), h = D(p);
    {
      var y = (x) => {
        var P = M(), w = D(P);
        te(w, o, () => ({ props: d(c) })), A(x, P);
      }, S = (x) => {
        var P = R2();
        ve(P, () => ({ ...d(c) }));
        var w = ge(P);
        te(w, () => i() ?? he), de(P), A(x, P);
      };
      ue(h, (x) => {
        o() ? x(y) : x(S, !1);
      });
    }
    A(b, p);
  }), A(t, g), H(f);
}
K(D0, { id: {}, ref: {}, child: {}, children: {}, "aria-label": {} }, [], [], { mode: "open" });
var V2 = /* @__PURE__ */ ne("<div><!></div>");
function M0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "progress", 7, 0), s = v(e, "id", 23, () => me(r)), o = v(e, "ref", 15, null), i = v(e, "children", 7), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "progress",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const u = _h.create({
    id: z(() => s()),
    ref: z(() => o(), (h) => o(h)),
    progress: z(() => n())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get progress() {
      return n();
    },
    set progress(h = 0) {
      n(h), m();
    },
    get id() {
      return s();
    },
    set id(h = me(r)) {
      s(h), m();
    },
    get ref() {
      return o();
    },
    set ref(h = null) {
      o(h), m();
    },
    get children() {
      return i();
    },
    set children(h) {
      i(h), m();
    },
    get child() {
      return a();
    },
    set child(h) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, a, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = V2();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => i() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      a() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(M0, { progress: {}, id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var L2 = /* @__PURE__ */ ne("<div><!></div>");
function I0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "forceMount", 7, !1), i = v(e, "children", 7), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "forceMount",
    "children",
    "child"
  ]);
  const u = wh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p)),
    forceMount: z(() => o())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get forceMount() {
      return o();
    },
    set forceMount(p = !1) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    },
    get child() {
      return a();
    },
    set child(p) {
      a(p), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (p) => {
      var h = M(), y = D(h);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, a, () => ({ props: d(c) })), A(P, w);
        }, x = (P) => {
          var w = L2();
          ve(w, () => ({ ...d(c) }));
          var C = ge(w);
          te(C, () => i() ?? he), de(w), A(P, w);
        };
        ue(y, (P) => {
          a() ? P(S) : P(x, !1);
        });
      }
      A(p, h);
    };
    ue(_, (p) => {
      u.shouldRender && p(b);
    });
  }
  return A(t, g), H(f);
}
K(I0, { id: {}, ref: {}, forceMount: {}, children: {}, child: {} }, [], [], { mode: "open" });
const kp = 1, j2 = 0.9, B2 = 0.8, z2 = 0.17, Xu = 0.1, Ju = 0.999, q2 = 0.9999, U2 = 0.99, K2 = /[\\/_+.#"@[({&]/, W2 = /[\\/_+.#"@[({&]/g, H2 = /[\s-]/, N0 = /[\s-]/g;
function Gc(t, e, r, n, s, o, i) {
  if (o === e.length)
    return s === t.length ? kp : U2;
  const a = `${s},${o}`;
  if (i[a] !== void 0)
    return i[a];
  const l = n.charAt(o);
  let u = r.indexOf(l, s), c = 0, f, g, _, b;
  for (; u >= 0; )
    f = Gc(t, e, r, n, u + 1, o + 1, i), f > c && (u === s ? f *= kp : K2.test(t.charAt(u - 1)) ? (f *= B2, _ = t.slice(s, u - 1).match(W2), _ && s > 0 && (f *= Ju ** _.length)) : H2.test(t.charAt(u - 1)) ? (f *= j2, b = t.slice(s, u - 1).match(N0), b && s > 0 && (f *= Ju ** b.length)) : (f *= z2, s > 0 && (f *= Ju ** (u - s))), t.charAt(u) !== e.charAt(o) && (f *= q2)), (f < Xu && r.charAt(u - 1) === n.charAt(o + 1) || n.charAt(o + 1) === n.charAt(o) && r.charAt(u - 1) !== n.charAt(o)) && (g = Gc(t, e, r, n, u + 1, o + 2, i), g * Xu > f && (f = g * Xu)), f > c && (c = f), u = r.indexOf(l, u + 1);
  return i[a] = c, c;
}
function $p(t) {
  return t.toLowerCase().replace(N0, " ");
}
function Yc(t, e, r) {
  return t = r && r.length > 0 ? `${`${t} ${r?.join(" ")}`}` : t, Gc(t, e, $p(t), $p(e), 0, 0, {});
}
function Ap(t, e) {
  const [r, n] = t;
  let s = !1;
  const o = e.length;
  for (let i = 0, a = o - 1; i < o; a = i++) {
    const [l, u] = e[i] ?? [0, 0], [c, f] = e[a] ?? [0, 0];
    u >= n != f >= n && r <= (c - l) * (n - u) / (f - u) + l && (s = !s);
  }
  return s;
}
function Ep(t, e) {
  return t[0] >= e.left && t[0] <= e.right && t[1] >= e.top && t[1] <= e.bottom;
}
function G2(t, e) {
  const r = t.left + t.width / 2, n = t.top + t.height / 2, s = e.left + e.width / 2, o = e.top + e.height / 2, i = s - r, a = o - n;
  return Math.abs(i) > Math.abs(a) ? i > 0 ? "right" : "left" : a > 0 ? "bottom" : "top";
}
class Y2 {
  #e;
  #t;
  // tracks the cursor position when leaving trigger or content
  #r = null;
  // tracks what we're moving toward: "content" when leaving trigger, "trigger" when leaving content
  #n = null;
  constructor(e) {
    this.#e = e, this.#t = e.buffer ?? 1, Fe([e.triggerNode, e.contentNode, e.enabled], ([r, n, s]) => {
      if (!r || !n || !s) {
        this.#r = null, this.#n = null;
        return;
      }
      const o = Ud(r), i = (f) => {
        this.#s(f, r, n);
      }, a = (f) => {
        const g = f.relatedTarget;
        ci(g) && n.contains(g) || (this.#r = [f.clientX, f.clientY], this.#n = "content");
      }, l = () => {
        this.#r = null, this.#n = null;
      }, u = () => {
        this.#r = null, this.#n = null;
      }, c = (f) => {
        const g = f.relatedTarget;
        ci(g) && r.contains(g) || (this.#r = [f.clientX, f.clientY], this.#n = "trigger");
      };
      return [
        Ye(o, "pointermove", i),
        Ye(r, "pointerleave", a),
        Ye(r, "pointerenter", l),
        Ye(n, "pointerenter", u),
        Ye(n, "pointerleave", c)
      ].reduce(
        (f, g) => () => {
          f(), g();
        },
        () => {
        }
      );
    });
  }
  #s(e, r, n) {
    if (!this.#r || !this.#n) return;
    const s = [e.clientX, e.clientY], o = r.getBoundingClientRect(), i = n.getBoundingClientRect();
    if (this.#n === "content" && Ep(s, i)) {
      this.#r = null, this.#n = null;
      return;
    }
    if (this.#n === "trigger" && Ep(s, o)) {
      this.#r = null, this.#n = null;
      return;
    }
    const a = G2(o, i), l = this.#o(o, i, a);
    if (l && Ap(s, l))
      return;
    const u = this.#n === "content" ? i : o, c = this.#i(this.#r, u, a, this.#n);
    Ap(s, c) || (this.#r = null, this.#n = null, this.#e.onPointerExit());
  }
  /**
   * Creates a rectangular corridor between trigger and content
   * This prevents closing when cursor is in the gap between them
   */
  #o(e, r, n) {
    const s = this.#t;
    switch (n) {
      case "top":
        return [
          [
            Math.min(e.left, r.left) - s,
            e.top
          ],
          [
            Math.min(e.left, r.left) - s,
            r.bottom
          ],
          [
            Math.max(e.right, r.right) + s,
            r.bottom
          ],
          [
            Math.max(e.right, r.right) + s,
            e.top
          ]
        ];
      case "bottom":
        return [
          [
            Math.min(e.left, r.left) - s,
            e.bottom
          ],
          [
            Math.min(e.left, r.left) - s,
            r.top
          ],
          [
            Math.max(e.right, r.right) + s,
            r.top
          ],
          [
            Math.max(e.right, r.right) + s,
            e.bottom
          ]
        ];
      case "left":
        return [
          [
            e.left,
            Math.min(e.top, r.top) - s
          ],
          [
            r.right,
            Math.min(e.top, r.top) - s
          ],
          [
            r.right,
            Math.max(e.bottom, r.bottom) + s
          ],
          [
            e.left,
            Math.max(e.bottom, r.bottom) + s
          ]
        ];
      case "right":
        return [
          [
            e.right,
            Math.min(e.top, r.top) - s
          ],
          [
            r.left,
            Math.min(e.top, r.top) - s
          ],
          [
            r.left,
            Math.max(e.bottom, r.bottom) + s
          ],
          [
            e.right,
            Math.max(e.bottom, r.bottom) + s
          ]
        ];
    }
  }
  /**
   * Creates a triangular/trapezoidal safe zone from the exit point to the target
   */
  #i(e, r, n, s) {
    const o = this.#t * 4, [i, a] = e;
    switch (s === "trigger" ? this.#a(n) : n) {
      case "top":
        return [
          [i - o, a + o],
          [i + o, a + o],
          [r.right + o, r.bottom],
          [r.right + o, r.top],
          [r.left - o, r.top],
          [r.left - o, r.bottom]
        ];
      case "bottom":
        return [
          [i - o, a - o],
          [i + o, a - o],
          [r.right + o, r.top],
          [r.right + o, r.bottom],
          [r.left - o, r.bottom],
          [r.left - o, r.top]
        ];
      case "left":
        return [
          [i + o, a - o],
          [i + o, a + o],
          [r.right, r.bottom + o],
          [r.left, r.bottom + o],
          [r.left, r.top - o],
          [r.right, r.top - o]
        ];
      case "right":
        return [
          [i - o, a - o],
          [i - o, a + o],
          [r.left, r.bottom + o],
          [r.right, r.bottom + o],
          [r.right, r.top - o],
          [r.left, r.top - o]
        ];
    }
  }
  #a(e) {
    switch (e) {
      case "top":
        return "bottom";
      case "bottom":
        return "top";
      case "left":
        return "right";
      case "right":
        return "left";
    }
  }
}
const _l = tr({
  component: "popover",
  parts: ["root", "trigger", "content", "close", "overlay"]
}), fu = new ht("Popover.Root");
class Ph {
  static create(e) {
    return fu.set(new Ph(e));
  }
  opts;
  #e = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#e);
  }
  set contentNode(e) {
    q(this.#e, e, !0);
  }
  contentPresence;
  #t = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#t);
  }
  set triggerNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get overlayNode() {
    return d(this.#r);
  }
  set overlayNode(e) {
    q(this.#r, e, !0);
  }
  overlayPresence;
  #n = /* @__PURE__ */ xe(!1);
  get openedViaHover() {
    return d(this.#n);
  }
  set openedViaHover(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(!1);
  get hasInteractedWithContent() {
    return d(this.#s);
  }
  set hasInteractedWithContent(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(!1);
  get hoverCooldown() {
    return d(this.#o);
  }
  set hoverCooldown(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(0);
  get closeDelay() {
    return d(this.#i);
  }
  set closeDelay(e) {
    q(this.#i, e, !0);
  }
  #a = null;
  #u = null;
  constructor(e) {
    this.opts = e, this.contentPresence = new bi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), this.overlayPresence = new bi({ ref: z(() => this.overlayNode), open: this.opts.open }), Fe(() => this.opts.open.current, (r) => {
      r || (this.openedViaHover = !1, this.hasInteractedWithContent = !1, this.#l());
    });
  }
  setDomContext(e) {
    this.#u = e;
  }
  #l() {
    this.#a !== null && this.#u && (this.#u.clearTimeout(this.#a), this.#a = null);
  }
  toggleOpen() {
    this.#l(), this.opts.open.current = !this.opts.open.current;
  }
  handleClose() {
    this.#l(), this.opts.open.current && (this.opts.open.current = !1);
  }
  handleHoverOpen() {
    this.#l(), !this.opts.open.current && (this.openedViaHover = !0, this.opts.open.current = !0);
  }
  handleHoverClose() {
    this.opts.open.current && this.openedViaHover && !this.hasInteractedWithContent && (this.opts.open.current = !1);
  }
  handleDelayedHoverClose() {
    this.opts.open.current && (!this.openedViaHover || this.hasInteractedWithContent || (this.#l(), this.closeDelay <= 0 ? this.opts.open.current = !1 : this.#u && (this.#a = this.#u.setTimeout(
      () => {
        this.openedViaHover && !this.hasInteractedWithContent && (this.opts.open.current = !1), this.#a = null;
      },
      this.closeDelay
    ))));
  }
  cancelDelayedClose() {
    this.#l();
  }
  markInteraction() {
    this.hasInteractedWithContent = !0, this.#l();
  }
}
class Oh {
  static create(e) {
    return new Oh(e, fu.get());
  }
  opts;
  root;
  attachment;
  domContext;
  #e = null;
  #t = null;
  #r = /* @__PURE__ */ xe(!1);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.triggerNode = n), this.domContext = new Fn(e.ref), this.root.setDomContext(this.domContext), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this), Fe(() => this.opts.closeDelay.current, (n) => {
      this.root.closeDelay = n;
    });
  }
  #n() {
    this.#e !== null && (this.domContext.clearTimeout(this.#e), this.#e = null);
  }
  #s() {
    this.#t !== null && (this.domContext.clearTimeout(this.#t), this.#t = null);
  }
  #o() {
    this.#n(), this.#s();
  }
  onpointerenter(e) {
    if (this.opts.disabled.current || !this.opts.openOnHover.current || ol(e) || (q(this.#r, !0), this.#s(), this.root.cancelDelayedClose(), this.root.opts.open.current || this.root.hoverCooldown)) return;
    const r = this.opts.openDelay.current;
    r <= 0 ? this.root.handleHoverOpen() : this.#e = this.domContext.setTimeout(
      () => {
        this.root.handleHoverOpen(), this.#e = null;
      },
      r
    );
  }
  onpointerleave(e) {
    this.opts.disabled.current || this.opts.openOnHover.current && (ol(e) || (q(this.#r, !1), this.#n(), this.root.hoverCooldown = !1));
  }
  onclick(e) {
    if (!this.opts.disabled.current && e.button === 0) {
      if (this.#o(), d(this.#r) && this.root.opts.open.current && this.root.openedViaHover) {
        this.root.openedViaHover = !1, this.root.hasInteractedWithContent = !0;
        return;
      }
      d(this.#r) && this.opts.openOnHover.current && this.root.opts.open.current && (this.root.hoverCooldown = !0), this.root.hoverCooldown && !this.root.opts.open.current && (this.root.hoverCooldown = !1), this.root.toggleOpen();
    }
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === Br || e.key === xr) && (e.preventDefault(), this.#o(), this.root.toggleOpen());
  }
  #i() {
    if (this.root.opts.open.current && this.root.contentNode?.id)
      return this.root.contentNode?.id;
  }
  #a = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "aria-haspopup": "dialog",
    "aria-expanded": at(this.root.opts.open.current),
    "data-state": Vi(this.root.opts.open.current),
    "aria-controls": this.#i(),
    [_l.trigger]: "",
    disabled: this.opts.disabled.current,
    //
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    onpointerenter: this.onpointerenter,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
class Ch {
  static create(e) {
    return new Ch(e, fu.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref, (n) => this.root.contentNode = n), this.onpointerdown = this.onpointerdown.bind(this), this.onfocusin = this.onfocusin.bind(this), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this), new Y2({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.root.contentNode,
      enabled: () => this.root.opts.open.current && this.root.openedViaHover && !this.root.hasInteractedWithContent,
      onPointerExit: () => {
        this.root.handleDelayedHoverClose();
      }
    });
  }
  onpointerdown(e) {
    this.root.markInteraction();
  }
  onfocusin(e) {
    const r = e.target;
    ci(r) && nA(r) && this.root.markInteraction();
  }
  onpointerenter(e) {
    ol(e) || this.root.cancelDelayedClose();
  }
  onpointerleave(e) {
    ol(e);
  }
  onInteractOutside = (e) => {
    if (this.opts.onInteractOutside.current(e), e.defaultPrevented || !ci(e.target)) return;
    const r = e.target.closest(_l.selector("trigger"));
    if (!(r && r === this.root.triggerNode)) {
      if (this.opts.customAnchor.current) {
        if (ci(this.opts.customAnchor.current)) {
          if (this.opts.customAnchor.current.contains(e.target)) return;
        } else if (typeof this.opts.customAnchor.current == "string") {
          const n = document.querySelector(this.opts.customAnchor.current);
          if (n && n.contains(e.target)) return;
        }
      }
      this.root.handleClose();
    }
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get shouldTrapFocus() {
    return !(this.root.openedViaHover && !this.root.hasInteractedWithContent);
  }
  #e = /* @__PURE__ */ O(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    tabindex: -1,
    "data-state": Vi(this.root.opts.open.current),
    [_l.content]: "",
    style: { pointerEvents: "auto", contain: "layout style paint" },
    onpointerdown: this.onpointerdown,
    onfocusin: this.onfocusin,
    onpointerenter: this.onpointerenter,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown
  };
}
class kh {
  static create(e) {
    return new kh(e, fu.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.root.handleClose();
  }
  onkeydown(e) {
    (e.key === Br || e.key === xr) && (e.preventDefault(), this.root.handleClose());
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    type: "button",
    [_l.close]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var X2 = /* @__PURE__ */ ne("<div><div><!></div></div>"), J2 = /* @__PURE__ */ ne("<div><div><!></div></div>");
function F0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "forceMount", 7, !1), l = v(e, "onOpenAutoFocus", 7, _e), u = v(e, "onCloseAutoFocus", 7, _e), c = v(e, "onEscapeKeydown", 7, _e), f = v(e, "onInteractOutside", 7, _e), g = v(e, "trapFocus", 7, !0), _ = v(e, "preventScroll", 7, !1), b = v(e, "customAnchor", 7, null), p = v(e, "style", 7), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id",
    "forceMount",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "customAnchor",
    "style"
  ]);
  const y = Ch.create({
    id: z(() => i()),
    ref: z(() => o(), (E) => o(E)),
    onInteractOutside: z(() => f()),
    onEscapeKeydown: z(() => c()),
    customAnchor: z(() => b())
  }), S = /* @__PURE__ */ O(() => Ce(h, y.props)), x = /* @__PURE__ */ O(() => g() && y.shouldTrapFocus);
  function P(E) {
    y.shouldTrapFocus || E.preventDefault(), l()(E);
  }
  var w = {
    get child() {
      return n();
    },
    set child(E) {
      n(E), m();
    },
    get children() {
      return s();
    },
    set children(E) {
      s(E), m();
    },
    get ref() {
      return o();
    },
    set ref(E = null) {
      o(E), m();
    },
    get id() {
      return i();
    },
    set id(E = me(r)) {
      i(E), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(E = !1) {
      a(E), m();
    },
    get onOpenAutoFocus() {
      return l();
    },
    set onOpenAutoFocus(E = _e) {
      l(E), m();
    },
    get onCloseAutoFocus() {
      return u();
    },
    set onCloseAutoFocus(E = _e) {
      u(E), m();
    },
    get onEscapeKeydown() {
      return c();
    },
    set onEscapeKeydown(E = _e) {
      c(E), m();
    },
    get onInteractOutside() {
      return f();
    },
    set onInteractOutside(E = _e) {
      f(E), m();
    },
    get trapFocus() {
      return g();
    },
    set trapFocus(E = !0) {
      g(E), m();
    },
    get preventScroll() {
      return _();
    },
    set preventScroll(E = !1) {
      _(E), m();
    },
    get customAnchor() {
      return b();
    },
    set customAnchor(E = null) {
      b(E), m();
    },
    get style() {
      return p();
    },
    set style(E) {
      p(E), m();
    }
  }, C = M(), k = D(C);
  {
    var $ = (E) => {
      hh(E, ce(() => d(S), () => y.popperProps, {
        get ref() {
          return y.opts.ref;
        },
        get enabled() {
          return y.root.opts.open.current;
        },
        get id() {
          return i();
        },
        get trapFocus() {
          return d(x);
        },
        get preventScroll() {
          return _();
        },
        loop: !0,
        forceMount: !0,
        get customAnchor() {
          return b();
        },
        onOpenAutoFocus: P,
        get onCloseAutoFocus() {
          return u();
        },
        get shouldRender() {
          return y.shouldRender;
        },
        popper: (F, U) => {
          let B = () => U?.().props, R = () => U?.().wrapperProps;
          const Z = /* @__PURE__ */ O(() => Ce(B(), { style: Hc("popover") }, { style: p() }));
          var Y = M(), X = D(Y);
          {
            var ae = (j) => {
              var ee = M(), L = D(ee);
              {
                let N = /* @__PURE__ */ O(() => ({
                  props: d(Z),
                  wrapperProps: R(),
                  ...y.snippetProps
                }));
                te(L, n, () => d(N));
              }
              A(j, ee);
            }, J = (j) => {
              var ee = X2();
              ve(ee, () => ({ ...R() }));
              var L = ge(ee);
              ve(L, () => ({ ...d(Z) }));
              var N = ge(L);
              te(N, () => s() ?? he), de(L), de(ee), A(j, ee);
            };
            ue(X, (j) => {
              n() ? j(ae) : j(J, !1);
            });
          }
          A(F, Y);
        },
        $$slots: { popper: !0 }
      }));
    }, T = (E) => {
      var I = M(), F = D(I);
      {
        var U = (B) => {
          fh(B, ce(() => d(S), () => y.popperProps, {
            get ref() {
              return y.opts.ref;
            },
            get open() {
              return y.root.opts.open.current;
            },
            get id() {
              return i();
            },
            get trapFocus() {
              return d(x);
            },
            get preventScroll() {
              return _();
            },
            loop: !0,
            forceMount: !1,
            get customAnchor() {
              return b();
            },
            onOpenAutoFocus: P,
            get onCloseAutoFocus() {
              return u();
            },
            get shouldRender() {
              return y.shouldRender;
            },
            popper: (Z, Y) => {
              let X = () => Y?.().props, ae = () => Y?.().wrapperProps;
              const J = /* @__PURE__ */ O(() => Ce(X(), { style: Hc("popover") }, { style: p() }));
              var j = M(), ee = D(j);
              {
                var L = (V) => {
                  var G = M(), fe = D(G);
                  {
                    let se = /* @__PURE__ */ O(() => ({
                      props: d(J),
                      wrapperProps: ae(),
                      ...y.snippetProps
                    }));
                    te(fe, n, () => d(se));
                  }
                  A(V, G);
                }, N = (V) => {
                  var G = J2();
                  ve(G, () => ({ ...ae() }));
                  var fe = ge(G);
                  ve(fe, () => ({ ...d(J) }));
                  var se = ge(fe);
                  te(se, () => s() ?? he), de(fe), de(G), A(V, G);
                };
                ue(ee, (V) => {
                  n() ? V(L) : V(N, !1);
                });
              }
              A(Z, j);
            },
            $$slots: { popper: !0 }
          }));
        };
        ue(
          F,
          (B) => {
            a() || B(U);
          },
          !0
        );
      }
      A(E, I);
    };
    ue(k, (E) => {
      a() ? E($) : E(T, !1);
    });
  }
  return A(t, C), H(w);
}
K(
  F0,
  {
    child: {},
    children: {},
    ref: {},
    id: {},
    forceMount: {},
    onOpenAutoFocus: {},
    onCloseAutoFocus: {},
    onEscapeKeydown: {},
    onInteractOutside: {},
    trapFocus: {},
    preventScroll: {},
    customAnchor: {},
    style: {}
  },
  [],
  [],
  { mode: "open" }
);
var Z2 = /* @__PURE__ */ ne("<button><!></button>");
function R0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7, !1), u = v(e, "openOnHover", 7, !1), c = v(e, "openDelay", 7, 700), f = v(e, "closeDelay", 7, 300), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "type",
    "disabled",
    "openOnHover",
    "openDelay",
    "closeDelay"
  ]);
  const _ = Oh.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h)),
    disabled: z(() => !!l()),
    openOnHover: z(() => u()),
    openDelay: z(() => c()),
    closeDelay: z(() => f())
  }), b = /* @__PURE__ */ O(() => Ce(g, _.props, { type: a() }));
  var p = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get type() {
      return a();
    },
    set type(h = "button") {
      a(h), m();
    },
    get disabled() {
      return l();
    },
    set disabled(h = !1) {
      l(h), m();
    },
    get openOnHover() {
      return u();
    },
    set openOnHover(h = !1) {
      u(h), m();
    },
    get openDelay() {
      return c();
    },
    set openDelay(h = 700) {
      c(h), m();
    },
    get closeDelay() {
      return f();
    },
    set closeDelay(h = 300) {
      f(h), m();
    }
  };
  return uh(t, {
    get id() {
      return o();
    },
    get ref() {
      return _.opts.ref;
    },
    children: (h, y) => {
      var S = M(), x = D(S);
      {
        var P = (C) => {
          var k = M(), $ = D(k);
          te($, s, () => ({ props: d(b) })), A(C, k);
        }, w = (C) => {
          var k = Z2();
          ve(k, () => ({ ...d(b) }));
          var $ = ge(k);
          te($, () => n() ?? he), de(k), A(C, k);
        };
        ue(x, (C) => {
          s() ? C(P) : C(w, !1);
        });
      }
      A(h, S);
    },
    $$slots: { default: !0 }
  }), H(p);
}
K(
  R0,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    type: {},
    disabled: {},
    openOnHover: {},
    openDelay: {},
    closeDelay: {}
  },
  [],
  [],
  { mode: "open" }
);
var Q2 = /* @__PURE__ */ ne("<button><!></button>");
function V0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "id",
    "ref"
  ]);
  const l = kh.create({
    id: z(() => o()),
    ref: z(() => i(), (p) => i(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get child() {
      return n();
    },
    set child(p) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    },
    get id() {
      return o();
    },
    set id(p = me(r)) {
      o(p), m();
    },
    get ref() {
      return i();
    },
    set ref(p = null) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, n, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = Q2();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => s() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      n() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(V0, { child: {}, children: {}, id: {}, ref: {} }, [], [], { mode: "open" });
const L0 = new ht("RangeCalendar.Cell");
class $h {
  static create(e) {
    return Ut.set(new $h(e));
  }
  opts;
  attachment;
  #e = /* @__PURE__ */ O(() => this.months.map((e) => e.value));
  get visibleMonths() {
    return d(this.#e);
  }
  set visibleMonths(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ xe(Pt([]));
  get months() {
    return d(this.#t);
  }
  set months(e) {
    q(this.#t, e, !0);
  }
  announcer;
  formatter;
  accessibleHeadingId = En();
  #r = /* @__PURE__ */ xe(void 0);
  get focusedValue() {
    return d(this.#r);
  }
  set focusedValue(e) {
    q(this.#r, e, !0);
  }
  lastPressedDateValue = void 0;
  domContext;
  #n = /* @__PURE__ */ O(() => M_({
    months: this.months,
    formatter: this.formatter,
    weekdayFormat: this.opts.weekdayFormat.current
  }));
  get weekdays() {
    return d(this.#n);
  }
  set weekdays(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.opts.startValue.current ? this.isDateUnavailable(this.opts.startValue.current) || this.isDateDisabled(this.opts.startValue.current) : !1);
  get isStartInvalid() {
    return d(this.#s);
  }
  set isStartInvalid(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => this.opts.endValue.current ? this.isDateUnavailable(this.opts.endValue.current) || this.isDateDisabled(this.opts.endValue.current) : !1);
  get isEndInvalid() {
    return d(this.#o);
  }
  set isEndInvalid(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => !!(this.isStartInvalid || this.isEndInvalid || this.opts.endValue.current && this.opts.startValue.current && Bt(this.opts.endValue.current, this.opts.startValue.current)));
  get isInvalid() {
    return d(this.#i);
  }
  set isInvalid(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => F_({
    maxValue: this.opts.maxValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isNextButtonDisabled() {
    return d(this.#a);
  }
  set isNextButtonDisabled(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => R_({
    minValue: this.opts.minValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isPrevButtonDisabled() {
    return d(this.#u);
  }
  set isPrevButtonDisabled(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => (this.opts.monthFormat.current, this.opts.yearFormat.current, V_({
    months: this.months,
    formatter: this.formatter,
    locale: this.opts.locale.current
  })));
  get headingValue() {
    return d(this.#l);
  }
  set headingValue(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => `${this.opts.calendarLabel.current} ${this.headingValue}`);
  get fullCalendarLabel() {
    return d(this.#c);
  }
  set fullCalendarLabel(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => {
    if (this.opts.startValue.current && this.opts.endValue.current || !this.opts.startValue.current || !this.focusedValue) return null;
    const e = Bt(this.opts.startValue.current, this.focusedValue), r = e ? this.opts.startValue.current : this.focusedValue, n = e ? this.focusedValue : this.opts.startValue.current, s = { start: r, end: n };
    return bt(r.add({ days: 1 }), n) || bt(r, n) || pE(r, n, this.isDateUnavailable, this.isDateDisabled) ? s : null;
  });
  get highlightedRange() {
    return d(this.#d);
  }
  set highlightedRange(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => ot(() => this.opts.placeholder.current.year));
  get initialPlaceholderYear() {
    return d(this.#g);
  }
  set initialPlaceholderYear(e) {
    q(this.#g, e);
  }
  #m = /* @__PURE__ */ O(() => z_({
    minValue: this.opts.minValue.current,
    maxValue: this.opts.maxValue.current,
    placeholderYear: this.initialPlaceholderYear
  }));
  get defaultYears() {
    return d(this.#m);
  }
  set defaultYears(e) {
    q(this.#m, e);
  }
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref), this.domContext = new Fn(e.ref), this.announcer = hl(null), this.formatter = $_({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    }), this.months = No({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    }), Co(() => {
      this.formatter.getLocale() !== this.opts.locale.current && this.formatter.setLocale(this.opts.locale.current);
    }), ko(() => {
      this.announcer = hl(this.domContext.getDocument());
    }), N_({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: this.setMonths
    }), I_({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    }), Xe(() => {
      const r = this.domContext.getElementById(this.accessibleHeadingId);
      r && (r.textContent = this.fullCalendarLabel);
    }), Fe(() => this.opts.value.current, (r) => {
      r.start && r.end ? (this.opts.startValue.current = r.start, this.opts.endValue.current = r.end) : r.start ? (this.opts.startValue.current = r.start, this.opts.endValue.current = void 0) : r.start === void 0 && r.end === void 0 && (this.opts.startValue.current = void 0, this.opts.endValue.current = void 0);
    }), Fe(() => this.opts.value.current, (r) => {
      const n = r.start;
      n && this.opts.placeholder.current !== n && (this.opts.placeholder.current = n);
    }), Fe(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current,
        () => this.opts.excludeDisabled.current
      ],
      ([r, n, s]) => {
        !s || !r || !n || this.#_(r, n) && (this.#f(void 0), this.#h(void 0), this.#y());
      }
    ), Fe(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([r, n]) => {
        this.opts.value.current && this.opts.value.current.start === r && this.opts.value.current.end === n || (r && n ? this.#p((s) => {
          if (s.start === r && s.end === n)
            return s;
          if (Bt(n, r)) {
            const o = r, i = n;
            return this.#f(i), this.#h(o), this.#b(n, r) ? { start: n, end: r } : (this.#f(r), this.#h(void 0), { start: r, end: void 0 });
          } else
            return this.#b(r, n) ? { start: r, end: n } : (this.#f(n), this.#h(void 0), { start: n, end: void 0 });
        }) : this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end && (this.opts.value.current.start = void 0, this.opts.value.current.end = void 0));
      }
    ), this.shiftFocus = this.shiftFocus.bind(this), this.handleCellClick = this.handleCellClick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.nextYear = this.nextYear.bind(this), this.prevYear = this.prevYear.bind(this), this.setYear = this.setYear.bind(this), this.setMonth = this.setMonth.bind(this), this.isDateDisabled = this.isDateDisabled.bind(this), this.isDateUnavailable = this.isDateUnavailable.bind(this), this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this), this.isSelected = this.isSelected.bind(this), j_({
      placeholder: e.placeholder,
      defaultPlaceholder: e.defaultPlaceholder,
      isDateDisabled: e.isDateDisabled,
      maxValue: e.maxValue,
      minValue: e.minValue,
      ref: e.ref
    });
  }
  #p(e) {
    const r = this.opts.value.current, n = e(r);
    this.opts.value.current = n, n.start && n.end && this.opts.onRangeSelect?.current?.();
  }
  #f(e) {
    this.opts.startValue.current = e, this.#p((r) => ({ ...r, start: e }));
  }
  #h(e) {
    this.opts.endValue.current = e, this.#p((r) => ({ ...r, end: e }));
  }
  setMonths = (e) => {
    this.months = e;
  };
  isOutsideVisibleMonths(e) {
    return !this.visibleMonths.some((r) => Io(e, r));
  }
  isDateDisabled(e) {
    if (this.opts.isDateDisabled.current(e) || this.opts.disabled.current) return !0;
    const r = this.opts.minValue.current, n = this.opts.maxValue.current;
    return !!(r && Bt(e, r) || n && C_(e, n));
  }
  isDateUnavailable(e) {
    return !!this.opts.isDateUnavailable.current(e);
  }
  isSelectionStart(e) {
    return this.opts.startValue.current ? bt(e, this.opts.startValue.current) : !1;
  }
  isSelectionEnd(e) {
    return this.opts.endValue.current ? bt(e, this.opts.endValue.current) : !1;
  }
  isSelected(e) {
    return this.opts.startValue.current && bt(this.opts.startValue.current, e) || this.opts.endValue.current && bt(this.opts.endValue.current, e) ? !0 : this.opts.startValue.current && this.opts.endValue.current ? k_(e, this.opts.startValue.current, this.opts.endValue.current) : !1;
  }
  #b(e, r) {
    const n = Bt(r, e) ? r : e, s = Bt(r, e) ? e : r, o = n.toDate(ft()), a = s.toDate(ft()).getTime() - o.getTime(), u = Math.floor(a / (1e3 * 60 * 60 * 24)) + 1;
    return !(this.opts.minDays.current && u < this.opts.minDays.current || this.opts.maxDays.current && u > this.opts.maxDays.current || this.opts.excludeDisabled.current && this.#_(n, s));
  }
  shiftFocus(e, r) {
    return A_({
      node: e,
      add: r,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #y() {
    this.announcer.announce("Selected date is now empty.", "polite");
  }
  #v(e) {
    this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(e, !1)}`, "polite");
  }
  #S(e, r) {
    this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(e, !1)} to ${this.formatter.selectedDate(r, !1)}`, "polite");
  }
  handleCellClick(e, r) {
    if (this.isDateDisabled(r) || this.isDateUnavailable(r)) return;
    const n = this.lastPressedDateValue;
    if (this.lastPressedDateValue = r, this.opts.startValue.current && this.highlightedRange === null)
      if (bt(this.opts.startValue.current, r) && !this.opts.preventDeselect.current && !this.opts.endValue.current) {
        this.#f(void 0), this.opts.placeholder.current = r, this.#y();
        return;
      } else this.opts.endValue.current || (e.preventDefault(), n && bt(n, r) && (this.#f(r), this.#v(r)));
    if (this.opts.startValue.current && this.opts.endValue.current && bt(this.opts.endValue.current, r) && !this.opts.preventDeselect.current) {
      this.#f(void 0), this.#h(void 0), this.opts.placeholder.current = r, this.#y();
      return;
    }
    if (!this.opts.startValue.current)
      this.#v(r), this.#f(r);
    else if (this.opts.endValue.current)
      this.opts.endValue.current && this.opts.startValue.current && (this.#h(void 0), this.#v(r), this.#f(r));
    else {
      const s = this.opts.startValue.current, o = r, i = Bt(o, s) ? o : s, a = Bt(o, s) ? s : o;
      this.#b(i, a) ? Bt(o, s) ? (this.#f(o), this.#h(s), this.#S(o, s)) : (this.#h(r), this.#S(this.opts.startValue.current, r)) : (this.#f(r), this.#h(void 0), this.#v(r));
    }
  }
  onkeydown(e) {
    return E_({
      event: e,
      handleCellClick: this.handleCellClick,
      placeholderValue: this.opts.placeholder.current,
      shiftFocus: this.shiftFocus
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    T_({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    D_({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year: e });
  }
  setMonth(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month: e });
  }
  getBitsAttr = (e) => B_.getAttr(e, "range-calendar");
  #w = /* @__PURE__ */ O(() => ({ months: this.months, weekdays: this.weekdays }));
  get snippetProps() {
    return d(this.#w);
  }
  set snippetProps(e) {
    q(this.#w, e);
  }
  #x = /* @__PURE__ */ O(() => ({
    ...L_({
      fullCalendarLabel: this.fullCalendarLabel,
      id: this.opts.id.current,
      isInvalid: this.isInvalid,
      disabled: this.opts.disabled.current,
      readonly: this.opts.readonly.current
    }),
    [this.getBitsAttr("root")]: "",
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#x);
  }
  set props(e) {
    q(this.#x, e);
  }
  #_(e, r) {
    for (let n = e; Bt(n, r) || bt(n, r); n = n.add({ days: 1 }))
      if (this.isDateDisabled(n)) return !0;
    return !1;
  }
}
class Ah {
  static create(e) {
    return L0.set(new Ah(e, Ut.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => _r(this.opts.date.current));
  get cellDate() {
    return d(this.#e);
  }
  set cellDate(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => !Io(this.opts.date.current, this.opts.month.current));
  get isOutsideMonth() {
    return d(this.#t);
  }
  set isOutsideMonth(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current);
  get isDisabled() {
    return d(this.#r);
  }
  set isDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.root.opts.isDateUnavailable.current(this.opts.date.current));
  get isUnavailable() {
    return d(this.#n);
  }
  set isUnavailable(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => s_(this.opts.date.current, ft()));
  get isDateToday() {
    return d(this.#s);
  }
  set isDateToday(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => this.root.isOutsideVisibleMonths(this.opts.date.current));
  get isOutsideVisibleMonths() {
    return d(this.#o);
  }
  set isOutsideVisibleMonths(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => bt(this.opts.date.current, this.root.opts.placeholder.current));
  get isFocusedDate() {
    return d(this.#i);
  }
  set isFocusedDate(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => this.root.isSelected(this.opts.date.current));
  get isSelectedDate() {
    return d(this.#a);
  }
  set isSelectedDate(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => this.root.isSelectionStart(this.opts.date.current));
  get isSelectionStart() {
    return d(this.#u);
  }
  set isSelectionStart(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => this.root.isSelectionStart(this.opts.date.current));
  get isRangeStart() {
    return d(this.#l);
  }
  set isRangeStart(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ O(() => this.root.opts.endValue.current ? this.root.isSelectionEnd(this.opts.date.current) : this.root.isSelectionStart(this.opts.date.current));
  get isRangeEnd() {
    return d(this.#c);
  }
  set isRangeEnd(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ O(() => this.isSelectionMiddle);
  get isRangeMiddle() {
    return d(this.#d);
  }
  set isRangeMiddle(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ O(() => this.isSelectedDate && !this.isSelectionStart && !this.isSelectionEnd);
  get isSelectionMiddle() {
    return d(this.#g);
  }
  set isSelectionMiddle(e) {
    q(this.#g, e);
  }
  #m = /* @__PURE__ */ O(() => this.root.isSelectionEnd(this.opts.date.current));
  get isSelectionEnd() {
    return d(this.#m);
  }
  set isSelectionEnd(e) {
    q(this.#m, e);
  }
  #p = /* @__PURE__ */ O(() => this.root.highlightedRange ? k_(this.opts.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : !1);
  get isHighlighted() {
    return d(this.#p);
  }
  set isHighlighted(e) {
    q(this.#p, e);
  }
  #f = /* @__PURE__ */ O(() => this.root.formatter.custom(this.cellDate, {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  }));
  get labelText() {
    return d(this.#f);
  }
  set labelText(e) {
    q(this.#f, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #h = /* @__PURE__ */ O(() => ({
    disabled: this.isDisabled,
    unavailable: this.isUnavailable,
    selected: this.isSelectedDate
  }));
  get snippetProps() {
    return d(this.#h);
  }
  set snippetProps(e) {
    q(this.#h, e);
  }
  #b = /* @__PURE__ */ O(() => this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable);
  get ariaDisabled() {
    return d(this.#b);
  }
  set ariaDisabled(e) {
    q(this.#b, e);
  }
  #y = /* @__PURE__ */ O(() => ({
    "data-unavailable": Re(this.isUnavailable),
    "data-today": this.isDateToday ? "" : void 0,
    "data-outside-month": this.isOutsideMonth ? "" : void 0,
    "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
    "data-focused": this.isFocusedDate ? "" : void 0,
    "data-selection-start": this.isSelectionStart ? "" : void 0,
    "data-selection-end": this.isSelectionEnd ? "" : void 0,
    "data-range-start": this.isRangeStart ? "" : void 0,
    "data-range-end": this.isRangeEnd ? "" : void 0,
    "data-range-middle": this.isRangeMiddle ? "" : void 0,
    "data-highlighted": this.isHighlighted ? "" : void 0,
    "data-selected": Re(this.isSelectedDate),
    "data-value": this.opts.date.current.toString(),
    "data-type": P_(this.opts.date.current),
    "data-disabled": Re(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
  }));
  get sharedDataAttrs() {
    return d(this.#y);
  }
  set sharedDataAttrs(e) {
    q(this.#y, e);
  }
  #v = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "gridcell",
    "aria-selected": at(this.isSelectedDate),
    "aria-disabled": at(this.ariaDisabled),
    ...this.sharedDataAttrs,
    [this.root.getBitsAttr("cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#v);
  }
  set props(e) {
    q(this.#v, e);
  }
}
class Eh {
  static create(e) {
    return new Eh(e, L0.get());
  }
  opts;
  cell;
  attachment;
  constructor(e, r) {
    this.opts = e, this.cell = r, this.attachment = Te(e.ref), this.onclick = this.onclick.bind(this), this.onmouseenter = this.onmouseenter.bind(this), this.onfocusin = this.onfocusin.bind(this);
  }
  #e = /* @__PURE__ */ O(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1);
  onclick(e) {
    this.cell.isDisabled || this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  onmouseenter(e) {
    this.cell.isDisabled || (this.cell.root.focusedValue = this.cell.opts.date.current);
  }
  onfocusin(e) {
    this.cell.isDisabled || (this.cell.root.focusedValue = this.cell.opts.date.current);
  }
  #t = /* @__PURE__ */ O(() => ({
    disabled: this.cell.isDisabled,
    unavailable: this.cell.isUnavailable,
    selected: this.cell.isSelectedDate,
    day: `${this.cell.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#t);
  }
  set snippetProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "button",
    "aria-label": this.cell.labelText,
    "aria-disabled": at(this.cell.ariaDisabled),
    ...this.cell.sharedDataAttrs,
    tabindex: d(this.#e),
    [this.cell.root.getBitsAttr("day")]: "",
    "data-bits-day": "",
    onclick: this.onclick,
    onmouseenter: this.onmouseenter,
    onfocusin: this.onfocusin,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
var eT = /* @__PURE__ */ ne("<td><!></td>");
function j0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "date", 7), l = v(e, "month", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "date",
    "month"
  ]);
  const c = Ah.create({
    id: z(() => o()),
    ref: z(() => i(), (y) => i(y)),
    date: z(() => a()),
    month: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var g = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get id() {
      return o();
    },
    set id(y = me(r)) {
      o(y), m();
    },
    get ref() {
      return i();
    },
    set ref(y = null) {
      i(y), m();
    },
    get date() {
      return a();
    },
    set date(y) {
      a(y), m();
    },
    get month() {
      return l();
    },
    set month(y) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({ props: d(f), ...c.snippetProps }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = eT();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => n() ?? he, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(p) : y(h, !1);
    });
  }
  return A(t, _), H(g);
}
K(
  j0,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    date: {},
    month: {}
  },
  [],
  [],
  { mode: "open" }
);
var tT = /* @__PURE__ */ ne("<div><!></div>");
function B0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const l = Eh.create({
    id: z(() => o()),
    ref: z(() => i(), (p) => i(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get id() {
      return o();
    },
    set id(p = me(r)) {
      o(p), m();
    },
    get ref() {
      return i();
    },
    set ref(p = null) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      {
        let S = /* @__PURE__ */ O(() => ({ props: d(u), ...l.snippetProps }));
        te(y, s, () => d(S));
      }
      A(p, h);
    }, b = (p) => {
      var h = tT();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      {
        var S = (P) => {
          var w = M(), C = D(w);
          te(C, () => n() ?? he, () => l.snippetProps), A(P, w);
        }, x = (P) => {
          var w = st();
          ke(() => Ie(w, l.cell.opts.date.current.day)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(B0, { children: {}, child: {}, id: {}, ref: {} }, [], [], { mode: "open" });
function z0(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "onOpenChange", 7, _e), s = v(e, "onOpenChangeComplete", 7, _e), o = v(e, "children", 7);
  Hd.create({
    variant: z(() => "dialog"),
    open: z(() => r(), (u) => {
      r(u), n()(u);
    }),
    onOpenChangeComplete: z(() => s())
  });
  var i = {
    get open() {
      return r();
    },
    set open(u = !1) {
      r(u), m();
    },
    get onOpenChange() {
      return n();
    },
    set onOpenChange(u = _e) {
      n(u), m();
    },
    get onOpenChangeComplete() {
      return s();
    },
    set onOpenChangeComplete(u = _e) {
      s(u), m();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), m();
    }
  }, a = M(), l = D(a);
  return te(l, () => o() ?? he), A(t, a), H(i);
}
K(
  z0,
  {
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var rT = /* @__PURE__ */ ne("<button><!></button>");
function Th(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "disabled", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "disabled"
  ]);
  const u = Yd.create({
    variant: z(() => "close"),
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h)),
    disabled: z(() => !!a())
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get disabled() {
      return a();
    },
    set disabled(h = !1) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = rT();
      ve(y, () => ({ ...d(c) }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(Th, { children: {}, child: {}, id: {}, ref: {}, disabled: {} }, [], [], { mode: "open" });
var nT = /* @__PURE__ */ ne("<!> <!>", 1), sT = /* @__PURE__ */ ne("<!> <div><!></div>", 1);
function q0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "ref", 15, null), a = v(e, "forceMount", 7, !1), l = v(e, "onCloseAutoFocus", 7, _e), u = v(e, "onOpenAutoFocus", 7, _e), c = v(e, "onEscapeKeydown", 7, _e), f = v(e, "onInteractOutside", 7, _e), g = v(e, "trapFocus", 7, !0), _ = v(e, "preventScroll", 7, !0), b = v(e, "restoreScrollDelay", 7, null), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "ref",
    "forceMount",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "restoreScrollDelay"
  ]);
  const h = Zd.create({
    id: z(() => n()),
    ref: z(() => i(), (C) => i(C))
  }), y = /* @__PURE__ */ O(() => Ce(p, h.props));
  var S = {
    get id() {
      return n();
    },
    set id(C = me(r)) {
      n(C), m();
    },
    get children() {
      return s();
    },
    set children(C) {
      s(C), m();
    },
    get child() {
      return o();
    },
    set child(C) {
      o(C), m();
    },
    get ref() {
      return i();
    },
    set ref(C = null) {
      i(C), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(C = !1) {
      a(C), m();
    },
    get onCloseAutoFocus() {
      return l();
    },
    set onCloseAutoFocus(C = _e) {
      l(C), m();
    },
    get onOpenAutoFocus() {
      return u();
    },
    set onOpenAutoFocus(C = _e) {
      u(C), m();
    },
    get onEscapeKeydown() {
      return c();
    },
    set onEscapeKeydown(C = _e) {
      c(C), m();
    },
    get onInteractOutside() {
      return f();
    },
    set onInteractOutside(C = _e) {
      f(C), m();
    },
    get trapFocus() {
      return g();
    },
    set trapFocus(C = !0) {
      g(C), m();
    },
    get preventScroll() {
      return _();
    },
    set preventScroll(C = !0) {
      _(C), m();
    },
    get restoreScrollDelay() {
      return b();
    },
    set restoreScrollDelay(C = null) {
      b(C), m();
    }
  }, x = M(), P = D(x);
  {
    var w = (C) => {
      lf(C, {
        get ref() {
          return h.opts.ref;
        },
        loop: !0,
        get trapFocus() {
          return g();
        },
        get enabled() {
          return h.root.opts.open.current;
        },
        get onOpenAutoFocus() {
          return u();
        },
        get onCloseAutoFocus() {
          return l();
        },
        focusScope: ($, T) => {
          let E = () => T?.().props;
          sf($, ce(() => d(y), {
            get enabled() {
              return h.root.opts.open.current;
            },
            get ref() {
              return h.opts.ref;
            },
            onEscapeKeydown: (I) => {
              c()(I), !I.defaultPrevented && h.root.handleClose();
            },
            children: (I, F) => {
              rf(I, ce(() => d(y), {
                get ref() {
                  return h.opts.ref;
                },
                get enabled() {
                  return h.root.opts.open.current;
                },
                onInteractOutside: (U) => {
                  f()(U), !U.defaultPrevented && h.root.handleClose();
                },
                children: (U, B) => {
                  cf(U, ce(() => d(y), {
                    get ref() {
                      return h.opts.ref;
                    },
                    get enabled() {
                      return h.root.opts.open.current;
                    },
                    children: (R, Z) => {
                      var Y = M(), X = D(Y);
                      {
                        var ae = (j) => {
                          var ee = nT(), L = D(ee);
                          {
                            var N = (G) => {
                              _i(G, {
                                get preventScroll() {
                                  return _();
                                },
                                get restoreScrollDelay() {
                                  return b();
                                }
                              });
                            };
                            ue(L, (G) => {
                              h.root.opts.open.current && G(N);
                            });
                          }
                          var V = be(L, 2);
                          {
                            let G = /* @__PURE__ */ O(() => ({
                              props: Ce(d(y), E()),
                              ...h.snippetProps
                            }));
                            te(V, o, () => d(G));
                          }
                          A(j, ee);
                        }, J = (j) => {
                          var ee = sT(), L = D(ee);
                          _i(L, {
                            get preventScroll() {
                              return _();
                            }
                          });
                          var N = be(L, 2);
                          ve(N, (G) => ({ ...G }), [() => Ce(d(y), E())]);
                          var V = ge(N);
                          te(V, () => s() ?? he), de(N), A(j, ee);
                        };
                        ue(X, (j) => {
                          o() ? j(ae) : j(J, !1);
                        });
                      }
                      A(R, Y);
                    },
                    $$slots: { default: !0 }
                  }));
                },
                $$slots: { default: !0 }
              }));
            },
            $$slots: { default: !0 }
          }));
        },
        $$slots: { focusScope: !0 }
      });
    };
    ue(P, (C) => {
      (h.shouldRender || a()) && C(w);
    });
  }
  return A(t, x), H(S);
}
K(
  q0,
  {
    id: {},
    children: {},
    child: {},
    ref: {},
    forceMount: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onEscapeKeydown: {},
    onInteractOutside: {},
    trapFocus: {},
    preventScroll: {},
    restoreScrollDelay: {}
  },
  [],
  [],
  { mode: "open" }
);
const oT = tr({ component: "label", parts: ["root"] });
class Dh {
  static create(e) {
    return new Dh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.onmousedown = this.onmousedown.bind(this);
  }
  onmousedown(e) {
    e.detail > 1 && e.preventDefault();
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [oT.root]: "",
    onmousedown: this.onmousedown,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var iT = /* @__PURE__ */ ne("<label><!></label>");
function U0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "for", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "for"
  ]);
  const u = Dh.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { for: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get for() {
      return a();
    },
    set for(h) {
      a(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = M(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, p = (h) => {
      var y = iT();
      ve(y, () => ({ ...d(c), for: a() }));
      var S = ge(y);
      te(S, () => n() ?? he), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(U0, { children: {}, child: {}, id: {}, ref: {}, for: {} }, [], [], { mode: "open" });
function K0(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "onOpenChange", 7, _e), s = v(e, "onOpenChangeComplete", 7, _e), o = v(e, "children", 7);
  Ph.create({
    open: z(() => r(), (a) => {
      r(a), n()(a);
    }),
    onOpenChangeComplete: z(() => s())
  });
  var i = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    },
    get onOpenChange() {
      return n();
    },
    set onOpenChange(a = _e) {
      n(a), m();
    },
    get onOpenChangeComplete() {
      return s();
    },
    set onOpenChangeComplete(a = _e) {
      s(a), m();
    },
    get children() {
      return o();
    },
    set children(a) {
      o(a), m();
    }
  };
  return Qf(t, {
    children: (a, l) => {
      var u = M(), c = D(u);
      te(c, () => o() ?? he), A(a, u);
    },
    $$slots: { default: !0 }
  }), H(i);
}
K(
  K0,
  {
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
const Xc = tr({ component: "radio-group", parts: ["root", "item"] }), Mh = new ht("RadioGroup.Root");
class Ih {
  static create(e) {
    return Mh.set(new Ih(e));
  }
  opts;
  #e = /* @__PURE__ */ O(() => this.opts.value.current !== "");
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  rovingFocusGroup;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.rovingFocusGroup = new Ib({
      rootNode: this.opts.ref,
      candidateAttr: Xc.item,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  isChecked(e) {
    return this.opts.value.current === e;
  }
  setValue(e) {
    this.opts.value.current = e;
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: "radiogroup",
    "aria-required": at(this.opts.required.current),
    "aria-disabled": at(this.opts.disabled.current),
    "aria-readonly": this.opts.readonly.current ? "true" : void 0,
    "data-disabled": Re(this.opts.disabled.current),
    "data-readonly": Re(this.opts.readonly.current),
    "data-orientation": this.opts.orientation.current,
    [Xc.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Nh {
  static create(e) {
    return new Nh(e, Mh.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root.opts.value.current === this.opts.value.current);
  get checked() {
    return d(this.#e);
  }
  set checked(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.opts.disabled.current || this.root.opts.disabled.current);
  #r = /* @__PURE__ */ O(() => this.root.opts.readonly.current);
  #n = /* @__PURE__ */ O(() => this.root.isChecked(this.opts.value.current));
  #s = /* @__PURE__ */ xe(-1);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), this.opts.value.current === this.root.opts.value.current ? (this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current), q(this.#s, 0)) : this.root.opts.value.current || q(this.#s, 0), Xe(() => {
      q(this.#s, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), !0);
    }), Fe(
      [
        () => this.opts.value.current,
        () => this.root.opts.value.current
      ],
      () => {
        this.opts.value.current === this.root.opts.value.current && (this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current), q(this.#s, 0));
      }
    ), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.onfocus = this.onfocus.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || d(this.#r) || this.root.setValue(this.opts.value.current);
  }
  onfocus(e) {
    !this.root.hasValue || d(this.#r) || this.root.setValue(this.opts.value.current);
  }
  onkeydown(e) {
    if (!d(this.#t)) {
      if (e.key === xr) {
        e.preventDefault(), d(this.#r) || this.root.setValue(this.opts.value.current);
        return;
      }
      this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e, !0);
    }
  }
  #o = /* @__PURE__ */ O(() => ({ checked: d(this.#n) }));
  get snippetProps() {
    return d(this.#o);
  }
  set snippetProps(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    disabled: d(this.#t) ? !0 : void 0,
    "data-value": this.opts.value.current,
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Re(d(this.#t)),
    "data-readonly": Re(d(this.#r)),
    "data-state": d(this.#n) ? "checked" : "unchecked",
    "aria-checked": ru(d(this.#n), !1),
    [Xc.item]: "",
    type: "button",
    role: "radio",
    tabindex: d(this.#s),
    onkeydown: this.onkeydown,
    onfocus: this.onfocus,
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#i);
  }
  set props(e) {
    q(this.#i, e);
  }
}
class Fh {
  static create() {
    return new Fh(Mh.get());
  }
  root;
  #e = /* @__PURE__ */ O(() => this.root.opts.name.current !== void 0);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e) {
    this.root = e, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    this.root.rovingFocusGroup.focusCurrentTabStop();
  }
  #t = /* @__PURE__ */ O(() => ({
    name: this.root.opts.name.current,
    value: this.root.opts.value.current,
    required: this.root.opts.required.current,
    disabled: this.root.opts.disabled.current,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function W0(t, e) {
  W(e, !1);
  const r = Fh.create();
  wd();
  var n = M(), s = D(n);
  {
    var o = (i) => {
      ji(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), H();
}
K(W0, {}, [], [], { mode: "open" });
var aT = /* @__PURE__ */ ne("<div><!></div>"), lT = /* @__PURE__ */ ne("<!> <!>", 1);
function H0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "disabled", 7, !1), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "value", 15, ""), a = v(e, "ref", 15, null), l = v(e, "orientation", 7, "vertical"), u = v(e, "loop", 7, !0), c = v(e, "name", 7, void 0), f = v(e, "required", 7, !1), g = v(e, "readonly", 7, !1), _ = v(e, "id", 23, () => me(r)), b = v(e, "onValueChange", 7, _e), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "disabled",
    "children",
    "child",
    "value",
    "ref",
    "orientation",
    "loop",
    "name",
    "required",
    "readonly",
    "id",
    "onValueChange"
  ]);
  const h = Ih.create({
    orientation: z(() => l()),
    disabled: z(() => n()),
    loop: z(() => u()),
    name: z(() => c()),
    required: z(() => f()),
    readonly: z(() => g()),
    id: z(() => _()),
    value: z(() => i(), ($) => {
      $ !== i() && (i($), b()?.($));
    }),
    ref: z(() => a(), ($) => a($))
  }), y = /* @__PURE__ */ O(() => Ce(p, h.props));
  var S = {
    get disabled() {
      return n();
    },
    set disabled($ = !1) {
      n($), m();
    },
    get children() {
      return s();
    },
    set children($) {
      s($), m();
    },
    get child() {
      return o();
    },
    set child($) {
      o($), m();
    },
    get value() {
      return i();
    },
    set value($ = "") {
      i($), m();
    },
    get ref() {
      return a();
    },
    set ref($ = null) {
      a($), m();
    },
    get orientation() {
      return l();
    },
    set orientation($ = "vertical") {
      l($), m();
    },
    get loop() {
      return u();
    },
    set loop($ = !0) {
      u($), m();
    },
    get name() {
      return c();
    },
    set name($ = void 0) {
      c($), m();
    },
    get required() {
      return f();
    },
    set required($ = !1) {
      f($), m();
    },
    get readonly() {
      return g();
    },
    set readonly($ = !1) {
      g($), m();
    },
    get id() {
      return _();
    },
    set id($ = me(r)) {
      _($), m();
    },
    get onValueChange() {
      return b();
    },
    set onValueChange($ = _e) {
      b($), m();
    }
  }, x = lT(), P = D(x);
  {
    var w = ($) => {
      var T = M(), E = D(T);
      te(E, o, () => ({ props: d(y) })), A($, T);
    }, C = ($) => {
      var T = aT();
      ve(T, () => ({ ...d(y) }));
      var E = ge(T);
      te(E, () => s() ?? he), de(T), A($, T);
    };
    ue(P, ($) => {
      o() ? $(w) : $(C, !1);
    });
  }
  var k = be(P, 2);
  return W0(k, {}), A(t, x), H(S);
}
K(
  H0,
  {
    disabled: {},
    children: {},
    child: {},
    value: {},
    ref: {},
    orientation: {},
    loop: {},
    name: {},
    required: {},
    readonly: {},
    id: {},
    onValueChange: {}
  },
  [],
  [],
  { mode: "open" }
);
var uT = /* @__PURE__ */ ne("<button><!></button>");
function G0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "value", 7), a = v(e, "disabled", 7, !1), l = v(e, "ref", 15, null), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "value",
    "disabled",
    "ref"
  ]);
  const c = Nh.create({
    value: z(() => i()),
    disabled: z(() => a() ?? !1),
    id: z(() => n()),
    ref: z(() => l(), (y) => l(y))
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var g = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get children() {
      return s();
    },
    set children(y) {
      s(y), m();
    },
    get child() {
      return o();
    },
    set child(y) {
      o(y), m();
    },
    get value() {
      return i();
    },
    set value(y) {
      i(y), m();
    },
    get disabled() {
      return a();
    },
    set disabled(y = !1) {
      a(y), m();
    },
    get ref() {
      return l();
    },
    set ref(y = null) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({ props: d(f), ...c.snippetProps }));
        te(x, o, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = uT();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      te(x, () => s() ?? he, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      o() ? y(p) : y(h, !1);
    });
  }
  return A(t, _), H(g);
}
K(
  G0,
  {
    id: {},
    children: {},
    child: {},
    value: {},
    disabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
var cT = /* @__PURE__ */ ne("<div><!></div>");
function Y0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "value", 15), l = v(e, "onValueChange", 7, _e), u = v(e, "placeholder", 15), c = v(e, "onPlaceholderChange", 7, _e), f = v(e, "weekdayFormat", 7, "narrow"), g = v(e, "weekStartsOn", 7), _ = v(e, "pagedNavigation", 7, !1), b = v(e, "isDateDisabled", 7, () => !1), p = v(e, "isDateUnavailable", 7, () => !1), h = v(e, "fixedWeeks", 7, !1), y = v(e, "numberOfMonths", 7, 1), S = v(e, "locale", 7), x = v(e, "calendarLabel", 7, "Event"), P = v(e, "disabled", 7, !1), w = v(e, "readonly", 7, !1), C = v(e, "minValue", 7, void 0), k = v(e, "maxValue", 7, void 0), $ = v(e, "preventDeselect", 7, !1), T = v(e, "disableDaysOutsideMonth", 7, !0), E = v(e, "minDays", 7), I = v(e, "maxDays", 7), F = v(e, "onStartValueChange", 7, _e), U = v(e, "onEndValueChange", 7, _e), B = v(e, "excludeDisabled", 7, !1), R = v(e, "monthFormat", 7, "long"), Z = v(e, "yearFormat", 7, "numeric"), Y = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "disableDaysOutsideMonth",
    "minDays",
    "maxDays",
    "onStartValueChange",
    "onEndValueChange",
    "excludeDisabled",
    "monthFormat",
    "yearFormat"
  ]), X = /* @__PURE__ */ xe(Pt(a()?.start)), ae = /* @__PURE__ */ xe(Pt(a()?.end));
  const J = S_({
    defaultValue: a()?.start,
    minValue: C(),
    maxValue: k()
  });
  function j() {
    u() === void 0 && u(J);
  }
  j(), Fe.pre(() => u(), () => {
    j();
  });
  function ee() {
    a() === void 0 && a({ start: void 0, end: void 0 });
  }
  ee(), Fe.pre(() => a(), () => {
    ee();
  });
  const L = $h.create({
    id: z(() => o()),
    ref: z(() => i(), (le) => i(le)),
    value: z(() => a(), (le) => {
      a(le), l()(le);
    }),
    placeholder: z(() => u(), (le) => {
      u(le), c()(le);
    }),
    disabled: z(() => P()),
    readonly: z(() => w()),
    preventDeselect: z(() => $()),
    minValue: z(() => C()),
    maxValue: z(() => k()),
    isDateUnavailable: z(() => p()),
    isDateDisabled: z(() => b()),
    pagedNavigation: z(() => _()),
    weekStartsOn: z(() => g()),
    weekdayFormat: z(() => f()),
    numberOfMonths: z(() => y()),
    locale: Lb(() => S()),
    calendarLabel: z(() => x()),
    fixedWeeks: z(() => h()),
    disableDaysOutsideMonth: z(() => T()),
    minDays: z(() => E()),
    maxDays: z(() => I()),
    excludeDisabled: z(() => B()),
    startValue: z(() => d(X), (le) => {
      q(X, le, !0), F()(le);
    }),
    endValue: z(() => d(ae), (le) => {
      q(ae, le, !0), U()(le);
    }),
    monthFormat: z(() => R()),
    yearFormat: z(() => Z()),
    defaultPlaceholder: J
  }), N = /* @__PURE__ */ O(() => Ce(Y, L.props));
  var V = {
    get children() {
      return n();
    },
    set children(le) {
      n(le), m();
    },
    get child() {
      return s();
    },
    set child(le) {
      s(le), m();
    },
    get id() {
      return o();
    },
    set id(le = me(r)) {
      o(le), m();
    },
    get ref() {
      return i();
    },
    set ref(le = null) {
      i(le), m();
    },
    get value() {
      return a();
    },
    set value(le) {
      a(le), m();
    },
    get onValueChange() {
      return l();
    },
    set onValueChange(le = _e) {
      l(le), m();
    },
    get placeholder() {
      return u();
    },
    set placeholder(le) {
      u(le), m();
    },
    get onPlaceholderChange() {
      return c();
    },
    set onPlaceholderChange(le = _e) {
      c(le), m();
    },
    get weekdayFormat() {
      return f();
    },
    set weekdayFormat(le = "narrow") {
      f(le), m();
    },
    get weekStartsOn() {
      return g();
    },
    set weekStartsOn(le) {
      g(le), m();
    },
    get pagedNavigation() {
      return _();
    },
    set pagedNavigation(le = !1) {
      _(le), m();
    },
    get isDateDisabled() {
      return b();
    },
    set isDateDisabled(le = () => !1) {
      b(le), m();
    },
    get isDateUnavailable() {
      return p();
    },
    set isDateUnavailable(le = () => !1) {
      p(le), m();
    },
    get fixedWeeks() {
      return h();
    },
    set fixedWeeks(le = !1) {
      h(le), m();
    },
    get numberOfMonths() {
      return y();
    },
    set numberOfMonths(le = 1) {
      y(le), m();
    },
    get locale() {
      return S();
    },
    set locale(le) {
      S(le), m();
    },
    get calendarLabel() {
      return x();
    },
    set calendarLabel(le = "Event") {
      x(le), m();
    },
    get disabled() {
      return P();
    },
    set disabled(le = !1) {
      P(le), m();
    },
    get readonly() {
      return w();
    },
    set readonly(le = !1) {
      w(le), m();
    },
    get minValue() {
      return C();
    },
    set minValue(le = void 0) {
      C(le), m();
    },
    get maxValue() {
      return k();
    },
    set maxValue(le = void 0) {
      k(le), m();
    },
    get preventDeselect() {
      return $();
    },
    set preventDeselect(le = !1) {
      $(le), m();
    },
    get disableDaysOutsideMonth() {
      return T();
    },
    set disableDaysOutsideMonth(le = !0) {
      T(le), m();
    },
    get minDays() {
      return E();
    },
    set minDays(le) {
      E(le), m();
    },
    get maxDays() {
      return I();
    },
    set maxDays(le) {
      I(le), m();
    },
    get onStartValueChange() {
      return F();
    },
    set onStartValueChange(le = _e) {
      F(le), m();
    },
    get onEndValueChange() {
      return U();
    },
    set onEndValueChange(le = _e) {
      U(le), m();
    },
    get excludeDisabled() {
      return B();
    },
    set excludeDisabled(le = !1) {
      B(le), m();
    },
    get monthFormat() {
      return R();
    },
    set monthFormat(le = "long") {
      R(le), m();
    },
    get yearFormat() {
      return Z();
    },
    set yearFormat(le = "numeric") {
      Z(le), m();
    }
  }, G = M(), fe = D(G);
  {
    var se = (le) => {
      var re = M(), oe = D(re);
      {
        let pe = /* @__PURE__ */ O(() => ({ props: d(N), ...L.snippetProps }));
        te(oe, s, () => d(pe));
      }
      A(le, re);
    }, we = (le) => {
      var re = cT();
      ve(re, () => ({ ...d(N) }));
      var oe = ge(re);
      te(oe, () => n() ?? he, () => L.snippetProps), de(re), A(le, re);
    };
    ue(fe, (le) => {
      s() ? le(se) : le(we, !1);
    });
  }
  return A(t, G), H(V);
}
K(
  Y0,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    placeholder: {},
    onPlaceholderChange: {},
    weekdayFormat: {},
    weekStartsOn: {},
    pagedNavigation: {},
    isDateDisabled: {},
    isDateUnavailable: {},
    fixedWeeks: {},
    numberOfMonths: {},
    locale: {},
    calendarLabel: {},
    disabled: {},
    readonly: {},
    minValue: {},
    maxValue: {},
    preventDeselect: {},
    disableDaysOutsideMonth: {},
    minDays: {},
    maxDays: {},
    onStartValueChange: {},
    onEndValueChange: {},
    excludeDisabled: {},
    monthFormat: {},
    yearFormat: {}
  },
  [],
  [],
  { mode: "open" }
);
var dT = /* @__PURE__ */ ne("<!> <!>", 1);
function X0(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "onValueChange", 7, _e), s = v(e, "name", 7, ""), o = v(e, "disabled", 7, !1), i = v(e, "type", 7), a = v(e, "open", 15, !1), l = v(e, "onOpenChange", 7, _e), u = v(e, "onOpenChangeComplete", 7, _e), c = v(e, "loop", 7, !1), f = v(e, "scrollAlignment", 7, "nearest"), g = v(e, "required", 7, !1), _ = v(e, "items", 23, () => []), b = v(e, "allowDeselect", 7, !1), p = v(e, "autocomplete", 7), h = v(e, "children", 7);
  function y() {
    r() === void 0 && r(i() === "single" ? "" : []);
  }
  y(), Fe.pre(() => r(), () => {
    y();
  });
  let S = /* @__PURE__ */ xe("");
  const x = o2.create({
    type: i(),
    value: z(() => r(), (E) => {
      r(E), n()(E);
    }),
    disabled: z(() => o()),
    required: z(() => g()),
    open: z(() => a(), (E) => {
      a(E), l()(E);
    }),
    loop: z(() => c()),
    scrollAlignment: z(() => f()),
    name: z(() => s()),
    isCombobox: !1,
    items: z(() => _()),
    allowDeselect: z(() => b()),
    inputValue: z(() => d(S), (E) => q(S, E, !0)),
    onOpenChangeComplete: z(() => u())
  });
  var P = {
    get value() {
      return r();
    },
    set value(E) {
      r(E), m();
    },
    get onValueChange() {
      return n();
    },
    set onValueChange(E = _e) {
      n(E), m();
    },
    get name() {
      return s();
    },
    set name(E = "") {
      s(E), m();
    },
    get disabled() {
      return o();
    },
    set disabled(E = !1) {
      o(E), m();
    },
    get type() {
      return i();
    },
    set type(E) {
      i(E), m();
    },
    get open() {
      return a();
    },
    set open(E = !1) {
      a(E), m();
    },
    get onOpenChange() {
      return l();
    },
    set onOpenChange(E = _e) {
      l(E), m();
    },
    get onOpenChangeComplete() {
      return u();
    },
    set onOpenChangeComplete(E = _e) {
      u(E), m();
    },
    get loop() {
      return c();
    },
    set loop(E = !1) {
      c(E), m();
    },
    get scrollAlignment() {
      return f();
    },
    set scrollAlignment(E = "nearest") {
      f(E), m();
    },
    get required() {
      return g();
    },
    set required(E = !1) {
      g(E), m();
    },
    get items() {
      return _();
    },
    set items(E = []) {
      _(E), m();
    },
    get allowDeselect() {
      return b();
    },
    set allowDeselect(E = !1) {
      b(E), m();
    },
    get autocomplete() {
      return p();
    },
    set autocomplete(E) {
      p(E), m();
    },
    get children() {
      return h();
    },
    set children(E) {
      h(E), m();
    }
  }, w = dT(), C = D(w);
  Qf(C, {
    children: (E, I) => {
      var F = M(), U = D(F);
      te(U, () => h() ?? he), A(E, F);
    },
    $$slots: { default: !0 }
  });
  var k = be(C, 2);
  {
    var $ = (E) => {
      var I = M(), F = D(I);
      {
        var U = (R) => {
          Ya(R, {
            get autocomplete() {
              return p();
            }
          });
        }, B = (R) => {
          var Z = M(), Y = D(Z);
          nt(Y, 16, () => x.opts.value.current, (X) => X, (X, ae) => {
            Ya(X, {
              get value() {
                return ae;
              },
              get autocomplete() {
                return p();
              }
            });
          }), A(R, Z);
        };
        ue(F, (R) => {
          x.opts.value.current.length === 0 ? R(U) : R(B, !1);
        });
      }
      A(E, I);
    }, T = (E) => {
      Ya(E, {
        get autocomplete() {
          return p();
        },
        get value() {
          return x.opts.value.current;
        },
        set value(I) {
          x.opts.value.current = I;
        }
      });
    };
    ue(k, (E) => {
      Array.isArray(x.opts.value.current) ? E($) : E(T, !1);
    });
  }
  return A(t, w), H(P);
}
K(
  X0,
  {
    value: {},
    onValueChange: {},
    name: {},
    disabled: {},
    type: {},
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    loop: {},
    scrollAlignment: {},
    required: {},
    items: {},
    allowDeselect: {},
    autocomplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var fT = /* @__PURE__ */ ne("<button><!></button>");
function J0(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "type", 7, "button"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "type"
  ]);
  const u = eh.create({
    id: z(() => n()),
    ref: z(() => s(), (b) => s(b))
  }), c = /* @__PURE__ */ O(() => Ce(l, u.props, { type: a() }));
  var f = {
    get id() {
      return n();
    },
    set id(b = me(r)) {
      n(b), m();
    },
    get ref() {
      return s();
    },
    set ref(b = null) {
      s(b), m();
    },
    get child() {
      return o();
    },
    set child(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get type() {
      return a();
    },
    set type(b = "button") {
      a(b), m();
    }
  }, g = M(), _ = D(g);
  return Q(_, () => uh, (b, p) => {
    p(b, {
      get id() {
        return n();
      },
      get ref() {
        return u.opts.ref;
      },
      children: (h, y) => {
        var S = M(), x = D(S);
        {
          var P = (C) => {
            var k = M(), $ = D(k);
            te($, o, () => ({ props: d(c) })), A(C, k);
          }, w = (C) => {
            var k = fT();
            ve(k, () => ({ ...d(c) }));
            var $ = ge(k);
            te($, () => i() ?? he), de(k), A(C, k);
          };
          ue(x, (C) => {
            o() ? C(P) : C(w, !1);
          });
        }
        A(h, S);
      },
      $$slots: { default: !0 }
    });
  }), A(t, g), H(f);
}
K(J0, { id: {}, ref: {}, child: {}, children: {}, type: {} }, [], [], { mode: "open" });
function Tp(t, e, r) {
  const n = {
    position: "absolute"
  };
  return t === "lr" ? (n.left = `${e}%`, n.right = `${r}%`) : t === "rl" ? (n.right = `${e}%`, n.left = `${r}%`) : t === "bt" ? (n.bottom = `${e}%`, n.top = `${r}%`) : (n.top = `${e}%`, n.bottom = `${r}%`), n;
}
function Z0(t, e) {
  const r = {
    position: "absolute"
  };
  return t === "lr" ? (r.left = `${e}%`, r.translate = "-50% 0") : t === "rl" ? (r.right = `${e}%`, r.translate = "50% 0") : t === "bt" ? (r.bottom = `${e}%`, r.translate = "0 50%") : (r.top = `${e}%`, r.translate = "0 -50%"), r;
}
function Q0(t, e, r) {
  const n = {
    position: "absolute"
  };
  return t === "lr" ? (n.left = `${e}%`, n.translate = `${r}% 0`) : t === "rl" ? (n.right = `${e}%`, n.translate = `${-r}% 0`) : t === "bt" ? (n.bottom = `${e}%`, n.translate = `0 ${-r}%`) : (n.top = `${e}%`, n.translate = `0 ${r}%`), n;
}
function hT(t) {
  if (Math.floor(t) === t)
    return 0;
  const e = t.toString();
  if (e.indexOf(".") !== -1 && e.indexOf("e-") === -1)
    return e.split(".")[1].length;
  if (e.indexOf("e-") !== -1) {
    const r = e.split("e-");
    return parseInt(r[1], 10);
  }
  return 0;
}
function gT(t, e) {
  const r = Math.pow(10, e);
  return Math.round(t * r) / r;
}
function Rh(t, e, r) {
  if (typeof t == "number") {
    const n = r - e;
    let s = Math.ceil(n / t);
    const o = hT(t), i = Math.pow(10, o), a = Math.round(n * i), l = Math.round(t * i);
    a % l === 0 && s++;
    const u = [];
    for (let c = 0; c < s; c++) {
      const f = e + c * t, g = gT(f, o);
      u.push(g);
    }
    return u;
  }
  return [...new Set(t)].filter((n) => n >= e && n <= r).sort((n, s) => n - s);
}
function Ds(t, e) {
  if (e.length === 0)
    return t;
  let r = e[0], n = Math.abs(t - r);
  for (const s of e) {
    const o = Math.abs(t - s);
    o < n && (n = o, r = s);
  }
  return r;
}
function Qi(t, e, r) {
  const n = e.indexOf(t);
  return n === -1 ? Ds(t, e) : r === "next" ? n < e.length - 1 ? e[n + 1] : t : n > 0 ? e[n - 1] : t;
}
function pT(t, e, r = !0) {
  const [n, s] = t, [o, i] = e, a = (i - o) / (s - n);
  return (l) => {
    const u = o + a * (l - n);
    return r ? u > Math.max(o, i) ? Math.max(o, i) : u < Math.min(o, i) ? Math.min(o, i) : u : u;
  };
}
const Xn = tr({
  component: "slider",
  parts: [
    "root",
    "thumb",
    "range",
    "tick",
    "tick-label",
    "thumb-label"
  ]
}), Vh = new ht("Slider.Root");
class ew {
  opts;
  attachment;
  #e = /* @__PURE__ */ xe(!1);
  get isActive() {
    return d(this.#e);
  }
  set isActive(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ O(() => this.opts.orientation.current === "horizontal" ? this.opts.dir.current === "rtl" ? "rl" : "lr" : this.opts.dir.current === "rtl" ? "tb" : "bt");
  get direction() {
    return d(this.#t);
  }
  set direction(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => Rh(this.opts.step.current, this.opts.min.current, this.opts.max.current));
  get normalizedSteps() {
    return d(this.#r);
  }
  set normalizedSteps(e) {
    q(this.#r, e);
  }
  domContext;
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref), this.domContext = new Fn(this.opts.ref);
  }
  isThumbActive(e) {
    return this.isActive;
  }
  #n = /* @__PURE__ */ O(() => {
    if (!this.opts.disabled.current)
      return this.opts.orientation.current === "horizontal" ? "pan-y" : "pan-x";
  });
  getAllThumbs = () => {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Xn.selector("thumb"))) : [];
  };
  getThumbScale = () => {
    const e = this.opts.trackPadding?.current;
    if (e !== void 0 && e > 0)
      return [e, 100 - e];
    if (this.opts.thumbPositioning.current === "exact")
      return [0, 100];
    const r = this.opts.orientation.current === "vertical", n = this.getAllThumbs()[0], s = r ? n?.offsetHeight : n?.offsetWidth;
    if (s === void 0 || Number.isNaN(s) || s === 0) return [0, 100];
    const o = r ? this.opts.ref.current?.offsetHeight : this.opts.ref.current?.offsetWidth;
    if (o === void 0 || Number.isNaN(o) || o === 0) return [0, 100];
    const i = s / 2 / o * 100, a = i, l = 100 - i;
    return [a, l];
  };
  getPositionFromValue = (e) => {
    const r = this.getThumbScale();
    return pT([this.opts.min.current, this.opts.max.current], r)(e);
  };
  #s = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-orientation": this.opts.orientation.current,
    "data-disabled": Re(this.opts.disabled.current),
    style: { touchAction: d(this.#n) },
    [Xn.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class mT extends ew {
  opts;
  isMulti = !1;
  constructor(e) {
    super(e), this.opts = e, zd(() => Ts(Ye(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), Ye(this.domContext.getDocument(), "pointerup", this.handlePointerUp), Ye(this.domContext.getDocument(), "pointermove", this.handlePointerMove), Ye(this.domContext.getDocument(), "pointerleave", this.handlePointerUp))), Fe(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([r, n, s, o]) => {
        const i = Rh(r, n, s), a = (u) => i.includes(u), l = (u) => Ds(u, i);
        a(o) || (this.opts.value.current = l(o));
      }
    );
  }
  isTickValueSelected = (e) => this.opts.value.current === e;
  applyPosition({ clientXY: e, start: r, end: n }) {
    const s = this.opts.min.current, o = this.opts.max.current, a = (e - r) / (n - r) * (o - s) + s;
    if (a < s)
      this.updateValue(s);
    else if (a > o)
      this.updateValue(o);
    else {
      const l = this.normalizedSteps, u = Ds(a, l);
      this.updateValue(u);
    }
  }
  updateValue = (e) => {
    this.opts.value.current = Ds(e, this.normalizedSteps);
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault(), e.stopPropagation();
    const r = this.opts.ref.current, n = this.getAllThumbs()[0];
    if (!r || !n) return;
    n.focus();
    const { left: s, right: o, top: i, bottom: a } = r.getBoundingClientRect();
    this.direction === "lr" ? this.applyPosition({ clientXY: e.clientX, start: s, end: o }) : this.direction === "rl" ? this.applyPosition({ clientXY: e.clientX, start: o, end: s }) : this.direction === "bt" ? this.applyPosition({ clientXY: e.clientY, start: a, end: i }) : this.direction === "tb" && this.applyPosition({ clientXY: e.clientY, start: i, end: a });
  };
  handlePointerDown = (e) => {
    if (e.button !== 0 || this.opts.disabled.current) return;
    const r = this.opts.ref.current, n = this.getAllThumbs()[0];
    if (!n || !r) return;
    const s = e.composedPath()[0] ?? e.target;
    !Wd(s) || !r.contains(s) || (e.preventDefault(), n.focus(), this.isActive = !0, this.handlePointerMove(e));
  };
  handlePointerUp = () => {
    this.opts.disabled.current || (this.isActive && this.opts.onValueCommit.current(ot(() => this.opts.value.current)), this.isActive = !1);
  };
  #e = /* @__PURE__ */ O(() => {
    const e = this.opts.value.current;
    return Array.from({ length: 1 }, () => {
      const r = e, n = this.getPositionFromValue(r), s = Z0(this.direction, n);
      return {
        role: "slider",
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": r,
        "aria-disabled": at(this.opts.disabled.current),
        "aria-orientation": this.opts.orientation.current,
        "data-value": r,
        "data-orientation": this.opts.orientation.current,
        style: s,
        [Xn.thumb]: ""
      };
    });
  });
  get thumbsPropsArr() {
    return d(this.#e);
  }
  set thumbsPropsArr(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => this.thumbsPropsArr.map((e, r) => r));
  get thumbsRenderArr() {
    return d(this.#t);
  }
  set thumbsRenderArr(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => {
    const e = this.normalizedSteps, r = this.opts.value.current;
    return e.map((n, s) => {
      const o = this.getPositionFromValue(n), i = s === 0, a = s === e.length - 1, l = i ? 0 : a ? -100 : -50, u = Q0(this.direction, o, l), c = n <= r;
      return {
        "data-disabled": Re(this.opts.disabled.current),
        "data-orientation": this.opts.orientation.current,
        "data-bounded": c ? "" : void 0,
        "data-value": n,
        "data-selected": this.isTickValueSelected(n) ? "" : void 0,
        style: u,
        [Xn.tick]: ""
      };
    });
  });
  get ticksPropsArr() {
    return d(this.#r);
  }
  set ticksPropsArr(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => r));
  get ticksRenderArr() {
    return d(this.#n);
  }
  set ticksRenderArr(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => ({ value: e["data-value"], index: r })));
  get tickItemsArr() {
    return d(this.#s);
  }
  set tickItemsArr(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => [{ value: this.opts.value.current, index: 0 }]);
  get thumbItemsArr() {
    return d(this.#o);
  }
  set thumbItemsArr(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => ({
    ticks: this.ticksRenderArr,
    thumbs: this.thumbsRenderArr,
    tickItems: this.tickItemsArr,
    thumbItems: this.thumbItemsArr
  }));
  get snippetProps() {
    return d(this.#i);
  }
  set snippetProps(e) {
    q(this.#i, e);
  }
}
class vT extends ew {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ xe(null);
  get activeThumb() {
    return d(this.#e);
  }
  set activeThumb(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(0);
  get currentThumbIdx() {
    return d(this.#t);
  }
  set currentThumbIdx(e) {
    q(this.#t, e, !0);
  }
  constructor(e) {
    super(e), this.opts = e, zd(() => Ts(Ye(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), Ye(this.domContext.getDocument(), "pointerup", this.handlePointerUp), Ye(this.domContext.getDocument(), "pointermove", this.handlePointerMove), Ye(this.domContext.getDocument(), "pointerleave", this.handlePointerUp))), Fe(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([r, n, s, o]) => {
        const i = Rh(r, n, s), a = (u) => i.includes(u), l = (u) => Ds(u, i);
        o.some((u) => !a(u)) && (this.opts.value.current = o.map(l));
      }
    );
  }
  isTickValueSelected = (e) => this.opts.value.current.includes(e);
  isThumbActive(e) {
    return this.isActive && this.activeThumb?.idx === e;
  }
  applyPosition({ clientXY: e, activeThumbIdx: r, start: n, end: s }) {
    const o = this.opts.min.current, i = this.opts.max.current, l = (e - n) / (s - n) * (i - o) + o;
    if (l < o)
      this.updateValue(o, r);
    else if (l > i)
      this.updateValue(i, r);
    else {
      const u = this.normalizedSteps, c = Ds(l, u);
      this.updateValue(c, r);
    }
  }
  #r = (e) => {
    const r = this.getAllThumbs();
    if (!r.length) return;
    for (const i of r)
      i.blur();
    const n = r.map((i) => {
      if (this.opts.orientation.current === "horizontal") {
        const { left: a, right: l } = i.getBoundingClientRect();
        return Math.abs(e.clientX - (a + l) / 2);
      } else {
        const { top: a, bottom: l } = i.getBoundingClientRect();
        return Math.abs(e.clientY - (a + l) / 2);
      }
    }), s = r[n.indexOf(Math.min(...n))], o = r.indexOf(s);
    return { node: s, idx: o };
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault(), e.stopPropagation();
    const r = this.opts.ref.current, n = this.activeThumb;
    if (!r || !n) return;
    n.node.focus();
    const { left: s, right: o, top: i, bottom: a } = r.getBoundingClientRect(), l = this.direction;
    l === "lr" ? this.applyPosition({
      clientXY: e.clientX,
      activeThumbIdx: n.idx,
      start: s,
      end: o
    }) : l === "rl" ? this.applyPosition({
      clientXY: e.clientX,
      activeThumbIdx: n.idx,
      start: o,
      end: s
    }) : l === "bt" ? this.applyPosition({
      clientXY: e.clientY,
      activeThumbIdx: n.idx,
      start: a,
      end: i
    }) : l === "tb" && this.applyPosition({
      clientXY: e.clientY,
      activeThumbIdx: n.idx,
      start: i,
      end: a
    });
  };
  handlePointerDown = (e) => {
    if (e.button !== 0 || this.opts.disabled.current) return;
    const r = this.opts.ref.current, n = this.#r(e);
    if (!n || !r) return;
    const s = e.composedPath()[0] ?? e.target;
    !Wd(s) || !r.contains(s) || (e.preventDefault(), this.activeThumb = n, n.node.focus(), this.isActive = !0, this.handlePointerMove(e));
  };
  handlePointerUp = () => {
    this.opts.disabled.current || (this.isActive && this.opts.onValueCommit.current(ot(() => this.opts.value.current)), this.isActive = !1);
  };
  getAllThumbs = () => {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Xn.selector("thumb"))) : [];
  };
  updateValue = (e, r) => {
    const n = this.opts.value.current;
    if (!n.length) {
      this.opts.value.current.push(e);
      return;
    }
    if (n[r] === e) return;
    const o = [...n];
    if (!Wa(r, o)) return;
    const i = o[r] > e ? -1 : 1, a = () => {
      const u = r + i;
      o[r] = o[u], o[u] = e;
      const c = this.getAllThumbs();
      c.length && (c[u]?.focus(), this.activeThumb = { node: c[u], idx: u });
    };
    if (this.opts.autoSort.current && (i === -1 && e < o[r - 1] || i === 1 && e > o[r + 1])) {
      a(), this.opts.value.current = o;
      return;
    }
    const l = this.normalizedSteps;
    o[r] = Ds(e, l), this.opts.value.current = o;
  };
  #n = /* @__PURE__ */ O(() => {
    const e = this.opts.value.current;
    return Array.from({ length: e.length || 1 }, (r, n) => {
      const s = ot(() => this.currentThumbIdx);
      s < e.length && ot(() => {
        this.currentThumbIdx = s + 1;
      });
      const o = e[n], i = this.getPositionFromValue(o ?? 0), a = Z0(this.direction, i);
      return {
        role: "slider",
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": o,
        "aria-disabled": at(this.opts.disabled.current),
        "aria-orientation": this.opts.orientation.current,
        "data-value": o,
        "data-orientation": this.opts.orientation.current,
        style: a,
        [Xn.thumb]: ""
      };
    });
  });
  get thumbsPropsArr() {
    return d(this.#n);
  }
  set thumbsPropsArr(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ O(() => this.thumbsPropsArr.map((e, r) => r));
  get thumbsRenderArr() {
    return d(this.#s);
  }
  set thumbsRenderArr(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ O(() => {
    const e = this.normalizedSteps, r = this.opts.value.current;
    return e.map((n, s) => {
      const o = this.getPositionFromValue(n), i = s === 0, a = s === e.length - 1, l = i ? 0 : a ? -100 : -50, u = Q0(this.direction, o, l), c = r.length === 1 ? n <= r[0] : r[0] <= n && n <= r[r.length - 1];
      return {
        "data-disabled": Re(this.opts.disabled.current),
        "data-orientation": this.opts.orientation.current,
        "data-bounded": c ? "" : void 0,
        "data-value": n,
        style: u,
        [Xn.tick]: ""
      };
    });
  });
  get ticksPropsArr() {
    return d(this.#o);
  }
  set ticksPropsArr(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => r));
  get ticksRenderArr() {
    return d(this.#i);
  }
  set ticksRenderArr(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => this.ticksPropsArr.map((e, r) => ({ value: e["data-value"], index: r })));
  get tickItemsArr() {
    return d(this.#a);
  }
  set tickItemsArr(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ O(() => this.opts.value.current.map((r, n) => ({ value: r, index: n })));
  get thumbItemsArr() {
    return d(this.#u);
  }
  set thumbItemsArr(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ O(() => ({
    ticks: this.ticksRenderArr,
    thumbs: this.thumbsRenderArr,
    tickItems: this.tickItemsArr,
    thumbItems: this.thumbItemsArr
  }));
  get snippetProps() {
    return d(this.#l);
  }
  set snippetProps(e) {
    q(this.#l, e);
  }
}
class yT {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new mT(n) : new vT(n);
    return Vh.set(s);
  }
}
const bT = [
  cs,
  ds,
  Qt,
  dr,
  Mo,
  Do
];
class Lh {
  static create(e) {
    return new Lh(e, Vh.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #e = /* @__PURE__ */ O(() => {
    if (Array.isArray(this.root.opts.value.current)) {
      const e = this.root.opts.value.current.length > 1 ? this.root.getPositionFromValue(Math.min(...this.root.opts.value.current) ?? 0) : 0, r = 100 - this.root.getPositionFromValue(Math.max(...this.root.opts.value.current) ?? 0);
      return {
        position: "absolute",
        ...Tp(this.root.direction, e, r)
      };
    } else {
      const e = this.root.opts.trackPadding?.current, r = this.root.opts.value.current, n = this.root.opts.max.current, s = 0, o = e !== void 0 && e > 0 && r === n ? 0 : (
        // 100% - 0% = full width
        100 - this.root.getPositionFromValue(r)
      );
      return {
        position: "absolute",
        ...Tp(this.root.direction, s, o)
      };
    }
  });
  get rangeStyles() {
    return d(this.#e);
  }
  set rangeStyles(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Re(this.root.opts.disabled.current),
    style: this.rangeStyles,
    [Xn.range]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class jh {
  static create(e) {
    return new jh(e, Vh.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.root.opts.disabled.current || this.opts.disabled.current);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref), this.onkeydown = this.onkeydown.bind(this);
  }
  #t(e) {
    this.root.isMulti ? this.root.updateValue(e, this.opts.index.current) : this.root.updateValue(e);
  }
  onkeydown(e) {
    if (d(this.#e)) return;
    const r = this.opts.ref.current;
    if (!r) return;
    const n = this.root.getAllThumbs();
    if (!n.length) return;
    const s = n.indexOf(r);
    if (this.root.isMulti && (this.root.currentThumbIdx = s), !bT.includes(e.key)) return;
    e.preventDefault();
    const o = this.root.opts.min.current, i = this.root.opts.max.current, a = this.root.opts.value.current, l = Array.isArray(a) ? a[s] : a, u = this.root.opts.orientation.current, c = this.root.direction, f = this.root.normalizedSteps;
    switch (e.key) {
      case Mo:
        this.#t(o);
        break;
      case Do:
        this.#t(i);
        break;
      case cs:
        if (u !== "horizontal") break;
        if (e.metaKey) {
          const g = c === "rl" ? i : o;
          this.#t(g);
        } else {
          const _ = Qi(l, f, c === "rl" ? "next" : "prev");
          this.#t(_);
        }
        break;
      case ds:
        if (u !== "horizontal") break;
        if (e.metaKey) {
          const g = c === "rl" ? o : i;
          this.#t(g);
        } else {
          const _ = Qi(l, f, c === "rl" ? "prev" : "next");
          this.#t(_);
        }
        break;
      case Qt:
        if (e.metaKey) {
          const g = c === "tb" ? o : i;
          this.#t(g);
        } else {
          const _ = Qi(l, f, c === "tb" ? "prev" : "next");
          this.#t(_);
        }
        break;
      case dr:
        if (e.metaKey) {
          const g = c === "tb" ? i : o;
          this.#t(g);
        } else {
          const _ = Qi(l, f, c === "tb" ? "next" : "prev");
          this.#t(_);
        }
        break;
    }
    this.root.opts.onValueCommit.current(this.root.opts.value.current);
  }
  #r = /* @__PURE__ */ O(() => ({
    ...this.root.thumbsPropsArr[this.opts.index.current],
    id: this.opts.id.current,
    onkeydown: this.onkeydown,
    "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
    "data-disabled": Re(this.opts.disabled.current || this.root.opts.disabled.current),
    tabindex: this.opts.disabled.current || this.root.opts.disabled.current ? -1 : 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
var _T = /* @__PURE__ */ ne("<span><!></span>");
function tw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "value", 15), l = v(e, "type", 7), u = v(e, "onValueChange", 7, _e), c = v(e, "onValueCommit", 7, _e), f = v(e, "disabled", 7, !1), g = v(e, "min", 7), _ = v(e, "max", 7), b = v(e, "step", 7, 1), p = v(e, "dir", 7, "ltr"), h = v(e, "autoSort", 7, !0), y = v(e, "orientation", 7, "horizontal"), S = v(e, "thumbPositioning", 7, "contain"), x = v(e, "trackPadding", 7), P = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "type",
    "onValueChange",
    "onValueCommit",
    "disabled",
    "min",
    "max",
    "step",
    "dir",
    "autoSort",
    "orientation",
    "thumbPositioning",
    "trackPadding"
  ]);
  const w = /* @__PURE__ */ O(() => g() !== void 0 ? g() : Array.isArray(b()) ? Math.min(...b()) : 0), C = /* @__PURE__ */ O(() => _() !== void 0 ? _() : Array.isArray(b()) ? Math.max(...b()) : 100);
  function k() {
    if (a() === void 0)
      return l() === "single" ? d(w) : [];
  }
  k(), Fe.pre(() => a(), () => {
    k();
  });
  const $ = yT.create({
    id: z(() => o()),
    ref: z(() => i(), (R) => i(R)),
    value: z(() => a(), (R) => {
      a(R), u()(R);
    }),
    // @ts-expect-error - we know
    onValueCommit: z(() => c()),
    disabled: z(() => f()),
    min: z(() => d(w)),
    max: z(() => d(C)),
    step: z(() => b()),
    dir: z(() => p()),
    autoSort: z(() => h()),
    orientation: z(() => y()),
    thumbPositioning: z(() => S()),
    type: l(),
    trackPadding: z(() => x())
  }), T = /* @__PURE__ */ O(() => Ce(P, $.props));
  var E = {
    get children() {
      return n();
    },
    set children(R) {
      n(R), m();
    },
    get child() {
      return s();
    },
    set child(R) {
      s(R), m();
    },
    get id() {
      return o();
    },
    set id(R = me(r)) {
      o(R), m();
    },
    get ref() {
      return i();
    },
    set ref(R = null) {
      i(R), m();
    },
    get value() {
      return a();
    },
    set value(R) {
      a(R), m();
    },
    get type() {
      return l();
    },
    set type(R) {
      l(R), m();
    },
    get onValueChange() {
      return u();
    },
    set onValueChange(R = _e) {
      u(R), m();
    },
    get onValueCommit() {
      return c();
    },
    set onValueCommit(R = _e) {
      c(R), m();
    },
    get disabled() {
      return f();
    },
    set disabled(R = !1) {
      f(R), m();
    },
    get min() {
      return g();
    },
    set min(R) {
      g(R), m();
    },
    get max() {
      return _();
    },
    set max(R) {
      _(R), m();
    },
    get step() {
      return b();
    },
    set step(R = 1) {
      b(R), m();
    },
    get dir() {
      return p();
    },
    set dir(R = "ltr") {
      p(R), m();
    },
    get autoSort() {
      return h();
    },
    set autoSort(R = !0) {
      h(R), m();
    },
    get orientation() {
      return y();
    },
    set orientation(R = "horizontal") {
      y(R), m();
    },
    get thumbPositioning() {
      return S();
    },
    set thumbPositioning(R = "contain") {
      S(R), m();
    },
    get trackPadding() {
      return x();
    },
    set trackPadding(R) {
      x(R), m();
    }
  }, I = M(), F = D(I);
  {
    var U = (R) => {
      var Z = M(), Y = D(Z);
      {
        let X = /* @__PURE__ */ O(() => ({ props: d(T), ...$.snippetProps }));
        te(Y, s, () => d(X));
      }
      A(R, Z);
    }, B = (R) => {
      var Z = _T();
      ve(Z, () => ({ ...d(T) }));
      var Y = ge(Z);
      te(Y, () => n() ?? he, () => $.snippetProps), de(Z), A(R, Z);
    };
    ue(F, (R) => {
      s() ? R(U) : R(B, !1);
    });
  }
  return A(t, I), H(E);
}
K(
  tw,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    value: {},
    type: {},
    onValueChange: {},
    onValueCommit: {},
    disabled: {},
    min: {},
    max: {},
    step: {},
    dir: {},
    autoSort: {},
    orientation: {},
    thumbPositioning: {},
    trackPadding: {}
  },
  [],
  [],
  { mode: "open" }
);
var wT = /* @__PURE__ */ ne("<span><!></span>");
function rw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Lh.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(p, h);
    }, b = (p) => {
      var h = wT();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => n() ?? he), de(h), A(p, h);
    };
    ue(g, (p) => {
      s() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(rw, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var ST = /* @__PURE__ */ ne("<span><!></span>");
function nw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "index", 7), l = v(e, "disabled", 7, !1), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "index",
    "disabled"
  ]);
  const c = jh.create({
    id: z(() => i()),
    ref: z(() => o(), (y) => o(y)),
    index: z(() => a()),
    disabled: z(() => l())
  }), f = /* @__PURE__ */ O(() => Ce(u, c.props));
  var g = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get ref() {
      return o();
    },
    set ref(y = null) {
      o(y), m();
    },
    get id() {
      return i();
    },
    set id(y = me(r)) {
      i(y), m();
    },
    get index() {
      return a();
    },
    set index(y) {
      a(y), m();
    },
    get disabled() {
      return l();
    },
    set disabled(y = !1) {
      l(y), m();
    }
  }, _ = M(), b = D(_);
  {
    var p = (y) => {
      var S = M(), x = D(S);
      {
        let P = /* @__PURE__ */ O(() => ({
          active: c.root.isThumbActive(c.opts.index.current),
          props: d(f)
        }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = ST();
      ve(S, () => ({ ...d(f) }));
      var x = ge(S);
      {
        let P = /* @__PURE__ */ O(() => ({
          active: c.root.isThumbActive(c.opts.index.current)
        }));
        te(x, () => n() ?? he, () => d(P));
      }
      de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(p) : y(h, !1);
    });
  }
  return A(t, _), H(g);
}
K(
  nw,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    index: {},
    disabled: {}
  },
  [],
  [],
  { mode: "open" }
);
const sw = tr({ component: "switch", parts: ["root", "thumb"] }), Bh = new ht("Switch.Root");
class zh {
  static create(e) {
    return Bh.set(new zh(e));
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(e.ref), this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this);
  }
  #e() {
    this.opts.checked.current = !this.opts.checked.current;
  }
  onkeydown(e) {
    !(e.key === Br || e.key === xr) || this.opts.disabled.current || (e.preventDefault(), this.#e());
  }
  onclick(e) {
    this.opts.disabled.current || this.#e();
  }
  #t = /* @__PURE__ */ O(() => ({
    "data-disabled": Re(this.opts.disabled.current),
    "data-state": y$(this.opts.checked.current),
    "data-required": Re(this.opts.required.current)
  }));
  get sharedProps() {
    return d(this.#t);
  }
  set sharedProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => ({ checked: this.opts.checked.current }));
  get snippetProps() {
    return d(this.#r);
  }
  set snippetProps(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ O(() => ({
    ...this.sharedProps,
    id: this.opts.id.current,
    role: "switch",
    disabled: yi(this.opts.disabled.current),
    "aria-checked": ru(this.opts.checked.current, !1),
    "aria-required": at(this.opts.required.current),
    [sw.root]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
}
class qh {
  static create() {
    return new qh(Bh.get());
  }
  root;
  #e = /* @__PURE__ */ O(() => this.root.opts.name.current !== void 0);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e) {
    this.root = e;
  }
  #t = /* @__PURE__ */ O(() => ({
    type: "checkbox",
    name: this.root.opts.name.current,
    value: this.root.opts.value.current,
    checked: this.root.opts.checked.current,
    disabled: this.root.opts.disabled.current,
    required: this.root.opts.required.current
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Uh {
  static create(e) {
    return new Uh(e, Bh.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(e.ref);
  }
  #e = /* @__PURE__ */ O(() => ({ checked: this.root.opts.checked.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    ...this.root.sharedProps,
    id: this.opts.id.current,
    [sw.thumb]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function ow(t, e) {
  W(e, !1);
  const r = qh.create();
  wd();
  var n = M(), s = D(n);
  {
    var o = (i) => {
      ji(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), H();
}
K(ow, {}, [], [], { mode: "open" });
var xT = /* @__PURE__ */ ne("<button><!></button>"), PT = /* @__PURE__ */ ne("<!> <!>", 1);
function iw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "disabled", 7, !1), l = v(e, "required", 7, !1), u = v(e, "checked", 15, !1), c = v(e, "value", 7, "on"), f = v(e, "name", 7, void 0), g = v(e, "type", 7, "button"), _ = v(e, "onCheckedChange", 7, _e), b = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id",
    "disabled",
    "required",
    "checked",
    "value",
    "name",
    "type",
    "onCheckedChange"
  ]);
  const p = zh.create({
    checked: z(() => u(), (k) => {
      u(k), _()?.(k);
    }),
    disabled: z(() => a() ?? !1),
    required: z(() => l()),
    value: z(() => c()),
    name: z(() => f()),
    id: z(() => i()),
    ref: z(() => o(), (k) => o(k))
  }), h = /* @__PURE__ */ O(() => Ce(b, p.props, { type: g() }));
  var y = {
    get child() {
      return n();
    },
    set child(k) {
      n(k), m();
    },
    get children() {
      return s();
    },
    set children(k) {
      s(k), m();
    },
    get ref() {
      return o();
    },
    set ref(k = null) {
      o(k), m();
    },
    get id() {
      return i();
    },
    set id(k = me(r)) {
      i(k), m();
    },
    get disabled() {
      return a();
    },
    set disabled(k = !1) {
      a(k), m();
    },
    get required() {
      return l();
    },
    set required(k = !1) {
      l(k), m();
    },
    get checked() {
      return u();
    },
    set checked(k = !1) {
      u(k), m();
    },
    get value() {
      return c();
    },
    set value(k = "on") {
      c(k), m();
    },
    get name() {
      return f();
    },
    set name(k = void 0) {
      f(k), m();
    },
    get type() {
      return g();
    },
    set type(k = "button") {
      g(k), m();
    },
    get onCheckedChange() {
      return _();
    },
    set onCheckedChange(k = _e) {
      _(k), m();
    }
  }, S = PT(), x = D(S);
  {
    var P = (k) => {
      var $ = M(), T = D($);
      {
        let E = /* @__PURE__ */ O(() => ({ props: d(h), ...p.snippetProps }));
        te(T, n, () => d(E));
      }
      A(k, $);
    }, w = (k) => {
      var $ = xT();
      ve($, () => ({ ...d(h) }));
      var T = ge($);
      te(T, () => s() ?? he, () => p.snippetProps), de($), A(k, $);
    };
    ue(x, (k) => {
      n() ? k(P) : k(w, !1);
    });
  }
  var C = be(x, 2);
  return ow(C, {}), A(t, S), H(y);
}
K(
  iw,
  {
    child: {},
    children: {},
    ref: {},
    id: {},
    disabled: {},
    required: {},
    checked: {},
    value: {},
    name: {},
    type: {},
    onCheckedChange: {}
  },
  [],
  [],
  { mode: "open" }
);
var OT = /* @__PURE__ */ ne("<span><!></span>");
function aw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id"
  ]);
  const l = Uh.create({
    id: z(() => i()),
    ref: z(() => o(), (p) => o(p))
  }), u = /* @__PURE__ */ O(() => Ce(a, l.props));
  var c = {
    get child() {
      return n();
    },
    set child(p) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    },
    get ref() {
      return o();
    },
    set ref(p = null) {
      o(p), m();
    },
    get id() {
      return i();
    },
    set id(p = me(r)) {
      i(p), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (p) => {
      var h = M(), y = D(h);
      {
        let S = /* @__PURE__ */ O(() => ({ props: d(u), ...l.snippetProps }));
        te(y, n, () => d(S));
      }
      A(p, h);
    }, b = (p) => {
      var h = OT();
      ve(h, () => ({ ...d(u) }));
      var y = ge(h);
      te(y, () => s() ?? he, () => l.snippetProps), de(h), A(p, h);
    };
    ue(g, (p) => {
      n() ? p(_) : p(b, !1);
    });
  }
  return A(t, f), H(c);
}
K(aw, { child: {}, children: {}, ref: {}, id: {} }, [], [], { mode: "open" });
const CT = tr({ component: "toggle", parts: ["root"] });
class Kh {
  static create(e) {
    return new Kh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.onclick = this.onclick.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || (this.opts.pressed.current = !this.opts.pressed.current);
  }
  #e = /* @__PURE__ */ O(() => ({ pressed: this.opts.pressed.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ O(() => ({
    [CT.root]: "",
    id: this.opts.id.current,
    "data-disabled": Re(this.opts.disabled.current),
    "aria-pressed": at(this.opts.pressed.current),
    "data-state": kT(this.opts.pressed.current),
    disabled: yi(this.opts.disabled.current),
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function kT(t) {
  return t ? "on" : "off";
}
var $T = /* @__PURE__ */ ne("<button><!></button>");
function lw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "ref", 15, null), s = v(e, "id", 23, () => me(r)), o = v(e, "pressed", 15, !1), i = v(e, "onPressedChange", 7, _e), a = v(e, "disabled", 7, !1), l = v(e, "type", 7, "button"), u = v(e, "children", 7), c = v(e, "child", 7), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "id",
    "pressed",
    "onPressedChange",
    "disabled",
    "type",
    "children",
    "child"
  ]);
  const g = Kh.create({
    pressed: z(() => o(), (x) => {
      o(x), i()(x);
    }),
    disabled: z(() => a() ?? !1),
    id: z(() => s()),
    ref: z(() => n(), (x) => n(x))
  }), _ = /* @__PURE__ */ O(() => Ce(f, g.props, { type: l() }));
  var b = {
    get ref() {
      return n();
    },
    set ref(x = null) {
      n(x), m();
    },
    get id() {
      return s();
    },
    set id(x = me(r)) {
      s(x), m();
    },
    get pressed() {
      return o();
    },
    set pressed(x = !1) {
      o(x), m();
    },
    get onPressedChange() {
      return i();
    },
    set onPressedChange(x = _e) {
      i(x), m();
    },
    get disabled() {
      return a();
    },
    set disabled(x = !1) {
      a(x), m();
    },
    get type() {
      return l();
    },
    set type(x = "button") {
      l(x), m();
    },
    get children() {
      return u();
    },
    set children(x) {
      u(x), m();
    },
    get child() {
      return c();
    },
    set child(x) {
      c(x), m();
    }
  }, p = M(), h = D(p);
  {
    var y = (x) => {
      var P = M(), w = D(P);
      {
        let C = /* @__PURE__ */ O(() => ({ props: d(_), ...g.snippetProps }));
        te(w, c, () => d(C));
      }
      A(x, P);
    }, S = (x) => {
      var P = $T();
      ve(P, () => ({ ...d(_) }));
      var w = ge(P);
      te(w, () => u() ?? he, () => g.snippetProps), de(P), A(x, P);
    };
    ue(h, (x) => {
      c() ? x(y) : x(S, !1);
    });
  }
  return A(t, p), H(b);
}
K(
  lw,
  {
    ref: {},
    id: {},
    pressed: {},
    onPressedChange: {},
    disabled: {},
    type: {},
    children: {},
    child: {}
  },
  [],
  [],
  { mode: "open" }
);
const Jc = tr({ component: "toggle-group", parts: ["root", "item"] }), uw = new ht("ToggleGroup.Root");
class cw {
  opts;
  rovingFocusGroup;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Te(this.opts.ref), this.rovingFocusGroup = new Ib({
      candidateAttr: Jc.item,
      rootNode: e.ref,
      loop: e.loop,
      orientation: e.orientation
    });
  }
  #e = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    [Jc.root]: "",
    role: "group",
    "data-orientation": this.opts.orientation.current,
    "data-disabled": Re(this.opts.disabled.current),
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class AT extends cw {
  opts;
  isMulti = !1;
  #e = /* @__PURE__ */ O(() => this.opts.value.current !== "");
  get anyPressed() {
    return d(this.#e);
  }
  set anyPressed(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e;
  }
  includesItem(e) {
    return this.opts.value.current === e;
  }
  toggleItem(e, r) {
    this.includesItem(e) ? this.opts.value.current = "" : (this.opts.value.current = e, this.rovingFocusGroup.setCurrentTabStopId(r));
  }
}
class ET extends cw {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ O(() => this.opts.value.current.length > 0);
  get anyPressed() {
    return d(this.#e);
  }
  set anyPressed(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e;
  }
  includesItem(e) {
    return this.opts.value.current.includes(e);
  }
  toggleItem(e, r) {
    this.includesItem(e) ? this.opts.value.current = this.opts.value.current.filter((n) => n !== e) : (this.opts.value.current = [...this.opts.value.current, e], this.rovingFocusGroup.setCurrentTabStopId(r));
  }
}
class TT {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new AT(n) : new ET(n);
    return uw.set(s);
  }
}
class Wh {
  static create(e) {
    return new Wh(e, uw.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ O(() => this.opts.disabled.current || this.root.opts.disabled.current);
  #t = /* @__PURE__ */ O(() => this.root.includesItem(this.opts.value.current));
  get isPressed() {
    return d(this.#t);
  }
  set isPressed(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ O(() => this.root.isMulti ? void 0 : ru(this.isPressed, !1));
  #n = /* @__PURE__ */ O(() => this.root.isMulti ? at(this.isPressed) : void 0);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Te(this.opts.ref), Xe(() => {
      this.root.opts.rovingFocus.current ? q(this.#o, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), !0) : q(this.#o, 0);
    }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  #s() {
    d(this.#e) || this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onclick(e) {
    d(this.#e) || this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onkeydown(e) {
    if (!d(this.#e)) {
      if (e.key === Br || e.key === xr) {
        e.preventDefault(), this.#s();
        return;
      }
      this.root.opts.rovingFocus.current && this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    }
  }
  #o = /* @__PURE__ */ xe(0);
  #i = /* @__PURE__ */ O(() => ({ pressed: this.isPressed }));
  get snippetProps() {
    return d(this.#i);
  }
  set snippetProps(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ O(() => ({
    id: this.opts.id.current,
    role: this.root.isMulti ? void 0 : "radio",
    tabindex: d(this.#o),
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Re(d(this.#e)),
    "data-state": DT(this.isPressed),
    "data-value": this.opts.value.current,
    "aria-pressed": d(this.#n),
    "aria-checked": d(this.#r),
    disabled: yi(d(this.#e)),
    [Jc.item]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
function DT(t) {
  return t ? "on" : "off";
}
var MT = /* @__PURE__ */ ne("<div><!></div>");
function dw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 15), i = v(e, "onValueChange", 7, _e), a = v(e, "type", 7), l = v(e, "disabled", 7, !1), u = v(e, "loop", 7, !0), c = v(e, "orientation", 7, "horizontal"), f = v(e, "rovingFocus", 7, !0), g = v(e, "child", 7), _ = v(e, "children", 7), b = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "onValueChange",
    "type",
    "disabled",
    "loop",
    "orientation",
    "rovingFocus",
    "child",
    "children"
  ]);
  function p() {
    o() === void 0 && o(a() === "single" ? "" : []);
  }
  p(), Fe.pre(() => o(), () => {
    p();
  });
  const h = TT.create({
    id: z(() => n()),
    value: z(() => o(), (k) => {
      o(k), i()(k);
    }),
    disabled: z(() => l()),
    loop: z(() => u()),
    orientation: z(() => c()),
    rovingFocus: z(() => f()),
    type: a(),
    ref: z(() => s(), (k) => s(k))
  }), y = /* @__PURE__ */ O(() => Ce(b, h.props));
  var S = {
    get id() {
      return n();
    },
    set id(k = me(r)) {
      n(k), m();
    },
    get ref() {
      return s();
    },
    set ref(k = null) {
      s(k), m();
    },
    get value() {
      return o();
    },
    set value(k) {
      o(k), m();
    },
    get onValueChange() {
      return i();
    },
    set onValueChange(k = _e) {
      i(k), m();
    },
    get type() {
      return a();
    },
    set type(k) {
      a(k), m();
    },
    get disabled() {
      return l();
    },
    set disabled(k = !1) {
      l(k), m();
    },
    get loop() {
      return u();
    },
    set loop(k = !0) {
      u(k), m();
    },
    get orientation() {
      return c();
    },
    set orientation(k = "horizontal") {
      c(k), m();
    },
    get rovingFocus() {
      return f();
    },
    set rovingFocus(k = !0) {
      f(k), m();
    },
    get child() {
      return g();
    },
    set child(k) {
      g(k), m();
    },
    get children() {
      return _();
    },
    set children(k) {
      _(k), m();
    }
  }, x = M(), P = D(x);
  {
    var w = (k) => {
      var $ = M(), T = D($);
      te(T, g, () => ({ props: d(y) })), A(k, $);
    }, C = (k) => {
      var $ = MT();
      ve($, () => ({ ...d(y) }));
      var T = ge($);
      te(T, () => _() ?? he), de($), A(k, $);
    };
    ue(P, (k) => {
      g() ? k(w) : k(C, !1);
    });
  }
  return A(t, x), H(S);
}
K(
  dw,
  {
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    type: {},
    disabled: {},
    loop: {},
    orientation: {},
    rovingFocus: {},
    child: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var IT = /* @__PURE__ */ ne("<button><!></button>");
function fw(t, e) {
  const r = De();
  W(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "value", 7), a = v(e, "disabled", 7, !1), l = v(e, "id", 23, () => me(r)), u = v(e, "type", 7, "button"), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "value",
    "disabled",
    "id",
    "type"
  ]);
  const f = Wh.create({
    id: z(() => l()),
    value: z(() => i()),
    disabled: z(() => a() ?? !1),
    ref: z(() => o(), (S) => o(S))
  }), g = /* @__PURE__ */ O(() => Ce(c, f.props, { type: u() }));
  var _ = {
    get children() {
      return n();
    },
    set children(S) {
      n(S), m();
    },
    get child() {
      return s();
    },
    set child(S) {
      s(S), m();
    },
    get ref() {
      return o();
    },
    set ref(S = null) {
      o(S), m();
    },
    get value() {
      return i();
    },
    set value(S) {
      i(S), m();
    },
    get disabled() {
      return a();
    },
    set disabled(S = !1) {
      a(S), m();
    },
    get id() {
      return l();
    },
    set id(S = me(r)) {
      l(S), m();
    },
    get type() {
      return u();
    },
    set type(S = "button") {
      u(S), m();
    }
  }, b = M(), p = D(b);
  {
    var h = (S) => {
      var x = M(), P = D(x);
      {
        let w = /* @__PURE__ */ O(() => ({ props: d(g), ...f.snippetProps }));
        te(P, s, () => d(w));
      }
      A(S, x);
    }, y = (S) => {
      var x = IT();
      ve(x, () => ({ ...d(g) }));
      var P = ge(x);
      te(P, () => n() ?? he, () => f.snippetProps), de(x), A(S, x);
    };
    ue(p, (S) => {
      s() ? S(h) : S(y, !1);
    });
  }
  return A(t, b), H(_);
}
K(
  fw,
  {
    children: {},
    child: {},
    ref: {},
    value: {},
    disabled: {},
    id: {},
    type: {}
  },
  [],
  [],
  { mode: "open" }
);
const NT = {
  allErrors: !0,
  multipleOfPrecision: 8,
  strict: !1,
  verbose: !0,
  discriminator: !0
}, FT = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, RT = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function VT(t) {
  return t.addFormat("color", FT), t.addFormat(gy, RT), t;
}
function LT(t) {
  return t.addKeyword(Bl), t;
}
function jT(t) {
  return LT(VT(t));
}
function BT(t, e, r = /* @__PURE__ */ new WeakMap()) {
  let n = "", s = !1;
  const o = py(r, (i) => {
    let a = i;
    return s && (a = dC(i, n), delete a[Cg]), t.compile(a);
  });
  return (i, a) => {
    n = a[Cg] ?? gO;
    let l = t.getSchema(n)?.schema;
    return l !== void 0 && l !== a && (t.removeSchema(n), r.delete(i), l = void 0), l === void 0 && t.addSchema(a, n), s = i !== a, o(i);
  };
}
function zT(t, e) {
  const n = zl(/* @__PURE__ */ new WeakMap(), (s) => t.compile({ ...s, $async: e }));
  return (s) => n(s.schema);
}
var ea = { exports: {} }, Zu = {}, hn = {}, _s = {}, Qu = {}, ec = {}, tc = {}, Dp;
function wl() {
  return Dp || (Dp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
    class e {
    }
    t._CodeOrName = e, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends e {
      constructor(S) {
        if (super(), !t.IDENTIFIER.test(S))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = S;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    t.Name = r;
    class n extends e {
      constructor(S) {
        super(), this._items = typeof S == "string" ? [S] : S;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const S = this._items[0];
        return S === "" || S === '""';
      }
      get str() {
        var S;
        return (S = this._str) !== null && S !== void 0 ? S : this._str = this._items.reduce((x, P) => `${x}${P}`, "");
      }
      get names() {
        var S;
        return (S = this._names) !== null && S !== void 0 ? S : this._names = this._items.reduce((x, P) => (P instanceof r && (x[P.str] = (x[P.str] || 0) + 1), x), {});
      }
    }
    t._Code = n, t.nil = new n("");
    function s(y, ...S) {
      const x = [y[0]];
      let P = 0;
      for (; P < S.length; )
        a(x, S[P]), x.push(y[++P]);
      return new n(x);
    }
    t._ = s;
    const o = new n("+");
    function i(y, ...S) {
      const x = [_(y[0])];
      let P = 0;
      for (; P < S.length; )
        x.push(o), a(x, S[P]), x.push(o, _(y[++P]));
      return l(x), new n(x);
    }
    t.str = i;
    function a(y, S) {
      S instanceof n ? y.push(...S._items) : S instanceof r ? y.push(S) : y.push(f(S));
    }
    t.addCodeArg = a;
    function l(y) {
      let S = 1;
      for (; S < y.length - 1; ) {
        if (y[S] === o) {
          const x = u(y[S - 1], y[S + 1]);
          if (x !== void 0) {
            y.splice(S - 1, 3, x);
            continue;
          }
          y[S++] = "+";
        }
        S++;
      }
    }
    function u(y, S) {
      if (S === '""')
        return y;
      if (y === '""')
        return S;
      if (typeof y == "string")
        return S instanceof r || y[y.length - 1] !== '"' ? void 0 : typeof S != "string" ? `${y.slice(0, -1)}${S}"` : S[0] === '"' ? y.slice(0, -1) + S.slice(1) : void 0;
      if (typeof S == "string" && S[0] === '"' && !(y instanceof r))
        return `"${y}${S.slice(1)}`;
    }
    function c(y, S) {
      return S.emptyStr() ? y : y.emptyStr() ? S : i`${y}${S}`;
    }
    t.strConcat = c;
    function f(y) {
      return typeof y == "number" || typeof y == "boolean" || y === null ? y : _(Array.isArray(y) ? y.join(",") : y);
    }
    function g(y) {
      return new n(_(y));
    }
    t.stringify = g;
    function _(y) {
      return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    t.safeStringify = _;
    function b(y) {
      return typeof y == "string" && t.IDENTIFIER.test(y) ? new n(`.${y}`) : s`[${y}]`;
    }
    t.getProperty = b;
    function p(y) {
      if (typeof y == "string" && t.IDENTIFIER.test(y))
        return new n(`${y}`);
      throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
    }
    t.getEsmExportName = p;
    function h(y) {
      return new n(y.toString());
    }
    t.regexpCode = h;
  })(tc)), tc;
}
var rc = {}, Mp;
function Ip() {
  return Mp || (Mp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
    const e = wl();
    class r extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var n;
    (function(l) {
      l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
    })(n || (t.UsedValueState = n = {})), t.varKinds = {
      const: new e.Name("const"),
      let: new e.Name("let"),
      var: new e.Name("var")
    };
    class s {
      constructor({ prefixes: u, parent: c } = {}) {
        this._names = {}, this._prefixes = u, this._parent = c;
      }
      toName(u) {
        return u instanceof e.Name ? u : this.name(u);
      }
      name(u) {
        return new e.Name(this._newName(u));
      }
      _newName(u) {
        const c = this._names[u] || this._nameGroup(u);
        return `${u}${c.index++}`;
      }
      _nameGroup(u) {
        var c, f;
        if (!((f = (c = this._parent) === null || c === void 0 ? void 0 : c._prefixes) === null || f === void 0) && f.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    t.Scope = s;
    class o extends e.Name {
      constructor(u, c) {
        super(c), this.prefix = u;
      }
      setValue(u, { property: c, itemIndex: f }) {
        this.value = u, this.scopePath = (0, e._)`.${new e.Name(c)}[${f}]`;
      }
    }
    t.ValueScopeName = o;
    const i = (0, e._)`\n`;
    class a extends s {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? i : e.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new o(u, this._newName(u));
      }
      value(u, c) {
        var f;
        if (c.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const g = this.toName(u), { prefix: _ } = g, b = (f = c.key) !== null && f !== void 0 ? f : c.ref;
        let p = this._values[_];
        if (p) {
          const S = p.get(b);
          if (S)
            return S;
        } else
          p = this._values[_] = /* @__PURE__ */ new Map();
        p.set(b, g);
        const h = this._scope[_] || (this._scope[_] = []), y = h.length;
        return h[y] = c.ref, g.setValue(c, { property: _, itemIndex: y }), g;
      }
      getValue(u, c) {
        const f = this._values[u];
        if (f)
          return f.get(c);
      }
      scopeRefs(u, c = this._values) {
        return this._reduceValues(c, (f) => {
          if (f.scopePath === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return (0, e._)`${u}${f.scopePath}`;
        });
      }
      scopeCode(u = this._values, c, f) {
        return this._reduceValues(u, (g) => {
          if (g.value === void 0)
            throw new Error(`CodeGen: name "${g}" has no value`);
          return g.value.code;
        }, c, f);
      }
      _reduceValues(u, c, f = {}, g) {
        let _ = e.nil;
        for (const b in u) {
          const p = u[b];
          if (!p)
            continue;
          const h = f[b] = f[b] || /* @__PURE__ */ new Map();
          p.forEach((y) => {
            if (h.has(y))
              return;
            h.set(y, n.Started);
            let S = c(y);
            if (S) {
              const x = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
              _ = (0, e._)`${_}${x} ${y} = ${S};${this.opts._n}`;
            } else if (S = g?.(y))
              _ = (0, e._)`${_}${S}${this.opts._n}`;
            else
              throw new r(y);
            h.set(y, n.Completed);
          });
        }
        return _;
      }
    }
    t.ValueScope = a;
  })(rc)), rc;
}
var Np;
function He() {
  return Np || (Np = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
    const e = wl(), r = Ip();
    var n = wl();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var s = Ip();
    Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
      return s.Scope;
    } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
      return s.ValueScope;
    } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
      return s.ValueScopeName;
    } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
      return s.varKinds;
    } }), t.operators = {
      GT: new e._Code(">"),
      GTE: new e._Code(">="),
      LT: new e._Code("<"),
      LTE: new e._Code("<="),
      EQ: new e._Code("==="),
      NEQ: new e._Code("!=="),
      NOT: new e._Code("!"),
      OR: new e._Code("||"),
      AND: new e._Code("&&"),
      ADD: new e._Code("+")
    };
    class o {
      optimizeNodes() {
        return this;
      }
      optimizeNames(N, V) {
        return this;
      }
    }
    class i extends o {
      constructor(N, V, G) {
        super(), this.varKind = N, this.name = V, this.rhs = G;
      }
      render({ es5: N, _n: V }) {
        const G = N ? r.varKinds.var : this.varKind, fe = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${G} ${this.name}${fe};` + V;
      }
      optimizeNames(N, V) {
        if (N[this.name.str])
          return this.rhs && (this.rhs = B(this.rhs, N, V)), this;
      }
      get names() {
        return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
      }
    }
    class a extends o {
      constructor(N, V, G) {
        super(), this.lhs = N, this.rhs = V, this.sideEffects = G;
      }
      render({ _n: N }) {
        return `${this.lhs} = ${this.rhs};` + N;
      }
      optimizeNames(N, V) {
        if (!(this.lhs instanceof e.Name && !N[this.lhs.str] && !this.sideEffects))
          return this.rhs = B(this.rhs, N, V), this;
      }
      get names() {
        const N = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
        return U(N, this.rhs);
      }
    }
    class l extends a {
      constructor(N, V, G, fe) {
        super(N, G, fe), this.op = V;
      }
      render({ _n: N }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + N;
      }
    }
    class u extends o {
      constructor(N) {
        super(), this.label = N, this.names = {};
      }
      render({ _n: N }) {
        return `${this.label}:` + N;
      }
    }
    class c extends o {
      constructor(N) {
        super(), this.label = N, this.names = {};
      }
      render({ _n: N }) {
        return `break${this.label ? ` ${this.label}` : ""};` + N;
      }
    }
    class f extends o {
      constructor(N) {
        super(), this.error = N;
      }
      render({ _n: N }) {
        return `throw ${this.error};` + N;
      }
      get names() {
        return this.error.names;
      }
    }
    class g extends o {
      constructor(N) {
        super(), this.code = N;
      }
      render({ _n: N }) {
        return `${this.code};` + N;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(N, V) {
        return this.code = B(this.code, N, V), this;
      }
      get names() {
        return this.code instanceof e._CodeOrName ? this.code.names : {};
      }
    }
    class _ extends o {
      constructor(N = []) {
        super(), this.nodes = N;
      }
      render(N) {
        return this.nodes.reduce((V, G) => V + G.render(N), "");
      }
      optimizeNodes() {
        const { nodes: N } = this;
        let V = N.length;
        for (; V--; ) {
          const G = N[V].optimizeNodes();
          Array.isArray(G) ? N.splice(V, 1, ...G) : G ? N[V] = G : N.splice(V, 1);
        }
        return N.length > 0 ? this : void 0;
      }
      optimizeNames(N, V) {
        const { nodes: G } = this;
        let fe = G.length;
        for (; fe--; ) {
          const se = G[fe];
          se.optimizeNames(N, V) || (R(N, se.names), G.splice(fe, 1));
        }
        return G.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((N, V) => F(N, V.names), {});
      }
    }
    class b extends _ {
      render(N) {
        return "{" + N._n + super.render(N) + "}" + N._n;
      }
    }
    class p extends _ {
    }
    class h extends b {
    }
    h.kind = "else";
    class y extends b {
      constructor(N, V) {
        super(V), this.condition = N;
      }
      render(N) {
        let V = `if(${this.condition})` + super.render(N);
        return this.else && (V += "else " + this.else.render(N)), V;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const N = this.condition;
        if (N === !0)
          return this.nodes;
        let V = this.else;
        if (V) {
          const G = V.optimizeNodes();
          V = this.else = Array.isArray(G) ? new h(G) : G;
        }
        if (V)
          return N === !1 ? V instanceof y ? V : V.nodes : this.nodes.length ? this : new y(Z(N), V instanceof y ? [V] : V.nodes);
        if (!(N === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(N, V) {
        var G;
        if (this.else = (G = this.else) === null || G === void 0 ? void 0 : G.optimizeNames(N, V), !!(super.optimizeNames(N, V) || this.else))
          return this.condition = B(this.condition, N, V), this;
      }
      get names() {
        const N = super.names;
        return U(N, this.condition), this.else && F(N, this.else.names), N;
      }
    }
    y.kind = "if";
    class S extends b {
    }
    S.kind = "for";
    class x extends S {
      constructor(N) {
        super(), this.iteration = N;
      }
      render(N) {
        return `for(${this.iteration})` + super.render(N);
      }
      optimizeNames(N, V) {
        if (super.optimizeNames(N, V))
          return this.iteration = B(this.iteration, N, V), this;
      }
      get names() {
        return F(super.names, this.iteration.names);
      }
    }
    class P extends S {
      constructor(N, V, G, fe) {
        super(), this.varKind = N, this.name = V, this.from = G, this.to = fe;
      }
      render(N) {
        const V = N.es5 ? r.varKinds.var : this.varKind, { name: G, from: fe, to: se } = this;
        return `for(${V} ${G}=${fe}; ${G}<${se}; ${G}++)` + super.render(N);
      }
      get names() {
        const N = U(super.names, this.from);
        return U(N, this.to);
      }
    }
    class w extends S {
      constructor(N, V, G, fe) {
        super(), this.loop = N, this.varKind = V, this.name = G, this.iterable = fe;
      }
      render(N) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(N);
      }
      optimizeNames(N, V) {
        if (super.optimizeNames(N, V))
          return this.iterable = B(this.iterable, N, V), this;
      }
      get names() {
        return F(super.names, this.iterable.names);
      }
    }
    class C extends b {
      constructor(N, V, G) {
        super(), this.name = N, this.args = V, this.async = G;
      }
      render(N) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(N);
      }
    }
    C.kind = "func";
    class k extends _ {
      render(N) {
        return "return " + super.render(N);
      }
    }
    k.kind = "return";
    class $ extends b {
      render(N) {
        let V = "try" + super.render(N);
        return this.catch && (V += this.catch.render(N)), this.finally && (V += this.finally.render(N)), V;
      }
      optimizeNodes() {
        var N, V;
        return super.optimizeNodes(), (N = this.catch) === null || N === void 0 || N.optimizeNodes(), (V = this.finally) === null || V === void 0 || V.optimizeNodes(), this;
      }
      optimizeNames(N, V) {
        var G, fe;
        return super.optimizeNames(N, V), (G = this.catch) === null || G === void 0 || G.optimizeNames(N, V), (fe = this.finally) === null || fe === void 0 || fe.optimizeNames(N, V), this;
      }
      get names() {
        const N = super.names;
        return this.catch && F(N, this.catch.names), this.finally && F(N, this.finally.names), N;
      }
    }
    class T extends b {
      constructor(N) {
        super(), this.error = N;
      }
      render(N) {
        return `catch(${this.error})` + super.render(N);
      }
    }
    T.kind = "catch";
    class E extends b {
      render(N) {
        return "finally" + super.render(N);
      }
    }
    E.kind = "finally";
    class I {
      constructor(N, V = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...V, _n: V.lines ? `
` : "" }, this._extScope = N, this._scope = new r.Scope({ parent: N }), this._nodes = [new p()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(N) {
        return this._scope.name(N);
      }
      // reserves unique name in the external scope
      scopeName(N) {
        return this._extScope.name(N);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(N, V) {
        const G = this._extScope.value(N, V);
        return (this._values[G.prefix] || (this._values[G.prefix] = /* @__PURE__ */ new Set())).add(G), G;
      }
      getScopeValue(N, V) {
        return this._extScope.getValue(N, V);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(N) {
        return this._extScope.scopeRefs(N, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(N, V, G, fe) {
        const se = this._scope.toName(V);
        return G !== void 0 && fe && (this._constants[se.str] = G), this._leafNode(new i(N, se, G)), se;
      }
      // `const` declaration (`var` in es5 mode)
      const(N, V, G) {
        return this._def(r.varKinds.const, N, V, G);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(N, V, G) {
        return this._def(r.varKinds.let, N, V, G);
      }
      // `var` declaration with optional assignment
      var(N, V, G) {
        return this._def(r.varKinds.var, N, V, G);
      }
      // assignment code
      assign(N, V, G) {
        return this._leafNode(new a(N, V, G));
      }
      // `+=` code
      add(N, V) {
        return this._leafNode(new l(N, t.operators.ADD, V));
      }
      // appends passed SafeExpr to code or executes Block
      code(N) {
        return typeof N == "function" ? N() : N !== e.nil && this._leafNode(new g(N)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...N) {
        const V = ["{"];
        for (const [G, fe] of N)
          V.length > 1 && V.push(","), V.push(G), (G !== fe || this.opts.es5) && (V.push(":"), (0, e.addCodeArg)(V, fe));
        return V.push("}"), new e._Code(V);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(N, V, G) {
        if (this._blockNode(new y(N)), V && G)
          this.code(V).else().code(G).endIf();
        else if (V)
          this.code(V).endIf();
        else if (G)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(N) {
        return this._elseNode(new y(N));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new h());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(y, h);
      }
      _for(N, V) {
        return this._blockNode(N), V && this.code(V).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(N, V) {
        return this._for(new x(N), V);
      }
      // `for` statement for a range of values
      forRange(N, V, G, fe, se = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const we = this._scope.toName(N);
        return this._for(new P(se, we, V, G), () => fe(we));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(N, V, G, fe = r.varKinds.const) {
        const se = this._scope.toName(N);
        if (this.opts.es5) {
          const we = V instanceof e.Name ? V : this.var("_arr", V);
          return this.forRange("_i", 0, (0, e._)`${we}.length`, (le) => {
            this.var(se, (0, e._)`${we}[${le}]`), G(se);
          });
        }
        return this._for(new w("of", fe, se, V), () => G(se));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(N, V, G, fe = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(N, (0, e._)`Object.keys(${V})`, G);
        const se = this._scope.toName(N);
        return this._for(new w("in", fe, se, V), () => G(se));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(S);
      }
      // `label` statement
      label(N) {
        return this._leafNode(new u(N));
      }
      // `break` statement
      break(N) {
        return this._leafNode(new c(N));
      }
      // `return` statement
      return(N) {
        const V = new k();
        if (this._blockNode(V), this.code(N), V.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(k);
      }
      // `try` statement
      try(N, V, G) {
        if (!V && !G)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const fe = new $();
        if (this._blockNode(fe), this.code(N), V) {
          const se = this.name("e");
          this._currNode = fe.catch = new T(se), V(se);
        }
        return G && (this._currNode = fe.finally = new E(), this.code(G)), this._endBlockNode(T, E);
      }
      // `throw` statement
      throw(N) {
        return this._leafNode(new f(N));
      }
      // start self-balancing block
      block(N, V) {
        return this._blockStarts.push(this._nodes.length), N && this.code(N).endBlock(V), this;
      }
      // end the current self-balancing block
      endBlock(N) {
        const V = this._blockStarts.pop();
        if (V === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const G = this._nodes.length - V;
        if (G < 0 || N !== void 0 && G !== N)
          throw new Error(`CodeGen: wrong number of nodes: ${G} vs ${N} expected`);
        return this._nodes.length = V, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(N, V = e.nil, G, fe) {
        return this._blockNode(new C(N, V, G)), fe && this.code(fe).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(C);
      }
      optimize(N = 1) {
        for (; N-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(N) {
        return this._currNode.nodes.push(N), this;
      }
      _blockNode(N) {
        this._currNode.nodes.push(N), this._nodes.push(N);
      }
      _endBlockNode(N, V) {
        const G = this._currNode;
        if (G instanceof N || V && G instanceof V)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${V ? `${N.kind}/${V.kind}` : N.kind}"`);
      }
      _elseNode(N) {
        const V = this._currNode;
        if (!(V instanceof y))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = V.else = N, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const N = this._nodes;
        return N[N.length - 1];
      }
      set _currNode(N) {
        const V = this._nodes;
        V[V.length - 1] = N;
      }
    }
    t.CodeGen = I;
    function F(L, N) {
      for (const V in N)
        L[V] = (L[V] || 0) + (N[V] || 0);
      return L;
    }
    function U(L, N) {
      return N instanceof e._CodeOrName ? F(L, N.names) : L;
    }
    function B(L, N, V) {
      if (L instanceof e.Name)
        return G(L);
      if (!fe(L))
        return L;
      return new e._Code(L._items.reduce((se, we) => (we instanceof e.Name && (we = G(we)), we instanceof e._Code ? se.push(...we._items) : se.push(we), se), []));
      function G(se) {
        const we = V[se.str];
        return we === void 0 || N[se.str] !== 1 ? se : (delete N[se.str], we);
      }
      function fe(se) {
        return se instanceof e._Code && se._items.some((we) => we instanceof e.Name && N[we.str] === 1 && V[we.str] !== void 0);
      }
    }
    function R(L, N) {
      for (const V in N)
        L[V] = (L[V] || 0) - (N[V] || 0);
    }
    function Z(L) {
      return typeof L == "boolean" || typeof L == "number" || L === null ? !L : (0, e._)`!${ee(L)}`;
    }
    t.not = Z;
    const Y = j(t.operators.AND);
    function X(...L) {
      return L.reduce(Y);
    }
    t.and = X;
    const ae = j(t.operators.OR);
    function J(...L) {
      return L.reduce(ae);
    }
    t.or = J;
    function j(L) {
      return (N, V) => N === e.nil ? V : V === e.nil ? N : (0, e._)`${ee(N)} ${L} ${ee(V)}`;
    }
    function ee(L) {
      return L instanceof e.Name ? L : (0, e._)`(${L})`;
    }
  })(ec)), ec;
}
var qe = {}, Fp;
function et() {
  if (Fp) return qe;
  Fp = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.checkStrictMode = qe.getErrorPath = qe.Type = qe.useFunc = qe.setEvaluated = qe.evaluatedPropsToName = qe.mergeEvaluated = qe.eachItem = qe.unescapeJsonPointer = qe.escapeJsonPointer = qe.escapeFragment = qe.unescapeFragment = qe.schemaRefOrVal = qe.schemaHasRulesButRef = qe.schemaHasRules = qe.checkUnknownRules = qe.alwaysValidSchema = qe.toHash = void 0;
  const t = He(), e = wl();
  function r(w) {
    const C = {};
    for (const k of w)
      C[k] = !0;
    return C;
  }
  qe.toHash = r;
  function n(w, C) {
    return typeof C == "boolean" ? C : Object.keys(C).length === 0 ? !0 : (s(w, C), !o(C, w.self.RULES.all));
  }
  qe.alwaysValidSchema = n;
  function s(w, C = w.schema) {
    const { opts: k, self: $ } = w;
    if (!k.strictSchema || typeof C == "boolean")
      return;
    const T = $.RULES.keywords;
    for (const E in C)
      T[E] || P(w, `unknown keyword: "${E}"`);
  }
  qe.checkUnknownRules = s;
  function o(w, C) {
    if (typeof w == "boolean")
      return !w;
    for (const k in w)
      if (C[k])
        return !0;
    return !1;
  }
  qe.schemaHasRules = o;
  function i(w, C) {
    if (typeof w == "boolean")
      return !w;
    for (const k in w)
      if (k !== "$ref" && C.all[k])
        return !0;
    return !1;
  }
  qe.schemaHasRulesButRef = i;
  function a({ topSchemaRef: w, schemaPath: C }, k, $, T) {
    if (!T) {
      if (typeof k == "number" || typeof k == "boolean")
        return k;
      if (typeof k == "string")
        return (0, t._)`${k}`;
    }
    return (0, t._)`${w}${C}${(0, t.getProperty)($)}`;
  }
  qe.schemaRefOrVal = a;
  function l(w) {
    return f(decodeURIComponent(w));
  }
  qe.unescapeFragment = l;
  function u(w) {
    return encodeURIComponent(c(w));
  }
  qe.escapeFragment = u;
  function c(w) {
    return typeof w == "number" ? `${w}` : w.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  qe.escapeJsonPointer = c;
  function f(w) {
    return w.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  qe.unescapeJsonPointer = f;
  function g(w, C) {
    if (Array.isArray(w))
      for (const k of w)
        C(k);
    else
      C(w);
  }
  qe.eachItem = g;
  function _({ mergeNames: w, mergeToName: C, mergeValues: k, resultToName: $ }) {
    return (T, E, I, F) => {
      const U = I === void 0 ? E : I instanceof t.Name ? (E instanceof t.Name ? w(T, E, I) : C(T, E, I), I) : E instanceof t.Name ? (C(T, I, E), E) : k(E, I);
      return F === t.Name && !(U instanceof t.Name) ? $(T, U) : U;
    };
  }
  qe.mergeEvaluated = {
    props: _({
      mergeNames: (w, C, k) => w.if((0, t._)`${k} !== true && ${C} !== undefined`, () => {
        w.if((0, t._)`${C} === true`, () => w.assign(k, !0), () => w.assign(k, (0, t._)`${k} || {}`).code((0, t._)`Object.assign(${k}, ${C})`));
      }),
      mergeToName: (w, C, k) => w.if((0, t._)`${k} !== true`, () => {
        C === !0 ? w.assign(k, !0) : (w.assign(k, (0, t._)`${k} || {}`), p(w, k, C));
      }),
      mergeValues: (w, C) => w === !0 ? !0 : { ...w, ...C },
      resultToName: b
    }),
    items: _({
      mergeNames: (w, C, k) => w.if((0, t._)`${k} !== true && ${C} !== undefined`, () => w.assign(k, (0, t._)`${C} === true ? true : ${k} > ${C} ? ${k} : ${C}`)),
      mergeToName: (w, C, k) => w.if((0, t._)`${k} !== true`, () => w.assign(k, C === !0 ? !0 : (0, t._)`${k} > ${C} ? ${k} : ${C}`)),
      mergeValues: (w, C) => w === !0 ? !0 : Math.max(w, C),
      resultToName: (w, C) => w.var("items", C)
    })
  };
  function b(w, C) {
    if (C === !0)
      return w.var("props", !0);
    const k = w.var("props", (0, t._)`{}`);
    return C !== void 0 && p(w, k, C), k;
  }
  qe.evaluatedPropsToName = b;
  function p(w, C, k) {
    Object.keys(k).forEach(($) => w.assign((0, t._)`${C}${(0, t.getProperty)($)}`, !0));
  }
  qe.setEvaluated = p;
  const h = {};
  function y(w, C) {
    return w.scopeValue("func", {
      ref: C,
      code: h[C.code] || (h[C.code] = new e._Code(C.code))
    });
  }
  qe.useFunc = y;
  var S;
  (function(w) {
    w[w.Num = 0] = "Num", w[w.Str = 1] = "Str";
  })(S || (qe.Type = S = {}));
  function x(w, C, k) {
    if (w instanceof t.Name) {
      const $ = C === S.Num;
      return k ? $ ? (0, t._)`"[" + ${w} + "]"` : (0, t._)`"['" + ${w} + "']"` : $ ? (0, t._)`"/" + ${w}` : (0, t._)`"/" + ${w}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return k ? (0, t.getProperty)(w).toString() : "/" + c(w);
  }
  qe.getErrorPath = x;
  function P(w, C, k = w.opts.strictSchema) {
    if (k) {
      if (C = `strict mode: ${C}`, k === !0)
        throw new Error(C);
      w.self.logger.warn(C);
    }
  }
  return qe.checkStrictMode = P, qe;
}
var ta = {}, Rp;
function hs() {
  if (Rp) return ta;
  Rp = 1, Object.defineProperty(ta, "__esModule", { value: !0 });
  const t = He(), e = {
    // validation function arguments
    data: new t.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new t.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new t.Name("instancePath"),
    parentData: new t.Name("parentData"),
    parentDataProperty: new t.Name("parentDataProperty"),
    rootData: new t.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new t.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new t.Name("vErrors"),
    // null or array of validation errors
    errors: new t.Name("errors"),
    // counter of validation errors
    this: new t.Name("this"),
    // "globals"
    self: new t.Name("self"),
    scope: new t.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new t.Name("json"),
    jsonPos: new t.Name("jsonPos"),
    jsonLen: new t.Name("jsonLen"),
    jsonPart: new t.Name("jsonPart")
  };
  return ta.default = e, ta;
}
var Vp;
function hu() {
  return Vp || (Vp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
    const e = He(), r = et(), n = hs();
    t.keywordError = {
      message: ({ keyword: h }) => (0, e.str)`must pass "${h}" keyword validation`
    }, t.keyword$DataError = {
      message: ({ keyword: h, schemaType: y }) => y ? (0, e.str)`"${h}" keyword must be ${y} ($data)` : (0, e.str)`"${h}" keyword is invalid ($data)`
    };
    function s(h, y = t.keywordError, S, x) {
      const { it: P } = h, { gen: w, compositeRule: C, allErrors: k } = P, $ = f(h, y, S);
      x ?? (C || k) ? l(w, $) : u(P, (0, e._)`[${$}]`);
    }
    t.reportError = s;
    function o(h, y = t.keywordError, S) {
      const { it: x } = h, { gen: P, compositeRule: w, allErrors: C } = x, k = f(h, y, S);
      l(P, k), w || C || u(x, n.default.vErrors);
    }
    t.reportExtraError = o;
    function i(h, y) {
      h.assign(n.default.errors, y), h.if((0, e._)`${n.default.vErrors} !== null`, () => h.if(y, () => h.assign((0, e._)`${n.default.vErrors}.length`, y), () => h.assign(n.default.vErrors, null)));
    }
    t.resetErrorsCount = i;
    function a({ gen: h, keyword: y, schemaValue: S, data: x, errsCount: P, it: w }) {
      if (P === void 0)
        throw new Error("ajv implementation error");
      const C = h.name("err");
      h.forRange("i", P, n.default.errors, (k) => {
        h.const(C, (0, e._)`${n.default.vErrors}[${k}]`), h.if((0, e._)`${C}.instancePath === undefined`, () => h.assign((0, e._)`${C}.instancePath`, (0, e.strConcat)(n.default.instancePath, w.errorPath))), h.assign((0, e._)`${C}.schemaPath`, (0, e.str)`${w.errSchemaPath}/${y}`), w.opts.verbose && (h.assign((0, e._)`${C}.schema`, S), h.assign((0, e._)`${C}.data`, x));
      });
    }
    t.extendErrors = a;
    function l(h, y) {
      const S = h.const("err", y);
      h.if((0, e._)`${n.default.vErrors} === null`, () => h.assign(n.default.vErrors, (0, e._)`[${S}]`), (0, e._)`${n.default.vErrors}.push(${S})`), h.code((0, e._)`${n.default.errors}++`);
    }
    function u(h, y) {
      const { gen: S, validateName: x, schemaEnv: P } = h;
      P.$async ? S.throw((0, e._)`new ${h.ValidationError}(${y})`) : (S.assign((0, e._)`${x}.errors`, y), S.return(!1));
    }
    const c = {
      keyword: new e.Name("keyword"),
      schemaPath: new e.Name("schemaPath"),
      // also used in JTD errors
      params: new e.Name("params"),
      propertyName: new e.Name("propertyName"),
      message: new e.Name("message"),
      schema: new e.Name("schema"),
      parentSchema: new e.Name("parentSchema")
    };
    function f(h, y, S) {
      const { createErrors: x } = h.it;
      return x === !1 ? (0, e._)`{}` : g(h, y, S);
    }
    function g(h, y, S = {}) {
      const { gen: x, it: P } = h, w = [
        _(P, S),
        b(h, S)
      ];
      return p(h, y, w), x.object(...w);
    }
    function _({ errorPath: h }, { instancePath: y }) {
      const S = y ? (0, e.str)`${h}${(0, r.getErrorPath)(y, r.Type.Str)}` : h;
      return [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, S)];
    }
    function b({ keyword: h, it: { errSchemaPath: y } }, { schemaPath: S, parentSchema: x }) {
      let P = x ? y : (0, e.str)`${y}/${h}`;
      return S && (P = (0, e.str)`${P}${(0, r.getErrorPath)(S, r.Type.Str)}`), [c.schemaPath, P];
    }
    function p(h, { params: y, message: S }, x) {
      const { keyword: P, data: w, schemaValue: C, it: k } = h, { opts: $, propertyName: T, topSchemaRef: E, schemaPath: I } = k;
      x.push([c.keyword, P], [c.params, typeof y == "function" ? y(h) : y || (0, e._)`{}`]), $.messages && x.push([c.message, typeof S == "function" ? S(h) : S]), $.verbose && x.push([c.schema, C], [c.parentSchema, (0, e._)`${E}${I}`], [n.default.data, w]), T && x.push([c.propertyName, T]);
    }
  })(Qu)), Qu;
}
var Lp;
function qT() {
  if (Lp) return _s;
  Lp = 1, Object.defineProperty(_s, "__esModule", { value: !0 }), _s.boolOrEmptySchema = _s.topBoolOrEmptySchema = void 0;
  const t = hu(), e = He(), r = hs(), n = {
    message: "boolean schema is false"
  };
  function s(a) {
    const { gen: l, schema: u, validateName: c } = a;
    u === !1 ? i(a, !1) : typeof u == "object" && u.$async === !0 ? l.return(r.default.data) : (l.assign((0, e._)`${c}.errors`, null), l.return(!0));
  }
  _s.topBoolOrEmptySchema = s;
  function o(a, l) {
    const { gen: u, schema: c } = a;
    c === !1 ? (u.var(l, !1), i(a)) : u.var(l, !0);
  }
  _s.boolOrEmptySchema = o;
  function i(a, l) {
    const { gen: u, data: c } = a, f = {
      gen: u,
      keyword: "false schema",
      data: c,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: a
    };
    (0, t.reportError)(f, n, void 0, l);
  }
  return _s;
}
var At = {}, ws = {}, jp;
function hw() {
  if (jp) return ws;
  jp = 1, Object.defineProperty(ws, "__esModule", { value: !0 }), ws.getRules = ws.isJSONType = void 0;
  const t = ["string", "number", "integer", "boolean", "null", "object", "array"], e = new Set(t);
  function r(s) {
    return typeof s == "string" && e.has(s);
  }
  ws.isJSONType = r;
  function n() {
    const s = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...s, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, s.number, s.string, s.array, s.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return ws.getRules = n, ws;
}
var gn = {}, Bp;
function gw() {
  if (Bp) return gn;
  Bp = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.shouldUseRule = gn.shouldUseGroup = gn.schemaHasRulesForType = void 0;
  function t({ schema: n, self: s }, o) {
    const i = s.RULES.types[o];
    return i && i !== !0 && e(n, i);
  }
  gn.schemaHasRulesForType = t;
  function e(n, s) {
    return s.rules.some((o) => r(n, o));
  }
  gn.shouldUseGroup = e;
  function r(n, s) {
    var o;
    return n[s.keyword] !== void 0 || ((o = s.definition.implements) === null || o === void 0 ? void 0 : o.some((i) => n[i] !== void 0));
  }
  return gn.shouldUseRule = r, gn;
}
var zp;
function Sl() {
  if (zp) return At;
  zp = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.reportTypeError = At.checkDataTypes = At.checkDataType = At.coerceAndCheckDataType = At.getJSONTypes = At.getSchemaTypes = At.DataType = void 0;
  const t = hw(), e = gw(), r = hu(), n = He(), s = et();
  var o;
  (function(S) {
    S[S.Correct = 0] = "Correct", S[S.Wrong = 1] = "Wrong";
  })(o || (At.DataType = o = {}));
  function i(S) {
    const x = a(S.type);
    if (x.includes("null")) {
      if (S.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!x.length && S.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      S.nullable === !0 && x.push("null");
    }
    return x;
  }
  At.getSchemaTypes = i;
  function a(S) {
    const x = Array.isArray(S) ? S : S ? [S] : [];
    if (x.every(t.isJSONType))
      return x;
    throw new Error("type must be JSONType or JSONType[]: " + x.join(","));
  }
  At.getJSONTypes = a;
  function l(S, x) {
    const { gen: P, data: w, opts: C } = S, k = c(x, C.coerceTypes), $ = x.length > 0 && !(k.length === 0 && x.length === 1 && (0, e.schemaHasRulesForType)(S, x[0]));
    if ($) {
      const T = b(x, w, C.strictNumbers, o.Wrong);
      P.if(T, () => {
        k.length ? f(S, x, k) : h(S);
      });
    }
    return $;
  }
  At.coerceAndCheckDataType = l;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function c(S, x) {
    return x ? S.filter((P) => u.has(P) || x === "array" && P === "array") : [];
  }
  function f(S, x, P) {
    const { gen: w, data: C, opts: k } = S, $ = w.let("dataType", (0, n._)`typeof ${C}`), T = w.let("coerced", (0, n._)`undefined`);
    k.coerceTypes === "array" && w.if((0, n._)`${$} == 'object' && Array.isArray(${C}) && ${C}.length == 1`, () => w.assign(C, (0, n._)`${C}[0]`).assign($, (0, n._)`typeof ${C}`).if(b(x, C, k.strictNumbers), () => w.assign(T, C))), w.if((0, n._)`${T} !== undefined`);
    for (const I of P)
      (u.has(I) || I === "array" && k.coerceTypes === "array") && E(I);
    w.else(), h(S), w.endIf(), w.if((0, n._)`${T} !== undefined`, () => {
      w.assign(C, T), g(S, T);
    });
    function E(I) {
      switch (I) {
        case "string":
          w.elseIf((0, n._)`${$} == "number" || ${$} == "boolean"`).assign(T, (0, n._)`"" + ${C}`).elseIf((0, n._)`${C} === null`).assign(T, (0, n._)`""`);
          return;
        case "number":
          w.elseIf((0, n._)`${$} == "boolean" || ${C} === null
              || (${$} == "string" && ${C} && ${C} == +${C})`).assign(T, (0, n._)`+${C}`);
          return;
        case "integer":
          w.elseIf((0, n._)`${$} === "boolean" || ${C} === null
              || (${$} === "string" && ${C} && ${C} == +${C} && !(${C} % 1))`).assign(T, (0, n._)`+${C}`);
          return;
        case "boolean":
          w.elseIf((0, n._)`${C} === "false" || ${C} === 0 || ${C} === null`).assign(T, !1).elseIf((0, n._)`${C} === "true" || ${C} === 1`).assign(T, !0);
          return;
        case "null":
          w.elseIf((0, n._)`${C} === "" || ${C} === 0 || ${C} === false`), w.assign(T, null);
          return;
        case "array":
          w.elseIf((0, n._)`${$} === "string" || ${$} === "number"
              || ${$} === "boolean" || ${C} === null`).assign(T, (0, n._)`[${C}]`);
      }
    }
  }
  function g({ gen: S, parentData: x, parentDataProperty: P }, w) {
    S.if((0, n._)`${x} !== undefined`, () => S.assign((0, n._)`${x}[${P}]`, w));
  }
  function _(S, x, P, w = o.Correct) {
    const C = w === o.Correct ? n.operators.EQ : n.operators.NEQ;
    let k;
    switch (S) {
      case "null":
        return (0, n._)`${x} ${C} null`;
      case "array":
        k = (0, n._)`Array.isArray(${x})`;
        break;
      case "object":
        k = (0, n._)`${x} && typeof ${x} == "object" && !Array.isArray(${x})`;
        break;
      case "integer":
        k = $((0, n._)`!(${x} % 1) && !isNaN(${x})`);
        break;
      case "number":
        k = $();
        break;
      default:
        return (0, n._)`typeof ${x} ${C} ${S}`;
    }
    return w === o.Correct ? k : (0, n.not)(k);
    function $(T = n.nil) {
      return (0, n.and)((0, n._)`typeof ${x} == "number"`, T, P ? (0, n._)`isFinite(${x})` : n.nil);
    }
  }
  At.checkDataType = _;
  function b(S, x, P, w) {
    if (S.length === 1)
      return _(S[0], x, P, w);
    let C;
    const k = (0, s.toHash)(S);
    if (k.array && k.object) {
      const $ = (0, n._)`typeof ${x} != "object"`;
      C = k.null ? $ : (0, n._)`!${x} || ${$}`, delete k.null, delete k.array, delete k.object;
    } else
      C = n.nil;
    k.number && delete k.integer;
    for (const $ in k)
      C = (0, n.and)(C, _($, x, P, w));
    return C;
  }
  At.checkDataTypes = b;
  const p = {
    message: ({ schema: S }) => `must be ${S}`,
    params: ({ schema: S, schemaValue: x }) => typeof S == "string" ? (0, n._)`{type: ${S}}` : (0, n._)`{type: ${x}}`
  };
  function h(S) {
    const x = y(S);
    (0, r.reportError)(x, p);
  }
  At.reportTypeError = h;
  function y(S) {
    const { gen: x, data: P, schema: w } = S, C = (0, s.schemaRefOrVal)(S, w, "type");
    return {
      gen: x,
      keyword: "type",
      data: P,
      schema: w.type,
      schemaCode: C,
      schemaValue: C,
      parentSchema: w,
      params: {},
      it: S
    };
  }
  return At;
}
var Qo = {}, qp;
function UT() {
  if (qp) return Qo;
  qp = 1, Object.defineProperty(Qo, "__esModule", { value: !0 }), Qo.assignDefaults = void 0;
  const t = He(), e = et();
  function r(s, o) {
    const { properties: i, items: a } = s.schema;
    if (o === "object" && i)
      for (const l in i)
        n(s, l, i[l].default);
    else o === "array" && Array.isArray(a) && a.forEach((l, u) => n(s, u, l.default));
  }
  Qo.assignDefaults = r;
  function n(s, o, i) {
    const { gen: a, compositeRule: l, data: u, opts: c } = s;
    if (i === void 0)
      return;
    const f = (0, t._)`${u}${(0, t.getProperty)(o)}`;
    if (l) {
      (0, e.checkStrictMode)(s, `default is ignored for: ${f}`);
      return;
    }
    let g = (0, t._)`${f} === undefined`;
    c.useDefaults === "empty" && (g = (0, t._)`${g} || ${f} === null || ${f} === ""`), a.if(g, (0, t._)`${f} = ${(0, t.stringify)(i)}`);
  }
  return Qo;
}
var Ar = {}, tt = {}, Up;
function Kr() {
  if (Up) return tt;
  Up = 1, Object.defineProperty(tt, "__esModule", { value: !0 }), tt.validateUnion = tt.validateArray = tt.usePattern = tt.callValidateCode = tt.schemaProperties = tt.allSchemaProperties = tt.noPropertyInData = tt.propertyInData = tt.isOwnProperty = tt.hasPropFunc = tt.reportMissingProp = tt.checkMissingProp = tt.checkReportMissingProp = void 0;
  const t = He(), e = et(), r = hs(), n = et();
  function s(S, x) {
    const { gen: P, data: w, it: C } = S;
    P.if(c(P, w, x, C.opts.ownProperties), () => {
      S.setParams({ missingProperty: (0, t._)`${x}` }, !0), S.error();
    });
  }
  tt.checkReportMissingProp = s;
  function o({ gen: S, data: x, it: { opts: P } }, w, C) {
    return (0, t.or)(...w.map((k) => (0, t.and)(c(S, x, k, P.ownProperties), (0, t._)`${C} = ${k}`)));
  }
  tt.checkMissingProp = o;
  function i(S, x) {
    S.setParams({ missingProperty: x }, !0), S.error();
  }
  tt.reportMissingProp = i;
  function a(S) {
    return S.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, t._)`Object.prototype.hasOwnProperty`
    });
  }
  tt.hasPropFunc = a;
  function l(S, x, P) {
    return (0, t._)`${a(S)}.call(${x}, ${P})`;
  }
  tt.isOwnProperty = l;
  function u(S, x, P, w) {
    const C = (0, t._)`${x}${(0, t.getProperty)(P)} !== undefined`;
    return w ? (0, t._)`${C} && ${l(S, x, P)}` : C;
  }
  tt.propertyInData = u;
  function c(S, x, P, w) {
    const C = (0, t._)`${x}${(0, t.getProperty)(P)} === undefined`;
    return w ? (0, t.or)(C, (0, t.not)(l(S, x, P))) : C;
  }
  tt.noPropertyInData = c;
  function f(S) {
    return S ? Object.keys(S).filter((x) => x !== "__proto__") : [];
  }
  tt.allSchemaProperties = f;
  function g(S, x) {
    return f(x).filter((P) => !(0, e.alwaysValidSchema)(S, x[P]));
  }
  tt.schemaProperties = g;
  function _({ schemaCode: S, data: x, it: { gen: P, topSchemaRef: w, schemaPath: C, errorPath: k }, it: $ }, T, E, I) {
    const F = I ? (0, t._)`${S}, ${x}, ${w}${C}` : x, U = [
      [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, k)],
      [r.default.parentData, $.parentData],
      [r.default.parentDataProperty, $.parentDataProperty],
      [r.default.rootData, r.default.rootData]
    ];
    $.opts.dynamicRef && U.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const B = (0, t._)`${F}, ${P.object(...U)}`;
    return E !== t.nil ? (0, t._)`${T}.call(${E}, ${B})` : (0, t._)`${T}(${B})`;
  }
  tt.callValidateCode = _;
  const b = (0, t._)`new RegExp`;
  function p({ gen: S, it: { opts: x } }, P) {
    const w = x.unicodeRegExp ? "u" : "", { regExp: C } = x.code, k = C(P, w);
    return S.scopeValue("pattern", {
      key: k.toString(),
      ref: k,
      code: (0, t._)`${C.code === "new RegExp" ? b : (0, n.useFunc)(S, C)}(${P}, ${w})`
    });
  }
  tt.usePattern = p;
  function h(S) {
    const { gen: x, data: P, keyword: w, it: C } = S, k = x.name("valid");
    if (C.allErrors) {
      const T = x.let("valid", !0);
      return $(() => x.assign(T, !1)), T;
    }
    return x.var(k, !0), $(() => x.break()), k;
    function $(T) {
      const E = x.const("len", (0, t._)`${P}.length`);
      x.forRange("i", 0, E, (I) => {
        S.subschema({
          keyword: w,
          dataProp: I,
          dataPropType: e.Type.Num
        }, k), x.if((0, t.not)(k), T);
      });
    }
  }
  tt.validateArray = h;
  function y(S) {
    const { gen: x, schema: P, keyword: w, it: C } = S;
    if (!Array.isArray(P))
      throw new Error("ajv implementation error");
    if (P.some((E) => (0, e.alwaysValidSchema)(C, E)) && !C.opts.unevaluated)
      return;
    const $ = x.let("valid", !1), T = x.name("_valid");
    x.block(() => P.forEach((E, I) => {
      const F = S.subschema({
        keyword: w,
        schemaProp: I,
        compositeRule: !0
      }, T);
      x.assign($, (0, t._)`${$} || ${T}`), S.mergeValidEvaluated(F, T) || x.if((0, t.not)($));
    })), S.result($, () => S.reset(), () => S.error(!0));
  }
  return tt.validateUnion = y, tt;
}
var Kp;
function KT() {
  if (Kp) return Ar;
  Kp = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.validateKeywordUsage = Ar.validSchemaType = Ar.funcKeywordCode = Ar.macroKeywordCode = void 0;
  const t = He(), e = hs(), r = Kr(), n = hu();
  function s(g, _) {
    const { gen: b, keyword: p, schema: h, parentSchema: y, it: S } = g, x = _.macro.call(S.self, h, y, S), P = u(b, p, x);
    S.opts.validateSchema !== !1 && S.self.validateSchema(x, !0);
    const w = b.name("valid");
    g.subschema({
      schema: x,
      schemaPath: t.nil,
      errSchemaPath: `${S.errSchemaPath}/${p}`,
      topSchemaRef: P,
      compositeRule: !0
    }, w), g.pass(w, () => g.error(!0));
  }
  Ar.macroKeywordCode = s;
  function o(g, _) {
    var b;
    const { gen: p, keyword: h, schema: y, parentSchema: S, $data: x, it: P } = g;
    l(P, _);
    const w = !x && _.compile ? _.compile.call(P.self, y, S, P) : _.validate, C = u(p, h, w), k = p.let("valid");
    g.block$data(k, $), g.ok((b = _.valid) !== null && b !== void 0 ? b : k);
    function $() {
      if (_.errors === !1)
        I(), _.modifying && i(g), F(() => g.error());
      else {
        const U = _.async ? T() : E();
        _.modifying && i(g), F(() => a(g, U));
      }
    }
    function T() {
      const U = p.let("ruleErrs", null);
      return p.try(() => I((0, t._)`await `), (B) => p.assign(k, !1).if((0, t._)`${B} instanceof ${P.ValidationError}`, () => p.assign(U, (0, t._)`${B}.errors`), () => p.throw(B))), U;
    }
    function E() {
      const U = (0, t._)`${C}.errors`;
      return p.assign(U, null), I(t.nil), U;
    }
    function I(U = _.async ? (0, t._)`await ` : t.nil) {
      const B = P.opts.passContext ? e.default.this : e.default.self, R = !("compile" in _ && !x || _.schema === !1);
      p.assign(k, (0, t._)`${U}${(0, r.callValidateCode)(g, C, B, R)}`, _.modifying);
    }
    function F(U) {
      var B;
      p.if((0, t.not)((B = _.valid) !== null && B !== void 0 ? B : k), U);
    }
  }
  Ar.funcKeywordCode = o;
  function i(g) {
    const { gen: _, data: b, it: p } = g;
    _.if(p.parentData, () => _.assign(b, (0, t._)`${p.parentData}[${p.parentDataProperty}]`));
  }
  function a(g, _) {
    const { gen: b } = g;
    b.if((0, t._)`Array.isArray(${_})`, () => {
      b.assign(e.default.vErrors, (0, t._)`${e.default.vErrors} === null ? ${_} : ${e.default.vErrors}.concat(${_})`).assign(e.default.errors, (0, t._)`${e.default.vErrors}.length`), (0, n.extendErrors)(g);
    }, () => g.error());
  }
  function l({ schemaEnv: g }, _) {
    if (_.async && !g.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(g, _, b) {
    if (b === void 0)
      throw new Error(`keyword "${_}" failed to compile`);
    return g.scopeValue("keyword", typeof b == "function" ? { ref: b } : { ref: b, code: (0, t.stringify)(b) });
  }
  function c(g, _, b = !1) {
    return !_.length || _.some((p) => p === "array" ? Array.isArray(g) : p === "object" ? g && typeof g == "object" && !Array.isArray(g) : typeof g == p || b && typeof g > "u");
  }
  Ar.validSchemaType = c;
  function f({ schema: g, opts: _, self: b, errSchemaPath: p }, h, y) {
    if (Array.isArray(h.keyword) ? !h.keyword.includes(y) : h.keyword !== y)
      throw new Error("ajv implementation error");
    const S = h.dependencies;
    if (S?.some((x) => !Object.prototype.hasOwnProperty.call(g, x)))
      throw new Error(`parent schema must have dependencies of ${y}: ${S.join(",")}`);
    if (h.validateSchema && !h.validateSchema(g[y])) {
      const P = `keyword "${y}" value is invalid at path "${p}": ` + b.errorsText(h.validateSchema.errors);
      if (_.validateSchema === "log")
        b.logger.error(P);
      else
        throw new Error(P);
    }
  }
  return Ar.validateKeywordUsage = f, Ar;
}
var pn = {}, Wp;
function WT() {
  if (Wp) return pn;
  Wp = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.extendSubschemaMode = pn.extendSubschemaData = pn.getSubschema = void 0;
  const t = He(), e = et();
  function r(o, { keyword: i, schemaProp: a, schema: l, schemaPath: u, errSchemaPath: c, topSchemaRef: f }) {
    if (i !== void 0 && l !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (i !== void 0) {
      const g = o.schema[i];
      return a === void 0 ? {
        schema: g,
        schemaPath: (0, t._)`${o.schemaPath}${(0, t.getProperty)(i)}`,
        errSchemaPath: `${o.errSchemaPath}/${i}`
      } : {
        schema: g[a],
        schemaPath: (0, t._)`${o.schemaPath}${(0, t.getProperty)(i)}${(0, t.getProperty)(a)}`,
        errSchemaPath: `${o.errSchemaPath}/${i}/${(0, e.escapeFragment)(a)}`
      };
    }
    if (l !== void 0) {
      if (u === void 0 || c === void 0 || f === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: l,
        schemaPath: u,
        topSchemaRef: f,
        errSchemaPath: c
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  pn.getSubschema = r;
  function n(o, i, { dataProp: a, dataPropType: l, data: u, dataTypes: c, propertyName: f }) {
    if (u !== void 0 && a !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: g } = i;
    if (a !== void 0) {
      const { errorPath: b, dataPathArr: p, opts: h } = i, y = g.let("data", (0, t._)`${i.data}${(0, t.getProperty)(a)}`, !0);
      _(y), o.errorPath = (0, t.str)`${b}${(0, e.getErrorPath)(a, l, h.jsPropertySyntax)}`, o.parentDataProperty = (0, t._)`${a}`, o.dataPathArr = [...p, o.parentDataProperty];
    }
    if (u !== void 0) {
      const b = u instanceof t.Name ? u : g.let("data", u, !0);
      _(b), f !== void 0 && (o.propertyName = f);
    }
    c && (o.dataTypes = c);
    function _(b) {
      o.data = b, o.dataLevel = i.dataLevel + 1, o.dataTypes = [], i.definedProperties = /* @__PURE__ */ new Set(), o.parentData = i.data, o.dataNames = [...i.dataNames, b];
    }
  }
  pn.extendSubschemaData = n;
  function s(o, { jtdDiscriminator: i, jtdMetadata: a, compositeRule: l, createErrors: u, allErrors: c }) {
    l !== void 0 && (o.compositeRule = l), u !== void 0 && (o.createErrors = u), c !== void 0 && (o.allErrors = c), o.jtdDiscriminator = i, o.jtdMetadata = a;
  }
  return pn.extendSubschemaMode = s, pn;
}
var Lt = {}, nc, Hp;
function pw() {
  return Hp || (Hp = 1, nc = function t(e, r) {
    if (e === r) return !0;
    if (e && r && typeof e == "object" && typeof r == "object") {
      if (e.constructor !== r.constructor) return !1;
      var n, s, o;
      if (Array.isArray(e)) {
        if (n = e.length, n != r.length) return !1;
        for (s = n; s-- !== 0; )
          if (!t(e[s], r[s])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === r.source && e.flags === r.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === r.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === r.toString();
      if (o = Object.keys(e), n = o.length, n !== Object.keys(r).length) return !1;
      for (s = n; s-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, o[s])) return !1;
      for (s = n; s-- !== 0; ) {
        var i = o[s];
        if (!t(e[i], r[i])) return !1;
      }
      return !0;
    }
    return e !== e && r !== r;
  }), nc;
}
var sc = { exports: {} }, Gp;
function HT() {
  if (Gp) return sc.exports;
  Gp = 1;
  var t = sc.exports = function(n, s, o) {
    typeof s == "function" && (o = s, s = {}), o = s.cb || o;
    var i = typeof o == "function" ? o : o.pre || function() {
    }, a = o.post || function() {
    };
    e(s, i, a, n, "", n);
  };
  t.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, t.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, t.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, t.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function e(n, s, o, i, a, l, u, c, f, g) {
    if (i && typeof i == "object" && !Array.isArray(i)) {
      s(i, a, l, u, c, f, g);
      for (var _ in i) {
        var b = i[_];
        if (Array.isArray(b)) {
          if (_ in t.arrayKeywords)
            for (var p = 0; p < b.length; p++)
              e(n, s, o, b[p], a + "/" + _ + "/" + p, l, a, _, i, p);
        } else if (_ in t.propsKeywords) {
          if (b && typeof b == "object")
            for (var h in b)
              e(n, s, o, b[h], a + "/" + _ + "/" + r(h), l, a, _, i, h);
        } else (_ in t.keywords || n.allKeys && !(_ in t.skipKeywords)) && e(n, s, o, b, a + "/" + _, l, a, _, i);
      }
      o(i, a, l, u, c, f, g);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return sc.exports;
}
var Yp;
function gu() {
  if (Yp) return Lt;
  Yp = 1, Object.defineProperty(Lt, "__esModule", { value: !0 }), Lt.getSchemaRefs = Lt.resolveUrl = Lt.normalizeId = Lt._getFullPath = Lt.getFullPath = Lt.inlineRef = void 0;
  const t = et(), e = pw(), r = HT(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function s(p, h = !0) {
    return typeof p == "boolean" ? !0 : h === !0 ? !i(p) : h ? a(p) <= h : !1;
  }
  Lt.inlineRef = s;
  const o = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function i(p) {
    for (const h in p) {
      if (o.has(h))
        return !0;
      const y = p[h];
      if (Array.isArray(y) && y.some(i) || typeof y == "object" && i(y))
        return !0;
    }
    return !1;
  }
  function a(p) {
    let h = 0;
    for (const y in p) {
      if (y === "$ref")
        return 1 / 0;
      if (h++, !n.has(y) && (typeof p[y] == "object" && (0, t.eachItem)(p[y], (S) => h += a(S)), h === 1 / 0))
        return 1 / 0;
    }
    return h;
  }
  function l(p, h = "", y) {
    y !== !1 && (h = f(h));
    const S = p.parse(h);
    return u(p, S);
  }
  Lt.getFullPath = l;
  function u(p, h) {
    return p.serialize(h).split("#")[0] + "#";
  }
  Lt._getFullPath = u;
  const c = /#\/?$/;
  function f(p) {
    return p ? p.replace(c, "") : "";
  }
  Lt.normalizeId = f;
  function g(p, h, y) {
    return y = f(y), p.resolve(h, y);
  }
  Lt.resolveUrl = g;
  const _ = /^[a-z_][-a-z0-9._]*$/i;
  function b(p, h) {
    if (typeof p == "boolean")
      return {};
    const { schemaId: y, uriResolver: S } = this.opts, x = f(p[y] || h), P = { "": x }, w = l(S, x, !1), C = {}, k = /* @__PURE__ */ new Set();
    return r(p, { allKeys: !0 }, (E, I, F, U) => {
      if (U === void 0)
        return;
      const B = w + I;
      let R = P[U];
      typeof E[y] == "string" && (R = Z.call(this, E[y])), Y.call(this, E.$anchor), Y.call(this, E.$dynamicAnchor), P[I] = R;
      function Z(X) {
        const ae = this.opts.uriResolver.resolve;
        if (X = f(R ? ae(R, X) : X), k.has(X))
          throw T(X);
        k.add(X);
        let J = this.refs[X];
        return typeof J == "string" && (J = this.refs[J]), typeof J == "object" ? $(E, J.schema, X) : X !== f(B) && (X[0] === "#" ? ($(E, C[X], X), C[X] = E) : this.refs[X] = B), X;
      }
      function Y(X) {
        if (typeof X == "string") {
          if (!_.test(X))
            throw new Error(`invalid anchor "${X}"`);
          Z.call(this, `#${X}`);
        }
      }
    }), C;
    function $(E, I, F) {
      if (I !== void 0 && !e(E, I))
        throw T(F);
    }
    function T(E) {
      return new Error(`reference "${E}" resolves to more than one schema`);
    }
  }
  return Lt.getSchemaRefs = b, Lt;
}
var Xp;
function pu() {
  if (Xp) return hn;
  Xp = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.getData = hn.KeywordCxt = hn.validateFunctionCode = void 0;
  const t = qT(), e = Sl(), r = gw(), n = Sl(), s = UT(), o = KT(), i = WT(), a = He(), l = hs(), u = gu(), c = et(), f = hu();
  function g(re) {
    if (w(re) && (k(re), P(re))) {
      h(re);
      return;
    }
    _(re, () => (0, t.topBoolOrEmptySchema)(re));
  }
  hn.validateFunctionCode = g;
  function _({ gen: re, validateName: oe, schema: pe, schemaEnv: ye, opts: Pe }, Oe) {
    Pe.code.es5 ? re.func(oe, (0, a._)`${l.default.data}, ${l.default.valCxt}`, ye.$async, () => {
      re.code((0, a._)`"use strict"; ${S(pe, Pe)}`), p(re, Pe), re.code(Oe);
    }) : re.func(oe, (0, a._)`${l.default.data}, ${b(Pe)}`, ye.$async, () => re.code(S(pe, Pe)).code(Oe));
  }
  function b(re) {
    return (0, a._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${re.dynamicRef ? (0, a._)`, ${l.default.dynamicAnchors}={}` : a.nil}}={}`;
  }
  function p(re, oe) {
    re.if(l.default.valCxt, () => {
      re.var(l.default.instancePath, (0, a._)`${l.default.valCxt}.${l.default.instancePath}`), re.var(l.default.parentData, (0, a._)`${l.default.valCxt}.${l.default.parentData}`), re.var(l.default.parentDataProperty, (0, a._)`${l.default.valCxt}.${l.default.parentDataProperty}`), re.var(l.default.rootData, (0, a._)`${l.default.valCxt}.${l.default.rootData}`), oe.dynamicRef && re.var(l.default.dynamicAnchors, (0, a._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
    }, () => {
      re.var(l.default.instancePath, (0, a._)`""`), re.var(l.default.parentData, (0, a._)`undefined`), re.var(l.default.parentDataProperty, (0, a._)`undefined`), re.var(l.default.rootData, l.default.data), oe.dynamicRef && re.var(l.default.dynamicAnchors, (0, a._)`{}`);
    });
  }
  function h(re) {
    const { schema: oe, opts: pe, gen: ye } = re;
    _(re, () => {
      pe.$comment && oe.$comment && U(re), E(re), ye.let(l.default.vErrors, null), ye.let(l.default.errors, 0), pe.unevaluated && y(re), $(re), B(re);
    });
  }
  function y(re) {
    const { gen: oe, validateName: pe } = re;
    re.evaluated = oe.const("evaluated", (0, a._)`${pe}.evaluated`), oe.if((0, a._)`${re.evaluated}.dynamicProps`, () => oe.assign((0, a._)`${re.evaluated}.props`, (0, a._)`undefined`)), oe.if((0, a._)`${re.evaluated}.dynamicItems`, () => oe.assign((0, a._)`${re.evaluated}.items`, (0, a._)`undefined`));
  }
  function S(re, oe) {
    const pe = typeof re == "object" && re[oe.schemaId];
    return pe && (oe.code.source || oe.code.process) ? (0, a._)`/*# sourceURL=${pe} */` : a.nil;
  }
  function x(re, oe) {
    if (w(re) && (k(re), P(re))) {
      C(re, oe);
      return;
    }
    (0, t.boolOrEmptySchema)(re, oe);
  }
  function P({ schema: re, self: oe }) {
    if (typeof re == "boolean")
      return !re;
    for (const pe in re)
      if (oe.RULES.all[pe])
        return !0;
    return !1;
  }
  function w(re) {
    return typeof re.schema != "boolean";
  }
  function C(re, oe) {
    const { schema: pe, gen: ye, opts: Pe } = re;
    Pe.$comment && pe.$comment && U(re), I(re), F(re);
    const Oe = ye.const("_errs", l.default.errors);
    $(re, Oe), ye.var(oe, (0, a._)`${Oe} === ${l.default.errors}`);
  }
  function k(re) {
    (0, c.checkUnknownRules)(re), T(re);
  }
  function $(re, oe) {
    if (re.opts.jtd)
      return Z(re, [], !1, oe);
    const pe = (0, e.getSchemaTypes)(re.schema), ye = (0, e.coerceAndCheckDataType)(re, pe);
    Z(re, pe, !ye, oe);
  }
  function T(re) {
    const { schema: oe, errSchemaPath: pe, opts: ye, self: Pe } = re;
    oe.$ref && ye.ignoreKeywordsWithRef && (0, c.schemaHasRulesButRef)(oe, Pe.RULES) && Pe.logger.warn(`$ref: keywords ignored in schema at path "${pe}"`);
  }
  function E(re) {
    const { schema: oe, opts: pe } = re;
    oe.default !== void 0 && pe.useDefaults && pe.strictSchema && (0, c.checkStrictMode)(re, "default is ignored in the schema root");
  }
  function I(re) {
    const oe = re.schema[re.opts.schemaId];
    oe && (re.baseId = (0, u.resolveUrl)(re.opts.uriResolver, re.baseId, oe));
  }
  function F(re) {
    if (re.schema.$async && !re.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function U({ gen: re, schemaEnv: oe, schema: pe, errSchemaPath: ye, opts: Pe }) {
    const Oe = pe.$comment;
    if (Pe.$comment === !0)
      re.code((0, a._)`${l.default.self}.logger.log(${Oe})`);
    else if (typeof Pe.$comment == "function") {
      const Ve = (0, a.str)`${ye}/$comment`, Ke = re.scopeValue("root", { ref: oe.root });
      re.code((0, a._)`${l.default.self}.opts.$comment(${Oe}, ${Ve}, ${Ke}.schema)`);
    }
  }
  function B(re) {
    const { gen: oe, schemaEnv: pe, validateName: ye, ValidationError: Pe, opts: Oe } = re;
    pe.$async ? oe.if((0, a._)`${l.default.errors} === 0`, () => oe.return(l.default.data), () => oe.throw((0, a._)`new ${Pe}(${l.default.vErrors})`)) : (oe.assign((0, a._)`${ye}.errors`, l.default.vErrors), Oe.unevaluated && R(re), oe.return((0, a._)`${l.default.errors} === 0`));
  }
  function R({ gen: re, evaluated: oe, props: pe, items: ye }) {
    pe instanceof a.Name && re.assign((0, a._)`${oe}.props`, pe), ye instanceof a.Name && re.assign((0, a._)`${oe}.items`, ye);
  }
  function Z(re, oe, pe, ye) {
    const { gen: Pe, schema: Oe, data: Ve, allErrors: Ke, opts: Le, self: je } = re, { RULES: We } = je;
    if (Oe.$ref && (Le.ignoreKeywordsWithRef || !(0, c.schemaHasRulesButRef)(Oe, We))) {
      Pe.block(() => fe(re, "$ref", We.all.$ref.definition));
      return;
    }
    Le.jtd || X(re, oe), Pe.block(() => {
      for (const Ze of We.rules)
        gt(Ze);
      gt(We.post);
    });
    function gt(Ze) {
      (0, r.shouldUseGroup)(Oe, Ze) && (Ze.type ? (Pe.if((0, n.checkDataType)(Ze.type, Ve, Le.strictNumbers)), Y(re, Ze), oe.length === 1 && oe[0] === Ze.type && pe && (Pe.else(), (0, n.reportTypeError)(re)), Pe.endIf()) : Y(re, Ze), Ke || Pe.if((0, a._)`${l.default.errors} === ${ye || 0}`));
    }
  }
  function Y(re, oe) {
    const { gen: pe, schema: ye, opts: { useDefaults: Pe } } = re;
    Pe && (0, s.assignDefaults)(re, oe.type), pe.block(() => {
      for (const Oe of oe.rules)
        (0, r.shouldUseRule)(ye, Oe) && fe(re, Oe.keyword, Oe.definition, oe.type);
    });
  }
  function X(re, oe) {
    re.schemaEnv.meta || !re.opts.strictTypes || (ae(re, oe), re.opts.allowUnionTypes || J(re, oe), j(re, re.dataTypes));
  }
  function ae(re, oe) {
    if (oe.length) {
      if (!re.dataTypes.length) {
        re.dataTypes = oe;
        return;
      }
      oe.forEach((pe) => {
        L(re.dataTypes, pe) || V(re, `type "${pe}" not allowed by context "${re.dataTypes.join(",")}"`);
      }), N(re, oe);
    }
  }
  function J(re, oe) {
    oe.length > 1 && !(oe.length === 2 && oe.includes("null")) && V(re, "use allowUnionTypes to allow union type keyword");
  }
  function j(re, oe) {
    const pe = re.self.RULES.all;
    for (const ye in pe) {
      const Pe = pe[ye];
      if (typeof Pe == "object" && (0, r.shouldUseRule)(re.schema, Pe)) {
        const { type: Oe } = Pe.definition;
        Oe.length && !Oe.some((Ve) => ee(oe, Ve)) && V(re, `missing type "${Oe.join(",")}" for keyword "${ye}"`);
      }
    }
  }
  function ee(re, oe) {
    return re.includes(oe) || oe === "number" && re.includes("integer");
  }
  function L(re, oe) {
    return re.includes(oe) || oe === "integer" && re.includes("number");
  }
  function N(re, oe) {
    const pe = [];
    for (const ye of re.dataTypes)
      L(oe, ye) ? pe.push(ye) : oe.includes("integer") && ye === "number" && pe.push("integer");
    re.dataTypes = pe;
  }
  function V(re, oe) {
    const pe = re.schemaEnv.baseId + re.errSchemaPath;
    oe += ` at "${pe}" (strictTypes)`, (0, c.checkStrictMode)(re, oe, re.opts.strictTypes);
  }
  class G {
    constructor(oe, pe, ye) {
      if ((0, o.validateKeywordUsage)(oe, pe, ye), this.gen = oe.gen, this.allErrors = oe.allErrors, this.keyword = ye, this.data = oe.data, this.schema = oe.schema[ye], this.$data = pe.$data && oe.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, c.schemaRefOrVal)(oe, this.schema, ye, this.$data), this.schemaType = pe.schemaType, this.parentSchema = oe.schema, this.params = {}, this.it = oe, this.def = pe, this.$data)
        this.schemaCode = oe.gen.const("vSchema", le(this.$data, oe));
      else if (this.schemaCode = this.schemaValue, !(0, o.validSchemaType)(this.schema, pe.schemaType, pe.allowUndefined))
        throw new Error(`${ye} value must be ${JSON.stringify(pe.schemaType)}`);
      ("code" in pe ? pe.trackErrors : pe.errors !== !1) && (this.errsCount = oe.gen.const("_errs", l.default.errors));
    }
    result(oe, pe, ye) {
      this.failResult((0, a.not)(oe), pe, ye);
    }
    failResult(oe, pe, ye) {
      this.gen.if(oe), ye ? ye() : this.error(), pe ? (this.gen.else(), pe(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(oe, pe) {
      this.failResult((0, a.not)(oe), void 0, pe);
    }
    fail(oe) {
      if (oe === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(oe), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(oe) {
      if (!this.$data)
        return this.fail(oe);
      const { schemaCode: pe } = this;
      this.fail((0, a._)`${pe} !== undefined && (${(0, a.or)(this.invalid$data(), oe)})`);
    }
    error(oe, pe, ye) {
      if (pe) {
        this.setParams(pe), this._error(oe, ye), this.setParams({});
        return;
      }
      this._error(oe, ye);
    }
    _error(oe, pe) {
      (oe ? f.reportExtraError : f.reportError)(this, this.def.error, pe);
    }
    $dataError() {
      (0, f.reportError)(this, this.def.$dataError || f.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, f.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(oe) {
      this.allErrors || this.gen.if(oe);
    }
    setParams(oe, pe) {
      pe ? Object.assign(this.params, oe) : this.params = oe;
    }
    block$data(oe, pe, ye = a.nil) {
      this.gen.block(() => {
        this.check$data(oe, ye), pe();
      });
    }
    check$data(oe = a.nil, pe = a.nil) {
      if (!this.$data)
        return;
      const { gen: ye, schemaCode: Pe, schemaType: Oe, def: Ve } = this;
      ye.if((0, a.or)((0, a._)`${Pe} === undefined`, pe)), oe !== a.nil && ye.assign(oe, !0), (Oe.length || Ve.validateSchema) && (ye.elseIf(this.invalid$data()), this.$dataError(), oe !== a.nil && ye.assign(oe, !1)), ye.else();
    }
    invalid$data() {
      const { gen: oe, schemaCode: pe, schemaType: ye, def: Pe, it: Oe } = this;
      return (0, a.or)(Ve(), Ke());
      function Ve() {
        if (ye.length) {
          if (!(pe instanceof a.Name))
            throw new Error("ajv implementation error");
          const Le = Array.isArray(ye) ? ye : [ye];
          return (0, a._)`${(0, n.checkDataTypes)(Le, pe, Oe.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return a.nil;
      }
      function Ke() {
        if (Pe.validateSchema) {
          const Le = oe.scopeValue("validate$data", { ref: Pe.validateSchema });
          return (0, a._)`!${Le}(${pe})`;
        }
        return a.nil;
      }
    }
    subschema(oe, pe) {
      const ye = (0, i.getSubschema)(this.it, oe);
      (0, i.extendSubschemaData)(ye, this.it, oe), (0, i.extendSubschemaMode)(ye, oe);
      const Pe = { ...this.it, ...ye, items: void 0, props: void 0 };
      return x(Pe, pe), Pe;
    }
    mergeEvaluated(oe, pe) {
      const { it: ye, gen: Pe } = this;
      ye.opts.unevaluated && (ye.props !== !0 && oe.props !== void 0 && (ye.props = c.mergeEvaluated.props(Pe, oe.props, ye.props, pe)), ye.items !== !0 && oe.items !== void 0 && (ye.items = c.mergeEvaluated.items(Pe, oe.items, ye.items, pe)));
    }
    mergeValidEvaluated(oe, pe) {
      const { it: ye, gen: Pe } = this;
      if (ye.opts.unevaluated && (ye.props !== !0 || ye.items !== !0))
        return Pe.if(pe, () => this.mergeEvaluated(oe, a.Name)), !0;
    }
  }
  hn.KeywordCxt = G;
  function fe(re, oe, pe, ye) {
    const Pe = new G(re, pe, oe);
    "code" in pe ? pe.code(Pe, ye) : Pe.$data && pe.validate ? (0, o.funcKeywordCode)(Pe, pe) : "macro" in pe ? (0, o.macroKeywordCode)(Pe, pe) : (pe.compile || pe.validate) && (0, o.funcKeywordCode)(Pe, pe);
  }
  const se = /^\/(?:[^~]|~0|~1)*$/, we = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function le(re, { dataLevel: oe, dataNames: pe, dataPathArr: ye }) {
    let Pe, Oe;
    if (re === "")
      return l.default.rootData;
    if (re[0] === "/") {
      if (!se.test(re))
        throw new Error(`Invalid JSON-pointer: ${re}`);
      Pe = re, Oe = l.default.rootData;
    } else {
      const je = we.exec(re);
      if (!je)
        throw new Error(`Invalid JSON-pointer: ${re}`);
      const We = +je[1];
      if (Pe = je[2], Pe === "#") {
        if (We >= oe)
          throw new Error(Le("property/index", We));
        return ye[oe - We];
      }
      if (We > oe)
        throw new Error(Le("data", We));
      if (Oe = pe[oe - We], !Pe)
        return Oe;
    }
    let Ve = Oe;
    const Ke = Pe.split("/");
    for (const je of Ke)
      je && (Oe = (0, a._)`${Oe}${(0, a.getProperty)((0, c.unescapeJsonPointer)(je))}`, Ve = (0, a._)`${Ve} && ${Oe}`);
    return Ve;
    function Le(je, We) {
      return `Cannot access ${je} ${We} levels up, current level is ${oe}`;
    }
  }
  return hn.getData = le, hn;
}
var ra = {}, Jp;
function Hh() {
  if (Jp) return ra;
  Jp = 1, Object.defineProperty(ra, "__esModule", { value: !0 });
  class t extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return ra.default = t, ra;
}
var na = {}, Zp;
function mu() {
  if (Zp) return na;
  Zp = 1, Object.defineProperty(na, "__esModule", { value: !0 });
  const t = gu();
  class e extends Error {
    constructor(n, s, o, i) {
      super(i || `can't resolve reference ${o} from id ${s}`), this.missingRef = (0, t.resolveUrl)(n, s, o), this.missingSchema = (0, t.normalizeId)((0, t.getFullPath)(n, this.missingRef));
    }
  }
  return na.default = e, na;
}
var ar = {}, Qp;
function Gh() {
  if (Qp) return ar;
  Qp = 1, Object.defineProperty(ar, "__esModule", { value: !0 }), ar.resolveSchema = ar.getCompilingSchema = ar.resolveRef = ar.compileSchema = ar.SchemaEnv = void 0;
  const t = He(), e = Hh(), r = hs(), n = gu(), s = et(), o = pu();
  class i {
    constructor(y) {
      var S;
      this.refs = {}, this.dynamicAnchors = {};
      let x;
      typeof y.schema == "object" && (x = y.schema), this.schema = y.schema, this.schemaId = y.schemaId, this.root = y.root || this, this.baseId = (S = y.baseId) !== null && S !== void 0 ? S : (0, n.normalizeId)(x?.[y.schemaId || "$id"]), this.schemaPath = y.schemaPath, this.localRefs = y.localRefs, this.meta = y.meta, this.$async = x?.$async, this.refs = {};
    }
  }
  ar.SchemaEnv = i;
  function a(h) {
    const y = c.call(this, h);
    if (y)
      return y;
    const S = (0, n.getFullPath)(this.opts.uriResolver, h.root.baseId), { es5: x, lines: P } = this.opts.code, { ownProperties: w } = this.opts, C = new t.CodeGen(this.scope, { es5: x, lines: P, ownProperties: w });
    let k;
    h.$async && (k = C.scopeValue("Error", {
      ref: e.default,
      code: (0, t._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const $ = C.scopeName("validate");
    h.validateName = $;
    const T = {
      gen: C,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [t.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: C.scopeValue("schema", this.opts.code.source === !0 ? { ref: h.schema, code: (0, t.stringify)(h.schema) } : { ref: h.schema }),
      validateName: $,
      ValidationError: k,
      schema: h.schema,
      schemaEnv: h,
      rootId: S,
      baseId: h.baseId || S,
      schemaPath: t.nil,
      errSchemaPath: h.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, t._)`""`,
      opts: this.opts,
      self: this
    };
    let E;
    try {
      this._compilations.add(h), (0, o.validateFunctionCode)(T), C.optimize(this.opts.code.optimize);
      const I = C.toString();
      E = `${C.scopeRefs(r.default.scope)}return ${I}`, this.opts.code.process && (E = this.opts.code.process(E, h));
      const U = new Function(`${r.default.self}`, `${r.default.scope}`, E)(this, this.scope.get());
      if (this.scope.value($, { ref: U }), U.errors = null, U.schema = h.schema, U.schemaEnv = h, h.$async && (U.$async = !0), this.opts.code.source === !0 && (U.source = { validateName: $, validateCode: I, scopeValues: C._values }), this.opts.unevaluated) {
        const { props: B, items: R } = T;
        U.evaluated = {
          props: B instanceof t.Name ? void 0 : B,
          items: R instanceof t.Name ? void 0 : R,
          dynamicProps: B instanceof t.Name,
          dynamicItems: R instanceof t.Name
        }, U.source && (U.source.evaluated = (0, t.stringify)(U.evaluated));
      }
      return h.validate = U, h;
    } catch (I) {
      throw delete h.validate, delete h.validateName, E && this.logger.error("Error compiling schema, function code:", E), I;
    } finally {
      this._compilations.delete(h);
    }
  }
  ar.compileSchema = a;
  function l(h, y, S) {
    var x;
    S = (0, n.resolveUrl)(this.opts.uriResolver, y, S);
    const P = h.refs[S];
    if (P)
      return P;
    let w = g.call(this, h, S);
    if (w === void 0) {
      const C = (x = h.localRefs) === null || x === void 0 ? void 0 : x[S], { schemaId: k } = this.opts;
      C && (w = new i({ schema: C, schemaId: k, root: h, baseId: y }));
    }
    if (w !== void 0)
      return h.refs[S] = u.call(this, w);
  }
  ar.resolveRef = l;
  function u(h) {
    return (0, n.inlineRef)(h.schema, this.opts.inlineRefs) ? h.schema : h.validate ? h : a.call(this, h);
  }
  function c(h) {
    for (const y of this._compilations)
      if (f(y, h))
        return y;
  }
  ar.getCompilingSchema = c;
  function f(h, y) {
    return h.schema === y.schema && h.root === y.root && h.baseId === y.baseId;
  }
  function g(h, y) {
    let S;
    for (; typeof (S = this.refs[y]) == "string"; )
      y = S;
    return S || this.schemas[y] || _.call(this, h, y);
  }
  function _(h, y) {
    const S = this.opts.uriResolver.parse(y), x = (0, n._getFullPath)(this.opts.uriResolver, S);
    let P = (0, n.getFullPath)(this.opts.uriResolver, h.baseId, void 0);
    if (Object.keys(h.schema).length > 0 && x === P)
      return p.call(this, S, h);
    const w = (0, n.normalizeId)(x), C = this.refs[w] || this.schemas[w];
    if (typeof C == "string") {
      const k = _.call(this, h, C);
      return typeof k?.schema != "object" ? void 0 : p.call(this, S, k);
    }
    if (typeof C?.schema == "object") {
      if (C.validate || a.call(this, C), w === (0, n.normalizeId)(y)) {
        const { schema: k } = C, { schemaId: $ } = this.opts, T = k[$];
        return T && (P = (0, n.resolveUrl)(this.opts.uriResolver, P, T)), new i({ schema: k, schemaId: $, root: h, baseId: P });
      }
      return p.call(this, S, C);
    }
  }
  ar.resolveSchema = _;
  const b = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function p(h, { baseId: y, schema: S, root: x }) {
    var P;
    if (((P = h.fragment) === null || P === void 0 ? void 0 : P[0]) !== "/")
      return;
    for (const k of h.fragment.slice(1).split("/")) {
      if (typeof S == "boolean")
        return;
      const $ = S[(0, s.unescapeFragment)(k)];
      if ($ === void 0)
        return;
      S = $;
      const T = typeof S == "object" && S[this.opts.schemaId];
      !b.has(k) && T && (y = (0, n.resolveUrl)(this.opts.uriResolver, y, T));
    }
    let w;
    if (typeof S != "boolean" && S.$ref && !(0, s.schemaHasRulesButRef)(S, this.RULES)) {
      const k = (0, n.resolveUrl)(this.opts.uriResolver, y, S.$ref);
      w = _.call(this, x, k);
    }
    const { schemaId: C } = this.opts;
    if (w = w || new i({ schema: S, schemaId: C, root: x, baseId: y }), w.schema !== w.root.schema)
      return w;
  }
  return ar;
}
const GT = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", YT = "Meta-schema for $data reference (JSON AnySchema extension proposal)", XT = "object", JT = ["$data"], ZT = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, QT = !1, eD = {
  $id: GT,
  description: YT,
  type: XT,
  required: JT,
  properties: ZT,
  additionalProperties: QT
};
var sa = {}, ei = { exports: {} }, oc, em;
function mw() {
  if (em) return oc;
  em = 1;
  const t = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), e = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function r(g) {
    let _ = "", b = 0, p = 0;
    for (p = 0; p < g.length; p++)
      if (b = g[p].charCodeAt(0), b !== 48) {
        if (!(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
          return "";
        _ += g[p];
        break;
      }
    for (p += 1; p < g.length; p++) {
      if (b = g[p].charCodeAt(0), !(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
        return "";
      _ += g[p];
    }
    return _;
  }
  const n = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function s(g) {
    return g.length = 0, !0;
  }
  function o(g, _, b) {
    if (g.length) {
      const p = r(g);
      if (p !== "")
        _.push(p);
      else
        return b.error = !0, !1;
      g.length = 0;
    }
    return !0;
  }
  function i(g) {
    let _ = 0;
    const b = { error: !1, address: "", zone: "" }, p = [], h = [];
    let y = !1, S = !1, x = o;
    for (let P = 0; P < g.length; P++) {
      const w = g[P];
      if (!(w === "[" || w === "]"))
        if (w === ":") {
          if (y === !0 && (S = !0), !x(h, p, b))
            break;
          if (++_ > 7) {
            b.error = !0;
            break;
          }
          P > 0 && g[P - 1] === ":" && (y = !0), p.push(":");
          continue;
        } else if (w === "%") {
          if (!x(h, p, b))
            break;
          x = s;
        } else {
          h.push(w);
          continue;
        }
    }
    return h.length && (x === s ? b.zone = h.join("") : S ? p.push(h.join("")) : p.push(r(h))), b.address = p.join(""), b;
  }
  function a(g) {
    if (l(g, ":") < 2)
      return { host: g, isIPV6: !1 };
    const _ = i(g);
    if (_.error)
      return { host: g, isIPV6: !1 };
    {
      let b = _.address, p = _.address;
      return _.zone && (b += "%" + _.zone, p += "%25" + _.zone), { host: b, isIPV6: !0, escapedHost: p };
    }
  }
  function l(g, _) {
    let b = 0;
    for (let p = 0; p < g.length; p++)
      g[p] === _ && b++;
    return b;
  }
  function u(g) {
    let _ = g;
    const b = [];
    let p = -1, h = 0;
    for (; h = _.length; ) {
      if (h === 1) {
        if (_ === ".")
          break;
        if (_ === "/") {
          b.push("/");
          break;
        } else {
          b.push(_);
          break;
        }
      } else if (h === 2) {
        if (_[0] === ".") {
          if (_[1] === ".")
            break;
          if (_[1] === "/") {
            _ = _.slice(2);
            continue;
          }
        } else if (_[0] === "/" && (_[1] === "." || _[1] === "/")) {
          b.push("/");
          break;
        }
      } else if (h === 3 && _ === "/..") {
        b.length !== 0 && b.pop(), b.push("/");
        break;
      }
      if (_[0] === ".") {
        if (_[1] === ".") {
          if (_[2] === "/") {
            _ = _.slice(3);
            continue;
          }
        } else if (_[1] === "/") {
          _ = _.slice(2);
          continue;
        }
      } else if (_[0] === "/" && _[1] === ".") {
        if (_[2] === "/") {
          _ = _.slice(2);
          continue;
        } else if (_[2] === "." && _[3] === "/") {
          _ = _.slice(3), b.length !== 0 && b.pop();
          continue;
        }
      }
      if ((p = _.indexOf("/", 1)) === -1) {
        b.push(_);
        break;
      } else
        b.push(_.slice(0, p)), _ = _.slice(p);
    }
    return b.join("");
  }
  function c(g, _) {
    const b = _ !== !0 ? escape : unescape;
    return g.scheme !== void 0 && (g.scheme = b(g.scheme)), g.userinfo !== void 0 && (g.userinfo = b(g.userinfo)), g.host !== void 0 && (g.host = b(g.host)), g.path !== void 0 && (g.path = b(g.path)), g.query !== void 0 && (g.query = b(g.query)), g.fragment !== void 0 && (g.fragment = b(g.fragment)), g;
  }
  function f(g) {
    const _ = [];
    if (g.userinfo !== void 0 && (_.push(g.userinfo), _.push("@")), g.host !== void 0) {
      let b = unescape(g.host);
      if (!e(b)) {
        const p = a(b);
        p.isIPV6 === !0 ? b = `[${p.escapedHost}]` : b = g.host;
      }
      _.push(b);
    }
    return (typeof g.port == "number" || typeof g.port == "string") && (_.push(":"), _.push(String(g.port))), _.length ? _.join("") : void 0;
  }
  return oc = {
    nonSimpleDomain: n,
    recomposeAuthority: f,
    normalizeComponentEncoding: c,
    removeDotSegments: u,
    isIPv4: e,
    isUUID: t,
    normalizeIPv6: a,
    stringArrayToHexStripped: r
  }, oc;
}
var ic, tm;
function tD() {
  if (tm) return ic;
  tm = 1;
  const { isUUID: t } = mw(), e = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, r = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function n(w) {
    return r.indexOf(
      /** @type {*} */
      w
    ) !== -1;
  }
  function s(w) {
    return w.secure === !0 ? !0 : w.secure === !1 ? !1 : w.scheme ? w.scheme.length === 3 && (w.scheme[0] === "w" || w.scheme[0] === "W") && (w.scheme[1] === "s" || w.scheme[1] === "S") && (w.scheme[2] === "s" || w.scheme[2] === "S") : !1;
  }
  function o(w) {
    return w.host || (w.error = w.error || "HTTP URIs must have a host."), w;
  }
  function i(w) {
    const C = String(w.scheme).toLowerCase() === "https";
    return (w.port === (C ? 443 : 80) || w.port === "") && (w.port = void 0), w.path || (w.path = "/"), w;
  }
  function a(w) {
    return w.secure = s(w), w.resourceName = (w.path || "/") + (w.query ? "?" + w.query : ""), w.path = void 0, w.query = void 0, w;
  }
  function l(w) {
    if ((w.port === (s(w) ? 443 : 80) || w.port === "") && (w.port = void 0), typeof w.secure == "boolean" && (w.scheme = w.secure ? "wss" : "ws", w.secure = void 0), w.resourceName) {
      const [C, k] = w.resourceName.split("?");
      w.path = C && C !== "/" ? C : void 0, w.query = k, w.resourceName = void 0;
    }
    return w.fragment = void 0, w;
  }
  function u(w, C) {
    if (!w.path)
      return w.error = "URN can not be parsed", w;
    const k = w.path.match(e);
    if (k) {
      const $ = C.scheme || w.scheme || "urn";
      w.nid = k[1].toLowerCase(), w.nss = k[2];
      const T = `${$}:${C.nid || w.nid}`, E = P(T);
      w.path = void 0, E && (w = E.parse(w, C));
    } else
      w.error = w.error || "URN can not be parsed.";
    return w;
  }
  function c(w, C) {
    if (w.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const k = C.scheme || w.scheme || "urn", $ = w.nid.toLowerCase(), T = `${k}:${C.nid || $}`, E = P(T);
    E && (w = E.serialize(w, C));
    const I = w, F = w.nss;
    return I.path = `${$ || C.nid}:${F}`, C.skipEscape = !0, I;
  }
  function f(w, C) {
    const k = w;
    return k.uuid = k.nss, k.nss = void 0, !C.tolerant && (!k.uuid || !t(k.uuid)) && (k.error = k.error || "UUID is not valid."), k;
  }
  function g(w) {
    const C = w;
    return C.nss = (w.uuid || "").toLowerCase(), C;
  }
  const _ = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: o,
      serialize: i
    }
  ), b = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: _.domainHost,
      parse: o,
      serialize: i
    }
  ), p = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: a,
      serialize: l
    }
  ), h = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: p.domainHost,
      parse: p.parse,
      serialize: p.serialize
    }
  ), x = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: _,
      https: b,
      ws: p,
      wss: h,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: u,
          serialize: c,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: f,
          serialize: g,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(x, null);
  function P(w) {
    return w && (x[
      /** @type {SchemeName} */
      w
    ] || x[
      /** @type {SchemeName} */
      w.toLowerCase()
    ]) || void 0;
  }
  return ic = {
    wsIsSecure: s,
    SCHEMES: x,
    isValidSchemeName: n,
    getSchemeHandler: P
  }, ic;
}
var rm;
function rD() {
  if (rm) return ei.exports;
  rm = 1;
  const { normalizeIPv6: t, removeDotSegments: e, recomposeAuthority: r, normalizeComponentEncoding: n, isIPv4: s, nonSimpleDomain: o } = mw(), { SCHEMES: i, getSchemeHandler: a } = tD();
  function l(h, y) {
    return typeof h == "string" ? h = /** @type {T} */
    g(b(h, y), y) : typeof h == "object" && (h = /** @type {T} */
    b(g(h, y), y)), h;
  }
  function u(h, y, S) {
    const x = S ? Object.assign({ scheme: "null" }, S) : { scheme: "null" }, P = c(b(h, x), b(y, x), x, !0);
    return x.skipEscape = !0, g(P, x);
  }
  function c(h, y, S, x) {
    const P = {};
    return x || (h = b(g(h, S), S), y = b(g(y, S), S)), S = S || {}, !S.tolerant && y.scheme ? (P.scheme = y.scheme, P.userinfo = y.userinfo, P.host = y.host, P.port = y.port, P.path = e(y.path || ""), P.query = y.query) : (y.userinfo !== void 0 || y.host !== void 0 || y.port !== void 0 ? (P.userinfo = y.userinfo, P.host = y.host, P.port = y.port, P.path = e(y.path || ""), P.query = y.query) : (y.path ? (y.path[0] === "/" ? P.path = e(y.path) : ((h.userinfo !== void 0 || h.host !== void 0 || h.port !== void 0) && !h.path ? P.path = "/" + y.path : h.path ? P.path = h.path.slice(0, h.path.lastIndexOf("/") + 1) + y.path : P.path = y.path, P.path = e(P.path)), P.query = y.query) : (P.path = h.path, y.query !== void 0 ? P.query = y.query : P.query = h.query), P.userinfo = h.userinfo, P.host = h.host, P.port = h.port), P.scheme = h.scheme), P.fragment = y.fragment, P;
  }
  function f(h, y, S) {
    return typeof h == "string" ? (h = unescape(h), h = g(n(b(h, S), !0), { ...S, skipEscape: !0 })) : typeof h == "object" && (h = g(n(h, !0), { ...S, skipEscape: !0 })), typeof y == "string" ? (y = unescape(y), y = g(n(b(y, S), !0), { ...S, skipEscape: !0 })) : typeof y == "object" && (y = g(n(y, !0), { ...S, skipEscape: !0 })), h.toLowerCase() === y.toLowerCase();
  }
  function g(h, y) {
    const S = {
      host: h.host,
      scheme: h.scheme,
      userinfo: h.userinfo,
      port: h.port,
      path: h.path,
      query: h.query,
      nid: h.nid,
      nss: h.nss,
      uuid: h.uuid,
      fragment: h.fragment,
      reference: h.reference,
      resourceName: h.resourceName,
      secure: h.secure,
      error: ""
    }, x = Object.assign({}, y), P = [], w = a(x.scheme || S.scheme);
    w && w.serialize && w.serialize(S, x), S.path !== void 0 && (x.skipEscape ? S.path = unescape(S.path) : (S.path = escape(S.path), S.scheme !== void 0 && (S.path = S.path.split("%3A").join(":")))), x.reference !== "suffix" && S.scheme && P.push(S.scheme, ":");
    const C = r(S);
    if (C !== void 0 && (x.reference !== "suffix" && P.push("//"), P.push(C), S.path && S.path[0] !== "/" && P.push("/")), S.path !== void 0) {
      let k = S.path;
      !x.absolutePath && (!w || !w.absolutePath) && (k = e(k)), C === void 0 && k[0] === "/" && k[1] === "/" && (k = "/%2F" + k.slice(2)), P.push(k);
    }
    return S.query !== void 0 && P.push("?", S.query), S.fragment !== void 0 && P.push("#", S.fragment), P.join("");
  }
  const _ = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function b(h, y) {
    const S = Object.assign({}, y), x = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let P = !1;
    S.reference === "suffix" && (S.scheme ? h = S.scheme + ":" + h : h = "//" + h);
    const w = h.match(_);
    if (w) {
      if (x.scheme = w[1], x.userinfo = w[3], x.host = w[4], x.port = parseInt(w[5], 10), x.path = w[6] || "", x.query = w[7], x.fragment = w[8], isNaN(x.port) && (x.port = w[5]), x.host)
        if (s(x.host) === !1) {
          const $ = t(x.host);
          x.host = $.host.toLowerCase(), P = $.isIPV6;
        } else
          P = !0;
      x.scheme === void 0 && x.userinfo === void 0 && x.host === void 0 && x.port === void 0 && x.query === void 0 && !x.path ? x.reference = "same-document" : x.scheme === void 0 ? x.reference = "relative" : x.fragment === void 0 ? x.reference = "absolute" : x.reference = "uri", S.reference && S.reference !== "suffix" && S.reference !== x.reference && (x.error = x.error || "URI is not a " + S.reference + " reference.");
      const C = a(S.scheme || x.scheme);
      if (!S.unicodeSupport && (!C || !C.unicodeSupport) && x.host && (S.domainHost || C && C.domainHost) && P === !1 && o(x.host))
        try {
          x.host = URL.domainToASCII(x.host.toLowerCase());
        } catch (k) {
          x.error = x.error || "Host's domain name can not be converted to ASCII: " + k;
        }
      (!C || C && !C.skipNormalize) && (h.indexOf("%") !== -1 && (x.scheme !== void 0 && (x.scheme = unescape(x.scheme)), x.host !== void 0 && (x.host = unescape(x.host))), x.path && (x.path = escape(unescape(x.path))), x.fragment && (x.fragment = encodeURI(decodeURIComponent(x.fragment)))), C && C.parse && C.parse(x, S);
    } else
      x.error = x.error || "URI can not be parsed.";
    return x;
  }
  const p = {
    SCHEMES: i,
    normalize: l,
    resolve: u,
    resolveComponent: c,
    equal: f,
    serialize: g,
    parse: b
  };
  return ei.exports = p, ei.exports.default = p, ei.exports.fastUri = p, ei.exports;
}
var nm;
function nD() {
  if (nm) return sa;
  nm = 1, Object.defineProperty(sa, "__esModule", { value: !0 });
  const t = rD();
  return t.code = 'require("ajv/dist/runtime/uri").default', sa.default = t, sa;
}
var sm;
function sD() {
  return sm || (sm = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    var e = pu();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return e.KeywordCxt;
    } });
    var r = He();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = Hh(), s = mu(), o = hw(), i = Gh(), a = He(), l = gu(), u = Sl(), c = et(), f = eD, g = nD(), _ = (J, j) => new RegExp(J, j);
    _.code = "new RegExp";
    const b = ["removeAdditional", "useDefaults", "coerceTypes"], p = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), h = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, y = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, S = 200;
    function x(J) {
      var j, ee, L, N, V, G, fe, se, we, le, re, oe, pe, ye, Pe, Oe, Ve, Ke, Le, je, We, gt, Ze, $t, lt;
      const ct = J.strict, pt = (j = J.code) === null || j === void 0 ? void 0 : j.optimize, Kt = pt === !0 || pt === void 0 ? 1 : pt || 0, vt = (L = (ee = J.code) === null || ee === void 0 ? void 0 : ee.regExp) !== null && L !== void 0 ? L : _, Vt = (N = J.uriResolver) !== null && N !== void 0 ? N : g.default;
      return {
        strictSchema: (G = (V = J.strictSchema) !== null && V !== void 0 ? V : ct) !== null && G !== void 0 ? G : !0,
        strictNumbers: (se = (fe = J.strictNumbers) !== null && fe !== void 0 ? fe : ct) !== null && se !== void 0 ? se : !0,
        strictTypes: (le = (we = J.strictTypes) !== null && we !== void 0 ? we : ct) !== null && le !== void 0 ? le : "log",
        strictTuples: (oe = (re = J.strictTuples) !== null && re !== void 0 ? re : ct) !== null && oe !== void 0 ? oe : "log",
        strictRequired: (ye = (pe = J.strictRequired) !== null && pe !== void 0 ? pe : ct) !== null && ye !== void 0 ? ye : !1,
        code: J.code ? { ...J.code, optimize: Kt, regExp: vt } : { optimize: Kt, regExp: vt },
        loopRequired: (Pe = J.loopRequired) !== null && Pe !== void 0 ? Pe : S,
        loopEnum: (Oe = J.loopEnum) !== null && Oe !== void 0 ? Oe : S,
        meta: (Ve = J.meta) !== null && Ve !== void 0 ? Ve : !0,
        messages: (Ke = J.messages) !== null && Ke !== void 0 ? Ke : !0,
        inlineRefs: (Le = J.inlineRefs) !== null && Le !== void 0 ? Le : !0,
        schemaId: (je = J.schemaId) !== null && je !== void 0 ? je : "$id",
        addUsedSchema: (We = J.addUsedSchema) !== null && We !== void 0 ? We : !0,
        validateSchema: (gt = J.validateSchema) !== null && gt !== void 0 ? gt : !0,
        validateFormats: (Ze = J.validateFormats) !== null && Ze !== void 0 ? Ze : !0,
        unicodeRegExp: ($t = J.unicodeRegExp) !== null && $t !== void 0 ? $t : !0,
        int32range: (lt = J.int32range) !== null && lt !== void 0 ? lt : !0,
        uriResolver: Vt
      };
    }
    class P {
      constructor(j = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), j = this.opts = { ...j, ...x(j) };
        const { es5: ee, lines: L } = this.opts.code;
        this.scope = new a.ValueScope({ scope: {}, prefixes: p, es5: ee, lines: L }), this.logger = F(j.logger);
        const N = j.validateFormats;
        j.validateFormats = !1, this.RULES = (0, o.getRules)(), w.call(this, h, j, "NOT SUPPORTED"), w.call(this, y, j, "DEPRECATED", "warn"), this._metaOpts = E.call(this), j.formats && $.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), j.keywords && T.call(this, j.keywords), typeof j.meta == "object" && this.addMetaSchema(j.meta), k.call(this), j.validateFormats = N;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: j, meta: ee, schemaId: L } = this.opts;
        let N = f;
        L === "id" && (N = { ...f }, N.id = N.$id, delete N.$id), ee && j && this.addMetaSchema(N, N[L], !1);
      }
      defaultMeta() {
        const { meta: j, schemaId: ee } = this.opts;
        return this.opts.defaultMeta = typeof j == "object" ? j[ee] || j : void 0;
      }
      validate(j, ee) {
        let L;
        if (typeof j == "string") {
          if (L = this.getSchema(j), !L)
            throw new Error(`no schema with key or ref "${j}"`);
        } else
          L = this.compile(j);
        const N = L(ee);
        return "$async" in L || (this.errors = L.errors), N;
      }
      compile(j, ee) {
        const L = this._addSchema(j, ee);
        return L.validate || this._compileSchemaEnv(L);
      }
      compileAsync(j, ee) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: L } = this.opts;
        return N.call(this, j, ee);
        async function N(le, re) {
          await V.call(this, le.$schema);
          const oe = this._addSchema(le, re);
          return oe.validate || G.call(this, oe);
        }
        async function V(le) {
          le && !this.getSchema(le) && await N.call(this, { $ref: le }, !0);
        }
        async function G(le) {
          try {
            return this._compileSchemaEnv(le);
          } catch (re) {
            if (!(re instanceof s.default))
              throw re;
            return fe.call(this, re), await se.call(this, re.missingSchema), G.call(this, le);
          }
        }
        function fe({ missingSchema: le, missingRef: re }) {
          if (this.refs[le])
            throw new Error(`AnySchema ${le} is loaded but ${re} cannot be resolved`);
        }
        async function se(le) {
          const re = await we.call(this, le);
          this.refs[le] || await V.call(this, re.$schema), this.refs[le] || this.addSchema(re, le, ee);
        }
        async function we(le) {
          const re = this._loading[le];
          if (re)
            return re;
          try {
            return await (this._loading[le] = L(le));
          } finally {
            delete this._loading[le];
          }
        }
      }
      // Adds schema to the instance
      addSchema(j, ee, L, N = this.opts.validateSchema) {
        if (Array.isArray(j)) {
          for (const G of j)
            this.addSchema(G, void 0, L, N);
          return this;
        }
        let V;
        if (typeof j == "object") {
          const { schemaId: G } = this.opts;
          if (V = j[G], V !== void 0 && typeof V != "string")
            throw new Error(`schema ${G} must be string`);
        }
        return ee = (0, l.normalizeId)(ee || V), this._checkUnique(ee), this.schemas[ee] = this._addSchema(j, L, ee, N, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(j, ee, L = this.opts.validateSchema) {
        return this.addSchema(j, ee, !0, L), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(j, ee) {
        if (typeof j == "boolean")
          return !0;
        let L;
        if (L = j.$schema, L !== void 0 && typeof L != "string")
          throw new Error("$schema must be a string");
        if (L = L || this.opts.defaultMeta || this.defaultMeta(), !L)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const N = this.validate(L, j);
        if (!N && ee) {
          const V = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(V);
          else
            throw new Error(V);
        }
        return N;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(j) {
        let ee;
        for (; typeof (ee = C.call(this, j)) == "string"; )
          j = ee;
        if (ee === void 0) {
          const { schemaId: L } = this.opts, N = new i.SchemaEnv({ schema: {}, schemaId: L });
          if (ee = i.resolveSchema.call(this, N, j), !ee)
            return;
          this.refs[j] = ee;
        }
        return ee.validate || this._compileSchemaEnv(ee);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(j) {
        if (j instanceof RegExp)
          return this._removeAllSchemas(this.schemas, j), this._removeAllSchemas(this.refs, j), this;
        switch (typeof j) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const ee = C.call(this, j);
            return typeof ee == "object" && this._cache.delete(ee.schema), delete this.schemas[j], delete this.refs[j], this;
          }
          case "object": {
            const ee = j;
            this._cache.delete(ee);
            let L = j[this.opts.schemaId];
            return L && (L = (0, l.normalizeId)(L), delete this.schemas[L], delete this.refs[L]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(j) {
        for (const ee of j)
          this.addKeyword(ee);
        return this;
      }
      addKeyword(j, ee) {
        let L;
        if (typeof j == "string")
          L = j, typeof ee == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), ee.keyword = L);
        else if (typeof j == "object" && ee === void 0) {
          if (ee = j, L = ee.keyword, Array.isArray(L) && !L.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (B.call(this, L, ee), !ee)
          return (0, c.eachItem)(L, (V) => R.call(this, V)), this;
        Y.call(this, ee);
        const N = {
          ...ee,
          type: (0, u.getJSONTypes)(ee.type),
          schemaType: (0, u.getJSONTypes)(ee.schemaType)
        };
        return (0, c.eachItem)(L, N.type.length === 0 ? (V) => R.call(this, V, N) : (V) => N.type.forEach((G) => R.call(this, V, N, G))), this;
      }
      getKeyword(j) {
        const ee = this.RULES.all[j];
        return typeof ee == "object" ? ee.definition : !!ee;
      }
      // Remove keyword
      removeKeyword(j) {
        const { RULES: ee } = this;
        delete ee.keywords[j], delete ee.all[j];
        for (const L of ee.rules) {
          const N = L.rules.findIndex((V) => V.keyword === j);
          N >= 0 && L.rules.splice(N, 1);
        }
        return this;
      }
      // Add format
      addFormat(j, ee) {
        return typeof ee == "string" && (ee = new RegExp(ee)), this.formats[j] = ee, this;
      }
      errorsText(j = this.errors, { separator: ee = ", ", dataVar: L = "data" } = {}) {
        return !j || j.length === 0 ? "No errors" : j.map((N) => `${L}${N.instancePath} ${N.message}`).reduce((N, V) => N + ee + V);
      }
      $dataMetaSchema(j, ee) {
        const L = this.RULES.all;
        j = JSON.parse(JSON.stringify(j));
        for (const N of ee) {
          const V = N.split("/").slice(1);
          let G = j;
          for (const fe of V)
            G = G[fe];
          for (const fe in L) {
            const se = L[fe];
            if (typeof se != "object")
              continue;
            const { $data: we } = se.definition, le = G[fe];
            we && le && (G[fe] = ae(le));
          }
        }
        return j;
      }
      _removeAllSchemas(j, ee) {
        for (const L in j) {
          const N = j[L];
          (!ee || ee.test(L)) && (typeof N == "string" ? delete j[L] : N && !N.meta && (this._cache.delete(N.schema), delete j[L]));
        }
      }
      _addSchema(j, ee, L, N = this.opts.validateSchema, V = this.opts.addUsedSchema) {
        let G;
        const { schemaId: fe } = this.opts;
        if (typeof j == "object")
          G = j[fe];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof j != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let se = this._cache.get(j);
        if (se !== void 0)
          return se;
        L = (0, l.normalizeId)(G || L);
        const we = l.getSchemaRefs.call(this, j, L);
        return se = new i.SchemaEnv({ schema: j, schemaId: fe, meta: ee, baseId: L, localRefs: we }), this._cache.set(se.schema, se), V && !L.startsWith("#") && (L && this._checkUnique(L), this.refs[L] = se), N && this.validateSchema(j, !0), se;
      }
      _checkUnique(j) {
        if (this.schemas[j] || this.refs[j])
          throw new Error(`schema with key or id "${j}" already exists`);
      }
      _compileSchemaEnv(j) {
        if (j.meta ? this._compileMetaSchema(j) : i.compileSchema.call(this, j), !j.validate)
          throw new Error("ajv implementation error");
        return j.validate;
      }
      _compileMetaSchema(j) {
        const ee = this.opts;
        this.opts = this._metaOpts;
        try {
          i.compileSchema.call(this, j);
        } finally {
          this.opts = ee;
        }
      }
    }
    P.ValidationError = n.default, P.MissingRefError = s.default, t.default = P;
    function w(J, j, ee, L = "error") {
      for (const N in J) {
        const V = N;
        V in j && this.logger[L](`${ee}: option ${N}. ${J[V]}`);
      }
    }
    function C(J) {
      return J = (0, l.normalizeId)(J), this.schemas[J] || this.refs[J];
    }
    function k() {
      const J = this.opts.schemas;
      if (J)
        if (Array.isArray(J))
          this.addSchema(J);
        else
          for (const j in J)
            this.addSchema(J[j], j);
    }
    function $() {
      for (const J in this.opts.formats) {
        const j = this.opts.formats[J];
        j && this.addFormat(J, j);
      }
    }
    function T(J) {
      if (Array.isArray(J)) {
        this.addVocabulary(J);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const j in J) {
        const ee = J[j];
        ee.keyword || (ee.keyword = j), this.addKeyword(ee);
      }
    }
    function E() {
      const J = { ...this.opts };
      for (const j of b)
        delete J[j];
      return J;
    }
    const I = { log() {
    }, warn() {
    }, error() {
    } };
    function F(J) {
      if (J === !1)
        return I;
      if (J === void 0)
        return console;
      if (J.log && J.warn && J.error)
        return J;
      throw new Error("logger must implement log, warn and error methods");
    }
    const U = /^[a-z_$][a-z0-9_$:-]*$/i;
    function B(J, j) {
      const { RULES: ee } = this;
      if ((0, c.eachItem)(J, (L) => {
        if (ee.keywords[L])
          throw new Error(`Keyword ${L} is already defined`);
        if (!U.test(L))
          throw new Error(`Keyword ${L} has invalid name`);
      }), !!j && j.$data && !("code" in j || "validate" in j))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function R(J, j, ee) {
      var L;
      const N = j?.post;
      if (ee && N)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: V } = this;
      let G = N ? V.post : V.rules.find(({ type: se }) => se === ee);
      if (G || (G = { type: ee, rules: [] }, V.rules.push(G)), V.keywords[J] = !0, !j)
        return;
      const fe = {
        keyword: J,
        definition: {
          ...j,
          type: (0, u.getJSONTypes)(j.type),
          schemaType: (0, u.getJSONTypes)(j.schemaType)
        }
      };
      j.before ? Z.call(this, G, fe, j.before) : G.rules.push(fe), V.all[J] = fe, (L = j.implements) === null || L === void 0 || L.forEach((se) => this.addKeyword(se));
    }
    function Z(J, j, ee) {
      const L = J.rules.findIndex((N) => N.keyword === ee);
      L >= 0 ? J.rules.splice(L, 0, j) : (J.rules.push(j), this.logger.warn(`rule ${ee} is not defined`));
    }
    function Y(J) {
      let { metaSchema: j } = J;
      j !== void 0 && (J.$data && this.opts.$data && (j = ae(j)), J.validateSchema = this.compile(j, !0));
    }
    const X = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function ae(J) {
      return { anyOf: [J, X] };
    }
  })(Zu)), Zu;
}
var oa = {}, ia = {}, aa = {}, om;
function oD() {
  if (om) return aa;
  om = 1, Object.defineProperty(aa, "__esModule", { value: !0 });
  const t = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return aa.default = t, aa;
}
var Vn = {}, im;
function iD() {
  if (im) return Vn;
  im = 1, Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.callRef = Vn.getValidate = void 0;
  const t = mu(), e = Kr(), r = He(), n = hs(), s = Gh(), o = et(), i = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: c, schema: f, it: g } = u, { baseId: _, schemaEnv: b, validateName: p, opts: h, self: y } = g, { root: S } = b;
      if ((f === "#" || f === "#/") && _ === S.baseId)
        return P();
      const x = s.resolveRef.call(y, S, _, f);
      if (x === void 0)
        throw new t.default(g.opts.uriResolver, _, f);
      if (x instanceof s.SchemaEnv)
        return w(x);
      return C(x);
      function P() {
        if (b === S)
          return l(u, p, b, b.$async);
        const k = c.scopeValue("root", { ref: S });
        return l(u, (0, r._)`${k}.validate`, S, S.$async);
      }
      function w(k) {
        const $ = a(u, k);
        l(u, $, k, k.$async);
      }
      function C(k) {
        const $ = c.scopeValue("schema", h.code.source === !0 ? { ref: k, code: (0, r.stringify)(k) } : { ref: k }), T = c.name("valid"), E = u.subschema({
          schema: k,
          dataTypes: [],
          schemaPath: r.nil,
          topSchemaRef: $,
          errSchemaPath: f
        }, T);
        u.mergeEvaluated(E), u.ok(T);
      }
    }
  };
  function a(u, c) {
    const { gen: f } = u;
    return c.validate ? f.scopeValue("validate", { ref: c.validate }) : (0, r._)`${f.scopeValue("wrapper", { ref: c })}.validate`;
  }
  Vn.getValidate = a;
  function l(u, c, f, g) {
    const { gen: _, it: b } = u, { allErrors: p, schemaEnv: h, opts: y } = b, S = y.passContext ? n.default.this : r.nil;
    g ? x() : P();
    function x() {
      if (!h.$async)
        throw new Error("async schema referenced by sync schema");
      const k = _.let("valid");
      _.try(() => {
        _.code((0, r._)`await ${(0, e.callValidateCode)(u, c, S)}`), C(c), p || _.assign(k, !0);
      }, ($) => {
        _.if((0, r._)`!(${$} instanceof ${b.ValidationError})`, () => _.throw($)), w($), p || _.assign(k, !1);
      }), u.ok(k);
    }
    function P() {
      u.result((0, e.callValidateCode)(u, c, S), () => C(c), () => w(c));
    }
    function w(k) {
      const $ = (0, r._)`${k}.errors`;
      _.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${$} : ${n.default.vErrors}.concat(${$})`), _.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function C(k) {
      var $;
      if (!b.opts.unevaluated)
        return;
      const T = ($ = f?.validate) === null || $ === void 0 ? void 0 : $.evaluated;
      if (b.props !== !0)
        if (T && !T.dynamicProps)
          T.props !== void 0 && (b.props = o.mergeEvaluated.props(_, T.props, b.props));
        else {
          const E = _.var("props", (0, r._)`${k}.evaluated.props`);
          b.props = o.mergeEvaluated.props(_, E, b.props, r.Name);
        }
      if (b.items !== !0)
        if (T && !T.dynamicItems)
          T.items !== void 0 && (b.items = o.mergeEvaluated.items(_, T.items, b.items));
        else {
          const E = _.var("items", (0, r._)`${k}.evaluated.items`);
          b.items = o.mergeEvaluated.items(_, E, b.items, r.Name);
        }
    }
  }
  return Vn.callRef = l, Vn.default = i, Vn;
}
var am;
function aD() {
  if (am) return ia;
  am = 1, Object.defineProperty(ia, "__esModule", { value: !0 });
  const t = oD(), e = iD(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    t.default,
    e.default
  ];
  return ia.default = r, ia;
}
var la = {}, ua = {}, lm;
function lD() {
  if (lm) return ua;
  lm = 1, Object.defineProperty(ua, "__esModule", { value: !0 });
  const t = He(), e = t.operators, r = {
    maximum: { okStr: "<=", ok: e.LTE, fail: e.GT },
    minimum: { okStr: ">=", ok: e.GTE, fail: e.LT },
    exclusiveMaximum: { okStr: "<", ok: e.LT, fail: e.GTE },
    exclusiveMinimum: { okStr: ">", ok: e.GT, fail: e.LTE }
  }, n = {
    message: ({ keyword: o, schemaCode: i }) => (0, t.str)`must be ${r[o].okStr} ${i}`,
    params: ({ keyword: o, schemaCode: i }) => (0, t._)`{comparison: ${r[o].okStr}, limit: ${i}}`
  }, s = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(o) {
      const { keyword: i, data: a, schemaCode: l } = o;
      o.fail$data((0, t._)`${a} ${r[i].fail} ${l} || isNaN(${a})`);
    }
  };
  return ua.default = s, ua;
}
var ca = {}, um;
function uD() {
  if (um) return ca;
  um = 1, Object.defineProperty(ca, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, t.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, t._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: s, data: o, schemaCode: i, it: a } = n, l = a.opts.multipleOfPrecision, u = s.let("res"), c = l ? (0, t._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}` : (0, t._)`${u} !== parseInt(${u})`;
      n.fail$data((0, t._)`(${i} === 0 || (${u} = ${o}/${i}, ${c}))`);
    }
  };
  return ca.default = r, ca;
}
var da = {}, fa = {}, cm;
function cD() {
  if (cm) return fa;
  cm = 1, Object.defineProperty(fa, "__esModule", { value: !0 });
  function t(e) {
    const r = e.length;
    let n = 0, s = 0, o;
    for (; s < r; )
      n++, o = e.charCodeAt(s++), o >= 55296 && o <= 56319 && s < r && (o = e.charCodeAt(s), (o & 64512) === 56320 && s++);
    return n;
  }
  return fa.default = t, t.code = 'require("ajv/dist/runtime/ucs2length").default', fa;
}
var dm;
function dD() {
  if (dm) return da;
  dm = 1, Object.defineProperty(da, "__esModule", { value: !0 });
  const t = He(), e = et(), r = cD(), s = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: o, schemaCode: i }) {
        const a = o === "maxLength" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${a} than ${i} characters`;
      },
      params: ({ schemaCode: o }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { keyword: i, data: a, schemaCode: l, it: u } = o, c = i === "maxLength" ? t.operators.GT : t.operators.LT, f = u.opts.unicode === !1 ? (0, t._)`${a}.length` : (0, t._)`${(0, e.useFunc)(o.gen, r.default)}(${a})`;
      o.fail$data((0, t._)`${f} ${c} ${l}`);
    }
  };
  return da.default = s, da;
}
var ha = {}, fm;
function fD() {
  if (fm) return ha;
  fm = 1, Object.defineProperty(ha, "__esModule", { value: !0 });
  const t = Kr(), e = He(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: s }) => (0, e.str)`must match pattern "${s}"`,
      params: ({ schemaCode: s }) => (0, e._)`{pattern: ${s}}`
    },
    code(s) {
      const { data: o, $data: i, schema: a, schemaCode: l, it: u } = s, c = u.opts.unicodeRegExp ? "u" : "", f = i ? (0, e._)`(new RegExp(${l}, ${c}))` : (0, t.usePattern)(s, a);
      s.fail$data((0, e._)`!${f}.test(${o})`);
    }
  };
  return ha.default = n, ha;
}
var ga = {}, hm;
function hD() {
  if (hm) return ga;
  hm = 1, Object.defineProperty(ga, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: s }) {
        const o = n === "maxProperties" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${o} than ${s} properties`;
      },
      params: ({ schemaCode: n }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: s, data: o, schemaCode: i } = n, a = s === "maxProperties" ? t.operators.GT : t.operators.LT;
      n.fail$data((0, t._)`Object.keys(${o}).length ${a} ${i}`);
    }
  };
  return ga.default = r, ga;
}
var pa = {}, gm;
function gD() {
  if (gm) return pa;
  gm = 1, Object.defineProperty(pa, "__esModule", { value: !0 });
  const t = Kr(), e = He(), r = et(), s = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: o } }) => (0, e.str)`must have required property '${o}'`,
      params: ({ params: { missingProperty: o } }) => (0, e._)`{missingProperty: ${o}}`
    },
    code(o) {
      const { gen: i, schema: a, schemaCode: l, data: u, $data: c, it: f } = o, { opts: g } = f;
      if (!c && a.length === 0)
        return;
      const _ = a.length >= g.loopRequired;
      if (f.allErrors ? b() : p(), g.strictRequired) {
        const S = o.parentSchema.properties, { definedProperties: x } = o.it;
        for (const P of a)
          if (S?.[P] === void 0 && !x.has(P)) {
            const w = f.schemaEnv.baseId + f.errSchemaPath, C = `required property "${P}" is not defined at "${w}" (strictRequired)`;
            (0, r.checkStrictMode)(f, C, f.opts.strictRequired);
          }
      }
      function b() {
        if (_ || c)
          o.block$data(e.nil, h);
        else
          for (const S of a)
            (0, t.checkReportMissingProp)(o, S);
      }
      function p() {
        const S = i.let("missing");
        if (_ || c) {
          const x = i.let("valid", !0);
          o.block$data(x, () => y(S, x)), o.ok(x);
        } else
          i.if((0, t.checkMissingProp)(o, a, S)), (0, t.reportMissingProp)(o, S), i.else();
      }
      function h() {
        i.forOf("prop", l, (S) => {
          o.setParams({ missingProperty: S }), i.if((0, t.noPropertyInData)(i, u, S, g.ownProperties), () => o.error());
        });
      }
      function y(S, x) {
        o.setParams({ missingProperty: S }), i.forOf(S, l, () => {
          i.assign(x, (0, t.propertyInData)(i, u, S, g.ownProperties)), i.if((0, e.not)(x), () => {
            o.error(), i.break();
          });
        }, e.nil);
      }
    }
  };
  return pa.default = s, pa;
}
var ma = {}, pm;
function pD() {
  if (pm) return ma;
  pm = 1, Object.defineProperty(ma, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: s }) {
        const o = n === "maxItems" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${o} than ${s} items`;
      },
      params: ({ schemaCode: n }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: s, data: o, schemaCode: i } = n, a = s === "maxItems" ? t.operators.GT : t.operators.LT;
      n.fail$data((0, t._)`${o}.length ${a} ${i}`);
    }
  };
  return ma.default = r, ma;
}
var va = {}, ya = {}, mm;
function Yh() {
  if (mm) return ya;
  mm = 1, Object.defineProperty(ya, "__esModule", { value: !0 });
  const t = pw();
  return t.code = 'require("ajv/dist/runtime/equal").default', ya.default = t, ya;
}
var vm;
function mD() {
  if (vm) return va;
  vm = 1, Object.defineProperty(va, "__esModule", { value: !0 });
  const t = Sl(), e = He(), r = et(), n = Yh(), o = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i, j: a } }) => (0, e.str)`must NOT have duplicate items (items ## ${a} and ${i} are identical)`,
      params: ({ params: { i, j: a } }) => (0, e._)`{i: ${i}, j: ${a}}`
    },
    code(i) {
      const { gen: a, data: l, $data: u, schema: c, parentSchema: f, schemaCode: g, it: _ } = i;
      if (!u && !c)
        return;
      const b = a.let("valid"), p = f.items ? (0, t.getSchemaTypes)(f.items) : [];
      i.block$data(b, h, (0, e._)`${g} === false`), i.ok(b);
      function h() {
        const P = a.let("i", (0, e._)`${l}.length`), w = a.let("j");
        i.setParams({ i: P, j: w }), a.assign(b, !0), a.if((0, e._)`${P} > 1`, () => (y() ? S : x)(P, w));
      }
      function y() {
        return p.length > 0 && !p.some((P) => P === "object" || P === "array");
      }
      function S(P, w) {
        const C = a.name("item"), k = (0, t.checkDataTypes)(p, C, _.opts.strictNumbers, t.DataType.Wrong), $ = a.const("indices", (0, e._)`{}`);
        a.for((0, e._)`;${P}--;`, () => {
          a.let(C, (0, e._)`${l}[${P}]`), a.if(k, (0, e._)`continue`), p.length > 1 && a.if((0, e._)`typeof ${C} == "string"`, (0, e._)`${C} += "_"`), a.if((0, e._)`typeof ${$}[${C}] == "number"`, () => {
            a.assign(w, (0, e._)`${$}[${C}]`), i.error(), a.assign(b, !1).break();
          }).code((0, e._)`${$}[${C}] = ${P}`);
        });
      }
      function x(P, w) {
        const C = (0, r.useFunc)(a, n.default), k = a.name("outer");
        a.label(k).for((0, e._)`;${P}--;`, () => a.for((0, e._)`${w} = ${P}; ${w}--;`, () => a.if((0, e._)`${C}(${l}[${P}], ${l}[${w}])`, () => {
          i.error(), a.assign(b, !1).break(k);
        })));
      }
    }
  };
  return va.default = o, va;
}
var ba = {}, ym;
function vD() {
  if (ym) return ba;
  ym = 1, Object.defineProperty(ba, "__esModule", { value: !0 });
  const t = He(), e = et(), r = Yh(), s = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: o }) => (0, t._)`{allowedValue: ${o}}`
    },
    code(o) {
      const { gen: i, data: a, $data: l, schemaCode: u, schema: c } = o;
      l || c && typeof c == "object" ? o.fail$data((0, t._)`!${(0, e.useFunc)(i, r.default)}(${a}, ${u})`) : o.fail((0, t._)`${c} !== ${a}`);
    }
  };
  return ba.default = s, ba;
}
var _a = {}, bm;
function yD() {
  if (bm) return _a;
  bm = 1, Object.defineProperty(_a, "__esModule", { value: !0 });
  const t = He(), e = et(), r = Yh(), s = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: o }) => (0, t._)`{allowedValues: ${o}}`
    },
    code(o) {
      const { gen: i, data: a, $data: l, schema: u, schemaCode: c, it: f } = o;
      if (!l && u.length === 0)
        throw new Error("enum must have non-empty array");
      const g = u.length >= f.opts.loopEnum;
      let _;
      const b = () => _ ?? (_ = (0, e.useFunc)(i, r.default));
      let p;
      if (g || l)
        p = i.let("valid"), o.block$data(p, h);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const S = i.const("vSchema", c);
        p = (0, t.or)(...u.map((x, P) => y(S, P)));
      }
      o.pass(p);
      function h() {
        i.assign(p, !1), i.forOf("v", c, (S) => i.if((0, t._)`${b()}(${a}, ${S})`, () => i.assign(p, !0).break()));
      }
      function y(S, x) {
        const P = u[x];
        return typeof P == "object" && P !== null ? (0, t._)`${b()}(${a}, ${S}[${x}])` : (0, t._)`${a} === ${P}`;
      }
    }
  };
  return _a.default = s, _a;
}
var _m;
function bD() {
  if (_m) return la;
  _m = 1, Object.defineProperty(la, "__esModule", { value: !0 });
  const t = lD(), e = uD(), r = dD(), n = fD(), s = hD(), o = gD(), i = pD(), a = mD(), l = vD(), u = yD(), c = [
    // number
    t.default,
    e.default,
    // string
    r.default,
    n.default,
    // object
    s.default,
    o.default,
    // array
    i.default,
    a.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    l.default,
    u.default
  ];
  return la.default = c, la;
}
var wa = {}, Qs = {}, wm;
function vw() {
  if (wm) return Qs;
  wm = 1, Object.defineProperty(Qs, "__esModule", { value: !0 }), Qs.validateAdditionalItems = void 0;
  const t = He(), e = et(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: o } }) => (0, t.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { parentSchema: i, it: a } = o, { items: l } = i;
      if (!Array.isArray(l)) {
        (0, e.checkStrictMode)(a, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      s(o, l);
    }
  };
  function s(o, i) {
    const { gen: a, schema: l, data: u, keyword: c, it: f } = o;
    f.items = !0;
    const g = a.const("len", (0, t._)`${u}.length`);
    if (l === !1)
      o.setParams({ len: i.length }), o.pass((0, t._)`${g} <= ${i.length}`);
    else if (typeof l == "object" && !(0, e.alwaysValidSchema)(f, l)) {
      const b = a.var("valid", (0, t._)`${g} <= ${i.length}`);
      a.if((0, t.not)(b), () => _(b)), o.ok(b);
    }
    function _(b) {
      a.forRange("i", i.length, g, (p) => {
        o.subschema({ keyword: c, dataProp: p, dataPropType: e.Type.Num }, b), f.allErrors || a.if((0, t.not)(b), () => a.break());
      });
    }
  }
  return Qs.validateAdditionalItems = s, Qs.default = n, Qs;
}
var Sa = {}, eo = {}, Sm;
function yw() {
  if (Sm) return eo;
  Sm = 1, Object.defineProperty(eo, "__esModule", { value: !0 }), eo.validateTuple = void 0;
  const t = He(), e = et(), r = Kr(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(o) {
      const { schema: i, it: a } = o;
      if (Array.isArray(i))
        return s(o, "additionalItems", i);
      a.items = !0, !(0, e.alwaysValidSchema)(a, i) && o.ok((0, r.validateArray)(o));
    }
  };
  function s(o, i, a = o.schema) {
    const { gen: l, parentSchema: u, data: c, keyword: f, it: g } = o;
    p(u), g.opts.unevaluated && a.length && g.items !== !0 && (g.items = e.mergeEvaluated.items(l, a.length, g.items));
    const _ = l.name("valid"), b = l.const("len", (0, t._)`${c}.length`);
    a.forEach((h, y) => {
      (0, e.alwaysValidSchema)(g, h) || (l.if((0, t._)`${b} > ${y}`, () => o.subschema({
        keyword: f,
        schemaProp: y,
        dataProp: y
      }, _)), o.ok(_));
    });
    function p(h) {
      const { opts: y, errSchemaPath: S } = g, x = a.length, P = x === h.minItems && (x === h.maxItems || h[i] === !1);
      if (y.strictTuples && !P) {
        const w = `"${f}" is ${x}-tuple, but minItems or maxItems/${i} are not specified or different at path "${S}"`;
        (0, e.checkStrictMode)(g, w, y.strictTuples);
      }
    }
  }
  return eo.validateTuple = s, eo.default = n, eo;
}
var xm;
function _D() {
  if (xm) return Sa;
  xm = 1, Object.defineProperty(Sa, "__esModule", { value: !0 });
  const t = yw(), e = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, t.validateTuple)(r, "items")
  };
  return Sa.default = e, Sa;
}
var xa = {}, Pm;
function wD() {
  if (Pm) return xa;
  Pm = 1, Object.defineProperty(xa, "__esModule", { value: !0 });
  const t = He(), e = et(), r = Kr(), n = vw(), o = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: i } }) => (0, t.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, t._)`{limit: ${i}}`
    },
    code(i) {
      const { schema: a, parentSchema: l, it: u } = i, { prefixItems: c } = l;
      u.items = !0, !(0, e.alwaysValidSchema)(u, a) && (c ? (0, n.validateAdditionalItems)(i, c) : i.ok((0, r.validateArray)(i)));
    }
  };
  return xa.default = o, xa;
}
var Pa = {}, Om;
function SD() {
  if (Om) return Pa;
  Om = 1, Object.defineProperty(Pa, "__esModule", { value: !0 });
  const t = He(), e = et(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: s, max: o } }) => o === void 0 ? (0, t.str)`must contain at least ${s} valid item(s)` : (0, t.str)`must contain at least ${s} and no more than ${o} valid item(s)`,
      params: ({ params: { min: s, max: o } }) => o === void 0 ? (0, t._)`{minContains: ${s}}` : (0, t._)`{minContains: ${s}, maxContains: ${o}}`
    },
    code(s) {
      const { gen: o, schema: i, parentSchema: a, data: l, it: u } = s;
      let c, f;
      const { minContains: g, maxContains: _ } = a;
      u.opts.next ? (c = g === void 0 ? 1 : g, f = _) : c = 1;
      const b = o.const("len", (0, t._)`${l}.length`);
      if (s.setParams({ min: c, max: f }), f === void 0 && c === 0) {
        (0, e.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (f !== void 0 && c > f) {
        (0, e.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), s.fail();
        return;
      }
      if ((0, e.alwaysValidSchema)(u, i)) {
        let x = (0, t._)`${b} >= ${c}`;
        f !== void 0 && (x = (0, t._)`${x} && ${b} <= ${f}`), s.pass(x);
        return;
      }
      u.items = !0;
      const p = o.name("valid");
      f === void 0 && c === 1 ? y(p, () => o.if(p, () => o.break())) : c === 0 ? (o.let(p, !0), f !== void 0 && o.if((0, t._)`${l}.length > 0`, h)) : (o.let(p, !1), h()), s.result(p, () => s.reset());
      function h() {
        const x = o.name("_valid"), P = o.let("count", 0);
        y(x, () => o.if(x, () => S(P)));
      }
      function y(x, P) {
        o.forRange("i", 0, b, (w) => {
          s.subschema({
            keyword: "contains",
            dataProp: w,
            dataPropType: e.Type.Num,
            compositeRule: !0
          }, x), P();
        });
      }
      function S(x) {
        o.code((0, t._)`${x}++`), f === void 0 ? o.if((0, t._)`${x} >= ${c}`, () => o.assign(p, !0).break()) : (o.if((0, t._)`${x} > ${f}`, () => o.assign(p, !1).break()), c === 1 ? o.assign(p, !0) : o.if((0, t._)`${x} >= ${c}`, () => o.assign(p, !0)));
      }
    }
  };
  return Pa.default = n, Pa;
}
var ac = {}, Cm;
function xD() {
  return Cm || (Cm = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
    const e = He(), r = et(), n = Kr();
    t.error = {
      message: ({ params: { property: l, depsCount: u, deps: c } }) => {
        const f = u === 1 ? "property" : "properties";
        return (0, e.str)`must have ${f} ${c} when property ${l} is present`;
      },
      params: ({ params: { property: l, depsCount: u, deps: c, missingProperty: f } }) => (0, e._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${u},
    deps: ${c}}`
      // TODO change to reference
    };
    const s = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: t.error,
      code(l) {
        const [u, c] = o(l);
        i(l, u), a(l, c);
      }
    };
    function o({ schema: l }) {
      const u = {}, c = {};
      for (const f in l) {
        if (f === "__proto__")
          continue;
        const g = Array.isArray(l[f]) ? u : c;
        g[f] = l[f];
      }
      return [u, c];
    }
    function i(l, u = l.schema) {
      const { gen: c, data: f, it: g } = l;
      if (Object.keys(u).length === 0)
        return;
      const _ = c.let("missing");
      for (const b in u) {
        const p = u[b];
        if (p.length === 0)
          continue;
        const h = (0, n.propertyInData)(c, f, b, g.opts.ownProperties);
        l.setParams({
          property: b,
          depsCount: p.length,
          deps: p.join(", ")
        }), g.allErrors ? c.if(h, () => {
          for (const y of p)
            (0, n.checkReportMissingProp)(l, y);
        }) : (c.if((0, e._)`${h} && (${(0, n.checkMissingProp)(l, p, _)})`), (0, n.reportMissingProp)(l, _), c.else());
      }
    }
    t.validatePropertyDeps = i;
    function a(l, u = l.schema) {
      const { gen: c, data: f, keyword: g, it: _ } = l, b = c.name("valid");
      for (const p in u)
        (0, r.alwaysValidSchema)(_, u[p]) || (c.if(
          (0, n.propertyInData)(c, f, p, _.opts.ownProperties),
          () => {
            const h = l.subschema({ keyword: g, schemaProp: p }, b);
            l.mergeValidEvaluated(h, b);
          },
          () => c.var(b, !0)
          // TODO var
        ), l.ok(b));
    }
    t.validateSchemaDeps = a, t.default = s;
  })(ac)), ac;
}
var Oa = {}, km;
function PD() {
  if (km) return Oa;
  km = 1, Object.defineProperty(Oa, "__esModule", { value: !0 });
  const t = He(), e = et(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: s }) => (0, t._)`{propertyName: ${s.propertyName}}`
    },
    code(s) {
      const { gen: o, schema: i, data: a, it: l } = s;
      if ((0, e.alwaysValidSchema)(l, i))
        return;
      const u = o.name("valid");
      o.forIn("key", a, (c) => {
        s.setParams({ propertyName: c }), s.subschema({
          keyword: "propertyNames",
          data: c,
          dataTypes: ["string"],
          propertyName: c,
          compositeRule: !0
        }, u), o.if((0, t.not)(u), () => {
          s.error(!0), l.allErrors || o.break();
        });
      }), s.ok(u);
    }
  };
  return Oa.default = n, Oa;
}
var Ca = {}, $m;
function bw() {
  if ($m) return Ca;
  $m = 1, Object.defineProperty(Ca, "__esModule", { value: !0 });
  const t = Kr(), e = He(), r = hs(), n = et(), o = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: i }) => (0, e._)`{additionalProperty: ${i.additionalProperty}}`
    },
    code(i) {
      const { gen: a, schema: l, parentSchema: u, data: c, errsCount: f, it: g } = i;
      if (!f)
        throw new Error("ajv implementation error");
      const { allErrors: _, opts: b } = g;
      if (g.props = !0, b.removeAdditional !== "all" && (0, n.alwaysValidSchema)(g, l))
        return;
      const p = (0, t.allSchemaProperties)(u.properties), h = (0, t.allSchemaProperties)(u.patternProperties);
      y(), i.ok((0, e._)`${f} === ${r.default.errors}`);
      function y() {
        a.forIn("key", c, (C) => {
          !p.length && !h.length ? P(C) : a.if(S(C), () => P(C));
        });
      }
      function S(C) {
        let k;
        if (p.length > 8) {
          const $ = (0, n.schemaRefOrVal)(g, u.properties, "properties");
          k = (0, t.isOwnProperty)(a, $, C);
        } else p.length ? k = (0, e.or)(...p.map(($) => (0, e._)`${C} === ${$}`)) : k = e.nil;
        return h.length && (k = (0, e.or)(k, ...h.map(($) => (0, e._)`${(0, t.usePattern)(i, $)}.test(${C})`))), (0, e.not)(k);
      }
      function x(C) {
        a.code((0, e._)`delete ${c}[${C}]`);
      }
      function P(C) {
        if (b.removeAdditional === "all" || b.removeAdditional && l === !1) {
          x(C);
          return;
        }
        if (l === !1) {
          i.setParams({ additionalProperty: C }), i.error(), _ || a.break();
          return;
        }
        if (typeof l == "object" && !(0, n.alwaysValidSchema)(g, l)) {
          const k = a.name("valid");
          b.removeAdditional === "failing" ? (w(C, k, !1), a.if((0, e.not)(k), () => {
            i.reset(), x(C);
          })) : (w(C, k), _ || a.if((0, e.not)(k), () => a.break()));
        }
      }
      function w(C, k, $) {
        const T = {
          keyword: "additionalProperties",
          dataProp: C,
          dataPropType: n.Type.Str
        };
        $ === !1 && Object.assign(T, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), i.subschema(T, k);
      }
    }
  };
  return Ca.default = o, Ca;
}
var ka = {}, Am;
function OD() {
  if (Am) return ka;
  Am = 1, Object.defineProperty(ka, "__esModule", { value: !0 });
  const t = pu(), e = Kr(), r = et(), n = bw(), s = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(o) {
      const { gen: i, schema: a, parentSchema: l, data: u, it: c } = o;
      c.opts.removeAdditional === "all" && l.additionalProperties === void 0 && n.default.code(new t.KeywordCxt(c, n.default, "additionalProperties"));
      const f = (0, e.allSchemaProperties)(a);
      for (const h of f)
        c.definedProperties.add(h);
      c.opts.unevaluated && f.length && c.props !== !0 && (c.props = r.mergeEvaluated.props(i, (0, r.toHash)(f), c.props));
      const g = f.filter((h) => !(0, r.alwaysValidSchema)(c, a[h]));
      if (g.length === 0)
        return;
      const _ = i.name("valid");
      for (const h of g)
        b(h) ? p(h) : (i.if((0, e.propertyInData)(i, u, h, c.opts.ownProperties)), p(h), c.allErrors || i.else().var(_, !0), i.endIf()), o.it.definedProperties.add(h), o.ok(_);
      function b(h) {
        return c.opts.useDefaults && !c.compositeRule && a[h].default !== void 0;
      }
      function p(h) {
        o.subschema({
          keyword: "properties",
          schemaProp: h,
          dataProp: h
        }, _);
      }
    }
  };
  return ka.default = s, ka;
}
var $a = {}, Em;
function CD() {
  if (Em) return $a;
  Em = 1, Object.defineProperty($a, "__esModule", { value: !0 });
  const t = Kr(), e = He(), r = et(), n = et(), s = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(o) {
      const { gen: i, schema: a, data: l, parentSchema: u, it: c } = o, { opts: f } = c, g = (0, t.allSchemaProperties)(a), _ = g.filter((P) => (0, r.alwaysValidSchema)(c, a[P]));
      if (g.length === 0 || _.length === g.length && (!c.opts.unevaluated || c.props === !0))
        return;
      const b = f.strictSchema && !f.allowMatchingProperties && u.properties, p = i.name("valid");
      c.props !== !0 && !(c.props instanceof e.Name) && (c.props = (0, n.evaluatedPropsToName)(i, c.props));
      const { props: h } = c;
      y();
      function y() {
        for (const P of g)
          b && S(P), c.allErrors ? x(P) : (i.var(p, !0), x(P), i.if(p));
      }
      function S(P) {
        for (const w in b)
          new RegExp(P).test(w) && (0, r.checkStrictMode)(c, `property ${w} matches pattern ${P} (use allowMatchingProperties)`);
      }
      function x(P) {
        i.forIn("key", l, (w) => {
          i.if((0, e._)`${(0, t.usePattern)(o, P)}.test(${w})`, () => {
            const C = _.includes(P);
            C || o.subschema({
              keyword: "patternProperties",
              schemaProp: P,
              dataProp: w,
              dataPropType: n.Type.Str
            }, p), c.opts.unevaluated && h !== !0 ? i.assign((0, e._)`${h}[${w}]`, !0) : !C && !c.allErrors && i.if((0, e.not)(p), () => i.break());
          });
        });
      }
    }
  };
  return $a.default = s, $a;
}
var Aa = {}, Tm;
function kD() {
  if (Tm) return Aa;
  Tm = 1, Object.defineProperty(Aa, "__esModule", { value: !0 });
  const t = et(), e = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: s, it: o } = r;
      if ((0, t.alwaysValidSchema)(o, s)) {
        r.fail();
        return;
      }
      const i = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, i), r.failResult(i, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Aa.default = e, Aa;
}
var Ea = {}, Dm;
function $D() {
  if (Dm) return Ea;
  Dm = 1, Object.defineProperty(Ea, "__esModule", { value: !0 });
  const e = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: Kr().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return Ea.default = e, Ea;
}
var Ta = {}, Mm;
function AD() {
  if (Mm) return Ta;
  Mm = 1, Object.defineProperty(Ta, "__esModule", { value: !0 });
  const t = He(), e = et(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: s }) => (0, t._)`{passingSchemas: ${s.passing}}`
    },
    code(s) {
      const { gen: o, schema: i, parentSchema: a, it: l } = s;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      if (l.opts.discriminator && a.discriminator)
        return;
      const u = i, c = o.let("valid", !1), f = o.let("passing", null), g = o.name("_valid");
      s.setParams({ passing: f }), o.block(_), s.result(c, () => s.reset(), () => s.error(!0));
      function _() {
        u.forEach((b, p) => {
          let h;
          (0, e.alwaysValidSchema)(l, b) ? o.var(g, !0) : h = s.subschema({
            keyword: "oneOf",
            schemaProp: p,
            compositeRule: !0
          }, g), p > 0 && o.if((0, t._)`${g} && ${c}`).assign(c, !1).assign(f, (0, t._)`[${f}, ${p}]`).else(), o.if(g, () => {
            o.assign(c, !0), o.assign(f, p), h && s.mergeEvaluated(h, t.Name);
          });
        });
      }
    }
  };
  return Ta.default = n, Ta;
}
var Da = {}, Im;
function ED() {
  if (Im) return Da;
  Im = 1, Object.defineProperty(Da, "__esModule", { value: !0 });
  const t = et(), e = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: s, it: o } = r;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const i = n.name("valid");
      s.forEach((a, l) => {
        if ((0, t.alwaysValidSchema)(o, a))
          return;
        const u = r.subschema({ keyword: "allOf", schemaProp: l }, i);
        r.ok(i), r.mergeEvaluated(u);
      });
    }
  };
  return Da.default = e, Da;
}
var Ma = {}, Nm;
function TD() {
  if (Nm) return Ma;
  Nm = 1, Object.defineProperty(Ma, "__esModule", { value: !0 });
  const t = He(), e = et(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: o }) => (0, t.str)`must match "${o.ifClause}" schema`,
      params: ({ params: o }) => (0, t._)`{failingKeyword: ${o.ifClause}}`
    },
    code(o) {
      const { gen: i, parentSchema: a, it: l } = o;
      a.then === void 0 && a.else === void 0 && (0, e.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
      const u = s(l, "then"), c = s(l, "else");
      if (!u && !c)
        return;
      const f = i.let("valid", !0), g = i.name("_valid");
      if (_(), o.reset(), u && c) {
        const p = i.let("ifClause");
        o.setParams({ ifClause: p }), i.if(g, b("then", p), b("else", p));
      } else u ? i.if(g, b("then")) : i.if((0, t.not)(g), b("else"));
      o.pass(f, () => o.error(!0));
      function _() {
        const p = o.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, g);
        o.mergeEvaluated(p);
      }
      function b(p, h) {
        return () => {
          const y = o.subschema({ keyword: p }, g);
          i.assign(f, g), o.mergeValidEvaluated(y, f), h ? i.assign(h, (0, t._)`${p}`) : o.setParams({ ifClause: p });
        };
      }
    }
  };
  function s(o, i) {
    const a = o.schema[i];
    return a !== void 0 && !(0, e.alwaysValidSchema)(o, a);
  }
  return Ma.default = n, Ma;
}
var Ia = {}, Fm;
function DD() {
  if (Fm) return Ia;
  Fm = 1, Object.defineProperty(Ia, "__esModule", { value: !0 });
  const t = et(), e = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: s }) {
      n.if === void 0 && (0, t.checkStrictMode)(s, `"${r}" without "if" is ignored`);
    }
  };
  return Ia.default = e, Ia;
}
var Rm;
function MD() {
  if (Rm) return wa;
  Rm = 1, Object.defineProperty(wa, "__esModule", { value: !0 });
  const t = vw(), e = _D(), r = yw(), n = wD(), s = SD(), o = xD(), i = PD(), a = bw(), l = OD(), u = CD(), c = kD(), f = $D(), g = AD(), _ = ED(), b = TD(), p = DD();
  function h(y = !1) {
    const S = [
      // any
      c.default,
      f.default,
      g.default,
      _.default,
      b.default,
      p.default,
      // object
      i.default,
      a.default,
      o.default,
      l.default,
      u.default
    ];
    return y ? S.push(e.default, n.default) : S.push(t.default, r.default), S.push(s.default), S;
  }
  return wa.default = h, wa;
}
var Na = {}, Fa = {}, Vm;
function ID() {
  if (Vm) return Fa;
  Vm = 1, Object.defineProperty(Fa, "__esModule", { value: !0 });
  const t = He(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, t.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, t._)`{format: ${n}}`
    },
    code(n, s) {
      const { gen: o, data: i, $data: a, schema: l, schemaCode: u, it: c } = n, { opts: f, errSchemaPath: g, schemaEnv: _, self: b } = c;
      if (!f.validateFormats)
        return;
      a ? p() : h();
      function p() {
        const y = o.scopeValue("formats", {
          ref: b.formats,
          code: f.code.formats
        }), S = o.const("fDef", (0, t._)`${y}[${u}]`), x = o.let("fType"), P = o.let("format");
        o.if((0, t._)`typeof ${S} == "object" && !(${S} instanceof RegExp)`, () => o.assign(x, (0, t._)`${S}.type || "string"`).assign(P, (0, t._)`${S}.validate`), () => o.assign(x, (0, t._)`"string"`).assign(P, S)), n.fail$data((0, t.or)(w(), C()));
        function w() {
          return f.strictSchema === !1 ? t.nil : (0, t._)`${u} && !${P}`;
        }
        function C() {
          const k = _.$async ? (0, t._)`(${S}.async ? await ${P}(${i}) : ${P}(${i}))` : (0, t._)`${P}(${i})`, $ = (0, t._)`(typeof ${P} == "function" ? ${k} : ${P}.test(${i}))`;
          return (0, t._)`${P} && ${P} !== true && ${x} === ${s} && !${$}`;
        }
      }
      function h() {
        const y = b.formats[l];
        if (!y) {
          w();
          return;
        }
        if (y === !0)
          return;
        const [S, x, P] = C(y);
        S === s && n.pass(k());
        function w() {
          if (f.strictSchema === !1) {
            b.logger.warn($());
            return;
          }
          throw new Error($());
          function $() {
            return `unknown format "${l}" ignored in schema at path "${g}"`;
          }
        }
        function C($) {
          const T = $ instanceof RegExp ? (0, t.regexpCode)($) : f.code.formats ? (0, t._)`${f.code.formats}${(0, t.getProperty)(l)}` : void 0, E = o.scopeValue("formats", { key: l, ref: $, code: T });
          return typeof $ == "object" && !($ instanceof RegExp) ? [$.type || "string", $.validate, (0, t._)`${E}.validate`] : ["string", $, E];
        }
        function k() {
          if (typeof y == "object" && !(y instanceof RegExp) && y.async) {
            if (!_.$async)
              throw new Error("async format in sync schema");
            return (0, t._)`await ${P}(${i})`;
          }
          return typeof x == "function" ? (0, t._)`${P}(${i})` : (0, t._)`${P}.test(${i})`;
        }
      }
    }
  };
  return Fa.default = r, Fa;
}
var Lm;
function ND() {
  if (Lm) return Na;
  Lm = 1, Object.defineProperty(Na, "__esModule", { value: !0 });
  const e = [ID().default];
  return Na.default = e, Na;
}
var Ss = {}, jm;
function FD() {
  return jm || (jm = 1, Object.defineProperty(Ss, "__esModule", { value: !0 }), Ss.contentVocabulary = Ss.metadataVocabulary = void 0, Ss.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Ss.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Ss;
}
var Bm;
function RD() {
  if (Bm) return oa;
  Bm = 1, Object.defineProperty(oa, "__esModule", { value: !0 });
  const t = aD(), e = bD(), r = MD(), n = ND(), s = FD(), o = [
    t.default,
    e.default,
    (0, r.default)(),
    n.default,
    s.metadataVocabulary,
    s.contentVocabulary
  ];
  return oa.default = o, oa;
}
var Ra = {}, ti = {}, zm;
function VD() {
  if (zm) return ti;
  zm = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.DiscrError = void 0;
  var t;
  return (function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  })(t || (ti.DiscrError = t = {})), ti;
}
var qm;
function LD() {
  if (qm) return Ra;
  qm = 1, Object.defineProperty(Ra, "__esModule", { value: !0 });
  const t = He(), e = VD(), r = Gh(), n = mu(), s = et(), i = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: a, tagName: l } }) => a === e.DiscrError.Tag ? `tag "${l}" must be string` : `value of tag "${l}" must be in oneOf`,
      params: ({ params: { discrError: a, tag: l, tagName: u } }) => (0, t._)`{error: ${a}, tag: ${u}, tagValue: ${l}}`
    },
    code(a) {
      const { gen: l, data: u, schema: c, parentSchema: f, it: g } = a, { oneOf: _ } = f;
      if (!g.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const b = c.propertyName;
      if (typeof b != "string")
        throw new Error("discriminator: requires propertyName");
      if (c.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!_)
        throw new Error("discriminator: requires oneOf keyword");
      const p = l.let("valid", !1), h = l.const("tag", (0, t._)`${u}${(0, t.getProperty)(b)}`);
      l.if((0, t._)`typeof ${h} == "string"`, () => y(), () => a.error(!1, { discrError: e.DiscrError.Tag, tag: h, tagName: b })), a.ok(p);
      function y() {
        const P = x();
        l.if(!1);
        for (const w in P)
          l.elseIf((0, t._)`${h} === ${w}`), l.assign(p, S(P[w]));
        l.else(), a.error(!1, { discrError: e.DiscrError.Mapping, tag: h, tagName: b }), l.endIf();
      }
      function S(P) {
        const w = l.name("valid"), C = a.subschema({ keyword: "oneOf", schemaProp: P }, w);
        return a.mergeEvaluated(C, t.Name), w;
      }
      function x() {
        var P;
        const w = {}, C = $(f);
        let k = !0;
        for (let I = 0; I < _.length; I++) {
          let F = _[I];
          if (F?.$ref && !(0, s.schemaHasRulesButRef)(F, g.self.RULES)) {
            const B = F.$ref;
            if (F = r.resolveRef.call(g.self, g.schemaEnv.root, g.baseId, B), F instanceof r.SchemaEnv && (F = F.schema), F === void 0)
              throw new n.default(g.opts.uriResolver, g.baseId, B);
          }
          const U = (P = F?.properties) === null || P === void 0 ? void 0 : P[b];
          if (typeof U != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${b}"`);
          k = k && (C || $(F)), T(U, I);
        }
        if (!k)
          throw new Error(`discriminator: "${b}" must be required`);
        return w;
        function $({ required: I }) {
          return Array.isArray(I) && I.includes(b);
        }
        function T(I, F) {
          if (I.const)
            E(I.const, F);
          else if (I.enum)
            for (const U of I.enum)
              E(U, F);
          else
            throw new Error(`discriminator: "properties/${b}" must have "const" or "enum"`);
        }
        function E(I, F) {
          if (typeof I != "string" || I in w)
            throw new Error(`discriminator: "${b}" values must be unique strings`);
          w[I] = F;
        }
      }
    }
  };
  return Ra.default = i, Ra;
}
const jD = "http://json-schema.org/draft-07/schema#", BD = "http://json-schema.org/draft-07/schema#", zD = "Core schema meta-schema", qD = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, UD = ["object", "boolean"], KD = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, WD = {
  $schema: jD,
  $id: BD,
  title: zD,
  definitions: qD,
  type: UD,
  properties: KD,
  default: !0
};
var Um;
function HD() {
  return Um || (Um = 1, (function(t, e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = e.Ajv = void 0;
    const r = sD(), n = RD(), s = LD(), o = WD, i = ["/properties"], a = "http://json-schema.org/draft-07/schema";
    class l extends r.default {
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((b) => this.addVocabulary(b)), this.opts.discriminator && this.addKeyword(s.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const b = this.opts.$data ? this.$dataMetaSchema(o, i) : o;
        this.addMetaSchema(b, a, !1), this.refs["http://json-schema.org/schema"] = a;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
      }
    }
    e.Ajv = l, t.exports = e = l, t.exports.Ajv = l, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l;
    var u = pu();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return u.KeywordCxt;
    } });
    var c = He();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return c._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return c.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return c.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return c.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return c.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return c.CodeGen;
    } });
    var f = Hh();
    Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
      return f.default;
    } });
    var g = mu();
    Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
      return g.default;
    } });
  })(ea, ea.exports)), ea.exports;
}
var GD = HD();
function YD({ params: { missingProperty: t, propertyName: e }, propertyName: r = e }, n) {
  let s = n;
  return s = t !== void 0 ? n.concat(t) : s, s = r !== void 0 ? n.concat(r, Md("key-input")) : s, s;
}
function _w({ params: { missingProperty: t }, parentSchema: e, message: r }, n) {
  if (!r)
    return "";
  if (t === void 0)
    return r;
  const s = n(t, e);
  return s === void 0 ? r : r.replace(t, s);
}
function XD({ uiSchema: t = {} }) {
  return (e, r) => ({
    value: r,
    errors: e.map((n) => {
      const s = hC(n.instancePath, r);
      return {
        path: YD(n, s),
        message: _w(n, (o, i) => {
          const a = vC(t, s.concat(o));
          if (a !== void 0)
            return a;
          const l = i?.properties?.[o];
          if (typeof l == "object")
            return l.title;
        })
      };
    })
  });
}
function ww(t) {
  return t.instancePath === "";
}
function JD(t) {
  return ww(t) && t.keyword !== "type";
}
function ZD(t) {
  return (e) => e.filter(t.required ? ww : JD).map((r) => _w(r, () => t.title));
}
function Sw(t, e, r, n) {
  t(e);
  const s = t.errors;
  return t.errors = null, s ? n(s, e) : r(e);
}
const QD = (t) => ({ value: t }), eM = () => [];
function tM({ compileSchema: t }) {
  return {
    isValid(e, r, n) {
      if (typeof e == "boolean")
        return e;
      const s = t(e, r);
      try {
        return s(n);
      } catch (o) {
        return console.warn("Failed to validate", o), !1;
      }
    }
  };
}
function rM(t) {
  const e = XD(t);
  return {
    validateFormValue(r, n) {
      return Sw(t.compileSchema(r, r), n, QD, e);
    }
  };
}
function nM({ compileFieldSchema: t }) {
  return {
    validateFieldValue(e, r) {
      return Sw(t(e), r, eM, ZD(e));
    }
  };
}
function sM({ ajvOptions: t = NT, ajvPlugins: e = jT, ajv: r = e(new GD.Ajv(t)), validatorsCache: n, compileSchema: s = BT(r, !1, n), compileFieldSchema: o = zT(r, !1), ...i } = {}) {
  const a = {
    ...i,
    compileSchema: s,
    compileFieldSchema: o
  };
  return Object.assign(tM(a), rM(a), nM(a));
}
function oM(t, e, { checkVisibility: r = !1 } = {}) {
  const n = t.querySelector(`[id="${e}"]`);
  return (n instanceof HTMLElement || n instanceof SVGElement) && n.tabIndex >= 0 && "disabled" in n && n.disabled !== !0 && (!r || window.getComputedStyle(n).visibility !== "hidden") ? n : null;
}
function iM(t, e) {
  return t.querySelector(`#${e}`);
}
function aM(t, e) {
  if (t !== null)
    return () => t.focus();
  const r = e();
  return r !== null ? () => r.scrollIntoView({ behavior: "auto", block: "center" }) : null;
}
function lM(t = {}) {
  return ({ errors: e }, r, n) => {
    if (e.length === 0)
      return !1;
    const s = r.target;
    if (!(s instanceof HTMLElement))
      return console.warn("Expected form to be an HTMLElement, got", s), !1;
    const { path: o } = e[0], i = aM(oM(s, qg(n, o), t), () => iM(s, qg(n, o.concat(Md("errors")))));
    return i === null ? !1 : Vl().then(i);
  };
}
const uM = "_";
function cM({ idPrefix: t = Ry, separator: e = uM } = {}) {
  return {
    fromPath: (r) => {
      let n = "";
      for (let s = 0; s < r.length; s++) {
        const o = r[s], i = TC(o);
        n += i !== void 0 ? `${e}${e}${i}` : `${e}${o}`;
      }
      return `${t}${n}`;
    }
  };
}
function dM({ jsonSchemaMerger: { mergeSchemaDefinitions: t, mergeArrayOfSchemaDefinitions: e } = TO(), jsonSchemaAllOfMerge: r = MO(e) } = {}) {
  return {
    mergeSchemas(n, s) {
      return t(n, s);
    },
    mergeAllOf(n) {
      return r(n);
    }
  };
}
function fM(t) {
  const e = dM(t);
  return {
    ...e,
    mergeFormDataAndSchemaDefaults({ formData: r, schema: n, initialDefaultsGenerated: s = !1, includeUndefinedValues: o = !1 }) {
      return tC(t.validator, e, n, r, t.schema, o, t, s);
    }
  };
}
const hM = {
  submit: "Submit",
  "array-schema-missing-items": "Missing items definition",
  yes: "Yes",
  no: "No",
  "multi-schema-option-label-with-title": ({ title: t, index: e }) => `${t} option ${e + 1}`,
  "multi-schema-option-label": ({ index: t }) => `Option ${t + 1}`,
  "add-array-item": "Add item",
  "copy-array-item": "Copy",
  "add-object-property": "Add property",
  "move-array-item-down": "Down",
  "move-array-item-up": "Up",
  "remove-array-item": "Del",
  "remove-object-property": "Del",
  edit: "Edit",
  clear: "Clear",
  "validation-process-error": ({ error: t }) => gM[t.reason],
  "component-not-found": ({ type: t }) => `"${t}" component not found`,
  "key-input-title": ({ name: t }) => `${t} Key`,
  "additional-property": "Additional property",
  "unknown-field-error": ({ schema: t }) => `You're seeing this error because your JSON Schema doesnâ€™t contain enough information
to determine its type. You can:
- specify the schema type (for example, using the 'type' keyword)
- specify which component to use via UiSchema
  ('{ "ui:components": { "unknownField": "myField" } }')
- specify which component to use by providing a custom 'resolver'
  (https://x0k.dev/svelte-jsonschema-form/guides/fields-resolution/)

JSON Schema:
${JSON.stringify(t, null, 2)}`
}, gM = {
  aborted: "Validation aborted",
  timeout: "Validation terminated by timeout",
  error: "Something went wrong during validation"
}, pM = Ii(hM);
var lc, Km;
function mM() {
  if (Km) return lc;
  Km = 1;
  function t(c) {
    return c === void 0;
  }
  function e(c) {
    return c === null;
  }
  function r(c) {
    return typeof c == "boolean";
  }
  function n(c) {
    return c === Object(c);
  }
  function s(c) {
    return Array.isArray(c);
  }
  function o(c) {
    return c instanceof Date;
  }
  function i(c, f) {
    return f ? n(c) && !t(c.uri) : n(c) && typeof c.size == "number" && typeof c.type == "string" && typeof c.slice == "function";
  }
  function a(c, f) {
    return i(c, f) && typeof c.name == "string" && (n(c.lastModifiedDate) || typeof c.lastModified == "number");
  }
  function l(c) {
    return t(c) ? !1 : c;
  }
  function u(c, f, g, _) {
    f = f || {}, g = g || new FormData(), f.indices = l(f.indices), f.nullsAsUndefineds = l(f.nullsAsUndefineds), f.booleansAsIntegers = l(f.booleansAsIntegers), f.allowEmptyArrays = l(f.allowEmptyArrays), f.noAttributesWithArrayNotation = l(
      f.noAttributesWithArrayNotation
    ), f.noFilesWithArrayNotation = l(f.noFilesWithArrayNotation), f.dotsForObjectNotation = l(f.dotsForObjectNotation);
    const b = typeof g.getParts == "function";
    return t(c) || (e(c) ? f.nullsAsUndefineds || g.append(_, "") : r(c) ? f.booleansAsIntegers ? g.append(_, c ? 1 : 0) : g.append(_, c) : s(c) ? c.length ? c.forEach((p, h) => {
      let y = _ + "[" + (f.indices ? h : "") + "]";
      (f.noAttributesWithArrayNotation || f.noFilesWithArrayNotation && a(p, b)) && (y = _), u(p, f, g, y);
    }) : f.allowEmptyArrays && g.append(f.noAttributesWithArrayNotation ? _ : _ + "[]", "") : o(c) ? g.append(_, c.toISOString()) : n(c) && !i(c, b) ? Object.keys(c).forEach((p) => {
      const h = c[p];
      if (s(h))
        for (; p.length > 2 && p.lastIndexOf("[]") === p.length - 2; )
          p = p.substring(0, p.length - 2);
      const y = _ ? f.dotsForObjectNotation ? _ + "." + p : _ + "[" + p + "]" : p;
      u(h, f, g, y);
    }) : g.append(_, c)), g;
  }
  return lc = {
    serialize: u
  }, lc;
}
var vM = mM(), yM = /* @__PURE__ */ ne("<!> <!>", 1);
function Xh(t, e) {
  W(e, !0);
  const r = (B) => {
    var R = M(), Z = D(R);
    te(
      Z,
      () => d($) ?? he,
      () => l,
      s,
      () => ({
        get current() {
          return n();
        },
        set current(Y) {
          n(Y);
        }
      }),
      () => d(w)
    ), A(B, R);
  };
  let n = v(e, "value", 15), s = v(e, "config", 7), o = v(e, "combinationKey", 7), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = Ee(), u = /* @__PURE__ */ O(() => Me(l, "multiFieldTemplate", s())), c = /* @__PURE__ */ O(() => Me(l, "selectWidget", s())), f = /* @__PURE__ */ O(() => {
    const { [o()]: B, ...R } = s().schema;
    if (go(s().schema) !== "object")
      return null;
    const Y = go(R);
    return {
      ...s(),
      schema: Y === "unknown" ? { type: "object" } : R
    };
  }), g = /* @__PURE__ */ O(() => d(f) && vo(l, d(f))), _ = /* @__PURE__ */ O(() => (s().schema[o()] ?? []).map((B) => typeof B != "boolean" ? Tr(l, B, n()) : {}));
  let b = /* @__PURE__ */ xe(void 0), p = /* @__PURE__ */ O(() => VC(l, n(), d(_), d(b) ?? 0, Fs(s().schema)));
  Xe(() => {
    const B = d(p);
    d(b) !== B && (n(ot(() => {
      const R = d(_)[B];
      if (R === void 0)
        return;
      const Z = d(b) !== void 0 ? d(_)[d(b)] : void 0;
      return Nd(l, {
        schema: R,
        formData: Z !== void 0 ? RC(l, R, Z, n()) : n(),
        includeUndefinedValues: "excludeObjectChildren"
      });
    })), q(b, B));
  });
  const h = /* @__PURE__ */ O(() => {
    const B = s().uiSchema[o()];
    return Array.isArray(B) ? B.map((R) => Yn(l, R)) : [];
  }), y = /* @__PURE__ */ O(() => {
    const B = Xr(l, s().uiSchema) ?? s().schema.title;
    return B ? (R) => a()("multi-schema-option-label-with-title", { index: R, title: B }) : (R) => a()("multi-schema-option-label", { index: R });
  }), S = /* @__PURE__ */ O(() => {
    const B = Fs(s().schema);
    return d(_).map((R, Z) => {
      if (B !== void 0) {
        const X = d(h)[Z]?.[B];
        if (typeof X == "object" && !Array.isArray(X)) {
          const J = Xr(l, Yn(l, X));
          if (J !== void 0)
            return J;
        }
        const ae = R.properties?.[B];
        if (ae !== void 0 && typeof ae != "boolean") {
          const { title: J } = Tr(l, ae, void 0);
          if (J !== void 0)
            return J;
        }
      }
      const Y = d(h)[Z];
      return (Y && Xr(l, Y)) ?? R.title ?? d(y)(Z);
    });
  }), x = /* @__PURE__ */ O(() => d(S).map((B, R) => ({
    id: Rs(l, s().path, R),
    label: B,
    value: R,
    disabled: !1
  }))), P = /* @__PURE__ */ O(() => {
    const B = o().toLowerCase(), R = Yn(l, s().uiSchema.combinationFieldOptionSelector);
    return {
      path: Mi(l, s().path, B),
      title: Xr(l, R) ?? s().title,
      schema: { type: "integer", default: 0 },
      uiSchema: R,
      required: !0
    };
  }), w = /* @__PURE__ */ O(() => kt(l, s().path)), C = /* @__PURE__ */ O(() => {
    const B = d(b) ?? d(p);
    if (B < 0)
      return null;
    const R = d(_)[B], { required: Z } = s().schema, Y = Z ? {
      ...R,
      required: R.required ? Z.concat(R.required) : Z
    } : R, X = B < d(h).length ? d(h)[B] : s().uiSchema;
    return {
      path: s().path,
      title: "",
      schema: Y,
      uiSchema: X,
      required: s().required
    };
  }), k = /* @__PURE__ */ O(() => d(C) && vo(l, d(C))), $ = /* @__PURE__ */ O(() => vr(l, s(), `${o()}Field`));
  var T = {
    get value() {
      return n();
    },
    set value(B) {
      n(B), m();
    },
    get config() {
      return s();
    },
    set config(B) {
      s(B), m();
    },
    get combinationKey() {
      return o();
    },
    set combinationKey(B) {
      o(B), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(B) {
      i(B), m();
    },
    get translate() {
      return a();
    },
    set translate(B) {
      a(B), m();
    }
  }, E = yM(), I = D(E);
  {
    var F = (B) => {
      var R = M(), Z = D(R);
      {
        let Y = /* @__PURE__ */ O(() => Vs(l, d(f)));
        Q(Z, () => d(g), (X, ae) => {
          ae(X, {
            type: "field",
            get config() {
              return d(f);
            },
            uiOption: (J) => Nt(l, d(f), J),
            get translate() {
              return d(Y);
            },
            get value() {
              return n();
            },
            set value(J) {
              n(J);
            }
          });
        });
      }
      A(B, R);
    };
    ue(I, (B) => {
      d(f) && B(F);
    });
  }
  var U = be(I, 2);
  {
    const B = (Z) => {
      var Y = M(), X = D(Y), ae = () => d(b) ?? d(p), J = (j) => q(p, j);
      Q(X, () => d(c), (j, ee) => {
        ee(j, {
          type: "widget",
          get errors() {
            return d(w);
          },
          handlers: {},
          get config() {
            return d(P);
          },
          uiOption: (L) => Nt(l, d(P), L),
          get options() {
            return d(x);
          },
          get value() {
            return ae();
          },
          set value(L) {
            J(L);
          }
        });
      }), A(Z, Y);
    };
    let R = /* @__PURE__ */ O(() => d($) && r);
    Q(U, () => d(u), (Z, Y) => {
      Y(Z, {
        type: "template",
        get config() {
          return s();
        },
        get value() {
          return n();
        },
        get errors() {
          return d(w);
        },
        get uiOption() {
          return i();
        },
        get action() {
          return d(R);
        },
        optionSelector: B,
        children: (X, ae) => {
          var J = M(), j = D(J);
          {
            var ee = (L) => {
              var N = M(), V = D(N);
              {
                let G = /* @__PURE__ */ O(() => Vs(l, d(C)));
                Q(V, () => d(k), (fe, se) => {
                  se(fe, {
                    type: "field",
                    get config() {
                      return d(C);
                    },
                    uiOption: (we) => Nt(l, d(C), we),
                    get translate() {
                      return d(G);
                    },
                    get value() {
                      return n();
                    },
                    set value(we) {
                      n(we);
                    }
                  });
                });
              }
              A(L, N);
            };
            ue(j, (L) => {
              d(C) && L(ee);
            });
          }
          A(X, J);
        },
        $$slots: { optionSelector: !0, default: !0 }
      });
    });
  }
  return A(t, E), H(T);
}
K(
  Xh,
  {
    value: {},
    config: {},
    combinationKey: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
class bM {
  array;
  nextKey;
  #e = /* @__PURE__ */ xe(0);
  get changesPropagator() {
    return d(this.#e);
  }
  set changesPropagator(e) {
    q(this.#e, e);
  }
  keys;
  constructor(e, r) {
    this.array = e, this.nextKey = r;
    const n = new Array(e.length);
    for (let s = 0; s < e.length; s++)
      n[s] = r();
    this.keys = n;
  }
  key(e) {
    return this.changesPropagator, this.keys[e];
  }
  push(e) {
    return this.keys.push(this.nextKey()), this.array.push(e);
  }
  swap(e, r) {
    const n = this.keys[e];
    if (this.keys[e] = this.keys[r], this.keys[r] = n, this.array[e] !== this.array[r]) {
      const s = this.array[e];
      this.array[e] = this.array[r], this.array[r] = s;
    }
    this.changesPropagator++;
  }
  insert(e, r) {
    this.keys.splice(e, 0, this.nextKey()), this.array.splice(e, 0, r);
  }
  remove(e) {
    return this.keys.splice(e, 1), this.array.splice(e, 1)[0];
  }
  splice(e, r, ...n) {
    const s = n.length;
    let o;
    if (s > 0) {
      const i = new Array(n.length);
      for (let a = 0; a < s; a++)
        i[a] = this.nextKey();
      this.keys.splice(e, r, ...i), o = this.array.splice(e, r, ...n);
    } else
      this.keys.splice(e, r), o = this.array.splice(e, r);
    return this.changesPropagator++, o;
  }
}
function _M(t, e, r) {
  return e >= r ? `${t}-${e - r + 1}` : t;
}
const xw = /* @__PURE__ */ Symbol("array-context");
function wM() {
  return Is(xw);
}
function SM(t) {
  Po(xw, t);
}
function Pw({ ctx: t, config: e, itemSchema: r, keyedArray: n, value: s }) {
  const o = (b) => Nt(t, e(), b);
  function i() {
    As(t, e().path, sl);
    const b = ib(t);
    !(b & wC) || b & Td && !t.isSubmitted || Cr(t, e(), s());
  }
  const a = /* @__PURE__ */ O(n), l = /* @__PURE__ */ O(() => kt(t, e().path)), u = /* @__PURE__ */ O(() => o("addable") ?? !0), c = /* @__PURE__ */ O(() => o("orderable") ?? !0), f = /* @__PURE__ */ O(() => o("removable") ?? !0), g = /* @__PURE__ */ O(() => o("copyable") ?? !1), _ = /* @__PURE__ */ O(() => o("itemTitle") ?? _M);
  return {
    config: e,
    uiOption: o,
    itemTitle(b, p, h, y) {
      return d(_)(b, p, h, y);
    },
    addable: () => d(u),
    orderable: () => d(c),
    removable: () => d(f),
    copyable: () => d(g),
    errors: () => d(l),
    key: (b) => d(a).key(b),
    pushItem: () => {
      const b = r();
      b !== void 0 && (d(a).push(Nd(t, { schema: b, formData: void 0 }) ?? My(go(b))), i());
    },
    moveItemUp(b) {
      d(a).swap(b, b - 1), i();
    },
    moveItemDown(b) {
      d(a).swap(b, b + 1), i();
    },
    copyItem(b) {
      d(a).insert(b, xo(s()[b])), i();
    },
    removeItem(b) {
      d(a).remove(b), i();
    }
  };
}
function Ow(t, e, r) {
  let n;
  return () => r() && (n = t().schema.maxItems, n === void 0 || e() < n);
}
function xM({ ctx: t, config: e, value: r, keyedArray: n }) {
  const s = /* @__PURE__ */ O(r), o = /* @__PURE__ */ O(() => {
    const { schema: { items: f } } = e();
    return Be(f) ? f : {};
  }), i = Pw({
    ctx: t,
    config: e,
    value: r,
    keyedArray: n,
    itemSchema: () => d(o)
  }), a = /* @__PURE__ */ O(() => {
    const { uiSchema: { items: f } } = e();
    return Yn(t, Array.isArray(f) ? void 0 : f);
  }), l = /* @__PURE__ */ O(() => Xr(t, d(a))), u = () => d(s)?.length ?? 0, c = /* @__PURE__ */ O(Ow(e, u, i.addable));
  return {
    ...i,
    length: u,
    set(f, g) {
      d(s)[f] = g;
    },
    canAdd() {
      return d(c);
    },
    canCopy() {
      return i.copyable() && d(c);
    },
    canRemove: i.removable,
    canMoveUp(f) {
      return i.orderable() && f > 0;
    },
    canMoveDown(f) {
      return i.orderable() && f < d(s).length - 1;
    },
    itemConfig(f, g, _) {
      const b = Tr(t, d(o), g);
      return Ql(t, {
        path: Xl(t, f.path, _),
        title: i.itemTitle(d(l) ?? b.title ?? f.title, _, 0, g),
        schema: b,
        uiSchema: d(a),
        required: !yy(b)
      });
    }
  };
}
function PM({ ctx: t, config: e, value: r, keyedArray: n }) {
  const s = /* @__PURE__ */ O(r), o = /* @__PURE__ */ O(() => {
    const { items: b } = e().schema;
    return Array.isArray(b) ? b.map((p, h) => {
      if (typeof p == "boolean")
        throw new Error("Invalid schema: items must be an array of schemas");
      return Tr(t, p, d(s)?.[h]);
    }) : [];
  }), i = (b) => b >= d(o).length, a = /* @__PURE__ */ O(() => {
    const { additionalItems: b } = e().schema;
    return Be(b) ? b : void 0;
  }), l = /* @__PURE__ */ O(n), u = Pw({
    ctx: t,
    config: e,
    value: r,
    keyedArray: () => d(l),
    itemSchema: () => d(a)
  }), c = /* @__PURE__ */ O(() => Math.max(d(s)?.length ?? 0, d(o).length)), f = () => d(c), g = /* @__PURE__ */ O(Ow(e, f, () => u.addable() && d(a) !== void 0));
  function _(b = my) {
    const p = new Array(d(c));
    b(p), d(l).splice(0, 0, ...p);
  }
  return {
    ...u,
    length: f,
    pushItem() {
      d(s) || _(), u.pushItem();
    },
    set(b, p) {
      d(s) ? d(s)[b] = p : _((h) => {
        h[b] = p;
      });
    },
    canAdd() {
      return d(g);
    },
    canCopy(b) {
      return u.copyable() && d(g) && i(b);
    },
    canRemove(b) {
      return u.removable() && i(b);
    },
    canMoveUp(b) {
      return u.orderable() && b > d(o).length;
    },
    canMoveDown(b) {
      return u.orderable() && b < d(c) - 1 && i(b);
    },
    itemConfig(b, p, h) {
      const y = i(h), S = Tr(
        t,
        y ? d(a) : d(o)[h],
        p
      ), x = Yn(t, y ? b.uiSchema.additionalItems : Array.isArray(b.uiSchema.items) ? b.uiSchema.items[h] : b.uiSchema.items);
      return Ql(t, {
        path: Xl(t, b.path, h),
        title: u.itemTitle(Xr(t, x) ?? S.title ?? b.title, h, d(o).length, p),
        schema: S,
        uiSchema: x,
        required: !yy(S)
      });
    }
  };
}
class OM {
  setValue;
  constructor(e) {
    this.setValue = e;
  }
  key(e) {
    return e;
  }
  push(e) {
    return this.setValue([e]), 1;
  }
  swap() {
    throw new Error('Method "swap" cannot be called on "VirtualKeyedArray" instance');
  }
  insert(e, r) {
    if (e !== 0)
      throw new Error(`Method "insert" cannot be called on "VirtualKeyedArray" instance with those args (index=${e}), expected (0)`);
    this.setValue([r]);
  }
  remove(e) {
    throw new Error('Method "remove" cannot be called on "VirtualKeyedArray" instance');
  }
  splice(e, r, ...n) {
    if (e !== 0 || r !== 0)
      throw new Error(`Method "splice" cannot be called on "VirtualKeyedArray" instance with those args(start=${e}, count=${r}) expected (0, 0)`);
    return this.setValue(n), [];
  }
}
function Jh(t, e) {
  W(e, !0);
  const r = (x) => {
    var P = M(), w = D(P);
    {
      let C = /* @__PURE__ */ O(() => f.errors());
      Q(w, () => d(b), (k, $) => {
        $(k, {
          get errors() {
            return d(C);
          },
          get config() {
            return o();
          },
          disabled: !1,
          type: "array-item-add",
          get onclick() {
            return f.pushItem;
          },
          children: (T, E) => {
            _n(T, {
              get config() {
                return o();
              },
              id: "add-array-item",
              get translate() {
                return l();
              }
            });
          },
          $$slots: { default: !0 }
        });
      });
    }
    A(x, P);
  }, n = (x) => {
    var P = M(), w = D(P);
    {
      let C = /* @__PURE__ */ O(() => f.errors());
      te(
        w,
        () => d(p) ?? he,
        () => c,
        o,
        () => ({
          get current() {
            return s();
          },
          set current(k) {
            s(k);
          }
        }),
        () => d(C)
      );
    }
    A(x, P);
  };
  let s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "createContext", 7), a = v(e, "uiOption", 7), l = v(e, "translate", 7), u = v(e, "field", 7);
  const c = Ee(), f = i()({
    ctx: c,
    config: () => o(),
    value: () => s(),
    keyedArray: lk(c, () => s(), () => new OM((x) => s(x)), (x, P) => new bM(x, P))
  });
  SM(f);
  const g = /* @__PURE__ */ O(() => Me(c, "arrayItemField", o())), _ = /* @__PURE__ */ O(() => Me(c, "arrayTemplate", o())), b = /* @__PURE__ */ O(() => Me(c, "button", o())), p = /* @__PURE__ */ O(() => vr(c, o(), u()));
  var h = {
    get value() {
      return s();
    },
    set value(x) {
      s(x), m();
    },
    get config() {
      return o();
    },
    set config(x) {
      o(x), m();
    },
    get createContext() {
      return i();
    },
    set createContext(x) {
      i(x), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(x) {
      a(x), m();
    },
    get translate() {
      return l();
    },
    set translate(x) {
      l(x), m();
    },
    get field() {
      return u();
    },
    set field(x) {
      u(x), m();
    }
  }, y = M(), S = D(y);
  {
    let x = /* @__PURE__ */ O(() => f.errors()), P = /* @__PURE__ */ O(() => f.canAdd() ? r : void 0), w = /* @__PURE__ */ O(() => d(p) && n);
    Q(S, () => d(_), (C, k) => {
      k(C, {
        type: "template",
        get errors() {
          return d(x);
        },
        get config() {
          return o();
        },
        get value() {
          return s();
        },
        get uiOption() {
          return a();
        },
        get addButton() {
          return d(P);
        },
        get action() {
          return d(w);
        },
        children: ($, T) => {
          var E = M(), I = D(E);
          nt(I, 19, () => ({ length: f.length() }), (F, U) => f.key(U), (F, U, B) => {
            const R = /* @__PURE__ */ O(() => f.itemConfig(o(), s()?.[d(B)], d(B)));
            var Z = M(), Y = D(Z), X = () => s()?.[d(B)], ae = (J) => f.set(d(B), J);
            {
              let J = /* @__PURE__ */ O(() => Vs(c, d(R)));
              Q(Y, () => d(g), (j, ee) => {
                ee(j, {
                  type: "field",
                  get index() {
                    return d(B);
                  },
                  get config() {
                    return d(R);
                  },
                  get value() {
                    return X();
                  },
                  set value(L) {
                    ae(L);
                  },
                  uiOption: (L) => Nt(c, d(R), L),
                  get translate() {
                    return d(J);
                  }
                });
              });
            }
            A(F, Z);
          }), A($, E);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, y), H(h);
}
K(
  Jh,
  {
    value: {},
    config: {},
    createContext: {},
    uiOption: {},
    translate: {},
    field: {}
  },
  [],
  [],
  { mode: "open" }
);
function Cw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return Jh(t, {
    type: "field",
    field: "arrayField",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get createContext() {
      return xM;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), H(i);
}
K(Cw, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function kw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return Jh(t, {
    type: "field",
    field: "tupleField",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get createContext() {
      return PM;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), H(i);
}
K(kw, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
var CM = /* @__PURE__ */ ne("<!> <!>", 1), kM = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function $w(t, e) {
  W(e, !0);
  const r = (C) => {
    var k = kM(), $ = D(k);
    {
      var T = (B) => {
        var R = CM(), Z = D(R);
        {
          let X = /* @__PURE__ */ O(() => !d(p));
          Q(Z, () => d(g), (ae, J) => {
            J(ae, {
              get errors() {
                return d(S);
              },
              get config() {
                return o();
              },
              type: "array-item-move-up",
              get disabled() {
                return d(X);
              },
              onclick: () => {
                u.moveItemUp(n());
              },
              children: (j, ee) => {
                _n(j, {
                  get config() {
                    return o();
                  },
                  id: "move-array-item-up",
                  get translate() {
                    return a();
                  }
                });
              },
              $$slots: { default: !0 }
            });
          });
        }
        var Y = be(Z, 2);
        {
          let X = /* @__PURE__ */ O(() => !d(h));
          Q(Y, () => d(g), (ae, J) => {
            J(ae, {
              get errors() {
                return d(S);
              },
              get config() {
                return o();
              },
              get disabled() {
                return d(X);
              },
              type: "array-item-move-down",
              onclick: () => {
                u.moveItemDown(n());
              },
              children: (j, ee) => {
                _n(j, {
                  get config() {
                    return o();
                  },
                  id: "move-array-item-down",
                  get translate() {
                    return a();
                  }
                });
              },
              $$slots: { default: !0 }
            });
          });
        }
        A(B, R);
      };
      ue($, (B) => {
        u.orderable() && B(T);
      });
    }
    var E = be($, 2);
    {
      var I = (B) => {
        var R = M(), Z = D(R);
        Q(Z, () => d(g), (Y, X) => {
          X(Y, {
            get errors() {
              return d(S);
            },
            get config() {
              return o();
            },
            type: "array-item-copy",
            onclick: () => {
              u.copyItem(n());
            },
            disabled: !1,
            children: (ae, J) => {
              _n(ae, {
                get config() {
                  return o();
                },
                id: "copy-array-item",
                get translate() {
                  return a();
                }
              });
            },
            $$slots: { default: !0 }
          });
        }), A(B, R);
      };
      ue(E, (B) => {
        d(_) && B(I);
      });
    }
    var F = be(E, 2);
    {
      var U = (B) => {
        var R = M(), Z = D(R);
        Q(Z, () => d(g), (Y, X) => {
          X(Y, {
            get errors() {
              return d(S);
            },
            get config() {
              return o();
            },
            disabled: !1,
            type: "array-item-remove",
            onclick: () => {
              u.removeItem(n());
            },
            children: (ae, J) => {
              _n(ae, {
                get config() {
                  return o();
                },
                id: "remove-array-item",
                get translate() {
                  return a();
                }
              });
            },
            $$slots: { default: !0 }
          });
        }), A(B, R);
      };
      ue(F, (B) => {
        d(b) && B(U);
      });
    }
    A(C, k);
  };
  let n = v(e, "index", 7), s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = Ee(), u = wM(), c = /* @__PURE__ */ O(() => Me(l, "arrayItemTemplate", o())), f = /* @__PURE__ */ O(() => vo(l, o())), g = /* @__PURE__ */ O(() => Me(l, "button", o())), _ = /* @__PURE__ */ O(() => u.canCopy(n())), b = /* @__PURE__ */ O(() => u.canRemove(n())), p = /* @__PURE__ */ O(() => u.canMoveUp(n())), h = /* @__PURE__ */ O(() => u.canMoveDown(n())), y = /* @__PURE__ */ O(() => d(_) || d(b) || d(p) || d(h)), S = /* @__PURE__ */ O(() => kt(l, o().path));
  var x = {
    get index() {
      return n();
    },
    set index(C) {
      n(C), m();
    },
    get value() {
      return s();
    },
    set value(C) {
      s(C), m();
    },
    get config() {
      return o();
    },
    set config(C) {
      o(C), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(C) {
      i(C), m();
    },
    get translate() {
      return a();
    },
    set translate(C) {
      a(C), m();
    }
  }, P = M(), w = D(P);
  {
    let C = /* @__PURE__ */ O(() => d(y) ? r : void 0);
    Q(w, () => d(c), (k, $) => {
      $(k, {
        type: "template",
        get index() {
          return n();
        },
        get value() {
          return s();
        },
        get config() {
          return o();
        },
        get errors() {
          return d(S);
        },
        get buttons() {
          return d(C);
        },
        get uiOption() {
          return i();
        },
        children: (T, E) => {
          var I = M(), F = D(I);
          Q(F, () => d(f), (U, B) => {
            B(U, {
              type: "field",
              get config() {
                return o();
              },
              get uiOption() {
                return i();
              },
              get translate() {
                return a();
              },
              get value() {
                return s();
              },
              set value(R) {
                s(R);
              }
            });
          }), A(T, I);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, P), H(x);
}
K(
  $w,
  {
    index: {},
    value: {},
    config: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
function Wm(t, e, r) {
  let n = 0, s;
  do
    s = r(e, n++);
  while (s in t);
  return s;
}
function $M(t, e) {
  return e === 0 ? t : `${t}-${e}`;
}
function AM(t) {
  const e = [], r = Object.keys(t);
  for (const n of r) {
    const s = t[n];
    !er(s) || Bl in s || e.push(n);
  }
  return e.length < r.length && e.push("*"), e;
}
const Aw = /* @__PURE__ */ Symbol("object-context");
function Ew() {
  return Is(Aw);
}
function EM(t) {
  Po(Aw, t);
}
function TM({ ctx: t, config: e, value: r, setValue: n, translate: s }) {
  const o = /* @__PURE__ */ O(() => Tr(t, e().schema, r(), !0));
  let i;
  const a = /* @__PURE__ */ O(() => {
    const y = xo(d(o).properties);
    return xy(i, y) || (i = y), i;
  });
  Xe(() => {
    d(a), LC(t);
  });
  const l = (y) => Nt(t, e(), y), u = /* @__PURE__ */ O(() => Be(d(a)) ? iC(d(a), l("order") ?? AM(d(a))) : []), c = /* @__PURE__ */ O(() => new Set(d(o).required)), f = /* @__PURE__ */ O(() => {
    const { additionalProperties: y, patternProperties: S } = d(o);
    let x;
    if (S !== void 0 && (x = Object.keys(S), x.length > 0)) {
      const P = x.map((C) => {
        const k = S[C];
        return [
          new RegExp(C),
          typeof k == "boolean" ? {} : k
        ];
      }), w = Be(y) ? (C) => Tr(t, y, C) : () => P[0][1];
      return (C, k) => Tr(t, P.find(([$]) => $.test(k))?.[1] ?? w(C), C);
    }
    return Be(y) ? (P) => Tr(t, y, P) : () => ({});
  }), g = /* @__PURE__ */ O(() => l("expandable") !== !1 && uC(d(o), r())), _ = /* @__PURE__ */ O(() => kt(t, e().path)), b = /* @__PURE__ */ O(() => s("additional-property", {}));
  function p(y) {
    As(t, e().path, sl);
    const S = ib(t);
    !(S & SC) || S & Td && !t.isSubmitted || Cr(t, e(), y);
  }
  const h = /* @__PURE__ */ O(() => l("additionalPropertyKey") ?? $M);
  return {
    errors() {
      return d(_);
    },
    canExpand() {
      return d(g);
    },
    propertiesOrder() {
      return d(u);
    },
    isAdditionalProperty(y) {
      return aC(d(a), y);
    },
    propertyConfig(y, S, x) {
      const P = d(a)[S] ?? !1, w = typeof P == "boolean" ? {} : Tr(t, P, r()?.[S]), C = Yn(t, x ? y.uiSchema.additionalProperties : y.uiSchema[S]);
      return Ql(t, {
        path: Xl(t, y.path, S),
        title: Xr(t, C) ?? w.title ?? S,
        schema: w,
        uiSchema: C,
        required: d(c).has(S)
      });
    },
    addProperty() {
      let y = r();
      const S = y ? Wm(y, d(b), d(h)) : d(h)(d(b), 0), x = d(f)(y, S), P = Nd(t, { schema: x, formData: void 0 }) ?? My(go(x));
      y ? y[S] = P : (y = { [S]: P }, n(y)), p(y);
    },
    removeProperty(y) {
      const S = r();
      S && (delete S[y], p(S));
    },
    renameProperty(y, S, x) {
      const P = r();
      if (!P)
        return;
      const w = Wm(P, S, d(h));
      qC(t, e(), w, x) && (P[w] = P[y], delete P[y], p(P));
    }
  };
}
const DM = "objectField";
function Tw(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    {
      let P = /* @__PURE__ */ O(() => u.errors());
      Q(x, () => d(g), (w, C) => {
        C(w, {
          type: "object-property-add",
          get config() {
            return o();
          },
          get errors() {
            return d(P);
          },
          disabled: !1,
          get onclick() {
            return u.addProperty;
          },
          children: (k, $) => {
            _n(k, {
              get config() {
                return o();
              },
              id: "add-object-property",
              get translate() {
                return l();
              }
            });
          },
          $$slots: { default: !0 }
        });
      });
    }
    A(y, S);
  }, n = (y) => {
    var S = M(), x = D(S);
    {
      let P = /* @__PURE__ */ O(() => u.errors());
      te(
        x,
        () => d(_) ?? he,
        () => s,
        o,
        () => ({
          get current() {
            return i();
          },
          set current(w) {
            i(w);
          }
        }),
        () => d(P)
      );
    }
    A(y, S);
  }, s = Ee();
  let o = v(e, "config", 7), i = v(e, "value", 15), a = v(e, "uiOption", 7), l = v(e, "translate", 7);
  const u = TM({
    ctx: s,
    config: () => o(),
    value: () => i(),
    setValue: (y) => i(y),
    translate: l()
  });
  EM(u);
  const c = /* @__PURE__ */ O(() => Me(s, "objectPropertyField", o())), f = /* @__PURE__ */ O(() => Me(s, "objectTemplate", o())), g = /* @__PURE__ */ O(() => Me(s, "button", o())), _ = /* @__PURE__ */ O(() => vr(s, o(), DM));
  var b = {
    get config() {
      return o();
    },
    set config(y) {
      o(y), m();
    },
    get value() {
      return i();
    },
    set value(y) {
      i(y), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(y) {
      a(y), m();
    },
    get translate() {
      return l();
    },
    set translate(y) {
      l(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => u.errors()), S = /* @__PURE__ */ O(() => u.canExpand() ? r : void 0), x = /* @__PURE__ */ O(() => d(_) && n);
    Q(h, () => d(f), (P, w) => {
      w(P, {
        type: "template",
        get value() {
          return i();
        },
        get config() {
          return o();
        },
        get uiOption() {
          return a();
        },
        get errors() {
          return d(y);
        },
        get addButton() {
          return d(S);
        },
        get action() {
          return d(x);
        },
        children: (C, k) => {
          var $ = M(), T = D($);
          nt(T, 16, () => u.propertiesOrder(), (E) => E, (E, I) => {
            const F = /* @__PURE__ */ O(() => u.isAdditionalProperty(I)), U = /* @__PURE__ */ O(() => u.propertyConfig(o(), I, d(F)));
            var B = M(), R = D(B), Z = () => i()?.[I], Y = (X) => {
              const ae = i();
              ae ? ae[I] = X : i({ [I]: X });
            };
            {
              let X = /* @__PURE__ */ O(() => Vs(s, d(U)));
              Q(R, () => d(c), (ae, J) => {
                J(ae, {
                  type: "field",
                  get property() {
                    return I;
                  },
                  get isAdditional() {
                    return d(F);
                  },
                  get value() {
                    return Z();
                  },
                  set value(j) {
                    Y(j);
                  },
                  get config() {
                    return d(U);
                  },
                  uiOption: (j) => Nt(s, d(U), j),
                  get translate() {
                    return d(X);
                  }
                });
              });
            }
            A(E, B);
          }), A(C, $);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Tw, { config: {}, value: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Dw(t, e) {
  W(e, !0);
  const r = v(e, "parent", 7), n = v(e, "property", 7), s = v(e, "uiSchema", 7), o = v(e, "translate", 7), i = Ee(), a = Ew(), l = /* @__PURE__ */ O(() => ({
    path: Mi(i, r().path, "key-input"),
    title: Xr(i, s()) ?? o()("key-input-title", { name: n() }),
    schema: { type: "string" },
    uiSchema: s(),
    required: !0
  })), u = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", d(l))), c = "textWidget", f = /* @__PURE__ */ O(() => Me(i, c, d(l)));
  let g = /* @__PURE__ */ O(n);
  const _ = {
    onblur: () => {
      d(g) === void 0 || d(g) === n() || a.renameProperty(n(), d(g), d(l));
    }
  }, b = /* @__PURE__ */ O(() => kt(i, d(l).path)), p = (x) => Nt(i, d(l), x);
  var h = {
    get parent() {
      return r();
    },
    set parent(x) {
      r(x), m();
    },
    get property() {
      return n();
    },
    set property(x) {
      n(x), m();
    },
    get uiSchema() {
      return s();
    },
    set uiSchema(x) {
      s(x), m();
    },
    get translate() {
      return o();
    },
    set translate(x) {
      o(x), m();
    }
  }, y = M(), S = D(y);
  return Q(S, () => d(u), (x, P) => {
    P(x, {
      type: "template",
      showTitle: !0,
      useLabel: !0,
      widgetType: c,
      get value() {
        return n();
      },
      get config() {
        return d(l);
      },
      get errors() {
        return d(b);
      },
      uiOption: p,
      children: (w, C) => {
        var k = M(), $ = D(k);
        Q($, () => d(f), (T, E) => {
          E(T, {
            type: "widget",
            get errors() {
              return d(b);
            },
            get handlers() {
              return _;
            },
            get config() {
              return d(l);
            },
            uiOption: p,
            get value() {
              return d(g);
            },
            set value(I) {
              q(g, I);
            }
          });
        }), A(w, k);
      },
      $$slots: { default: !0 }
    });
  }), A(t, y), H(h);
}
K(Dw, { parent: {}, property: {}, uiSchema: {}, translate: {} }, [], [], { mode: "open" });
function Mw(t, e) {
  W(e, !0);
  const r = (x) => {
    {
      let P = /* @__PURE__ */ O(() => Yn(c, s().uiSchema.additionalPropertyKeyInput));
      Dw(x, {
        get translate() {
          return u();
        },
        get property() {
          return o();
        },
        get parent() {
          return s();
        },
        get uiSchema() {
          return d(P);
        }
      });
    }
  }, n = (x) => {
    var P = M(), w = D(P);
    Q(w, () => d(b), (C, k) => {
      k(C, {
        get errors() {
          return d(p);
        },
        get config() {
          return s();
        },
        type: "object-property-remove",
        disabled: !1,
        onclick: () => {
          f.removeProperty(o());
        },
        children: ($, T) => {
          _n($, {
            get config() {
              return s();
            },
            id: "remove-object-property",
            get translate() {
              return u();
            }
          });
        },
        $$slots: { default: !0 }
      });
    }), A(x, P);
  };
  let s = v(e, "config", 7), o = v(e, "property", 7), i = v(e, "isAdditional", 7), a = v(e, "value", 15), l = v(e, "uiOption", 7), u = v(e, "translate", 7);
  const c = Ee(), f = Ew(), g = /* @__PURE__ */ O(() => Me(c, "objectPropertyTemplate", s())), _ = /* @__PURE__ */ O(() => vo(c, s())), b = /* @__PURE__ */ O(() => Me(c, "button", s())), p = /* @__PURE__ */ O(() => kt(c, s().path));
  var h = {
    get config() {
      return s();
    },
    set config(x) {
      s(x), m();
    },
    get property() {
      return o();
    },
    set property(x) {
      o(x), m();
    },
    get isAdditional() {
      return i();
    },
    set isAdditional(x) {
      i(x), m();
    },
    get value() {
      return a();
    },
    set value(x) {
      a(x), m();
    },
    get uiOption() {
      return l();
    },
    set uiOption(x) {
      l(x), m();
    },
    get translate() {
      return u();
    },
    set translate(x) {
      u(x), m();
    }
  }, y = M(), S = D(y);
  {
    let x = /* @__PURE__ */ O(() => i() ? r : void 0), P = /* @__PURE__ */ O(() => i() ? n : void 0);
    Q(S, () => d(g), (w, C) => {
      C(w, {
        type: "template",
        get property() {
          return o();
        },
        get value() {
          return a();
        },
        get config() {
          return s();
        },
        get errors() {
          return d(p);
        },
        get keyInput() {
          return d(x);
        },
        get removeButton() {
          return d(P);
        },
        get uiOption() {
          return l();
        },
        children: (k, $) => {
          var T = M(), E = D(T);
          Q(E, () => d(_), (I, F) => {
            F(I, {
              type: "field",
              get config() {
                return s();
              },
              get uiOption() {
                return l();
              },
              get translate() {
                return u();
              },
              get value() {
                return a();
              },
              set value(U) {
                a(U);
              }
            });
          }), A(k, T);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, y), H(h);
}
K(
  Mw,
  {
    config: {},
    property: {},
    isAdditional: {},
    value: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
function zi(t, e) {
  W(e, !0);
  const r = (w) => {
    var C = M(), k = D(C);
    te(
      k,
      () => d(y) ?? he,
      () => n,
      a,
      () => ({
        get current() {
          return i();
        },
        set current($) {
          i($);
        }
      }),
      () => d(h)
    ), A(w, C);
  }, n = Ee();
  let s = v(e, "field", 7), o = v(e, "widgetType", 7), i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "uiOption", 7), u = v(e, "fromValue", 7), c = v(e, "toValue", 7), f = v(e, "showTitle", 7), g = v(e, "useLabel", 7);
  const _ = /* @__PURE__ */ O(() => Me(n, "fieldTemplate", a())), b = /* @__PURE__ */ O(() => Me(n, o(), a())), p = un(n, () => a(), () => Cr(n, a(), i())), h = /* @__PURE__ */ O(() => kt(n, a().path)), y = /* @__PURE__ */ O(() => vr(n, a(), s()));
  var S = {
    get field() {
      return s();
    },
    set field(w) {
      s(w), m();
    },
    get widgetType() {
      return o();
    },
    set widgetType(w) {
      o(w), m();
    },
    get value() {
      return i();
    },
    set value(w) {
      i(w), m();
    },
    get config() {
      return a();
    },
    set config(w) {
      a(w), m();
    },
    get uiOption() {
      return l();
    },
    set uiOption(w) {
      l(w), m();
    },
    get fromValue() {
      return u();
    },
    set fromValue(w) {
      u(w), m();
    },
    get toValue() {
      return c();
    },
    set toValue(w) {
      c(w), m();
    },
    get showTitle() {
      return f();
    },
    set showTitle(w) {
      f(w), m();
    },
    get useLabel() {
      return g();
    },
    set useLabel(w) {
      g(w), m();
    }
  }, x = M(), P = D(x);
  {
    let w = /* @__PURE__ */ O(() => d(y) && r);
    Q(P, () => d(_), (C, k) => {
      k(C, {
        type: "template",
        get showTitle() {
          return f();
        },
        get useLabel() {
          return g();
        },
        get widgetType() {
          return o();
        },
        get uiOption() {
          return l();
        },
        get value() {
          return i();
        },
        get config() {
          return a();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(w);
        },
        children: ($, T) => {
          var E = M(), I = D(E), F = () => u()(i()), U = (B) => i(c()(B));
          Q(I, () => d(b), (B, R) => {
            R(B, {
              type: "widget",
              get config() {
                return a();
              },
              get errors() {
                return d(h);
              },
              get uiOption() {
                return l();
              },
              get value() {
                return F();
              },
              set value(Z) {
                U(Z);
              },
              get handlers() {
                return p;
              }
            });
          }), A($, E);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, x), H(S);
}
K(
  zi,
  {
    field: {},
    widgetType: {},
    value: {},
    config: {},
    uiOption: {},
    fromValue: {},
    toValue: {},
    showTitle: {},
    useLabel: {}
  },
  [],
  [],
  { mode: "open" }
);
const MM = "booleanField";
function Iw(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "uiOption", 7);
  var o = {
    get config() {
      return r();
    },
    set config(i) {
      r(i), m();
    },
    get value() {
      return n();
    },
    set value(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  {
    let i = /* @__PURE__ */ O(() => s()("hideTitle") === !1);
    zi(t, {
      field: MM,
      get config() {
        return r();
      },
      get uiOption() {
        return s();
      },
      widgetType: "checkboxWidget",
      get showTitle() {
        return d(i);
      },
      useLabel: !0,
      fromValue: (a) => a ?? void 0,
      get toValue() {
        return rl;
      },
      get value() {
        return n();
      },
      set value(a) {
        n(a);
      }
    });
  }
  return H(o);
}
K(Iw, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
const IM = "integerField";
function Nw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  var o = {
    get value() {
      return r();
    },
    set value(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(l) {
      s(l), m();
    }
  }, i = () => r(), a = (l) => {
    Number.isInteger(l) ? r(l) : l === void 0 && r(s()("numberEmptyValue"));
  };
  return zi(t, {
    field: IM,
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "numberWidget",
    get value() {
      return i();
    },
    set value(l) {
      a(l);
    },
    fromValue: (l) => l ?? void 0,
    get toValue() {
      return rl;
    }
  }), H(o);
}
K(Nw, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
function Fw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  Xe(() => {
    r() === void 0 && r(null);
  });
  const o = Ee(), i = /* @__PURE__ */ O(() => Me(o, "fieldTemplate", n())), a = /* @__PURE__ */ O(() => kt(o, n().path));
  var l = {
    get value() {
      return r();
    },
    set value(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(f) {
      s(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(i), (f, g) => {
    g(f, {
      type: "template",
      showTitle: !0,
      useLabel: !1,
      widgetType: "nullField",
      get uiOption() {
        return s();
      },
      get errors() {
        return d(a);
      },
      get value() {
        return r();
      },
      get config() {
        return n();
      },
      children: (_, b) => {
        St();
        var p = st();
        p.nodeValue = "", A(_, p);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), H(l);
}
K(Fw, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
const NM = "numberField";
function Rw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  var o = {
    get value() {
      return r();
    },
    set value(i) {
      r(i), m();
    },
    get config() {
      return n();
    },
    set config(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  return zi(t, {
    field: NM,
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "numberWidget",
    fromValue: (i) => i ?? void 0,
    toValue: (i) => i ?? s()("numberEmptyValue"),
    get value() {
      return r();
    },
    set value(i) {
      r(i);
    }
  }), H(o);
}
K(Rw, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
const FM = "stringField";
function Zh(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "uiOption", 7);
  var o = {
    get config() {
      return r();
    },
    set config(i) {
      r(i), m();
    },
    get value() {
      return n();
    },
    set value(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  return zi(t, {
    field: FM,
    get config() {
      return r();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "textWidget",
    fromValue: (i) => i ?? void 0,
    toValue: (i) => i || s()("stringEmptyValue"),
    get value() {
      return n();
    },
    set value(i) {
      n(i);
    }
  }), H(o);
}
K(Zh, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function Vw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return Xh(t, {
    type: "field",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get combinationKey() {
      return so;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), H(i);
}
K(Vw, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Lw(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "uiOption", 7), s = v(e, "value", 15), o = v(e, "translate", 7);
  var i = {
    get config() {
      return r();
    },
    set config(a) {
      r(a), m();
    },
    get uiOption() {
      return n();
    },
    set uiOption(a) {
      n(a), m();
    },
    get value() {
      return s();
    },
    set value(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return Xh(t, {
    type: "field",
    get config() {
      return r();
    },
    get uiOption() {
      return n();
    },
    get translate() {
      return o();
    },
    get combinationKey() {
      return oo;
    },
    get value() {
      return s();
    },
    set value(a) {
      s(a);
    }
  }), H(i);
}
K(Lw, { config: {}, uiOption: {}, value: {}, translate: {} }, [], [], { mode: "open" });
function jw(t, e) {
  W(e, !0);
  const r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7), i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = /* @__PURE__ */ O(() => kt(i, n().path));
  var u = {
    get value() {
      return r();
    },
    set value(g) {
      r(g), m();
    },
    get config() {
      return n();
    },
    set config(g) {
      n(g), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(g) {
      s(g), m();
    },
    get translate() {
      return o();
    },
    set translate(g) {
      o(g), m();
    }
  }, c = M(), f = D(c);
  return Q(f, () => d(a), (g, _) => {
    _(g, {
      type: "template",
      showTitle: !0,
      useLabel: !1,
      widgetType: "unknownField",
      get uiOption() {
        return s();
      },
      get errors() {
        return d(l);
      },
      get config() {
        return n();
      },
      value: void 0,
      children: (b, p) => {
        {
          let h = /* @__PURE__ */ O(() => o()("unknown-field-error", { schema: n().schema }));
          Rd(b, {
            get message() {
              return d(h);
            }
          });
        }
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), H(u);
}
K(jw, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
const RM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anyOfField: Vw,
  arrayField: Cw,
  arrayItemField: $w,
  booleanField: Iw,
  integerField: Nw,
  nullField: Fw,
  numberField: Rw,
  objectField: Tw,
  objectPropertyField: Mw,
  oneOfField: Lw,
  stringField: Zh,
  tupleField: kw,
  unknownField: jw
}, Symbol.toStringTag, { value: "Module" }));
function Qh(t, e) {
  return {
    title: e.title,
    showMeta: t("hideTitle") !== !0,
    description: t("description") ?? e.schema.description
  };
}
var VM = /* @__PURE__ */ ne("<!> <!>", 1), LM = /* @__PURE__ */ ne("<!> <!>", 1), jM = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function Bw(t, e) {
  W(e, !0);
  const r = "fieldTemplate", n = v(e, "children", 7), s = v(e, "config", 7), o = v(e, "uiOption", 7), i = v(e, "showTitle", 7), a = v(e, "useLabel", 7), l = v(e, "errors", 7), u = v(e, "action", 7), c = Ee(), f = /* @__PURE__ */ O(() => Me(c, "layout", s())), g = /* @__PURE__ */ O(() => Me(c, o()("useLabel") ?? a() ? "label" : "title", s())), _ = /* @__PURE__ */ O(() => Me(c, "description", s())), b = /* @__PURE__ */ O(() => Me(c, "errorsList", s())), p = /* @__PURE__ */ O(() => Me(c, "help", s())), h = /* @__PURE__ */ O(() => Qh(o(), s())), y = /* @__PURE__ */ O(() => d(h).title), S = /* @__PURE__ */ O(() => d(h).description), x = /* @__PURE__ */ O(() => d(h).showMeta), P = /* @__PURE__ */ O(() => o()("help"));
  var w = {
    get children() {
      return n();
    },
    set children($) {
      n($), m();
    },
    get config() {
      return s();
    },
    set config($) {
      s($), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption($) {
      o($), m();
    },
    get showTitle() {
      return i();
    },
    set showTitle($) {
      i($), m();
    },
    get useLabel() {
      return a();
    },
    set useLabel($) {
      a($), m();
    },
    get errors() {
      return l();
    },
    set errors($) {
      l($), m();
    },
    get action() {
      return u();
    },
    set action($) {
      u($), m();
    }
  }, C = M(), k = D(C);
  return Q(k, () => d(f), ($, T) => {
    T($, {
      type: "field",
      get config() {
        return s();
      },
      get errors() {
        return l();
      },
      children: (E, I) => {
        var F = jM(), U = D(F);
        {
          var B = (J) => {
            var j = M(), ee = D(j);
            Q(ee, () => d(f), (L, N) => {
              N(L, {
                type: "field-meta",
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                },
                children: (V, G) => {
                  var fe = LM(), se = D(fe);
                  {
                    var we = (oe) => {
                      var pe = M(), ye = D(pe);
                      Q(ye, () => d(f), (Pe, Oe) => {
                        Oe(Pe, {
                          type: "field-title-row",
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          },
                          children: (Ve, Ke) => {
                            var Le = VM(), je = D(Le);
                            Q(je, () => d(g), (gt, Ze) => {
                              Ze(gt, {
                                templateType: r,
                                get title() {
                                  return d(y);
                                },
                                get config() {
                                  return s();
                                },
                                get errors() {
                                  return l();
                                }
                              });
                            });
                            var We = be(je, 2);
                            te(We, () => u() ?? he), A(Ve, Le);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(oe, pe);
                    };
                    ue(se, (oe) => {
                      i() && d(y) && oe(we);
                    });
                  }
                  var le = be(se, 2);
                  {
                    var re = (oe) => {
                      var pe = M(), ye = D(pe);
                      Q(ye, () => d(_), (Pe, Oe) => {
                        Oe(Pe, {
                          templateType: r,
                          get description() {
                            return d(S);
                          },
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          }
                        });
                      }), A(oe, pe);
                    };
                    ue(le, (oe) => {
                      d(S) && oe(re);
                    });
                  }
                  A(V, fe);
                },
                $$slots: { default: !0 }
              });
            }), A(J, j);
          };
          ue(U, (J) => {
            d(x) && (i() && d(y) || d(S)) && J(B);
          });
        }
        var R = be(U, 2);
        Q(R, () => d(f), (J, j) => {
          j(J, {
            type: "field-content",
            get config() {
              return s();
            },
            get errors() {
              return l();
            },
            children: (ee, L) => {
              var N = M(), V = D(N);
              te(V, n), A(ee, N);
            },
            $$slots: { default: !0 }
          });
        });
        var Z = be(R, 2);
        {
          var Y = (J) => {
            var j = M(), ee = D(j);
            Q(ee, () => d(b), (L, N) => {
              N(L, {
                get errors() {
                  return l();
                },
                get config() {
                  return s();
                }
              });
            }), A(J, j);
          };
          ue(Z, (J) => {
            l().length > 0 && J(Y);
          });
        }
        var X = be(Z, 2);
        {
          var ae = (J) => {
            var j = M(), ee = D(j);
            Q(ee, () => d(p), (L, N) => {
              N(L, {
                get help() {
                  return d(P);
                },
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                }
              });
            }), A(J, j);
          };
          ue(X, (J) => {
            d(P) !== void 0 && J(ae);
          });
        }
        A(E, F);
      },
      $$slots: { default: !0 }
    });
  }), A(t, C), H(w);
}
K(
  Bw,
  {
    children: {},
    config: {},
    uiOption: {},
    showTitle: {},
    useLabel: {},
    errors: {},
    action: {}
  },
  [],
  [],
  { mode: "open" }
);
var BM = /* @__PURE__ */ ne("<!> <!>", 1), zM = /* @__PURE__ */ ne("<!> <!>", 1), qM = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function zw(t, e) {
  W(e, !0);
  const r = Ee(), n = "objectTemplate", s = v(e, "config", 7), o = v(e, "children", 7), i = v(e, "addButton", 7), a = v(e, "action", 7), l = v(e, "errors", 7), u = v(e, "uiOption", 7), c = /* @__PURE__ */ O(() => Me(r, "layout", s())), f = /* @__PURE__ */ O(() => Me(r, "title", s())), g = /* @__PURE__ */ O(() => Me(r, "description", s())), _ = /* @__PURE__ */ O(() => Me(r, "errorsList", s())), b = /* @__PURE__ */ O(() => Qh(u(), s())), p = /* @__PURE__ */ O(() => d(b).title), h = /* @__PURE__ */ O(() => d(b).description), y = /* @__PURE__ */ O(() => d(b).showMeta);
  var S = {
    get config() {
      return s();
    },
    set config(w) {
      s(w), m();
    },
    get children() {
      return o();
    },
    set children(w) {
      o(w), m();
    },
    get addButton() {
      return i();
    },
    set addButton(w) {
      i(w), m();
    },
    get action() {
      return a();
    },
    set action(w) {
      a(w), m();
    },
    get errors() {
      return l();
    },
    set errors(w) {
      l(w), m();
    },
    get uiOption() {
      return u();
    },
    set uiOption(w) {
      u(w), m();
    }
  }, x = M(), P = D(x);
  return Q(P, () => d(c), (w, C) => {
    C(w, {
      type: "object-field",
      get config() {
        return s();
      },
      get errors() {
        return l();
      },
      children: (k, $) => {
        var T = qM(), E = D(T);
        {
          var I = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(c), (ae, J) => {
              J(ae, {
                type: "object-field-meta",
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                },
                children: (j, ee) => {
                  var L = zM(), N = D(L);
                  {
                    var V = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(c), (re, oe) => {
                        oe(re, {
                          type: "object-field-title-row",
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          },
                          children: (pe, ye) => {
                            var Pe = BM(), Oe = D(Pe);
                            Q(Oe, () => d(f), (Ke, Le) => {
                              Le(Ke, {
                                templateType: n,
                                get title() {
                                  return d(p);
                                },
                                get config() {
                                  return s();
                                },
                                get errors() {
                                  return l();
                                }
                              });
                            });
                            var Ve = be(Oe, 2);
                            te(Ve, () => a() ?? he), A(pe, Pe);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(se, we);
                    };
                    ue(N, (se) => {
                      d(p) && se(V);
                    });
                  }
                  var G = be(N, 2);
                  {
                    var fe = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(g), (re, oe) => {
                        oe(re, {
                          templateType: n,
                          get description() {
                            return d(h);
                          },
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          }
                        });
                      }), A(se, we);
                    };
                    ue(G, (se) => {
                      d(h) && se(fe);
                    });
                  }
                  A(j, L);
                },
                $$slots: { default: !0 }
              });
            }), A(Z, Y);
          };
          ue(E, (Z) => {
            d(y) && (d(p) || d(h)) && Z(I);
          });
        }
        var F = be(E, 2);
        Q(F, () => d(c), (Z, Y) => {
          Y(Z, {
            type: "object-properties",
            get config() {
              return s();
            },
            get errors() {
              return l();
            },
            children: (X, ae) => {
              var J = M(), j = D(J);
              te(j, o), A(X, J);
            },
            $$slots: { default: !0 }
          });
        });
        var U = be(F, 2);
        te(U, () => i() ?? he);
        var B = be(U, 2);
        {
          var R = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(_), (ae, J) => {
              J(ae, {
                get errors() {
                  return l();
                },
                get config() {
                  return s();
                }
              });
            }), A(Z, Y);
          };
          ue(B, (Z) => {
            l().length > 0 && Z(R);
          });
        }
        A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), H(S);
}
K(
  zw,
  {
    config: {},
    children: {},
    addButton: {},
    action: {},
    errors: {},
    uiOption: {}
  },
  [],
  [],
  { mode: "open" }
);
var UM = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function qw(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "keyInput", 7), s = v(e, "removeButton", 7), o = v(e, "config", 7), i = v(e, "errors", 7), a = Ee(), l = /* @__PURE__ */ O(() => Me(a, "layout", o()));
  var u = {
    get children() {
      return r();
    },
    set children(g) {
      r(g), m();
    },
    get keyInput() {
      return n();
    },
    set keyInput(g) {
      n(g), m();
    },
    get removeButton() {
      return s();
    },
    set removeButton(g) {
      s(g), m();
    },
    get config() {
      return o();
    },
    set config(g) {
      o(g), m();
    },
    get errors() {
      return i();
    },
    set errors(g) {
      i(g), m();
    }
  }, c = M(), f = D(c);
  return Q(f, () => d(l), (g, _) => {
    _(g, {
      type: "object-property",
      get config() {
        return o();
      },
      get errors() {
        return i();
      },
      children: (b, p) => {
        var h = UM(), y = D(h);
        {
          var S = (C) => {
            var k = M(), $ = D(k);
            Q($, () => d(l), (T, E) => {
              E(T, {
                type: "object-property-key-input",
                get config() {
                  return o();
                },
                get errors() {
                  return i();
                },
                children: (I, F) => {
                  var U = M(), B = D(U);
                  te(B, n), A(I, U);
                },
                $$slots: { default: !0 }
              });
            }), A(C, k);
          };
          ue(y, (C) => {
            n() && C(S);
          });
        }
        var x = be(y, 2);
        Q(x, () => d(l), (C, k) => {
          k(C, {
            type: "object-property-content",
            get config() {
              return o();
            },
            get errors() {
              return i();
            },
            children: ($, T) => {
              var E = M(), I = D(E);
              te(I, r), A($, E);
            },
            $$slots: { default: !0 }
          });
        });
        var P = be(x, 2);
        {
          var w = (C) => {
            var k = M(), $ = D(k);
            Q($, () => d(l), (T, E) => {
              E(T, {
                type: "object-property-controls",
                get config() {
                  return o();
                },
                get errors() {
                  return i();
                },
                children: (I, F) => {
                  var U = M(), B = D(U);
                  te(B, s), A(I, U);
                },
                $$slots: { default: !0 }
              });
            }), A(C, k);
          };
          ue(P, (C) => {
            s() && C(w);
          });
        }
        A(b, h);
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), H(u);
}
K(
  qw,
  {
    children: {},
    keyInput: {},
    removeButton: {},
    config: {},
    errors: {}
  },
  [],
  [],
  { mode: "open" }
);
var KM = /* @__PURE__ */ ne("<!> <!>", 1), WM = /* @__PURE__ */ ne("<!> <!>", 1), HM = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function Uw(t, e) {
  W(e, !0);
  const r = Ee(), n = "arrayTemplate", s = v(e, "children", 7), o = v(e, "addButton", 7), i = v(e, "action", 7), a = v(e, "uiOption", 7), l = v(e, "config", 7), u = v(e, "errors", 7), c = /* @__PURE__ */ O(() => Me(r, "layout", l())), f = /* @__PURE__ */ O(() => Me(r, "title", l())), g = /* @__PURE__ */ O(() => Me(r, "description", l())), _ = /* @__PURE__ */ O(() => Me(r, "errorsList", l())), b = /* @__PURE__ */ O(() => Qh(a(), l())), p = /* @__PURE__ */ O(() => d(b).title), h = /* @__PURE__ */ O(() => d(b).description), y = /* @__PURE__ */ O(() => d(b).showMeta);
  var S = {
    get children() {
      return s();
    },
    set children(w) {
      s(w), m();
    },
    get addButton() {
      return o();
    },
    set addButton(w) {
      o(w), m();
    },
    get action() {
      return i();
    },
    set action(w) {
      i(w), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(w) {
      a(w), m();
    },
    get config() {
      return l();
    },
    set config(w) {
      l(w), m();
    },
    get errors() {
      return u();
    },
    set errors(w) {
      u(w), m();
    }
  }, x = M(), P = D(x);
  return Q(P, () => d(c), (w, C) => {
    C(w, {
      type: "array-field",
      get config() {
        return l();
      },
      get errors() {
        return u();
      },
      children: (k, $) => {
        var T = HM(), E = D(T);
        {
          var I = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(c), (ae, J) => {
              J(ae, {
                type: "array-field-meta",
                get config() {
                  return l();
                },
                get errors() {
                  return u();
                },
                children: (j, ee) => {
                  var L = WM(), N = D(L);
                  {
                    var V = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(c), (re, oe) => {
                        oe(re, {
                          type: "array-field-title-row",
                          get config() {
                            return l();
                          },
                          get errors() {
                            return u();
                          },
                          children: (pe, ye) => {
                            var Pe = KM(), Oe = D(Pe);
                            Q(Oe, () => d(f), (Ke, Le) => {
                              Le(Ke, {
                                templateType: n,
                                get title() {
                                  return d(p);
                                },
                                get config() {
                                  return l();
                                },
                                get errors() {
                                  return u();
                                }
                              });
                            });
                            var Ve = be(Oe, 2);
                            te(Ve, () => i() ?? he), A(pe, Pe);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(se, we);
                    };
                    ue(N, (se) => {
                      d(p) && se(V);
                    });
                  }
                  var G = be(N, 2);
                  {
                    var fe = (se) => {
                      var we = M(), le = D(we);
                      Q(le, () => d(g), (re, oe) => {
                        oe(re, {
                          templateType: n,
                          get description() {
                            return d(h);
                          },
                          get config() {
                            return l();
                          },
                          get errors() {
                            return u();
                          }
                        });
                      }), A(se, we);
                    };
                    ue(G, (se) => {
                      d(h) && se(fe);
                    });
                  }
                  A(j, L);
                },
                $$slots: { default: !0 }
              });
            }), A(Z, Y);
          };
          ue(E, (Z) => {
            d(y) && (d(p) || d(h)) && Z(I);
          });
        }
        var F = be(E, 2);
        Q(F, () => d(c), (Z, Y) => {
          Y(Z, {
            type: "array-items",
            get config() {
              return l();
            },
            get errors() {
              return u();
            },
            children: (X, ae) => {
              var J = M(), j = D(J);
              te(j, s), A(X, J);
            },
            $$slots: { default: !0 }
          });
        });
        var U = be(F, 2);
        te(U, () => o() ?? he);
        var B = be(U, 2);
        {
          var R = (Z) => {
            var Y = M(), X = D(Y);
            Q(X, () => d(_), (ae, J) => {
              J(ae, {
                get errors() {
                  return u();
                },
                get config() {
                  return l();
                }
              });
            }), A(Z, Y);
          };
          ue(B, (Z) => {
            u().length > 0 && Z(R);
          });
        }
        A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), H(S);
}
K(
  Uw,
  {
    children: {},
    addButton: {},
    action: {},
    uiOption: {},
    config: {},
    errors: {}
  },
  [],
  [],
  { mode: "open" }
);
var GM = /* @__PURE__ */ ne("<!> <!>", 1);
function Kw(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "buttons", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "layout", s()));
  var l = {
    get children() {
      return r();
    },
    set children(f) {
      r(f), m();
    },
    get buttons() {
      return n();
    },
    set buttons(f) {
      n(f), m();
    },
    get config() {
      return s();
    },
    set config(f) {
      s(f), m();
    },
    get errors() {
      return o();
    },
    set errors(f) {
      o(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(a), (f, g) => {
    g(f, {
      type: "array-item",
      get config() {
        return s();
      },
      get errors() {
        return o();
      },
      children: (_, b) => {
        var p = GM(), h = D(p);
        Q(h, () => d(a), (x, P) => {
          P(x, {
            type: "array-item-content",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, C) => {
              var k = M(), $ = D(k);
              te($, r), A(w, k);
            },
            $$slots: { default: !0 }
          });
        });
        var y = be(h, 2);
        {
          var S = (x) => {
            var P = M(), w = D(P);
            Q(w, () => d(a), (C, k) => {
              k(C, {
                type: "array-item-controls",
                get config() {
                  return s();
                },
                get errors() {
                  return o();
                },
                children: ($, T) => {
                  var E = M(), I = D(E);
                  te(I, n), A($, E);
                },
                $$slots: { default: !0 }
              });
            }), A(x, P);
          };
          ue(y, (x) => {
            n() && x(S);
          });
        }
        A(_, p);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), H(l);
}
K(Kw, { children: {}, buttons: {}, config: {}, errors: {} }, [], [], { mode: "open" });
var YM = /* @__PURE__ */ ne("<!> <!>", 1), XM = /* @__PURE__ */ ne("<!> <!>", 1);
function Ww(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "optionSelector", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = v(e, "action", 7), a = Ee(), l = /* @__PURE__ */ O(() => Me(a, "layout", s()));
  var u = {
    get children() {
      return r();
    },
    set children(g) {
      r(g), m();
    },
    get optionSelector() {
      return n();
    },
    set optionSelector(g) {
      n(g), m();
    },
    get config() {
      return s();
    },
    set config(g) {
      s(g), m();
    },
    get errors() {
      return o();
    },
    set errors(g) {
      o(g), m();
    },
    get action() {
      return i();
    },
    set action(g) {
      i(g), m();
    }
  }, c = M(), f = D(c);
  return Q(f, () => d(l), (g, _) => {
    _(g, {
      type: "multi-field",
      get config() {
        return s();
      },
      get errors() {
        return o();
      },
      children: (b, p) => {
        var h = XM(), y = D(h);
        Q(y, () => d(l), (x, P) => {
          P(x, {
            type: "multi-field-controls",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, C) => {
              var k = YM(), $ = D(k);
              te($, n);
              var T = be($, 2);
              te(T, () => i() ?? he), A(w, k);
            },
            $$slots: { default: !0 }
          });
        });
        var S = be(y, 2);
        Q(S, () => d(l), (x, P) => {
          P(x, {
            type: "multi-field-content",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, C) => {
              var k = M(), $ = D(k);
              te($, r), A(w, k);
            },
            $$slots: { default: !0 }
          });
        }), A(b, h);
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), H(u);
}
K(
  Ww,
  {
    children: {},
    optionSelector: {},
    config: {},
    errors: {},
    action: {}
  },
  [],
  [],
  { mode: "open" }
);
const JM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayItemTemplate: Kw,
  arrayTemplate: Uw,
  fieldTemplate: Bw,
  multiFieldTemplate: Ww,
  objectPropertyTemplate: qw,
  objectTemplate: zw
}, Symbol.toStringTag, { value: "Module" })), rr = Object.assign({}, RM, JM);
function Hw(t, e) {
  return (r) => {
    const n = r?.findIndex((s) => s === void 0 || !e(s)) ?? -1;
    if (n >= 0) {
      const s = r[n];
      throw new TypeError(`Expected array of "${t}" or "undefined", but got (${typeof s}: ${JSON.stringify(s)})`);
    }
  };
}
const Gw = Hw("string", (t) => typeof t == "string"), ZM = Hw("File", (t) => t instanceof File);
function QM(t) {
  if (t !== void 0 && !(t instanceof File))
    throw new Error(`expected "File" or "undefined", but got (${typeof t}: ${JSON.stringify(t)})`);
}
const eI = "nativeFilesField";
function eg(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(f)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => kt(i, n().path)), g = yo({
    combinator: vi,
    async execute(y, S) {
      if (S === void 0)
        return;
      const x = Array.from(S);
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return x;
    },
    onSuccess(y) {
      s(y);
    }
  }), _ = /* @__PURE__ */ O(() => vr(i, n(), eI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(f);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => {
            const E = s(), I = new DataTransfer();
            if (E)
              for (const F of E)
                I.items.add(F);
            return I.files;
          }, T = g.run;
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get processing() {
                return g.isProcessed;
              },
              loading: !1,
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(f);
              },
              get config() {
                return n();
              },
              multiple: !0
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(eg, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function Yw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (ZM(r()), r()), i = (a) => {
    r(a);
  };
  return eg(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), H(s);
}
K(Yw, { value: {} }, [], [], { mode: "open" });
rr.arrayNativeFilesField = Yw;
function tI(t, e) {
  return t.anyOf ? [t.anyOf, e.anyOf] : [t.oneOf, e.oneOf];
}
function xl(t, e, r, n) {
  const s = n.enum, o = new Set(r("disabledEnumValues"));
  if (s) {
    const l = r("enumNames");
    return s.map((u, c) => {
      const f = l?.[c] ?? Fg(u);
      return {
        id: Rs(t, e.path, c),
        label: f,
        value: u,
        disabled: o.has(u)
      };
    });
  }
  const [i, a] = tI(n, e.uiSchema);
  return i && i.map((l, u) => {
    if (typeof l == "boolean")
      throw new Error(`Invalid enum definition in anyOf ${u}`);
    const c = Ay(l), f = Yn(t, a?.[u])["ui:options"]?.title ?? l.title ?? Fg(c);
    return {
      id: Rs(t, e.path, u),
      schema: l,
      label: f,
      value: c,
      disabled: o.has(c)
    };
  });
}
const rI = "enumField";
function Xw(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(g)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "selectWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => xl(i, n(), o(), n().schema) ?? []), g = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), rI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get handlers() {
                return c;
              },
              get config() {
                return n();
              },
              get errors() {
                return d(g);
              },
              get uiOption() {
                return o();
              },
              get options() {
                return d(f);
              },
              get value() {
                return s();
              },
              set value(E) {
                s(E);
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Xw, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
rr.enumField = Xw;
const nI = "fileField";
function Jw(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(g)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = pb({
    initialOutput: void 0,
    getInput: () => s(),
    setInput: (y) => s(y),
    async toOutput(y, S) {
      const x = new DataTransfer();
      return S && await gb(i, y, x, S), x.files;
    },
    async toInput(y, S) {
      if (S === void 0 || S.length === 0)
        return;
      const x = S[0];
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return mb(y, x);
    }
  }), g = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), nI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get processing() {
                return f.inputProcessing;
              },
              get loading() {
                return f.outputProcessing;
              },
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(g);
              },
              get config() {
                return n();
              },
              multiple: !1,
              get value() {
                return f.current;
              },
              set value(E) {
                f.current = E;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Jw, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
rr.fileField = Jw;
const sI = "filesField";
function tg(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(g)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = pb({
    initialOutput: void 0,
    getInput: () => s(),
    setInput: (y) => s(y),
    isEqual: (y, S) => y === void 0 && S === void 0 || Array.isArray(y) && Array.isArray(S) && y.length === S.length && y.every((x, P) => x === S[P]),
    async toOutput(y, S) {
      const x = new DataTransfer();
      return S && await ok(i, y, x, S), x.files;
    },
    async toInput(y, S) {
      if (S === void 0)
        return;
      const x = Array.from(S);
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return Promise.all(x.map((P) => mb(y, P)));
    }
  }), g = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), sI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get processing() {
                return f.inputProcessing;
              },
              get loading() {
                return f.outputProcessing;
              },
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(g);
              },
              get config() {
                return n();
              },
              multiple: !0,
              get value() {
                return f.current;
              },
              set value(E) {
                f.current = E;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(tg, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
rr.filesField = tg;
const oI = "multiEnumField";
function Zw(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return o();
        },
        set current(P) {
          o(P);
        }
      }),
      () => d(g)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "value", 15);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "checkboxesWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), o())), f = /* @__PURE__ */ O(() => {
    const { items: y } = n().schema, S = Be(y) ? y : {};
    return xl(i, n(), s(), S) ?? [];
  }), g = /* @__PURE__ */ O(() => kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), oI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(y) {
      s(y), m();
    },
    get value() {
      return o();
    },
    set value(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !1,
        get uiOption() {
          return s();
        },
        widgetType: l,
        get value() {
          return o();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => o() ?? void 0, T = (E) => o(E);
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get handlers() {
                return c;
              },
              get config() {
                return n();
              },
              get errors() {
                return d(g);
              },
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get options() {
                return d(f);
              },
              get uiOption() {
                return s();
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(Zw, { config: {}, uiOption: {}, value: {} }, [], [], { mode: "open" });
rr.multiEnumField = Zw;
const iI = "nativeFileField";
function rg(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(f)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => kt(i, n().path)), g = yo({
    combinator: vi,
    async execute(y, S) {
      if (S === void 0 || S.length === 0)
        return;
      const x = S[0];
      if (!await Jl(y, i, n(), S))
        throw new Kl();
      return x;
    },
    onSuccess(y) {
      s(y);
    }
  }), _ = /* @__PURE__ */ O(() => vr(i, n(), iI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(f);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => {
            const E = s(), I = new DataTransfer();
            return E && I.items.add(E), I.files;
          }, T = g.run;
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get processing() {
                return g.isProcessed;
              },
              loading: !1,
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(f);
              },
              get config() {
                return n();
              },
              multiple: !1
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(rg, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
rr.nativeFileField = rg;
rr.nativeFilesField = eg;
function Qw(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (QM(r()), r()), i = (a) => {
    r(a);
  };
  return rg(t, ce(
    {
      get value() {
        return o();
      },
      set value(a) {
        i(a);
      }
    },
    () => n
  )), H(s);
}
K(Qw, { value: {} }, [], [], { mode: "open" });
rr.unknownNativeFileField = Qw;
function aI(t) {
  return (e) => {
    const { schema: r } = e;
    if (IC(t, r))
      return "enumField";
    if (r.oneOf !== void 0)
      return "oneOfField";
    if (r.anyOf !== void 0)
      return "anyOfField";
    const n = go(r);
    return n === "array" ? NC(t, r) ? "multiEnumField" : Ty(r) ? "tupleField" : FC(t, r) && Nt(t, e, "orderable") !== !0 ? "filesField" : "arrayField" : Fy(r) ? "fileField" : `${n}Field`;
  };
}
const lI = "aggregatedField";
function e1(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(g)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = Ee(), a = /* @__PURE__ */ O(() => Me(i, "fieldTemplate", n())), l = "aggregatedWidget", u = /* @__PURE__ */ O(() => Me(i, l, n())), c = un(i, () => n(), () => Cr(i, n(), s())), f = /* @__PURE__ */ O(() => o()("collectErrors") ?? !1), g = /* @__PURE__ */ O(() => d(f) ? ob(i, tb(i, n().path)) : kt(i, n().path)), _ = /* @__PURE__ */ O(() => vr(i, n(), lI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        widgetType: l,
        get uiOption() {
          return o();
        },
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => s() ?? void 0, T = (E) => s(E);
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get config() {
                return n();
              },
              get errors() {
                return d(g);
              },
              get uiOption() {
                return o();
              },
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get handlers() {
                return c;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(e1, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
rr.aggregatedField = e1;
function t1(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (Gw(r()), r()), i = (a) => {
    r(a);
  };
  return tg(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), H(s);
}
K(t1, { value: {} }, [], [], { mode: "open" });
rr.arrayFilesField = t1;
const uI = "tagsField";
function ng(t, e) {
  W(e, !0);
  const r = (y) => {
    var S = M(), x = D(S);
    te(
      x,
      () => d(_) ?? he,
      () => a,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(g)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = "tagsWidget", a = Ee(), l = /* @__PURE__ */ O(() => Me(a, "fieldTemplate", n())), u = /* @__PURE__ */ O(() => Me(a, i, n())), c = un(a, () => n(), () => Cr(a, n(), s())), f = /* @__PURE__ */ O(() => o()("collectErrors") ?? !1), g = /* @__PURE__ */ O(() => d(f) ? ob(a, tb(a, n().path)) : kt(a, n().path)), _ = /* @__PURE__ */ O(() => vr(a, n(), uI));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, p = M(), h = D(p);
  {
    let y = /* @__PURE__ */ O(() => d(_) && r);
    Q(h, () => d(l), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        widgetType: i,
        get uiOption() {
          return o();
        },
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(g);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var C = M(), k = D(C), $ = () => s() ?? void 0, T = (E) => s(E);
          Q(k, () => d(u), (E, I) => {
            I(E, {
              type: "widget",
              get config() {
                return n();
              },
              get errors() {
                return d(g);
              },
              get uiOption() {
                return o();
              },
              get value() {
                return $();
              },
              set value(F) {
                T(F);
              },
              get handlers() {
                return c;
              }
            });
          }), A(P, C);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, p), H(b);
}
K(ng, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function r1(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (Gw(r()), r()), i = (a) => {
    r(a);
  };
  return ng(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), H(s);
}
K(r1, { value: {} }, [], [], { mode: "open" });
rr.arrayTagsField = r1;
const cI = "booleanSelectField";
function n1(t, e) {
  W(e, !0);
  const r = (S) => {
    var x = M(), P = D(x);
    te(
      P,
      () => d(b) ?? he,
      () => n,
      s,
      () => ({
        get current() {
          return o();
        },
        set current(w) {
          o(w);
        }
      }),
      () => d(_)
    ), A(S, x);
  }, n = Ee();
  let s = v(e, "config", 7), o = v(e, "value", 15), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = /* @__PURE__ */ O(() => Me(n, "fieldTemplate", s())), u = "selectWidget", c = /* @__PURE__ */ O(() => Me(n, u, s())), f = /* @__PURE__ */ O(() => {
    const S = a()("yes", {}), x = a()("no", {});
    if (Array.isArray(s().schema.oneOf))
      return xl(n, s(), i(), {
        oneOf: s().schema.oneOf.map((w) => typeof w == "boolean" ? w ? { const: !0, title: S } : { const: !1, title: x } : {
          ...w,
          title: w.title ?? (w.const === !0 ? S : x)
        })
      }) ?? [];
    const P = s().schema.enum ?? gC;
    return P.length === 2 && P.every((w) => typeof w == "boolean") && i()("enumNames") === void 0 ? P.map((w, C) => ({
      id: Rs(n, s().path, C),
      label: w ? S : x,
      value: w,
      disabled: !1
    })) : xl(n, s(), i(), Object.setPrototypeOf({ enum: P }, s().schema)) ?? [];
  }), g = un(n, () => s(), () => Cr(n, s(), o())), _ = /* @__PURE__ */ O(() => kt(n, s().path)), b = /* @__PURE__ */ O(() => vr(n, s(), cI));
  var p = {
    get config() {
      return s();
    },
    set config(S) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S) {
      o(S), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(S) {
      i(S), m();
    },
    get translate() {
      return a();
    },
    set translate(S) {
      a(S), m();
    }
  }, h = M(), y = D(h);
  {
    let S = /* @__PURE__ */ O(() => d(b) && r);
    Q(y, () => d(l), (x, P) => {
      P(x, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return i();
        },
        widgetType: u,
        get value() {
          return o();
        },
        get config() {
          return s();
        },
        get errors() {
          return d(_);
        },
        get action() {
          return d(S);
        },
        children: (w, C) => {
          var k = M(), $ = D(k);
          Q($, () => d(c), (T, E) => {
            E(T, {
              type: "widget",
              get options() {
                return d(f);
              },
              get errors() {
                return d(_);
              },
              get handlers() {
                return g;
              },
              get uiOption() {
                return i();
              },
              get config() {
                return s();
              },
              get value() {
                return o();
              },
              set value(I) {
                o(I);
              }
            });
          }), A(w, k);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, h), H(p);
}
K(n1, { config: {}, value: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
rr.booleanSelectField = n1;
rr.tagsField = ng;
const dI = Ii(rr);
var fI = /* @__PURE__ */ ne("<form><!></form>");
function hI(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "ref", 15), s = v(e, "config", 7), o = v(e, "attributes", 7);
  const i = Ee();
  var a = {
    get children() {
      return r();
    },
    set children(c) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    },
    get attributes() {
      return o();
    },
    set attributes(c) {
      o(c), m();
    }
  }, l = fI();
  ve(l, (c) => ({ onsubmit: i.submit, onreset: i.reset, ...c }), [
    () => cb(i, s(), "form", o(), { class: "sjsf-form" })
  ]);
  var u = ge(l);
  return te(u, r), de(l), Qe(l, (c) => n(c), () => n()), A(t, l), H(a);
}
K(hI, { children: {}, ref: {}, config: {}, attributes: {} }, [], [], { mode: "open" });
var gI = /* @__PURE__ */ ne("<form><!></form>");
function s1(t, e) {
  W(e, !0);
  let r = v(e, "children", 7), n = v(e, "ref", 15), s = v(e, "config", 7), o = v(e, "attributes", 7);
  const i = Ee();
  var a = {
    get children() {
      return r();
    },
    set children(c) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    },
    get attributes() {
      return o();
    },
    set attributes(c) {
      o(c), m();
    }
  }, l = gI();
  ve(
    l,
    (c) => ({
      onsubmit: i.submit,
      onreset: i.reset,
      class: "flex flex-col gap-4",
      ...c
    }),
    [
      () => cb(i, s(), "form", o(), {})
    ]
  );
  var u = ge(l);
  return te(u, () => r() ?? he), de(l), Qe(l, (c) => n(c), () => n()), A(t, l), H(a);
}
K(s1, { children: {}, ref: {}, config: {}, attributes: {} }, [], [], { mode: "open" });
const o1 = /* @__PURE__ */ Symbol("theme-context");
function ut() {
  return Is(o1);
}
function pI(t) {
  Po(o1, t);
}
function i1(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "disabled", 7), s = v(e, "onclick", 7), o = v(e, "config", 7), i = v(e, "type", 7), a = Ee(), l = ut(), u = /* @__PURE__ */ O(() => l.components), c = /* @__PURE__ */ O(() => d(u).Button);
  var f = {
    get children() {
      return r();
    },
    set children(b) {
      r(b), m();
    },
    get disabled() {
      return n();
    },
    set disabled(b) {
      n(b), m();
    },
    get onclick() {
      return s();
    },
    set onclick(b) {
      s(b), m();
    },
    get config() {
      return o();
    },
    set config(b) {
      o(b), m();
    },
    get type() {
      return i();
    },
    set type(b) {
      i(b), m();
    }
  }, g = M(), _ = D(g);
  {
    let b = /* @__PURE__ */ O(() => Ft(
      a,
      o(),
      {
        type: "button",
        disabled: n(),
        onclick: s(),
        variant: "outline"
      },
      wt("shadcn4Button"),
      sb("shadcn4Buttons", (p) => p[i()]),
      To
    ));
    Q(_, () => d(c), (p, h) => {
      h(p, ce(() => d(b), {
        children: (y, S) => {
          var x = M(), P = D(x);
          te(P, r), A(y, x);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, g), H(f);
}
K(
  i1,
  {
    children: {},
    disabled: {},
    onclick: {},
    config: {},
    type: {}
  },
  [],
  [],
  { mode: "open" }
);
function a1(t, e) {
  W(e, !0);
  const r = v(e, "children", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).Button);
  var l = {
    get children() {
      return r();
    },
    set children(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => sk(s, n(), "shadcn4SubmitButton", "submit", {}));
    Q(c, () => d(a), (g, _) => {
      _(g, ce(() => d(f), {
        children: (b, p) => {
          var h = M(), y = D(h);
          te(y, r), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(a1, { children: {}, config: {} }, [], [], { mode: "open" });
var mI = /* @__PURE__ */ ne("<div><!></div>");
function vI(t, e) {
  W(e, !0);
  const r = v(e, "type", 7), n = v(e, "children", 7), s = v(e, "config", 7), o = Ee(), i = /* @__PURE__ */ O(() => fb(o, s(), "layout", "layouts", r(), { class: "sjsf-layout" }));
  var a = {
    get type() {
      return r();
    },
    set type(c) {
      r(c), m();
    },
    get children() {
      return n();
    },
    set children(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    }
  }, l = mI();
  ve(l, () => ({ ...d(i) }));
  var u = ge(l);
  return te(u, n), de(l), A(t, l), H(a);
}
K(vI, { type: {}, children: {}, config: {} }, [], [], { mode: "open" });
var yI = /* @__PURE__ */ ne("<div><!></div>"), bI = /* @__PURE__ */ ne("<div><!></div>");
function l1(t, e) {
  W(e, !0);
  const r = v(e, "type", 7), n = v(e, "children", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = /* @__PURE__ */ O(() => r() === "array-item"), a = /* @__PURE__ */ O(() => r() === "array-item-content" || r() === "object-property-key-input" || r() === "object-property-content"), l = /* @__PURE__ */ O(() => r() === "object-property"), u = /* @__PURE__ */ O(() => r() === "field-meta" || r() === "array-field-meta" || r() === "object-field-meta"), c = /* @__PURE__ */ O(() => r() === "multi-field-controls"), f = Ee(), g = ut(), _ = /* @__PURE__ */ O(() => g.components), b = /* @__PURE__ */ O(() => d(_).ButtonGroup), p = /* @__PURE__ */ O(() => d(_).FieldSet), h = /* @__PURE__ */ O(() => d(_).FieldLegend), y = /* @__PURE__ */ O(() => d(_).Field), S = /* @__PURE__ */ O(() => d(_).FieldGroup), x = /* @__PURE__ */ O(() => fb(f, s(), "layout", "layouts", r(), {}));
  var P = {
    get type() {
      return r();
    },
    set type(T) {
      r(T), m();
    },
    get children() {
      return n();
    },
    set children(T) {
      n(T), m();
    },
    get config() {
      return s();
    },
    set config(T) {
      s(T), m();
    },
    get errors() {
      return o();
    },
    set errors(T) {
      o(T), m();
    }
  }, w = M(), C = D(w);
  {
    var k = (T) => {
      var E = M(), I = D(E);
      te(I, n), A(T, E);
    }, $ = (T) => {
      var E = M(), I = D(E);
      {
        var F = (B) => {
          var R = M(), Z = D(R);
          {
            let Y = /* @__PURE__ */ O(() => wt("shadcn4ButtonGroup")(d(x), s(), f));
            Q(Z, () => d(b), (X, ae) => {
              ae(X, ce(() => d(Y), {
                children: (J, j) => {
                  var ee = M(), L = D(ee);
                  te(L, n), A(J, ee);
                },
                $$slots: { default: !0 }
              }));
            });
          }
          A(B, R);
        }, U = (B) => {
          var R = M(), Z = D(R);
          {
            var Y = (ae) => {
              var J = M(), j = D(J);
              {
                let ee = /* @__PURE__ */ O(() => wt("shadcn4FieldSet")(d(x), s(), f));
                Q(j, () => d(p), (L, N) => {
                  N(L, ce(() => d(ee), {
                    children: (V, G) => {
                      var fe = M(), se = D(fe);
                      te(se, n), A(V, fe);
                    },
                    $$slots: { default: !0 }
                  }));
                });
              }
              A(ae, J);
            }, X = (ae) => {
              var J = M(), j = D(J);
              {
                var ee = (N) => {
                  var V = M(), G = D(V);
                  {
                    let fe = /* @__PURE__ */ O(() => o().length > 0), se = /* @__PURE__ */ O(() => wt("shadcn4Field")(d(x), s(), f));
                    Q(G, () => d(y), (we, le) => {
                      le(we, ce(
                        {
                          get "data-invalid"() {
                            return d(fe);
                          }
                        },
                        () => d(se),
                        {
                          children: (re, oe) => {
                            var pe = M(), ye = D(pe);
                            te(ye, n), A(re, pe);
                          },
                          $$slots: { default: !0 }
                        }
                      ));
                    });
                  }
                  A(N, V);
                }, L = (N) => {
                  var V = M(), G = D(V);
                  {
                    var fe = (we) => {
                      var le = yI();
                      ve(le, () => ({
                        class: "flex w-full items-center justify-between",
                        ...d(x)
                      }));
                      var re = ge(le);
                      te(re, n), de(le), A(we, le);
                    }, se = (we) => {
                      var le = M(), re = D(le);
                      {
                        var oe = (ye) => {
                          var Pe = M(), Oe = D(Pe);
                          Q(Oe, () => d(h), (Ve, Ke) => {
                            Ke(Ve, ce({ class: "flex w-full items-center justify-between" }, () => d(x), {
                              children: (Le, je) => {
                                var We = M(), gt = D(We);
                                te(gt, n), A(Le, We);
                              },
                              $$slots: { default: !0 }
                            }));
                          }), A(ye, Pe);
                        }, pe = (ye) => {
                          var Pe = M(), Oe = D(Pe);
                          {
                            var Ve = (Le) => {
                              var je = M(), We = D(je);
                              Q(We, () => d(S), (gt, Ze) => {
                                Ze(gt, ce(() => d(x), {
                                  children: ($t, lt) => {
                                    var ct = M(), pt = D(ct);
                                    te(pt, n), A($t, ct);
                                  },
                                  $$slots: { default: !0 }
                                }));
                              }), A(Le, je);
                            }, Ke = (Le) => {
                              var je = bI();
                              ve(je, () => ({
                                class: {
                                  grow: d(a),
                                  "flex items-center gap-2": d(c),
                                  "flex items-start gap-1.5": d(i),
                                  "grid grid-cols-1 grid-rows-[1fr] items-start gap-x-1.5 [&:has(>:nth-child(2))]:grid-cols-[1fr_1fr_auto]": d(l)
                                },
                                ...d(x)
                              }));
                              var We = ge(je);
                              te(We, n), de(je), A(Le, je);
                            };
                            ue(
                              Oe,
                              (Le) => {
                                r() === "array-items" || r() === "object-properties" || r() === "multi-field" || r() === "multi-field-content" ? Le(Ve) : Le(Ke, !1);
                              },
                              !0
                            );
                          }
                          A(ye, Pe);
                        };
                        ue(
                          re,
                          (ye) => {
                            r() === "array-field-title-row" || r() === "object-field-title-row" ? ye(oe) : ye(pe, !1);
                          },
                          !0
                        );
                      }
                      A(we, le);
                    };
                    ue(
                      G,
                      (we) => {
                        r() === "field-title-row" ? we(fe) : we(se, !1);
                      },
                      !0
                    );
                  }
                  A(N, V);
                };
                ue(
                  j,
                  (N) => {
                    r() == "field" ? N(ee) : N(L, !1);
                  },
                  !0
                );
              }
              A(ae, J);
            };
            ue(
              Z,
              (ae) => {
                r() === "array-field" || r() === "object-field" ? ae(Y) : ae(X, !1);
              },
              !0
            );
          }
          A(B, R);
        };
        ue(
          I,
          (B) => {
            r() === "array-item-controls" ? B(F) : B(U, !1);
          },
          !0
        );
      }
      A(T, E);
    };
    ue(C, (T) => {
      (r() === "field-content" || d(u)) && Object.keys(d(x)).length < 2 ? T(k) : T($, !1);
    });
  }
  return A(t, w), H(P);
}
K(l1, { type: {}, children: {}, config: {}, errors: {} }, [], [], { mode: "open" });
var _I = /* @__PURE__ */ ne("<legend> <!></legend>");
function wI(t, e) {
  W(e, !0);
  const r = v(e, "title", 7), n = v(e, "config", 7), s = v(e, "templateType", 7), o = Ee();
  var i = {
    get title() {
      return r();
    },
    set title(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    },
    get templateType() {
      return s();
    },
    set templateType(f) {
      s(f), m();
    }
  }, a = _I();
  ve(a, (f) => ({ ...f }), [
    () => Mc(o, n(), "titleAttributes", { class: "sjsf-title", "data-template": s() })
  ]);
  var l = ge(a), u = be(l);
  {
    var c = (f) => {
      var g = st("*");
      A(f, g);
    };
    ue(u, (f) => {
      n().required && s() === "fieldTemplate" && f(c);
    });
  }
  return de(a), ke(() => Ie(l, `${r() ?? ""} `)), A(t, a), H(i);
}
K(wI, { title: {}, config: {}, templateType: {} }, [], [], { mode: "open" });
var SI = /* @__PURE__ */ ne(" <!>", 1), xI = /* @__PURE__ */ ne("<div> </div>");
function u1(t, e) {
  W(e, !0);
  const r = v(e, "title", 7), n = v(e, "templateType", 7), s = v(e, "config", 7), o = Ee(), i = ut(), a = /* @__PURE__ */ O(() => i.components), l = /* @__PURE__ */ O(() => d(a).FieldTitle);
  var u = {
    get title() {
      return r();
    },
    set title(b) {
      r(b), m();
    },
    get templateType() {
      return n();
    },
    set templateType(b) {
      n(b), m();
    },
    get config() {
      return s();
    },
    set config(b) {
      s(b), m();
    }
  }, c = M(), f = D(c);
  {
    var g = (b) => {
      var p = M(), h = D(p);
      {
        let y = /* @__PURE__ */ O(() => Mc(o, s(), "titleAttributes", {}));
        Q(h, () => d(l), (S, x) => {
          x(S, ce(() => d(y), {
            children: (P, w) => {
              St();
              var C = SI(), k = D(C), $ = be(k);
              {
                var T = (E) => {
                  var I = st("*");
                  A(E, I);
                };
                ue($, (E) => {
                  s().required && E(T);
                });
              }
              ke(() => Ie(k, `${r() ?? ""} `)), A(P, C);
            },
            $$slots: { default: !0 }
          }));
        });
      }
      A(b, p);
    }, _ = (b) => {
      var p = xI();
      ve(p, (y) => ({ ...y }), [() => Mc(o, s(), "titleAttributes", {})]);
      var h = ge(p, !0);
      de(p), ke(() => Ie(h, r())), A(b, p);
    };
    ue(f, (b) => {
      n() === "fieldTemplate" ? b(g) : b(_, !1);
    });
  }
  return A(t, c), H(u);
}
K(u1, { title: {}, templateType: {}, config: {} }, [], [], { mode: "open" });
var PI = /* @__PURE__ */ ne("<span>*</span>"), OI = /* @__PURE__ */ ne(" <!>", 1);
function c1(t, e) {
  W(e, !0);
  const r = v(e, "title", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldLabel);
  var l = {
    get title() {
      return r();
    },
    set title(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => nk(s, n(), "shadcn4Label", {}));
    Q(c, () => d(a), (g, _) => {
      _(g, ce(() => d(f), {
        children: (b, p) => {
          St();
          var h = OI(), y = D(h), S = be(y);
          {
            var x = (P) => {
              var w = PI();
              A(P, w);
            };
            ue(S, (P) => {
              n().required && P(x);
            });
          }
          ke(() => Ie(y, `${r() ?? ""} `)), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(c1, { title: {}, config: {} }, [], [], { mode: "open" });
var CI = /* @__PURE__ */ ne("<div> </div>");
function kI(t, e) {
  W(e, !0);
  const r = v(e, "description", 7), n = v(e, "config", 7), s = Ee();
  var o = {
    get description() {
      return r();
    },
    set description(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    }
  }, i = CI();
  ve(i, (l) => ({ ...l }), [
    () => lb(s, n(), "descriptionAttributes", { class: "sjsf-description" })
  ]);
  var a = ge(i, !0);
  return de(i), ke(() => Ie(a, r())), A(t, i), H(o);
}
K(kI, { description: {}, config: {} }, [], [], { mode: "open" });
function d1(t, e) {
  W(e, !0);
  const r = v(e, "description", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldDescription);
  var l = {
    get description() {
      return r();
    },
    set description(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => lb(s, n(), "descriptionAttributes", {}));
    Q(c, () => d(a), (g, _) => {
      _(g, ce(() => d(f), {
        children: (b, p) => {
          St();
          var h = st();
          ke(() => Ie(h, r())), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(d1, { description: {}, config: {} }, [], [], { mode: "open" });
var $I = /* @__PURE__ */ ne("<div> </div>");
function AI(t, e) {
  W(e, !0);
  const r = v(e, "help", 7), n = v(e, "config", 7), s = Ee();
  var o = {
    get help() {
      return r();
    },
    set help(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    }
  }, i = $I();
  ve(i, (l) => ({ ...l }), [
    () => db(s, n(), "helpAttributes", { class: "sjsf-help" })
  ]);
  var a = ge(i, !0);
  return de(i), ke(() => Ie(a, r())), A(t, i), H(o);
}
K(AI, { help: {}, config: {} }, [], [], { mode: "open" });
function f1(t, e) {
  W(e, !0);
  const r = v(e, "help", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldDescription);
  var l = {
    get help() {
      return r();
    },
    set help(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => db(s, n(), "helpAttributes", {}));
    Q(c, () => d(a), (g, _) => {
      _(g, ce(() => d(f), {
        children: (b, p) => {
          St();
          var h = st();
          ke(() => Ie(h, r())), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), H(l);
}
K(f1, { help: {}, config: {} }, [], [], { mode: "open" });
var EI = /* @__PURE__ */ ne("<li> </li>"), TI = /* @__PURE__ */ ne("<ul></ul>");
function DI(t, e) {
  W(e, !0);
  const r = v(e, "errors", 7), n = v(e, "config", 7), s = Ee();
  var o = {
    get errors() {
      return r();
    },
    set errors(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    }
  }, i = TI();
  return ve(i, (a) => ({ ...a }), [
    () => ub(s, n(), "errorsList", { class: "sjsf-errors-list" })
  ]), nt(i, 21, r, jl, (a, l) => {
    var u = EI(), c = ge(u, !0);
    de(u), ke(() => Ie(c, d(l))), A(a, u);
  }), de(i), A(t, i), H(o);
}
K(DI, { errors: {}, config: {} }, [], [], { mode: "open" });
var MI = /* @__PURE__ */ ne("<li> </li>"), II = /* @__PURE__ */ ne("<ul></ul>");
function h1(t, e) {
  W(e, !0);
  const r = v(e, "errors", 7), n = v(e, "config", 7), s = Ee(), o = ut(), i = /* @__PURE__ */ O(() => o.components), a = /* @__PURE__ */ O(() => d(i).FieldError);
  var l = {
    get errors() {
      return r();
    },
    set errors(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = M(), c = D(u);
  return Q(c, () => d(a), (f, g) => {
    g(f, {
      children: (_, b) => {
        var p = II();
        ve(p, (h) => ({ class: "ml-4 flex list-disc flex-col gap-1", ...h }), [() => ub(s, n(), "errorsList", {})]), nt(p, 21, r, jl, (h, y) => {
          var S = MI(), x = ge(S, !0);
          de(S), ke(() => Ie(x, d(y))), A(h, S);
        }), de(p), A(_, p);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), H(l);
}
K(h1, { errors: {}, config: {} }, [], [], { mode: "open" });
const NI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  button: i1,
  description: d1,
  errorsList: h1,
  form: s1,
  help: f1,
  label: c1,
  layout: l1,
  submitButton: a1,
  title: u1
}, Symbol.toStringTag, { value: "Module" }));
var FI = /* @__PURE__ */ ne("<!> <!>", 1);
function g1(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Input);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ O(() => Ni(r, a(), "shadcn4Text", l(), {}));
  var c = {
    get value() {
      return i();
    },
    set value(b) {
      i(b), m();
    },
    get config() {
      return a();
    },
    set config(b) {
      a(b), m();
    },
    get handlers() {
      return l();
    },
    set handlers(b) {
      l(b), m();
    }
  }, f = FI(), g = D(f);
  Q(g, () => d(o), (b, p) => {
    p(b, ce(() => d(u), {
      get value() {
        return i();
      },
      set value(h) {
        i(h);
      }
    }));
  });
  var _ = be(g, 2);
  return jd(_, {
    get id() {
      return d(u).list;
    },
    get config() {
      return a();
    }
  }), A(t, f), H(c);
}
K(g1, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
var RI = /* @__PURE__ */ ne("<!> <!>", 1);
function p1(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Input);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ O(() => Ni(r, a(), "shadcn4Number", l(), { type: "number" }));
  var c = {
    get value() {
      return i();
    },
    set value(h) {
      i(h), m();
    },
    get config() {
      return a();
    },
    set config(h) {
      a(h), m();
    },
    get handlers() {
      return l();
    },
    set handlers(h) {
      l(h), m();
    }
  }, f = RI(), g = D(f), _ = () => i() ?? null, b = (h) => i(h ?? void 0);
  Q(g, () => d(o), (h, y) => {
    y(h, ce(
      {
        get value() {
          return _();
        },
        set value(S) {
          b(S);
        }
      },
      () => d(u)
    ));
  });
  var p = be(g, 2);
  return jd(p, {
    get id() {
      return d(u).list;
    },
    get config() {
      return a();
    }
  }), A(t, f), H(c);
}
K(p1, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
const Xa = "-1";
function Lo(t) {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  for (const n of t)
    e.set(n.id, n.value), r.set(n.value, n.id);
  return {
    fromValue(n) {
      if (n === void 0)
        return Xa;
      const s = r.get(n);
      return s !== void 0 ? s : Ns(n) ? t.find((o) => Ul(o.value, n))?.id ?? Xa : t.find((o) => o.value === n)?.id ?? Xa;
    },
    toValue(n) {
      return e.get(n);
    }
  };
}
function vu({ mapper: t, value: e, update: r }) {
  const n = /* @__PURE__ */ O(t), s = /* @__PURE__ */ O(() => d(n).fromValue), o = /* @__PURE__ */ O(() => d(n).toValue), i = /* @__PURE__ */ O(() => d(s)(e()));
  return {
    get value() {
      return d(i);
    },
    set value(a) {
      r(d(o)(a));
    },
    get current() {
      return d(i);
    },
    set current(a) {
      r(d(o)(a));
    }
  };
}
function m1({ mapper: t, value: e, update: r }) {
  const n = /* @__PURE__ */ O(t), s = /* @__PURE__ */ O(() => d(n).fromValue), o = /* @__PURE__ */ O(() => d(n).toValue), i = /* @__PURE__ */ O(() => e()?.map(d(s)) ?? []);
  return {
    get value() {
      return d(i);
    },
    set value(a) {
      r(a.map(d(o)));
    },
    get current() {
      return d(i);
    },
    set current(a) {
      r(a.map(d(o)));
    }
  };
}
var VI = /* @__PURE__ */ ne("<span> </span>"), LI = /* @__PURE__ */ ne('<span class="min-h-5"> </span>'), jI = /* @__PURE__ */ ne("<!> <!>", 1), BI = /* @__PURE__ */ ne("<!> <!>", 1);
function v1(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Select), i = /* @__PURE__ */ O(() => d(s).SelectTrigger), a = /* @__PURE__ */ O(() => d(s).SelectContent), l = /* @__PURE__ */ O(() => d(s).SelectItem);
  let u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7), g = v(e, "config", 7);
  const _ = /* @__PURE__ */ O(() => new Map(f().map(($) => [$.id, $.label]))), b = vu({
    mapper: () => Lo(f()),
    value: () => c(),
    update: ($) => c($)
  }), p = /* @__PURE__ */ O(() => u().oninput), h = /* @__PURE__ */ O(() => u().onchange), y = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), S = /* @__PURE__ */ O(() => pr(r, g(), "shadcn4Select", {
    required: g().required,
    onValueChange: () => {
      d(p)?.(), d(h)?.();
    }
  })), x = /* @__PURE__ */ O(() => d(_).get(b.current) ?? d(S).placeholder), P = /* @__PURE__ */ O(() => mr(r, g().path));
  var w = {
    get handlers() {
      return u();
    },
    set handlers($) {
      u($), m();
    },
    get value() {
      return c();
    },
    set value($) {
      c($), m();
    },
    get options() {
      return f();
    },
    set options($) {
      f($), m();
    },
    get config() {
      return g();
    },
    set config($) {
      g($), m();
    }
  }, C = M(), k = D(C);
  return Q(k, () => d(o), ($, T) => {
    T($, ce(() => d(S), {
      type: "single",
      get value() {
        return b.current;
      },
      set value(E) {
        b.current = E;
      },
      children: (E, I) => {
        var F = BI(), U = D(F);
        {
          let R = /* @__PURE__ */ O(() => pr(r, g(), "shadcn4SelectTrigger", cn(d(y))({ id: d(P), name: d(P) })));
          Q(U, () => d(i), (Z, Y) => {
            Y(Z, ce({ class: "w-full" }, () => d(R), {
              children: (X, ae) => {
                var J = VI(), j = ge(J, !0);
                de(J), ke(() => Ie(j, d(x))), A(X, J);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var B = be(U, 2);
        Q(B, () => d(a), (R, Z) => {
          Z(R, {
            children: (Y, X) => {
              var ae = jI(), J = D(ae);
              {
                var j = (L) => {
                  var N = M(), V = D(N);
                  Q(V, () => d(l), (G, fe) => {
                    fe(G, {
                      get value() {
                        return Xa;
                      },
                      children: (se, we) => {
                        var le = LI(), re = ge(le, !0);
                        de(le), ke(() => Ie(re, d(S).placeholder)), A(se, le);
                      },
                      $$slots: { default: !0 }
                    });
                  }), A(L, N);
                };
                ue(J, (L) => {
                  g().schema.default === void 0 && L(j);
                });
              }
              var ee = be(J, 2);
              nt(ee, 17, f, (L) => L.id, (L, N) => {
                var V = M(), G = D(V);
                Q(G, () => d(l), (fe, se) => {
                  se(fe, {
                    get value() {
                      return d(N).id;
                    },
                    get label() {
                      return d(N).label;
                    },
                    get disabled() {
                      return d(N).disabled;
                    }
                  });
                }), A(L, V);
              }), A(Y, ae);
            },
            $$slots: { default: !0 }
          });
        }), A(E, F);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, C), H(w);
}
K(v1, { handlers: {}, value: {}, options: {}, config: {} }, [], [], { mode: "open" });
var zI = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function y1(t, e) {
  W(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "handlers", 7);
  const o = Ee(), i = ut(), a = /* @__PURE__ */ O(() => i.components), l = /* @__PURE__ */ O(() => d(a).Checkbox), u = /* @__PURE__ */ O(() => d(a).FieldLabel), c = /* @__PURE__ */ O(() => s().oninput), f = /* @__PURE__ */ O(() => s().onchange), g = /* @__PURE__ */ O(() => Nn(s(), ["oninput", "onchange"])), _ = /* @__PURE__ */ O(() => mr(o, r().path)), b = /* @__PURE__ */ O(() => pr(o, r(), "shadcn4Checkbox", cn(d(g))({
    id: d(_),
    name: d(_),
    required: r().required,
    onCheckedChange: () => {
      d(c)?.(), d(f)?.();
    }
  })));
  var p = {
    get config() {
      return r();
    },
    set config(w) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get handlers() {
      return s();
    },
    set handlers(w) {
      s(w), m();
    }
  }, h = zI(), y = ge(h), S = () => n() ?? !1, x = (w) => {
    n(w);
  };
  Q(y, () => d(l), (w, C) => {
    C(w, ce(
      {
        get checked() {
          return S();
        },
        set checked(k) {
          x(k);
        }
      },
      () => d(b)
    ));
  });
  var P = be(y, 2);
  return Q(P, () => d(u), (w, C) => {
    C(w, {
      get for() {
        return d(b).id;
      },
      children: (k, $) => {
        St();
        var T = st();
        ke(() => Ie(T, r().title)), A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), de(h), A(t, h), H(p);
}
K(y1, { config: {}, value: {}, handlers: {} }, [], [], { mode: "open" });
const qI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkboxWidget: y1,
  numberWidget: p1,
  selectWidget: v1,
  textWidget: g1
}, Symbol.toStringTag, { value: "Module" })), nr = {
  ...NI,
  ...qI
}, UI = nb(dI, nr);
const KI = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var WI = /* @__PURE__ */ NP("<svg><!><!></svg>");
function Dt(t, e) {
  W(e, !0);
  const r = v(e, "name", 7), n = v(e, "color", 7, "currentColor"), s = v(e, "size", 7, 24), o = v(e, "strokeWidth", 7, 2), i = v(e, "absoluteStrokeWidth", 7, !1), a = v(e, "iconNode", 23, () => []), l = v(e, "children", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode",
    "children"
  ]);
  var c = {
    get name() {
      return r();
    },
    set name(b) {
      r(b), m();
    },
    get color() {
      return n();
    },
    set color(b = "currentColor") {
      n(b), m();
    },
    get size() {
      return s();
    },
    set size(b = 24) {
      s(b), m();
    },
    get strokeWidth() {
      return o();
    },
    set strokeWidth(b = 2) {
      o(b), m();
    },
    get absoluteStrokeWidth() {
      return i();
    },
    set absoluteStrokeWidth(b = !1) {
      i(b), m();
    },
    get iconNode() {
      return a();
    },
    set iconNode(b = []) {
      a(b), m();
    },
    get children() {
      return l();
    },
    set children(b) {
      l(b), m();
    }
  }, f = WI();
  ve(
    f,
    (b) => ({
      ...KI,
      ...u,
      width: s(),
      height: s(),
      stroke: n(),
      "stroke-width": b,
      class: [
        "lucide-icon lucide",
        r() && `lucide-${r()}`,
        e.class
      ]
    }),
    [
      () => i() ? Number(o()) * 24 / Number(s()) : o()
    ]
  );
  var g = ge(f);
  nt(g, 17, a, jl, (b, p) => {
    var h = /* @__PURE__ */ O(() => qx(d(p), 2));
    let y = () => d(h)[0], S = () => d(h)[1];
    var x = M(), P = D(x);
    JP(P, y, !0, (w, C) => {
      ve(w, () => ({ ...S() }));
    }), A(b, x);
  });
  var _ = be(g);
  return te(_, () => l() ?? he), de(f), A(t, f), H(c);
}
K(
  Dt,
  {
    name: {},
    color: {},
    size: {},
    strokeWidth: {},
    absoluteStrokeWidth: {},
    iconNode: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
function b1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M12 5v14" }],
    ["path", { d: "m19 12-7 7-7-7" }]
  ];
  Dt(t, ce({ name: "arrow-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(b1, {}, [], [], { mode: "open" });
function _1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m5 12 7-7 7 7" }],
    ["path", { d: "M12 19V5" }]
  ];
  Dt(t, ce({ name: "arrow-up" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(_1, {}, [], [], { mode: "open" });
function w1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    [
      "rect",
      { width: "18", height: "18", x: "3", y: "4", rx: "2" }
    ],
    ["path", { d: "M3 10h18" }]
  ];
  Dt(t, ce({ name: "calendar" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(w1, {}, [], [], { mode: "open" });
function yu(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "M20 6 9 17l-5-5" }]];
  Dt(t, ce({ name: "check" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(yu, {}, [], [], { mode: "open" });
function gs(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m6 9 6 6 6-6" }]];
  Dt(t, ce({ name: "chevron-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(gs, {}, [], [], { mode: "open" });
function sg(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m15 18-6-6 6-6" }]];
  Dt(t, ce({ name: "chevron-left" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(sg, {}, [], [], { mode: "open" });
function og(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m9 18 6-6-6-6" }]];
  Dt(t, ce({ name: "chevron-right" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(og, {}, [], [], { mode: "open" });
function S1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m18 15-6-6-6 6" }]];
  Dt(t, ce({ name: "chevron-up" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(S1, {}, [], [], { mode: "open" });
function x1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m7 15 5 5 5-5" }],
    ["path", { d: "m7 9 5-5 5 5" }]
  ];
  Dt(t, ce({ name: "chevrons-up-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(x1, {}, [], [], { mode: "open" });
function P1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["circle", { cx: "12", cy: "12", r: "10" }]];
  Dt(t, ce({ name: "circle" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(P1, {}, [], [], { mode: "open" });
function O1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    [
      "rect",
      {
        width: "14",
        height: "14",
        x: "8",
        y: "8",
        rx: "2",
        ry: "2"
      }
    ],
    [
      "path",
      {
        d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
      }
    ]
  ];
  Dt(t, ce({ name: "copy" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(O1, {}, [], [], { mode: "open" });
function C1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "M5 12h14" }]];
  Dt(t, ce({ name: "minus" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(C1, {}, [], [], { mode: "open" });
function k1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m21 21-4.34-4.34" }],
    ["circle", { cx: "11", cy: "11", r: "8" }]
  ];
  Dt(t, ce({ name: "search" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(k1, {}, [], [], { mode: "open" });
function $1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }]
  ];
  Dt(t, ce({ name: "trash" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K($1, {}, [], [], { mode: "open" });
function A1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    [
      "path",
      {
        d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"
      }
    ],
    ["path", { d: "M12 9v4" }],
    ["path", { d: "M12 17h.01" }]
  ];
  Dt(t, ce({ name: "triangle-alert" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(A1, {}, [], [], { mode: "open" });
function E1(t, e) {
  W(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M18 6 6 18" }],
    ["path", { d: "m6 6 12 12" }]
  ];
  Dt(t, ce({ name: "x" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = M(), a = D(i);
      te(a, () => e.children ?? he), A(s, i);
    },
    $$slots: { default: !0 }
  })), H();
}
K(E1, {}, [], [], { mode: "open" });
function HI(t) {
  return t instanceof Error ? t.message : String(t);
}
const jo = function(t, e) {
  let s = t;
  const o = ii[e];
  let i = null, a = 0, l = null;
  const u = [], c = {}, f = function(k, $) {
    a = s * 4 + 17, i = (function(T) {
      const E = new Array(T);
      for (let I = 0; I < T; I += 1) {
        E[I] = new Array(T);
        for (let F = 0; F < T; F += 1)
          E[I][F] = null;
      }
      return E;
    })(a), g(0, 0), g(a - 7, 0), g(0, a - 7), p(), b(), y(k, $), s >= 7 && h(k), l == null && (l = P(s, o, u)), S(l, $);
  }, g = function(k, $) {
    for (let T = -1; T <= 7; T += 1)
      if (!(k + T <= -1 || a <= k + T))
        for (let E = -1; E <= 7; E += 1)
          $ + E <= -1 || a <= $ + E || (0 <= T && T <= 6 && (E == 0 || E == 6) || 0 <= E && E <= 6 && (T == 0 || T == 6) || 2 <= T && T <= 4 && 2 <= E && E <= 4 ? i[k + T][$ + E] = !0 : i[k + T][$ + E] = !1);
  }, _ = function() {
    let k = 0, $ = 0;
    for (let T = 0; T < 8; T += 1) {
      f(!0, T);
      const E = jn.getLostPoint(c);
      (T == 0 || k > E) && (k = E, $ = T);
    }
    return $;
  }, b = function() {
    for (let k = 8; k < a - 8; k += 1)
      i[k][6] == null && (i[k][6] = k % 2 == 0);
    for (let k = 8; k < a - 8; k += 1)
      i[6][k] == null && (i[6][k] = k % 2 == 0);
  }, p = function() {
    const k = jn.getPatternPosition(s);
    for (let $ = 0; $ < k.length; $ += 1)
      for (let T = 0; T < k.length; T += 1) {
        const E = k[$], I = k[T];
        if (i[E][I] == null)
          for (let F = -2; F <= 2; F += 1)
            for (let U = -2; U <= 2; U += 1)
              F == -2 || F == 2 || U == -2 || U == 2 || F == 0 && U == 0 ? i[E + F][I + U] = !0 : i[E + F][I + U] = !1;
      }
  }, h = function(k) {
    const $ = jn.getBCHTypeNumber(s);
    for (let T = 0; T < 18; T += 1) {
      const E = !k && ($ >> T & 1) == 1;
      i[Math.floor(T / 3)][T % 3 + a - 8 - 3] = E;
    }
    for (let T = 0; T < 18; T += 1) {
      const E = !k && ($ >> T & 1) == 1;
      i[T % 3 + a - 8 - 3][Math.floor(T / 3)] = E;
    }
  }, y = function(k, $) {
    const T = o << 3 | $, E = jn.getBCHTypeInfo(T);
    for (let I = 0; I < 15; I += 1) {
      const F = !k && (E >> I & 1) == 1;
      I < 6 ? i[I][8] = F : I < 8 ? i[I + 1][8] = F : i[a - 15 + I][8] = F;
    }
    for (let I = 0; I < 15; I += 1) {
      const F = !k && (E >> I & 1) == 1;
      I < 8 ? i[8][a - I - 1] = F : I < 9 ? i[8][15 - I - 1 + 1] = F : i[8][15 - I - 1] = F;
    }
    i[a - 8][8] = !k;
  }, S = function(k, $) {
    let T = -1, E = a - 1, I = 7, F = 0;
    const U = jn.getMaskFunction($);
    for (let B = a - 1; B > 0; B -= 2)
      for (B == 6 && (B -= 1); ; ) {
        for (let R = 0; R < 2; R += 1)
          if (i[E][B - R] == null) {
            let Z = !1;
            F < k.length && (Z = (k[F] >>> I & 1) == 1), U(E, B - R) && (Z = !Z), i[E][B - R] = Z, I -= 1, I == -1 && (F += 1, I = 7);
          }
        if (E += T, E < 0 || a <= E) {
          E -= T, T = -T;
          break;
        }
      }
  }, x = function(k, $) {
    let T = 0, E = 0, I = 0;
    const F = new Array($.length), U = new Array($.length);
    for (let Y = 0; Y < $.length; Y += 1) {
      const X = $[Y].dataCount, ae = $[Y].totalCount - X;
      E = Math.max(E, X), I = Math.max(I, ae), F[Y] = new Array(X);
      for (let L = 0; L < F[Y].length; L += 1)
        F[Y][L] = 255 & k.getBuffer()[L + T];
      T += X;
      const J = jn.getErrorCorrectPolynomial(ae), ee = Oi(F[Y], J.getLength() - 1).mod(J);
      U[Y] = new Array(J.getLength() - 1);
      for (let L = 0; L < U[Y].length; L += 1) {
        const N = L + ee.getLength() - U[Y].length;
        U[Y][L] = N >= 0 ? ee.getAt(N) : 0;
      }
    }
    let B = 0;
    for (let Y = 0; Y < $.length; Y += 1)
      B += $[Y].totalCount;
    const R = new Array(B);
    let Z = 0;
    for (let Y = 0; Y < E; Y += 1)
      for (let X = 0; X < $.length; X += 1)
        Y < F[X].length && (R[Z] = F[X][Y], Z += 1);
    for (let Y = 0; Y < I; Y += 1)
      for (let X = 0; X < $.length; X += 1)
        Y < U[X].length && (R[Z] = U[X][Y], Z += 1);
    return R;
  }, P = function(k, $, T) {
    const E = Hm.getRSBlocks(k, $), I = Gm();
    for (let U = 0; U < T.length; U += 1) {
      const B = T[U];
      I.put(B.getMode(), 4), I.put(B.getLength(), jn.getLengthInBits(B.getMode(), k)), B.write(I);
    }
    let F = 0;
    for (let U = 0; U < E.length; U += 1)
      F += E[U].dataCount;
    if (I.getLengthInBits() > F * 8)
      throw "code length overflow. (" + I.getLengthInBits() + ">" + F * 8 + ")";
    for (I.getLengthInBits() + 4 <= F * 8 && I.put(0, 4); I.getLengthInBits() % 8 != 0; )
      I.putBit(!1);
    for (; !(I.getLengthInBits() >= F * 8 || (I.put(236, 8), I.getLengthInBits() >= F * 8)); )
      I.put(17, 8);
    return x(I, E);
  };
  c.addData = function(k, $) {
    $ = $ || "Byte";
    let T = null;
    switch ($) {
      case "Numeric":
        T = GI(k);
        break;
      case "Alphanumeric":
        T = YI(k);
        break;
      case "Byte":
        T = XI(k);
        break;
      case "Kanji":
        T = JI(k);
        break;
      default:
        throw "mode:" + $;
    }
    u.push(T), l = null;
  }, c.isDark = function(k, $) {
    if (k < 0 || a <= k || $ < 0 || a <= $)
      throw k + "," + $;
    return i[k][$];
  }, c.getModuleCount = function() {
    return a;
  }, c.make = function() {
    if (s < 1) {
      let k = 1;
      for (; k < 40; k++) {
        const $ = Hm.getRSBlocks(k, o), T = Gm();
        for (let I = 0; I < u.length; I++) {
          const F = u[I];
          T.put(F.getMode(), 4), T.put(F.getLength(), jn.getLengthInBits(F.getMode(), k)), F.write(T);
        }
        let E = 0;
        for (let I = 0; I < $.length; I++)
          E += $[I].dataCount;
        if (T.getLengthInBits() <= E * 8)
          break;
      }
      s = k;
    }
    f(!1, _());
  }, c.createTableTag = function(k, $) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    let T = "";
    T += '<table style="', T += " border-width: 0px; border-style: none;", T += " border-collapse: collapse;", T += " padding: 0px; margin: " + $ + "px;", T += '">', T += "<tbody>";
    for (let E = 0; E < c.getModuleCount(); E += 1) {
      T += "<tr>";
      for (let I = 0; I < c.getModuleCount(); I += 1)
        T += '<td style="', T += " border-width: 0px; border-style: none;", T += " border-collapse: collapse;", T += " padding: 0px; margin: 0px;", T += " width: " + k + "px;", T += " height: " + k + "px;", T += " background-color: ", T += c.isDark(E, I) ? "#000000" : "#ffffff", T += ";", T += '"/>';
      T += "</tr>";
    }
    return T += "</tbody>", T += "</table>", T;
  }, c.createSvgTag = function(k, $, T, E) {
    let I = {};
    typeof arguments[0] == "object" && (I = arguments[0], k = I.cellSize, $ = I.margin, T = I.alt, E = I.title), k = k || 2, $ = typeof $ > "u" ? k * 4 : $, T = typeof T == "string" ? { text: T } : T || {}, T.text = T.text || null, T.id = T.text ? T.id || "qrcode-description" : null, E = typeof E == "string" ? { text: E } : E || {}, E.text = E.text || null, E.id = E.text ? E.id || "qrcode-title" : null;
    const F = c.getModuleCount() * k + $ * 2;
    let U, B, R, Z, Y = "", X;
    for (X = "l" + k + ",0 0," + k + " -" + k + ",0 0,-" + k + "z ", Y += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Y += I.scalable ? "" : ' width="' + F + 'px" height="' + F + 'px"', Y += ' viewBox="0 0 ' + F + " " + F + '" ', Y += ' preserveAspectRatio="xMinYMin meet"', Y += E.text || T.text ? ' role="img" aria-labelledby="' + w([E.id, T.id].join(" ").trim()) + '"' : "", Y += ">", Y += E.text ? '<title id="' + w(E.id) + '">' + w(E.text) + "</title>" : "", Y += T.text ? '<description id="' + w(T.id) + '">' + w(T.text) + "</description>" : "", Y += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Y += '<path d="', R = 0; R < c.getModuleCount(); R += 1)
      for (Z = R * k + $, U = 0; U < c.getModuleCount(); U += 1)
        c.isDark(R, U) && (B = U * k + $, Y += "M" + B + "," + Z + X);
    return Y += '" stroke="transparent" fill="black"/>', Y += "</svg>", Y;
  }, c.createDataURL = function(k, $) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    const T = c.getModuleCount() * k + $ * 2, E = $, I = T - $;
    return tN(T, T, function(F, U) {
      if (E <= F && F < I && E <= U && U < I) {
        const B = Math.floor((F - E) / k), R = Math.floor((U - E) / k);
        return c.isDark(R, B) ? 0 : 1;
      } else
        return 1;
    });
  }, c.createImgTag = function(k, $, T) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    const E = c.getModuleCount() * k + $ * 2;
    let I = "";
    return I += "<img", I += ' src="', I += c.createDataURL(k, $), I += '"', I += ' width="', I += E, I += '"', I += ' height="', I += E, I += '"', T && (I += ' alt="', I += w(T), I += '"'), I += "/>", I;
  };
  const w = function(k) {
    let $ = "";
    for (let T = 0; T < k.length; T += 1) {
      const E = k.charAt(T);
      switch (E) {
        case "<":
          $ += "&lt;";
          break;
        case ">":
          $ += "&gt;";
          break;
        case "&":
          $ += "&amp;";
          break;
        case '"':
          $ += "&quot;";
          break;
        default:
          $ += E;
          break;
      }
    }
    return $;
  }, C = function(k) {
    k = typeof k > "u" ? 2 : k;
    const T = c.getModuleCount() * 1 + k * 2, E = k, I = T - k;
    let F, U, B, R, Z;
    const Y = {
      "â–ˆâ–ˆ": "â–ˆ",
      "â–ˆ ": "â–€",
      " â–ˆ": "â–„",
      "  ": " "
    }, X = {
      "â–ˆâ–ˆ": "â–€",
      "â–ˆ ": "â–€",
      " â–ˆ": " ",
      "  ": " "
    };
    let ae = "";
    for (F = 0; F < T; F += 2) {
      for (B = Math.floor((F - E) / 1), R = Math.floor((F + 1 - E) / 1), U = 0; U < T; U += 1)
        Z = "â–ˆ", E <= U && U < I && E <= F && F < I && c.isDark(B, Math.floor((U - E) / 1)) && (Z = " "), E <= U && U < I && E <= F + 1 && F + 1 < I && c.isDark(R, Math.floor((U - E) / 1)) ? Z += " " : Z += "â–ˆ", ae += k < 1 && F + 1 >= I ? X[Z] : Y[Z];
      ae += `
`;
    }
    return T % 2 && k > 0 ? ae.substring(0, ae.length - T - 1) + Array(T + 1).join("â–€") : ae.substring(0, ae.length - 1);
  };
  return c.createASCII = function(k, $) {
    if (k = k || 1, k < 2)
      return C($);
    k -= 1, $ = typeof $ > "u" ? k * 2 : $;
    const T = c.getModuleCount() * k + $ * 2, E = $, I = T - $;
    let F, U, B, R;
    const Z = Array(k + 1).join("â–ˆâ–ˆ"), Y = Array(k + 1).join("  ");
    let X = "", ae = "";
    for (F = 0; F < T; F += 1) {
      for (B = Math.floor((F - E) / k), ae = "", U = 0; U < T; U += 1)
        R = 1, E <= U && U < I && E <= F && F < I && c.isDark(B, Math.floor((U - E) / k)) && (R = 0), ae += R ? Z : Y;
      for (B = 0; B < k; B += 1)
        X += ae + `
`;
    }
    return X.substring(0, X.length - 1);
  }, c.renderTo2dContext = function(k, $) {
    $ = $ || 2;
    const T = c.getModuleCount();
    for (let E = 0; E < T; E++)
      for (let I = 0; I < T; I++)
        k.fillStyle = c.isDark(E, I) ? "black" : "white", k.fillRect(I * $, E * $, $, $);
  }, c;
};
jo.stringToBytes = function(t) {
  const e = [];
  for (let r = 0; r < t.length; r += 1) {
    const n = t.charCodeAt(r);
    e.push(n & 255);
  }
  return e;
};
jo.createStringToBytes = function(t, e) {
  const r = (function() {
    const s = QI(t), o = function() {
      const l = s.read();
      if (l == -1) throw "eof";
      return l;
    };
    let i = 0;
    const a = {};
    for (; ; ) {
      const l = s.read();
      if (l == -1) break;
      const u = o(), c = o(), f = o(), g = String.fromCharCode(l << 8 | u), _ = c << 8 | f;
      a[g] = _, i += 1;
    }
    if (i != e)
      throw i + " != " + e;
    return a;
  })(), n = 63;
  return function(s) {
    const o = [];
    for (let i = 0; i < s.length; i += 1) {
      const a = s.charCodeAt(i);
      if (a < 128)
        o.push(a);
      else {
        const l = r[s.charAt(i)];
        typeof l == "number" ? (l & 255) == l ? o.push(l) : (o.push(l >>> 8), o.push(l & 255)) : o.push(n);
      }
    }
    return o;
  };
};
const It = {
  MODE_NUMBER: 1,
  MODE_ALPHA_NUM: 2,
  MODE_8BIT_BYTE: 4,
  MODE_KANJI: 8
}, ii = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
}, Ln = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
}, jn = (function() {
  const t = [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
  ], e = 1335, r = 7973, n = 21522, s = {}, o = function(i) {
    let a = 0;
    for (; i != 0; )
      a += 1, i >>>= 1;
    return a;
  };
  return s.getBCHTypeInfo = function(i) {
    let a = i << 10;
    for (; o(a) - o(e) >= 0; )
      a ^= e << o(a) - o(e);
    return (i << 10 | a) ^ n;
  }, s.getBCHTypeNumber = function(i) {
    let a = i << 12;
    for (; o(a) - o(r) >= 0; )
      a ^= r << o(a) - o(r);
    return i << 12 | a;
  }, s.getPatternPosition = function(i) {
    return t[i - 1];
  }, s.getMaskFunction = function(i) {
    switch (i) {
      case Ln.PATTERN000:
        return function(a, l) {
          return (a + l) % 2 == 0;
        };
      case Ln.PATTERN001:
        return function(a, l) {
          return a % 2 == 0;
        };
      case Ln.PATTERN010:
        return function(a, l) {
          return l % 3 == 0;
        };
      case Ln.PATTERN011:
        return function(a, l) {
          return (a + l) % 3 == 0;
        };
      case Ln.PATTERN100:
        return function(a, l) {
          return (Math.floor(a / 2) + Math.floor(l / 3)) % 2 == 0;
        };
      case Ln.PATTERN101:
        return function(a, l) {
          return a * l % 2 + a * l % 3 == 0;
        };
      case Ln.PATTERN110:
        return function(a, l) {
          return (a * l % 2 + a * l % 3) % 2 == 0;
        };
      case Ln.PATTERN111:
        return function(a, l) {
          return (a * l % 3 + (a + l) % 2) % 2 == 0;
        };
      default:
        throw "bad maskPattern:" + i;
    }
  }, s.getErrorCorrectPolynomial = function(i) {
    let a = Oi([1], 0);
    for (let l = 0; l < i; l += 1)
      a = a.multiply(Oi([1, Un.gexp(l)], 0));
    return a;
  }, s.getLengthInBits = function(i, a) {
    if (1 <= a && a < 10)
      switch (i) {
        case It.MODE_NUMBER:
          return 10;
        case It.MODE_ALPHA_NUM:
          return 9;
        case It.MODE_8BIT_BYTE:
          return 8;
        case It.MODE_KANJI:
          return 8;
        default:
          throw "mode:" + i;
      }
    else if (a < 27)
      switch (i) {
        case It.MODE_NUMBER:
          return 12;
        case It.MODE_ALPHA_NUM:
          return 11;
        case It.MODE_8BIT_BYTE:
          return 16;
        case It.MODE_KANJI:
          return 10;
        default:
          throw "mode:" + i;
      }
    else if (a < 41)
      switch (i) {
        case It.MODE_NUMBER:
          return 14;
        case It.MODE_ALPHA_NUM:
          return 13;
        case It.MODE_8BIT_BYTE:
          return 16;
        case It.MODE_KANJI:
          return 12;
        default:
          throw "mode:" + i;
      }
    else
      throw "type:" + a;
  }, s.getLostPoint = function(i) {
    const a = i.getModuleCount();
    let l = 0;
    for (let f = 0; f < a; f += 1)
      for (let g = 0; g < a; g += 1) {
        let _ = 0;
        const b = i.isDark(f, g);
        for (let p = -1; p <= 1; p += 1)
          if (!(f + p < 0 || a <= f + p))
            for (let h = -1; h <= 1; h += 1)
              g + h < 0 || a <= g + h || p == 0 && h == 0 || b == i.isDark(f + p, g + h) && (_ += 1);
        _ > 5 && (l += 3 + _ - 5);
      }
    for (let f = 0; f < a - 1; f += 1)
      for (let g = 0; g < a - 1; g += 1) {
        let _ = 0;
        i.isDark(f, g) && (_ += 1), i.isDark(f + 1, g) && (_ += 1), i.isDark(f, g + 1) && (_ += 1), i.isDark(f + 1, g + 1) && (_ += 1), (_ == 0 || _ == 4) && (l += 3);
      }
    for (let f = 0; f < a; f += 1)
      for (let g = 0; g < a - 6; g += 1)
        i.isDark(f, g) && !i.isDark(f, g + 1) && i.isDark(f, g + 2) && i.isDark(f, g + 3) && i.isDark(f, g + 4) && !i.isDark(f, g + 5) && i.isDark(f, g + 6) && (l += 40);
    for (let f = 0; f < a; f += 1)
      for (let g = 0; g < a - 6; g += 1)
        i.isDark(g, f) && !i.isDark(g + 1, f) && i.isDark(g + 2, f) && i.isDark(g + 3, f) && i.isDark(g + 4, f) && !i.isDark(g + 5, f) && i.isDark(g + 6, f) && (l += 40);
    let u = 0;
    for (let f = 0; f < a; f += 1)
      for (let g = 0; g < a; g += 1)
        i.isDark(g, f) && (u += 1);
    const c = Math.abs(100 * u / a / a - 50) / 5;
    return l += c * 10, l;
  }, s;
})(), Un = (function() {
  const t = new Array(256), e = new Array(256);
  for (let n = 0; n < 8; n += 1)
    t[n] = 1 << n;
  for (let n = 8; n < 256; n += 1)
    t[n] = t[n - 4] ^ t[n - 5] ^ t[n - 6] ^ t[n - 8];
  for (let n = 0; n < 255; n += 1)
    e[t[n]] = n;
  const r = {};
  return r.glog = function(n) {
    if (n < 1)
      throw "glog(" + n + ")";
    return e[n];
  }, r.gexp = function(n) {
    for (; n < 0; )
      n += 255;
    for (; n >= 256; )
      n -= 255;
    return t[n];
  }, r;
})(), Oi = function(t, e) {
  if (typeof t.length > "u")
    throw t.length + "/" + e;
  const r = (function() {
    let s = 0;
    for (; s < t.length && t[s] == 0; )
      s += 1;
    const o = new Array(t.length - s + e);
    for (let i = 0; i < t.length - s; i += 1)
      o[i] = t[i + s];
    return o;
  })(), n = {};
  return n.getAt = function(s) {
    return r[s];
  }, n.getLength = function() {
    return r.length;
  }, n.multiply = function(s) {
    const o = new Array(n.getLength() + s.getLength() - 1);
    for (let i = 0; i < n.getLength(); i += 1)
      for (let a = 0; a < s.getLength(); a += 1)
        o[i + a] ^= Un.gexp(Un.glog(n.getAt(i)) + Un.glog(s.getAt(a)));
    return Oi(o, 0);
  }, n.mod = function(s) {
    if (n.getLength() - s.getLength() < 0)
      return n;
    const o = Un.glog(n.getAt(0)) - Un.glog(s.getAt(0)), i = new Array(n.getLength());
    for (let a = 0; a < n.getLength(); a += 1)
      i[a] = n.getAt(a);
    for (let a = 0; a < s.getLength(); a += 1)
      i[a] ^= Un.gexp(Un.glog(s.getAt(a)) + o);
    return Oi(i, 0).mod(s);
  }, n;
}, Hm = (function() {
  const t = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12, 7, 37, 13],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ], e = function(s, o) {
    const i = {};
    return i.totalCount = s, i.dataCount = o, i;
  }, r = {}, n = function(s, o) {
    switch (o) {
      case ii.L:
        return t[(s - 1) * 4 + 0];
      case ii.M:
        return t[(s - 1) * 4 + 1];
      case ii.Q:
        return t[(s - 1) * 4 + 2];
      case ii.H:
        return t[(s - 1) * 4 + 3];
      default:
        return;
    }
  };
  return r.getRSBlocks = function(s, o) {
    const i = n(s, o);
    if (typeof i > "u")
      throw "bad rs block @ typeNumber:" + s + "/errorCorrectionLevel:" + o;
    const a = i.length / 3, l = [];
    for (let u = 0; u < a; u += 1) {
      const c = i[u * 3 + 0], f = i[u * 3 + 1], g = i[u * 3 + 2];
      for (let _ = 0; _ < c; _ += 1)
        l.push(e(f, g));
    }
    return l;
  }, r;
})(), Gm = function() {
  const t = [];
  let e = 0;
  const r = {};
  return r.getBuffer = function() {
    return t;
  }, r.getAt = function(n) {
    const s = Math.floor(n / 8);
    return (t[s] >>> 7 - n % 8 & 1) == 1;
  }, r.put = function(n, s) {
    for (let o = 0; o < s; o += 1)
      r.putBit((n >>> s - o - 1 & 1) == 1);
  }, r.getLengthInBits = function() {
    return e;
  }, r.putBit = function(n) {
    const s = Math.floor(e / 8);
    t.length <= s && t.push(0), n && (t[s] |= 128 >>> e % 8), e += 1;
  }, r;
}, GI = function(t) {
  const e = It.MODE_NUMBER, r = t, n = {};
  n.getMode = function() {
    return e;
  }, n.getLength = function(i) {
    return r.length;
  }, n.write = function(i) {
    const a = r;
    let l = 0;
    for (; l + 2 < a.length; )
      i.put(s(a.substring(l, l + 3)), 10), l += 3;
    l < a.length && (a.length - l == 1 ? i.put(s(a.substring(l, l + 1)), 4) : a.length - l == 2 && i.put(s(a.substring(l, l + 2)), 7));
  };
  const s = function(i) {
    let a = 0;
    for (let l = 0; l < i.length; l += 1)
      a = a * 10 + o(i.charAt(l));
    return a;
  }, o = function(i) {
    if ("0" <= i && i <= "9")
      return i.charCodeAt(0) - 48;
    throw "illegal char :" + i;
  };
  return n;
}, YI = function(t) {
  const e = It.MODE_ALPHA_NUM, r = t, n = {};
  n.getMode = function() {
    return e;
  }, n.getLength = function(o) {
    return r.length;
  }, n.write = function(o) {
    const i = r;
    let a = 0;
    for (; a + 1 < i.length; )
      o.put(
        s(i.charAt(a)) * 45 + s(i.charAt(a + 1)),
        11
      ), a += 2;
    a < i.length && o.put(s(i.charAt(a)), 6);
  };
  const s = function(o) {
    if ("0" <= o && o <= "9")
      return o.charCodeAt(0) - 48;
    if ("A" <= o && o <= "Z")
      return o.charCodeAt(0) - 65 + 10;
    switch (o) {
      case " ":
        return 36;
      case "$":
        return 37;
      case "%":
        return 38;
      case "*":
        return 39;
      case "+":
        return 40;
      case "-":
        return 41;
      case ".":
        return 42;
      case "/":
        return 43;
      case ":":
        return 44;
      default:
        throw "illegal char :" + o;
    }
  };
  return n;
}, XI = function(t) {
  const e = It.MODE_8BIT_BYTE, r = jo.stringToBytes(t), n = {};
  return n.getMode = function() {
    return e;
  }, n.getLength = function(s) {
    return r.length;
  }, n.write = function(s) {
    for (let o = 0; o < r.length; o += 1)
      s.put(r[o], 8);
  }, n;
}, JI = function(t) {
  const e = It.MODE_KANJI, r = jo.stringToBytes;
  (function(o, i) {
    const a = r(o);
    if (a.length != 2 || (a[0] << 8 | a[1]) != i)
      throw "sjis not supported.";
  })("å‹", 38726);
  const n = r(t), s = {};
  return s.getMode = function() {
    return e;
  }, s.getLength = function(o) {
    return ~~(n.length / 2);
  }, s.write = function(o) {
    const i = n;
    let a = 0;
    for (; a + 1 < i.length; ) {
      let l = (255 & i[a]) << 8 | 255 & i[a + 1];
      if (33088 <= l && l <= 40956)
        l -= 33088;
      else if (57408 <= l && l <= 60351)
        l -= 49472;
      else
        throw "illegal char at " + (a + 1) + "/" + l;
      l = (l >>> 8 & 255) * 192 + (l & 255), o.put(l, 13), a += 2;
    }
    if (a < i.length)
      throw "illegal char at " + (a + 1);
  }, s;
}, T1 = function() {
  const t = [], e = {};
  return e.writeByte = function(r) {
    t.push(r & 255);
  }, e.writeShort = function(r) {
    e.writeByte(r), e.writeByte(r >>> 8);
  }, e.writeBytes = function(r, n, s) {
    n = n || 0, s = s || r.length;
    for (let o = 0; o < s; o += 1)
      e.writeByte(r[o + n]);
  }, e.writeString = function(r) {
    for (let n = 0; n < r.length; n += 1)
      e.writeByte(r.charCodeAt(n));
  }, e.toByteArray = function() {
    return t;
  }, e.toString = function() {
    let r = "";
    r += "[";
    for (let n = 0; n < t.length; n += 1)
      n > 0 && (r += ","), r += t[n];
    return r += "]", r;
  }, e;
}, ZI = function() {
  let t = 0, e = 0, r = 0, n = "";
  const s = {}, o = function(a) {
    n += String.fromCharCode(i(a & 63));
  }, i = function(a) {
    if (a < 0)
      throw "n:" + a;
    if (a < 26)
      return 65 + a;
    if (a < 52)
      return 97 + (a - 26);
    if (a < 62)
      return 48 + (a - 52);
    if (a == 62)
      return 43;
    if (a == 63)
      return 47;
    throw "n:" + a;
  };
  return s.writeByte = function(a) {
    for (t = t << 8 | a & 255, e += 8, r += 1; e >= 6; )
      o(t >>> e - 6), e -= 6;
  }, s.flush = function() {
    if (e > 0 && (o(t << 6 - e), t = 0, e = 0), r % 3 != 0) {
      const a = 3 - r % 3;
      for (let l = 0; l < a; l += 1)
        n += "=";
    }
  }, s.toString = function() {
    return n;
  }, s;
}, QI = function(t) {
  const e = t;
  let r = 0, n = 0, s = 0;
  const o = {};
  o.read = function() {
    for (; s < 8; ) {
      if (r >= e.length) {
        if (s == 0)
          return -1;
        throw "unexpected end of file./" + s;
      }
      const l = e.charAt(r);
      if (r += 1, l == "=")
        return s = 0, -1;
      if (l.match(/^\s$/))
        continue;
      n = n << 6 | i(l.charCodeAt(0)), s += 6;
    }
    const a = n >>> s - 8 & 255;
    return s -= 8, a;
  };
  const i = function(a) {
    if (65 <= a && a <= 90)
      return a - 65;
    if (97 <= a && a <= 122)
      return a - 97 + 26;
    if (48 <= a && a <= 57)
      return a - 48 + 52;
    if (a == 43)
      return 62;
    if (a == 47)
      return 63;
    throw "c:" + a;
  };
  return o;
}, eN = function(t, e) {
  const r = t, n = e, s = new Array(t * e), o = {};
  o.setPixel = function(u, c, f) {
    s[c * r + u] = f;
  }, o.write = function(u) {
    u.writeString("GIF87a"), u.writeShort(r), u.writeShort(n), u.writeByte(128), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(255), u.writeByte(255), u.writeByte(255), u.writeString(","), u.writeShort(0), u.writeShort(0), u.writeShort(r), u.writeShort(n), u.writeByte(0);
    const c = 2, f = a(c);
    u.writeByte(c);
    let g = 0;
    for (; f.length - g > 255; )
      u.writeByte(255), u.writeBytes(f, g, 255), g += 255;
    u.writeByte(f.length - g), u.writeBytes(f, g, f.length - g), u.writeByte(0), u.writeString(";");
  };
  const i = function(u) {
    const c = u;
    let f = 0, g = 0;
    const _ = {};
    return _.write = function(b, p) {
      if (b >>> p)
        throw "length over";
      for (; f + p >= 8; )
        c.writeByte(255 & (b << f | g)), p -= 8 - f, b >>>= 8 - f, g = 0, f = 0;
      g = b << f | g, f = f + p;
    }, _.flush = function() {
      f > 0 && c.writeByte(g);
    }, _;
  }, a = function(u) {
    const c = 1 << u, f = (1 << u) + 1;
    let g = u + 1;
    const _ = l();
    for (let S = 0; S < c; S += 1)
      _.add(String.fromCharCode(S));
    _.add(String.fromCharCode(c)), _.add(String.fromCharCode(f));
    const b = T1(), p = i(b);
    p.write(c, g);
    let h = 0, y = String.fromCharCode(s[h]);
    for (h += 1; h < s.length; ) {
      const S = String.fromCharCode(s[h]);
      h += 1, _.contains(y + S) ? y = y + S : (p.write(_.indexOf(y), g), _.size() < 4095 && (_.size() == 1 << g && (g += 1), _.add(y + S)), y = S);
    }
    return p.write(_.indexOf(y), g), p.write(f, g), p.flush(), b.toByteArray();
  }, l = function() {
    const u = {};
    let c = 0;
    const f = {};
    return f.add = function(g) {
      if (f.contains(g))
        throw "dup key:" + g;
      u[g] = c, c += 1;
    }, f.size = function() {
      return c;
    }, f.indexOf = function(g) {
      return u[g];
    }, f.contains = function(g) {
      return typeof u[g] < "u";
    }, f;
  };
  return o;
}, tN = function(t, e, r) {
  const n = eN(t, e);
  for (let a = 0; a < e; a += 1)
    for (let l = 0; l < t; l += 1)
      n.setPixel(l, a, r(l, a));
  const s = T1();
  n.write(s);
  const o = ZI(), i = s.toByteArray();
  for (let a = 0; a < i.length; a += 1)
    o.writeByte(i[a]);
  return o.flush(), "data:image/gif;base64," + o;
};
jo.stringToBytes;
var rN = /* @__PURE__ */ ne("<!> <p> </p>", 1), nN = /* @__PURE__ */ ne('<img class="aspect-square h-full w-full object-contain" alt="QR Code"/>'), sN = /* @__PURE__ */ ne("<p>Type something to generate a QR Code</p>"), oN = /* @__PURE__ */ ne('<div class="flex gap-4"><!> <div><!></div></div>');
function D1(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  function s(_, b = 20) {
    const p = jo(0, "L");
    return p.addData(_), p.make(), p.createDataURL(b);
  }
  const o = /* @__PURE__ */ O(() => {
    if (r())
      try {
        return s(r());
      } catch (_) {
        return new Error(HI(_));
      }
  });
  var i = {
    get value() {
      return r();
    },
    set value(_) {
      r(_), m();
    }
  }, a = oN(), l = ge(a);
  Zh(l, ce(() => n, {
    get value() {
      return r();
    },
    set value(_) {
      r(_);
    }
  }));
  var u = be(l, 2), c = ge(u);
  {
    var f = (_) => {
      var b = rN(), p = D(b);
      A1(p, { size: 20 });
      var h = be(p, 2), y = ge(h, !0);
      de(h), ke(() => Ie(y, d(o).message)), A(_, b);
    }, g = (_) => {
      var b = M(), p = D(b);
      {
        var h = (S) => {
          var x = nN();
          ke(() => An(x, "src", d(o))), A(S, x);
        }, y = (S) => {
          var x = sN();
          A(S, x);
        };
        ue(
          p,
          (S) => {
            d(o) ? S(h) : S(y, !1);
          },
          !0
        );
      }
      A(_, b);
    };
    ue(c, (_) => {
      d(o) instanceof Error ? _(f) : _(g, !1);
    });
  }
  return de(u), de(a), ke(() => ls(u, 1, as([
    "aspect-square size-48 shrink-0 overflow-hidden rounded-md border bg-slate-50",
    "flex flex-col items-center justify-center gap-1",
    "text-center text-xs text-muted-foreground",
    (!d(o) || d(o) instanceof Error) && "p-3"
  ]))), A(t, a), H(i);
}
K(D1, { value: {} }, [], [], { mode: "open" });
const iN = (t) => {
  _1(t, { size: 20 });
}, aN = (t) => {
  b1(t, { size: 20 });
}, Ym = (t) => {
  $1(t, { size: 20 });
}, lN = (t) => {
  O1(t, { size: 20 });
};
function uN(t) {
}
K(uN, {}, [], [], { mode: "open" });
const cN = {
  "move-array-item-up": iN,
  "move-array-item-down": aN,
  "remove-array-item": Ym,
  "copy-array-item": lN,
  "remove-object-property": Ym
}, dN = cN, fN = Ii(dN);
var hN = /\s+/g, gN = (t) => typeof t != "string" || !t ? t : t.replace(hN, " ").trim(), Pl = (...t) => {
  const e = [], r = (n) => {
    if (!n && n !== 0 && n !== 0n) return;
    if (Array.isArray(n)) {
      for (let o = 0, i = n.length; o < i; o++) r(n[o]);
      return;
    }
    const s = typeof n;
    if (s === "string" || s === "number" || s === "bigint") {
      if (s === "number" && n !== n) return;
      e.push(String(n));
    } else if (s === "object") {
      const o = Object.keys(n);
      for (let i = 0, a = o.length; i < a; i++) {
        const l = o[i];
        n[l] && e.push(l);
      }
    }
  };
  for (let n = 0, s = t.length; n < s; n++) {
    const o = t[n];
    o != null && r(o);
  }
  return e.length > 0 ? gN(e.join(" ")) : void 0;
}, Xm = (t) => t === !1 ? "false" : t === !0 ? "true" : t === 0 ? "0" : t, Gt = (t) => {
  if (!t || typeof t != "object") return !0;
  for (const e in t) return !1;
  return !0;
}, pN = (t, e) => {
  if (t === e) return !0;
  if (!t || !e) return !1;
  const r = Object.keys(t), n = Object.keys(e);
  if (r.length !== n.length) return !1;
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    if (!n.includes(o) || t[o] !== e[o]) return !1;
  }
  return !0;
}, mN = (t, e) => {
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const n = e[r];
      r in t ? t[r] = Pl(t[r], n) : t[r] = n;
    }
  return t;
}, M1 = (t, e) => {
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    Array.isArray(n) ? M1(n, e) : n && e.push(n);
  }
}, I1 = (...t) => {
  const e = [];
  M1(t, e);
  const r = [];
  for (let n = 0; n < e.length; n++)
    e[n] && r.push(e[n]);
  return r;
}, Zc = (t, e) => {
  const r = {};
  for (const n in t) {
    const s = t[n];
    if (n in e) {
      const o = e[n];
      Array.isArray(s) || Array.isArray(o) ? r[n] = I1(o, s) : typeof s == "object" && typeof o == "object" && s && o ? r[n] = Zc(s, o) : r[n] = o + " " + s;
    } else
      r[n] = s;
  }
  for (const n in e)
    n in t || (r[n] = e[n]);
  return r;
}, vN = {
  twMerge: !0,
  twMergeConfig: {}
};
function yN() {
  let t = null, e = {}, r = !1;
  return {
    get cachedTwMerge() {
      return t;
    },
    set cachedTwMerge(n) {
      t = n;
    },
    get cachedTwMergeConfig() {
      return e;
    },
    set cachedTwMergeConfig(n) {
      e = n;
    },
    get didTwMergeConfigChange() {
      return r;
    },
    set didTwMergeConfigChange(n) {
      r = n;
    },
    reset() {
      t = null, e = {}, r = !1;
    }
  };
}
var yn = yN(), bN = (t) => {
  const e = (n, s) => {
    const {
      extend: o = null,
      slots: i = {},
      variants: a = {},
      compoundVariants: l = [],
      compoundSlots: u = [],
      defaultVariants: c = {}
    } = n, f = { ...vN, ...s }, g = o?.base ? Pl(o.base, n?.base) : n?.base, _ = o?.variants && !Gt(o.variants) ? Zc(a, o.variants) : a, b = o?.defaultVariants && !Gt(o.defaultVariants) ? { ...o.defaultVariants, ...c } : c;
    !Gt(f.twMergeConfig) && !pN(f.twMergeConfig, yn.cachedTwMergeConfig) && (yn.didTwMergeConfigChange = !0, yn.cachedTwMergeConfig = f.twMergeConfig);
    const p = Gt(o?.slots), h = Gt(i) ? {} : {
      // add "base" to the slots object
      base: Pl(n?.base, p && o?.base),
      ...i
    }, y = p ? h : mN(
      { ...o?.slots },
      Gt(h) ? { base: n?.base } : h
    ), S = Gt(o?.compoundVariants) ? l : I1(o?.compoundVariants, l), x = (w) => {
      if (Gt(_) && Gt(i) && p)
        return t(g, w?.class, w?.className)(f);
      if (S && !Array.isArray(S))
        throw new TypeError(
          `The "compoundVariants" prop must be an array. Received: ${typeof S}`
        );
      if (u && !Array.isArray(u))
        throw new TypeError(
          `The "compoundSlots" prop must be an array. Received: ${typeof u}`
        );
      const C = (B, R = _, Z = null, Y = null) => {
        const X = R[B];
        if (!X || Gt(X))
          return null;
        const ae = Y?.[B] ?? w?.[B];
        if (ae === null) return null;
        const J = Xm(ae);
        if (typeof J == "object")
          return null;
        const j = b?.[B], ee = J ?? Xm(j);
        return X[ee || "false"];
      }, k = () => {
        if (!_) return null;
        const B = Object.keys(_), R = [];
        for (let Z = 0; Z < B.length; Z++) {
          const Y = C(B[Z], _);
          Y && R.push(Y);
        }
        return R;
      }, $ = (B, R) => {
        if (!_ || typeof _ != "object") return null;
        const Z = [];
        for (const Y in _) {
          const X = C(Y, _, B, R), ae = B === "base" && typeof X == "string" ? X : X && X[B];
          ae && Z.push(ae);
        }
        return Z;
      }, T = {};
      for (const B in w) {
        const R = w[B];
        R !== void 0 && (T[B] = R);
      }
      const E = (B, R) => {
        const Z = typeof w?.[B] == "object" ? {
          [B]: w[B]?.initial
        } : {};
        return {
          ...b,
          ...T,
          ...Z,
          ...R
        };
      }, I = (B = [], R) => {
        const Z = [], Y = B.length;
        for (let X = 0; X < Y; X++) {
          const { class: ae, className: J, ...j } = B[X];
          let ee = !0;
          const L = E(null, R);
          for (const N in j) {
            const V = j[N], G = L[N];
            if (Array.isArray(V)) {
              if (!V.includes(G)) {
                ee = !1;
                break;
              }
            } else {
              if ((V == null || V === !1) && (G == null || G === !1))
                continue;
              if (G !== V) {
                ee = !1;
                break;
              }
            }
          }
          ee && (ae && Z.push(ae), J && Z.push(J));
        }
        return Z;
      }, F = (B) => {
        const R = I(S, B);
        if (!Array.isArray(R)) return R;
        const Z = {}, Y = t;
        for (let X = 0; X < R.length; X++) {
          const ae = R[X];
          if (typeof ae == "string")
            Z.base = Y(Z.base, ae)(f);
          else if (typeof ae == "object")
            for (const J in ae)
              Z[J] = Y(Z[J], ae[J])(f);
        }
        return Z;
      }, U = (B) => {
        if (u.length < 1) return null;
        const R = {}, Z = E(null, B);
        for (let Y = 0; Y < u.length; Y++) {
          const {
            slots: X = [],
            class: ae,
            className: J,
            ...j
          } = u[Y];
          if (!Gt(j)) {
            let ee = !0;
            for (const L in j) {
              const N = Z[L], V = j[L];
              if (N === void 0 || (Array.isArray(V) ? !V.includes(N) : V !== N)) {
                ee = !1;
                break;
              }
            }
            if (!ee) continue;
          }
          for (let ee = 0; ee < X.length; ee++) {
            const L = X[ee];
            R[L] || (R[L] = []), R[L].push([ae, J]);
          }
        }
        return R;
      };
      if (!Gt(i) || !p) {
        const B = {};
        if (typeof y == "object" && !Gt(y)) {
          const R = t;
          for (const Z in y)
            B[Z] = (Y) => {
              const X = F(Y), ae = U(Y);
              return R(
                y[Z],
                $(Z, Y),
                X ? X[Z] : void 0,
                ae ? ae[Z] : void 0,
                Y?.class,
                Y?.className
              )(f);
            };
        }
        return B;
      }
      return t(
        g,
        k(),
        I(S),
        w?.class,
        w?.className
      )(f);
    }, P = () => {
      if (!(!_ || typeof _ != "object"))
        return Object.keys(_);
    };
    return x.variantKeys = P(), x.extend = o, x.base = g, x.slots = y, x.variants = _, x.defaultVariants = b, x.compoundSlots = u, x.compoundVariants = S, x;
  };
  return {
    tv: e,
    createTV: (n) => (s, o) => e(s, o ? Zc(n, o) : n)
  };
};
const _N = (t, e) => {
  const r = new Array(t.length + e.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t[n];
  for (let n = 0; n < e.length; n++)
    r[t.length + n] = e[n];
  return r;
}, wN = (t, e) => ({
  classGroupId: t,
  validator: e
}), N1 = (t = /* @__PURE__ */ new Map(), e = null, r) => ({
  nextPart: t,
  validators: e,
  classGroupId: r
}), Ol = "-", Jm = [], SN = "arbitrary..", xN = (t) => {
  const e = ON(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (i) => {
      if (i.startsWith("[") && i.endsWith("]"))
        return PN(i);
      const a = i.split(Ol), l = a[0] === "" && a.length > 1 ? 1 : 0;
      return F1(a, l, e);
    },
    getConflictingClassGroupIds: (i, a) => {
      if (a) {
        const l = n[i], u = r[i];
        return l ? u ? _N(u, l) : l : u || Jm;
      }
      return r[i] || Jm;
    }
  };
}, F1 = (t, e, r) => {
  if (t.length - e === 0)
    return r.classGroupId;
  const s = t[e], o = r.nextPart.get(s);
  if (o) {
    const u = F1(t, e + 1, o);
    if (u) return u;
  }
  const i = r.validators;
  if (i === null)
    return;
  const a = e === 0 ? t.join(Ol) : t.slice(e).join(Ol), l = i.length;
  for (let u = 0; u < l; u++) {
    const c = i[u];
    if (c.validator(a))
      return c.classGroupId;
  }
}, PN = (t) => t.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const e = t.slice(1, -1), r = e.indexOf(":"), n = e.slice(0, r);
  return n ? SN + n : void 0;
})(), ON = (t) => {
  const {
    theme: e,
    classGroups: r
  } = t;
  return CN(r, e);
}, CN = (t, e) => {
  const r = N1();
  for (const n in t) {
    const s = t[n];
    ig(s, r, n, e);
  }
  return r;
}, ig = (t, e, r, n) => {
  const s = t.length;
  for (let o = 0; o < s; o++) {
    const i = t[o];
    kN(i, e, r, n);
  }
}, kN = (t, e, r, n) => {
  if (typeof t == "string") {
    $N(t, e, r);
    return;
  }
  if (typeof t == "function") {
    AN(t, e, r, n);
    return;
  }
  EN(t, e, r, n);
}, $N = (t, e, r) => {
  const n = t === "" ? e : R1(e, t);
  n.classGroupId = r;
}, AN = (t, e, r, n) => {
  if (TN(t)) {
    ig(t(n), e, r, n);
    return;
  }
  e.validators === null && (e.validators = []), e.validators.push(wN(r, t));
}, EN = (t, e, r, n) => {
  const s = Object.entries(t), o = s.length;
  for (let i = 0; i < o; i++) {
    const [a, l] = s[i];
    ig(l, R1(e, a), r, n);
  }
}, R1 = (t, e) => {
  let r = t;
  const n = e.split(Ol), s = n.length;
  for (let o = 0; o < s; o++) {
    const i = n[o];
    let a = r.nextPart.get(i);
    a || (a = N1(), r.nextPart.set(i, a)), r = a;
  }
  return r;
}, TN = (t) => "isThemeGetter" in t && t.isThemeGetter === !0, DN = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  const s = (o, i) => {
    r[o] = i, e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let i = r[o];
      if (i !== void 0)
        return i;
      if ((i = n[o]) !== void 0)
        return s(o, i), i;
    },
    set(o, i) {
      o in r ? r[o] = i : s(o, i);
    }
  };
}, Qc = "!", Zm = ":", MN = [], Qm = (t, e, r, n, s) => ({
  modifiers: t,
  hasImportantModifier: e,
  baseClassName: r,
  maybePostfixModifierPosition: n,
  isExternal: s
}), IN = (t) => {
  const {
    prefix: e,
    experimentalParseClassName: r
  } = t;
  let n = (s) => {
    const o = [];
    let i = 0, a = 0, l = 0, u;
    const c = s.length;
    for (let p = 0; p < c; p++) {
      const h = s[p];
      if (i === 0 && a === 0) {
        if (h === Zm) {
          o.push(s.slice(l, p)), l = p + 1;
          continue;
        }
        if (h === "/") {
          u = p;
          continue;
        }
      }
      h === "[" ? i++ : h === "]" ? i-- : h === "(" ? a++ : h === ")" && a--;
    }
    const f = o.length === 0 ? s : s.slice(l);
    let g = f, _ = !1;
    f.endsWith(Qc) ? (g = f.slice(0, -1), _ = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(Qc) && (g = f.slice(1), _ = !0)
    );
    const b = u && u > l ? u - l : void 0;
    return Qm(o, _, g, b);
  };
  if (e) {
    const s = e + Zm, o = n;
    n = (i) => i.startsWith(s) ? o(i.slice(s.length)) : Qm(MN, !1, i, void 0, !0);
  }
  if (r) {
    const s = n;
    n = (o) => r({
      className: o,
      parseClassName: s
    });
  }
  return n;
}, NN = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.orderSensitiveModifiers.forEach((r, n) => {
    e.set(r, 1e6 + n);
  }), (r) => {
    const n = [];
    let s = [];
    for (let o = 0; o < r.length; o++) {
      const i = r[o], a = i[0] === "[", l = e.has(i);
      a || l ? (s.length > 0 && (s.sort(), n.push(...s), s = []), n.push(i)) : s.push(i);
    }
    return s.length > 0 && (s.sort(), n.push(...s)), n;
  };
}, FN = (t) => ({
  cache: DN(t.cacheSize),
  parseClassName: IN(t),
  sortModifiers: NN(t),
  ...xN(t)
}), RN = /\s+/, VN = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: s,
    sortModifiers: o
  } = e, i = [], a = t.trim().split(RN);
  let l = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const c = a[u], {
      isExternal: f,
      modifiers: g,
      hasImportantModifier: _,
      baseClassName: b,
      maybePostfixModifierPosition: p
    } = r(c);
    if (f) {
      l = c + (l.length > 0 ? " " + l : l);
      continue;
    }
    let h = !!p, y = n(h ? b.substring(0, p) : b);
    if (!y) {
      if (!h) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      if (y = n(b), !y) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      h = !1;
    }
    const S = g.length === 0 ? "" : g.length === 1 ? g[0] : o(g).join(":"), x = _ ? S + Qc : S, P = x + y;
    if (i.indexOf(P) > -1)
      continue;
    i.push(P);
    const w = s(y, h);
    for (let C = 0; C < w.length; ++C) {
      const k = w[C];
      i.push(x + k);
    }
    l = c + (l.length > 0 ? " " + l : l);
  }
  return l;
}, LN = (...t) => {
  let e = 0, r, n, s = "";
  for (; e < t.length; )
    (r = t[e++]) && (n = V1(r)) && (s && (s += " "), s += n);
  return s;
}, V1 = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = V1(t[n])) && (r && (r += " "), r += e);
  return r;
}, ed = (t, ...e) => {
  let r, n, s, o;
  const i = (l) => {
    const u = e.reduce((c, f) => f(c), t());
    return r = FN(u), n = r.cache.get, s = r.cache.set, o = a, a(l);
  }, a = (l) => {
    const u = n(l);
    if (u)
      return u;
    const c = VN(l, r);
    return s(l, c), c;
  };
  return o = i, (...l) => o(LN(...l));
}, jN = [], yt = (t) => {
  const e = (r) => r[t] || jN;
  return e.isThemeGetter = !0, e;
}, L1 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, j1 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, BN = /^\d+\/\d+$/, zN = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, qN = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, UN = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, KN = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, WN = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, to = (t) => BN.test(t), Ue = (t) => !!t && !Number.isNaN(Number(t)), Bn = (t) => !!t && Number.isInteger(Number(t)), uc = (t) => t.endsWith("%") && Ue(t.slice(0, -1)), mn = (t) => zN.test(t), HN = () => !0, GN = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  qN.test(t) && !UN.test(t)
), B1 = () => !1, YN = (t) => KN.test(t), XN = (t) => WN.test(t), JN = (t) => !$e(t) && !Ae(t), ZN = (t) => Bo(t, U1, B1), $e = (t) => L1.test(t), xs = (t) => Bo(t, K1, GN), cc = (t) => Bo(t, nF, Ue), ev = (t) => Bo(t, z1, B1), QN = (t) => Bo(t, q1, XN), Va = (t) => Bo(t, W1, YN), Ae = (t) => j1.test(t), ri = (t) => zo(t, K1), eF = (t) => zo(t, sF), tv = (t) => zo(t, z1), tF = (t) => zo(t, U1), rF = (t) => zo(t, q1), La = (t) => zo(t, W1, !0), Bo = (t, e, r) => {
  const n = L1.exec(t);
  return n ? n[1] ? e(n[1]) : r(n[2]) : !1;
}, zo = (t, e, r = !1) => {
  const n = j1.exec(t);
  return n ? n[1] ? e(n[1]) : r : !1;
}, z1 = (t) => t === "position" || t === "percentage", q1 = (t) => t === "image" || t === "url", U1 = (t) => t === "length" || t === "size" || t === "bg-size", K1 = (t) => t === "length", nF = (t) => t === "number", sF = (t) => t === "family-name", W1 = (t) => t === "shadow", td = () => {
  const t = yt("color"), e = yt("font"), r = yt("text"), n = yt("font-weight"), s = yt("tracking"), o = yt("leading"), i = yt("breakpoint"), a = yt("container"), l = yt("spacing"), u = yt("radius"), c = yt("shadow"), f = yt("inset-shadow"), g = yt("text-shadow"), _ = yt("drop-shadow"), b = yt("blur"), p = yt("perspective"), h = yt("aspect"), y = yt("ease"), S = yt("animate"), x = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], P = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], w = () => [...P(), Ae, $e], C = () => ["auto", "hidden", "clip", "visible", "scroll"], k = () => ["auto", "contain", "none"], $ = () => [Ae, $e, l], T = () => [to, "full", "auto", ...$()], E = () => [Bn, "none", "subgrid", Ae, $e], I = () => ["auto", {
    span: ["full", Bn, Ae, $e]
  }, Bn, Ae, $e], F = () => [Bn, "auto", Ae, $e], U = () => ["auto", "min", "max", "fr", Ae, $e], B = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], R = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], Z = () => ["auto", ...$()], Y = () => [to, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...$()], X = () => [t, Ae, $e], ae = () => [...P(), tv, ev, {
    position: [Ae, $e]
  }], J = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], j = () => ["auto", "cover", "contain", tF, ZN, {
    size: [Ae, $e]
  }], ee = () => [uc, ri, xs], L = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    u,
    Ae,
    $e
  ], N = () => ["", Ue, ri, xs], V = () => ["solid", "dashed", "dotted", "double"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], fe = () => [Ue, uc, tv, ev], se = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    b,
    Ae,
    $e
  ], we = () => ["none", Ue, Ae, $e], le = () => ["none", Ue, Ae, $e], re = () => [Ue, Ae, $e], oe = () => [to, "full", ...$()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [mn],
      breakpoint: [mn],
      color: [HN],
      container: [mn],
      "drop-shadow": [mn],
      ease: ["in", "out", "in-out"],
      font: [JN],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [mn],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [mn],
      shadow: [mn],
      spacing: ["px", Ue],
      text: [mn],
      "text-shadow": [mn],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", to, $e, Ae, h]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ue, $e, Ae, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": x()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": x()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: w()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: C()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": C()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": C()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: k()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": k()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": k()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: T()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": T()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": T()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: T()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: T()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: T()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: T()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: T()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: T()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Bn, "auto", Ae, $e]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [to, "full", "auto", a, ...$()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Ue, to, "auto", "initial", "none", $e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Ue, Ae, $e]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Ue, Ae, $e]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Bn, "first", "last", "none", Ae, $e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": E()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: I()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": E()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: I()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": U()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": U()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: $()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": $()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": $()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...B(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...R(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...R()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...B()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...R(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...R(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": B()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...R(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...R()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: $()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: $()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: $()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: $()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: $()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: $()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: $()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: $()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: $()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: Z()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: Z()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: Z()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: Z()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: Z()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: Z()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: Z()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: Z()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: Z()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": $()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": $()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Y()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...Y()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Y()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [i]
          },
          ...Y()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Y()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Y()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Y()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", r, ri, xs]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [n, Ae, cc]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", uc, $e]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [eF, $e, e]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [s, Ae, $e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Ue, "none", Ae, cc]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...$()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ae, $e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", Ae, $e]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: X()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: X()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...V(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Ue, "from-font", "auto", Ae, xs]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: X()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Ue, "auto", Ae, $e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: $()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ae, $e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ae, $e]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: ae()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: J()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: j()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Bn, Ae, $e],
          radial: ["", Ae, $e],
          conic: [Bn, Ae, $e]
        }, rF, QN]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: X()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: ee()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: ee()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: ee()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: X()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: L()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": L()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": L()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": L()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": L()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": L()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": L()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": L()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": L()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": L()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": L()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": L()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": L()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": L()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": L()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: N()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": N()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": N()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": N()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": N()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": N()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": N()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": N()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": N()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": N()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": N()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...V(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...V(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: X()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": X()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": X()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": X()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": X()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": X()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": X()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": X()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": X()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: X()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...V(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ue, Ae, $e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Ue, ri, xs]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: X()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          La,
          Va
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: X()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, La, Va]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": X()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: N()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: X()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Ue, xs]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": X()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": N()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": X()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", g, La, Va]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": X()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Ue, Ae, $e]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...G(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": G()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Ue]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": fe()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": fe()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": X()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": X()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": fe()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": fe()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": X()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": X()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": fe()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": fe()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": X()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": X()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": fe()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": fe()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": X()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": X()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": fe()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": fe()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": X()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": X()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": fe()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": fe()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": X()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": X()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": fe()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": fe()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": X()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": X()
      }],
      "mask-image-radial": [{
        "mask-radial": [Ae, $e]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": fe()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": fe()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": X()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": X()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": P()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Ue]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": fe()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": fe()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": X()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": X()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: ae()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: J()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: j()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", Ae, $e]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Ae,
          $e
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: se()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ue, Ae, $e]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Ue, Ae, $e]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          _,
          La,
          Va
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": X()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Ue, Ae, $e]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Ue, Ae, $e]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Ue, Ae, $e]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ue, Ae, $e]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Ae,
          $e
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": se()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Ue, Ae, $e]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": $()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": $()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": $()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Ae, $e]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Ue, "initial", Ae, $e]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", y, Ae, $e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Ue, Ae, $e]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, Ae, $e]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [p, Ae, $e]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": w()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: we()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": we()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": we()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": we()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: le()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": le()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": le()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": le()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: re()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": re()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": re()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [Ae, $e, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: w()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: oe()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": oe()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": oe()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": oe()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: X()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: X()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ae, $e]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": $()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": $()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": $()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": $()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": $()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": $()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": $()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": $()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": $()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": $()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": $()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": $()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": $()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": $()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": $()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": $()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": $()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": $()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ae, $e]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...X()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ue, ri, xs, cc]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...X()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, oF = (t, {
  cacheSize: e,
  prefix: r,
  experimentalParseClassName: n,
  extend: s = {},
  override: o = {}
}) => (ai(t, "cacheSize", e), ai(t, "prefix", r), ai(t, "experimentalParseClassName", n), ja(t.theme, o.theme), ja(t.classGroups, o.classGroups), ja(t.conflictingClassGroups, o.conflictingClassGroups), ja(t.conflictingClassGroupModifiers, o.conflictingClassGroupModifiers), ai(t, "orderSensitiveModifiers", o.orderSensitiveModifiers), Ba(t.theme, s.theme), Ba(t.classGroups, s.classGroups), Ba(t.conflictingClassGroups, s.conflictingClassGroups), Ba(t.conflictingClassGroupModifiers, s.conflictingClassGroupModifiers), H1(t, s, "orderSensitiveModifiers"), t), ai = (t, e, r) => {
  r !== void 0 && (t[e] = r);
}, ja = (t, e) => {
  if (e)
    for (const r in e)
      ai(t, r, e[r]);
}, Ba = (t, e) => {
  if (e)
    for (const r in e)
      H1(t, e, r);
}, H1 = (t, e, r) => {
  const n = e[r];
  n !== void 0 && (t[r] = t[r] ? t[r].concat(n) : n);
}, iF = (t, ...e) => typeof t == "function" ? ed(td, t, ...e) : ed(() => oF(td(), t), ...e), ag = /* @__PURE__ */ ed(td);
var aF = (t) => Gt(t) ? ag : iF({
  ...t,
  extend: {
    theme: t.theme,
    classGroups: t.classGroups,
    conflictingClassGroupModifiers: t.conflictingClassGroupModifiers,
    conflictingClassGroups: t.conflictingClassGroups,
    ...t.extend
  }
}), lF = (t, e) => {
  const r = Pl(t);
  return !r || !(e?.twMerge ?? !0) ? r : ((!yn.cachedTwMerge || yn.didTwMergeConfigChange) && (yn.didTwMergeConfigChange = !1, yn.cachedTwMerge = aF(yn.cachedTwMergeConfig)), yn.cachedTwMerge(r) || void 0);
}, uF = (...t) => (e) => lF(t, e), { tv: qi } = bN(uF);
function Se(...t) {
  return ag(io(t));
}
const cF = qi({
  base: "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*]:focus-visible:relative [&>*]:focus-visible:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-e-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  variants: {
    orientation: {
      horizontal: "[&>*:not(:first-child)]:rounded-s-none [&>*:not(:first-child)]:border-s-0 [&>*:not(:last-child)]:rounded-e-none",
      vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
    }
  },
  defaultVariants: { orientation: "horizontal" }
});
var dF = /* @__PURE__ */ ne("<div><!></div>");
function G1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "orientation", 7, "horizontal"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "orientation"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get orientation() {
      return o();
    },
    set orientation(c = "horizontal") {
      o(c), m();
    }
  }, l = dF();
  ve(
    l,
    (c) => ({
      role: "group",
      "data-slot": "button-group",
      "data-orientation": o(),
      class: c,
      ...i
    }),
    [
      () => Se(cF({ orientation: o() }), n())
    ]
  );
  var u = ge(l);
  return te(u, () => s() ?? he), de(l), Qe(l, (c) => r(c), () => r()), A(t, l), H(a);
}
K(G1, { ref: {}, class: {}, children: {}, orientation: {} }, [], [], { mode: "open" });
var fF = /* @__PURE__ */ ne("<div><!></div>");
function hF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "child", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "child"
  ]);
  const i = /* @__PURE__ */ O(() => ({
    ...o,
    class: Se("bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4", n())
  }));
  var a = {
    get ref() {
      return r();
    },
    set ref(g = null) {
      r(g), m();
    },
    get class() {
      return n();
    },
    set class(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    }
  }, l = M(), u = D(l);
  {
    var c = (g) => {
      var _ = M(), b = D(_);
      te(b, s, () => ({ props: d(i) })), A(g, _);
    }, f = (g) => {
      var _ = fF();
      ve(_, () => ({ ...d(i) }));
      var b = ge(_);
      te(b, () => d(i).children ?? he), de(_), Qe(_, (p) => r(p), () => r()), A(g, _);
    };
    ue(u, (g) => {
      s() ? g(c) : g(f, !1);
    });
  }
  return A(t, l), H(a);
}
K(hF, { ref: {}, class: {}, child: {} }, [], [], { mode: "open" });
function bu(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "data-slot", 7, "separator"), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "data-slot"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get "data-slot"() {
      return s();
    },
    set "data-slot"(u = "separator") {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:min-h-full data-[orientation=vertical]:w-px", n()));
    Q(l, () => f0, (c, f) => {
      f(c, ce(
        {
          get "data-slot"() {
            return s();
          },
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(bu, { ref: {}, class: {}, "data-slot": {} }, [], [], { mode: "open" });
function gF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "orientation", 7, "vertical"), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "orientation"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    },
    get class() {
      return n();
    },
    set class(a) {
      n(a), m();
    },
    get orientation() {
      return s();
    },
    set orientation(a = "vertical") {
      s(a), m();
    }
  };
  {
    let a = /* @__PURE__ */ O(() => Se("bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto", n()));
    bu(t, ce(
      {
        "data-slot": "button-group-separator",
        get orientation() {
          return s();
        },
        get class() {
          return d(a);
        }
      },
      () => o,
      {
        get ref() {
          return r();
        },
        set ref(l) {
          r(l);
        }
      }
    ));
  }
  return H(i);
}
K(gF, { ref: {}, class: {}, orientation: {} }, [], [], { mode: "open" });
const os = qi({
  base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-xs",
      destructive: "bg-destructive hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white shadow-xs",
      outline: "bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80 shadow-xs",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
var pF = /* @__PURE__ */ ne("<a><!></a>"), mF = /* @__PURE__ */ ne("<button><!></button>");
function Y1(t, e) {
  W(e, !0);
  let r = v(e, "class", 7), n = v(e, "variant", 7, "default"), s = v(e, "size", 7, "default"), o = v(e, "ref", 15, null), i = v(e, "href", 7, void 0), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7), u = v(e, "children", 7), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "class",
    "variant",
    "size",
    "ref",
    "href",
    "type",
    "disabled",
    "children"
  ]);
  var f = {
    get class() {
      return r();
    },
    set class(h) {
      r(h), m();
    },
    get variant() {
      return n();
    },
    set variant(h = "default") {
      n(h), m();
    },
    get size() {
      return s();
    },
    set size(h = "default") {
      s(h), m();
    },
    get ref() {
      return o();
    },
    set ref(h = null) {
      o(h), m();
    },
    get href() {
      return i();
    },
    set href(h = void 0) {
      i(h), m();
    },
    get type() {
      return a();
    },
    set type(h = "button") {
      a(h), m();
    },
    get disabled() {
      return l();
    },
    set disabled(h) {
      l(h), m();
    },
    get children() {
      return u();
    },
    set children(h) {
      u(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = pF();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          href: l() ? void 0 : i(),
          "aria-disabled": l(),
          role: l() ? "link" : void 0,
          tabindex: l() ? -1 : void 0,
          ...c
        }),
        [
          () => Se(os({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), Qe(y, (x) => o(x), () => o()), A(h, y);
    }, p = (h) => {
      var y = mF();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          type: a(),
          disabled: l(),
          ...c
        }),
        [
          () => Se(os({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), Qe(y, (x) => o(x), () => o()), A(h, y);
    };
    ue(_, (h) => {
      i() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(
  Y1,
  {
    class: {},
    variant: {},
    size: {},
    ref: {},
    href: {},
    type: {},
    disabled: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var vF = /* @__PURE__ */ ne("<!> <!>", 1), yF = /* @__PURE__ */ ne("<!> <!>", 1), bF = /* @__PURE__ */ ne("<!> <!>", 1), _F = /* @__PURE__ */ ne("<!> <!>", 1);
function X1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "placeholder", 15), o = v(e, "class", 7), i = v(e, "weekdayFormat", 7, "short"), a = v(e, "buttonVariant", 7, "ghost"), l = v(e, "captionLayout", 7, "label"), u = v(e, "locale", 7, "en-US"), c = v(e, "months", 7), f = v(e, "years", 7), g = v(e, "monthFormat", 7), _ = v(e, "yearFormat", 7, "numeric"), b = v(e, "day", 7), p = v(e, "disableDaysOutsideMonth", 7, !1), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "placeholder",
    "class",
    "weekdayFormat",
    "buttonVariant",
    "captionLayout",
    "locale",
    "months",
    "years",
    "monthFormat",
    "yearFormat",
    "day",
    "disableDaysOutsideMonth"
  ]);
  const y = /* @__PURE__ */ O(() => g() ? g() : l().startsWith("dropdown") ? "short" : "long");
  var S = {
    get ref() {
      return r();
    },
    set ref(w = null) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get placeholder() {
      return s();
    },
    set placeholder(w) {
      s(w), m();
    },
    get class() {
      return o();
    },
    set class(w) {
      o(w), m();
    },
    get weekdayFormat() {
      return i();
    },
    set weekdayFormat(w = "short") {
      i(w), m();
    },
    get buttonVariant() {
      return a();
    },
    set buttonVariant(w = "ghost") {
      a(w), m();
    },
    get captionLayout() {
      return l();
    },
    set captionLayout(w = "label") {
      l(w), m();
    },
    get locale() {
      return u();
    },
    set locale(w = "en-US") {
      u(w), m();
    },
    get months() {
      return c();
    },
    set months(w) {
      c(w), m();
    },
    get years() {
      return f();
    },
    set years(w) {
      f(w), m();
    },
    get monthFormat() {
      return g();
    },
    set monthFormat(w) {
      g(w), m();
    },
    get yearFormat() {
      return _();
    },
    set yearFormat(w = "numeric") {
      _(w), m();
    },
    get day() {
      return b();
    },
    set day(w) {
      b(w), m();
    },
    get disableDaysOutsideMonth() {
      return p();
    },
    set disableDaysOutsideMonth(w = !1) {
      p(w), m();
    }
  }, x = M(), P = D(x);
  {
    const w = (k, $) => {
      let T = () => $?.().months, E = () => $?.().weekdays;
      var I = M(), F = D(I);
      Q(F, () => tS, (U, B) => {
        B(U, {
          children: (R, Z) => {
            var Y = _F(), X = D(Y);
            Q(X, () => cS, (J, j) => {
              j(J, {
                children: (ee, L) => {
                  var N = vF(), V = D(N);
                  Q(V, () => iS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  });
                  var G = be(V, 2);
                  Q(G, () => oS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  }), A(ee, N);
                },
                $$slots: { default: !0 }
              });
            });
            var ae = be(X, 2);
            nt(ae, 18, T, (J) => J, (J, j, ee) => {
              var L = M(), N = D(L);
              Q(N, () => uS, (V, G) => {
                G(V, {
                  children: (fe, se) => {
                    var we = bF(), le = D(we);
                    Q(le, () => eS, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = M(), Ve = D(Oe);
                          Q(Ve, () => dS, (Ke, Le) => {
                            Le(Ke, {
                              get captionLayout() {
                                return l();
                              },
                              get months() {
                                return c();
                              },
                              get monthFormat() {
                                return d(y);
                              },
                              get years() {
                                return f();
                              },
                              get yearFormat() {
                                return _();
                              },
                              get month() {
                                return j.value;
                              },
                              get locale() {
                                return u();
                              },
                              get monthIndex() {
                                return d(ee);
                              },
                              get placeholder() {
                                return s();
                              },
                              set placeholder(je) {
                                s(je);
                              }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    });
                    var re = be(le, 2);
                    Q(re, () => Q1, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = yF(), Ve = D(Oe);
                          Q(Ve, () => nS, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                Q($t, () => rd, (lt, ct) => {
                                  ct(lt, {
                                    class: "select-none",
                                    children: (pt, Kt) => {
                                      var vt = M(), Vt = D(vt);
                                      nt(Vt, 16, E, (Mt) => Mt, (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        Q(fn, () => sS, (sr, or) => {
                                          or(sr, {
                                            children: (kr, Xs) => {
                                              St();
                                              var yr = st();
                                              ke((Wr) => Ie(yr, Wr), [() => Wt.slice(0, 2)]), A(kr, yr);
                                            },
                                            $$slots: { default: !0 }
                                          });
                                        }), A(Mt, Ht);
                                      }), A(pt, vt);
                                    },
                                    $$slots: { default: !0 }
                                  });
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          });
                          var Ke = be(Ve, 2);
                          Q(Ke, () => rS, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                nt($t, 16, () => j.weeks, (lt) => lt, (lt, ct) => {
                                  var pt = M(), Kt = D(pt);
                                  Q(Kt, () => rd, (vt, Vt) => {
                                    Vt(vt, {
                                      class: "mt-2 w-full",
                                      children: (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        nt(fn, 16, () => ct, (sr) => sr, (sr, or) => {
                                          var kr = M(), Xs = D(kr);
                                          Q(Xs, () => J1, (yr, Wr) => {
                                            Wr(yr, {
                                              get date() {
                                                return or;
                                              },
                                              get month() {
                                                return j.value;
                                              },
                                              children: (qo, _u) => {
                                                var Uo = M(), wu = D(Uo);
                                                {
                                                  var Su = (ir) => {
                                                    var $r = M(), ps = D($r);
                                                    {
                                                      let ms = /* @__PURE__ */ O(() => ({ day: or, outsideMonth: !r_(or, j.value) }));
                                                      te(ps, b, () => d(ms));
                                                    }
                                                    A(ir, $r);
                                                  }, xu = (ir) => {
                                                    var $r = M(), ps = D($r);
                                                    Q(ps, () => Z1, (ms, Pu) => {
                                                      Pu(ms, {});
                                                    }), A(ir, $r);
                                                  };
                                                  ue(wu, (ir) => {
                                                    b() ? ir(Su) : ir(xu, !1);
                                                  });
                                                }
                                                A(qo, Uo);
                                              },
                                              $$slots: { default: !0 }
                                            });
                                          }), A(sr, kr);
                                        }), A(Mt, Ht);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(lt, pt);
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(fe, we);
                  },
                  $$slots: { default: !0 }
                });
              }), A(J, L);
            }), A(R, Y);
          },
          $$slots: { default: !0 }
        });
      }), A(k, I);
    };
    let C = /* @__PURE__ */ O(() => Se("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", o()));
    Q(P, () => U_, (k, $) => {
      $(k, ce(
        {
          get weekdayFormat() {
            return i();
          },
          get disableDaysOutsideMonth() {
            return p();
          },
          get class() {
            return d(C);
          },
          get locale() {
            return u();
          },
          get monthFormat() {
            return d(y);
          },
          get yearFormat() {
            return _();
          }
        },
        () => h,
        {
          get value() {
            return n();
          },
          set value(T) {
            n(T);
          },
          get ref() {
            return r();
          },
          set ref(T) {
            r(T);
          },
          get placeholder() {
            return s();
          },
          set placeholder(T) {
            s(T);
          },
          children: w,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, x), H(S);
}
K(
  X1,
  {
    ref: {},
    value: {},
    placeholder: {},
    class: {},
    weekdayFormat: {},
    buttonVariant: {},
    captionLayout: {},
    locale: {},
    months: {},
    years: {},
    monthFormat: {},
    yearFormat: {},
    day: {},
    disableDaysOutsideMonth: {}
  },
  [],
  [],
  { mode: "open" }
);
function J1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("relative size-(--cell-size) p-0 text-center text-sm focus-within:z-20 [&:first-child[data-selected]_[data-bits-day]]:rounded-s-md [&:last-child[data-selected]_[data-bits-day]]:rounded-e-md", n()));
    Q(a, () => W_, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(J1, { ref: {}, class: {} }, [], [], { mode: "open" });
function Z1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(os({ variant: "ghost" }), "flex size-(--cell-size) flex-col items-center justify-center gap-1 p-0 leading-none font-normal whitespace-nowrap select-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground", "data-[selected]:bg-primary dark:data-[selected]:hover:bg-accent/50 data-[selected]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:text-muted-foreground data-[unavailable]:line-through", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", n()));
    Q(a, () => K_, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(Z1, { ref: {}, class: {} }, [], [], { mode: "open" });
function Q1(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("mt-4 flex w-full border-collapse flex-col gap-1", n()));
    Q(a, () => Tf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(Q1, { ref: {}, class: {} }, [], [], { mode: "open" });
function eS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex h-(--cell-size) w-full items-center justify-center gap-1.5 text-sm font-medium", n()));
    Q(a, () => Ff, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(eS, { ref: {}, class: {} }, [], [], { mode: "open" });
var wF = /* @__PURE__ */ ne("<div><!></div>");
function tS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = wF();
  ve(a, (u) => ({ class: u, ...o }), [
    () => Se("relative flex flex-col gap-4 md:flex-row", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(tS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function rd(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex", n()));
    Q(a, () => Nf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(rd, { ref: {}, class: {} }, [], [], { mode: "open" });
function SF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("px-(--cell-size) text-sm font-medium", n()));
    Q(a, () => Rf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(SF, { ref: {}, class: {} }, [], [], { mode: "open" });
function rS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(n()));
    Q(a, () => Df, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(rS, { ref: {}, class: {} }, [], [], { mode: "open" });
function nS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(n()));
    Q(a, () => Mf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(nS, { ref: {}, class: {} }, [], [], { mode: "open" });
function sS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", n()));
    Q(a, () => If, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(sS, { ref: {}, class: {} }, [], [], { mode: "open" });
const xF = (t) => {
  og(t, { class: "size-4" });
};
function oS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || xF);
    Q(u, () => Lf, (g, _) => {
      _(g, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(oS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
const PF = (t) => {
  sg(t, { class: "size-4" });
};
function iS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || PF);
    Q(u, () => jf, (g, _) => {
      _(g, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(iS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
var OF = /* @__PURE__ */ ne("<option> </option>"), CF = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), kF = /* @__PURE__ */ ne("<span><!></span>");
function aS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "onchange", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "onchange"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c) {
      s(c), m();
    },
    get onchange() {
      return o();
    },
    set onchange(c) {
      o(c), m();
    }
  }, l = kF(), u = ge(l);
  {
    const c = (f, g) => {
      let _ = () => g?.().props, b = () => g?.().monthItems, p = () => g?.().selectedMonthItem;
      var h = CF(), y = D(h);
      ve(y, () => ({ ..._(), value: s(), onchange: o() })), nt(y, 21, b, (w) => w.value, (w, C) => {
        var k = OF(), $ = ge(k, !0);
        de(k);
        var T = {};
        ke(() => {
          Ks(k, s() !== void 0 ? d(C).value === s() : d(C).value === p().value), Ie($, d(C).label), T !== (T = d(C).value) && (k.value = (k.__value = d(C).value) ?? "");
        }), A(w, k);
      }), de(y);
      var S = be(y, 2), x = ge(S), P = be(x);
      gs(P, { class: "size-4" }), de(S), ke((w) => Ie(x, `${w ?? ""} `), [
        () => b().find((w) => w.value === s())?.label || p().label
      ]), A(f, h);
    };
    Q(u, () => Vf, (f, g) => {
      g(f, ce(
        {
          class: "dark:bg-popover dark:text-popover-foreground absolute inset-0 opacity-0"
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          child: c,
          $$slots: { child: !0 }
        }
      ));
    });
  }
  return de(l), ke((c) => ls(l, 1, c), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, l), H(a);
}
K(aS, { ref: {}, class: {}, value: {}, onchange: {} }, [], [], { mode: "open" });
var $F = /* @__PURE__ */ ne("<option> </option>"), AF = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), EF = /* @__PURE__ */ ne("<span><!></span>");
function lS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u) {
      s(u), m();
    }
  }, a = EF(), l = ge(a);
  {
    const u = (c, f) => {
      let g = () => f?.().props, _ = () => f?.().yearItems, b = () => f?.().selectedYearItem;
      var p = AF(), h = D(p);
      ve(h, () => ({ ...g(), value: s() })), nt(h, 21, _, (P) => P.value, (P, w) => {
        var C = $F(), k = ge(C, !0);
        de(C);
        var $ = {};
        ke(() => {
          Ks(C, s() !== void 0 ? d(w).value === s() : d(w).value === b().value), Ie(k, d(w).label), $ !== ($ = d(w).value) && (C.value = (C.__value = d(w).value) ?? "");
        }), A(P, C);
      }), de(h);
      var y = be(h, 2), S = ge(y), x = be(S);
      gs(x, { class: "size-4" }), de(y), ke((P) => Ie(S, `${P ?? ""} `), [
        () => _().find((P) => P.value === s())?.label || b().label
      ]), A(c, p);
    };
    Q(l, () => Bf, (c, f) => {
      f(c, ce(
        {
          class: "dark:bg-popover dark:text-popover-foreground absolute inset-0 opacity-0"
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          child: u,
          $$slots: { child: !0 }
        }
      ));
    });
  }
  return de(a), ke((u) => ls(a, 1, u), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, a), H(i);
}
K(lS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var TF = /* @__PURE__ */ ne("<div><!></div>");
function uS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = TF();
  ve(a, (u) => ({ ...o, class: u }), [() => Se("flex flex-col", n())]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(uS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var DF = /* @__PURE__ */ ne("<nav><!></nav>");
function cS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = DF();
  ve(a, (u) => ({ ...o, class: u }), [
    () => Se("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(cS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var MF = /* @__PURE__ */ ne("<!> <!>", 1), IF = /* @__PURE__ */ ne("<!> <!>", 1), NF = /* @__PURE__ */ ne("<!> <!>", 1);
function dS(t, e) {
  W(e, !0);
  const r = (P) => {
    aS(P, {
      get months() {
        return o();
      },
      get monthFormat() {
        return i();
      },
      get value() {
        return u().month;
      },
      onchange: (w) => {
        if (!f()) return;
        const C = Number.parseInt(w.currentTarget.value), k = f().set({ month: C });
        f(k.subtract({ months: g() }));
      }
    });
  }, n = (P) => {
    lS(P, {
      get years() {
        return a();
      },
      get yearFormat() {
        return l();
      },
      get value() {
        return u().year;
      }
    });
  };
  let s = v(e, "captionLayout", 7), o = v(e, "months", 7), i = v(e, "monthFormat", 7), a = v(e, "years", 7), l = v(e, "yearFormat", 7), u = v(e, "month", 7), c = v(e, "locale", 7), f = v(e, "placeholder", 15), g = v(e, "monthIndex", 7, 0);
  function _(P) {
    const w = P.toDate(ft());
    return typeof l() == "function" ? l()(w.getFullYear()) : new jt(c(), { year: l() }).format(w);
  }
  function b(P) {
    const w = P.toDate(ft());
    return typeof i() == "function" ? i()(w.getMonth() + 1) : new jt(c(), { month: i() }).format(w);
  }
  var p = {
    get captionLayout() {
      return s();
    },
    set captionLayout(P) {
      s(P), m();
    },
    get months() {
      return o();
    },
    set months(P) {
      o(P), m();
    },
    get monthFormat() {
      return i();
    },
    set monthFormat(P) {
      i(P), m();
    },
    get years() {
      return a();
    },
    set years(P) {
      a(P), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(P) {
      l(P), m();
    },
    get month() {
      return u();
    },
    set month(P) {
      u(P), m();
    },
    get locale() {
      return c();
    },
    set locale(P) {
      c(P), m();
    },
    get placeholder() {
      return f();
    },
    set placeholder(P) {
      f(P), m();
    },
    get monthIndex() {
      return g();
    },
    set monthIndex(P = 0) {
      g(P), m();
    }
  }, h = M(), y = D(h);
  {
    var S = (P) => {
      var w = MF(), C = D(w);
      r(C);
      var k = be(C, 2);
      n(k), A(P, w);
    }, x = (P) => {
      var w = M(), C = D(w);
      {
        var k = (T) => {
          var E = IF(), I = D(E);
          r(I);
          var F = be(I, 2);
          {
            var U = (B) => {
              var R = st();
              ke((Z) => Ie(R, Z), [() => _(f())]), A(B, R);
            };
            ue(F, (B) => {
              f() && B(U);
            });
          }
          A(T, E);
        }, $ = (T) => {
          var E = M(), I = D(E);
          {
            var F = (B) => {
              var R = NF(), Z = D(R);
              {
                var Y = (ae) => {
                  var J = st();
                  ke((j) => Ie(J, j), [() => b(f())]), A(ae, J);
                };
                ue(Z, (ae) => {
                  f() && ae(Y);
                });
              }
              var X = be(Z, 2);
              n(X), A(B, R);
            }, U = (B) => {
              var R = st();
              ke((Z, Y) => Ie(R, `${Z ?? ""} ${Y ?? ""}`), [() => b(u()), () => _(u())]), A(B, R);
            };
            ue(
              I,
              (B) => {
                s() === "dropdown-years" ? B(F) : B(U, !1);
              },
              !0
            );
          }
          A(T, E);
        };
        ue(
          C,
          (T) => {
            s() === "dropdown-months" ? T(k) : T($, !1);
          },
          !0
        );
      }
      A(P, w);
    };
    ue(y, (P) => {
      s() === "dropdown" ? P(S) : P(x, !1);
    });
  }
  return A(t, h), H(p);
}
K(
  dS,
  {
    captionLayout: {},
    months: {},
    monthFormat: {},
    years: {},
    yearFormat: {},
    month: {},
    locale: {},
    placeholder: {},
    monthIndex: {}
  },
  [],
  [],
  { mode: "open" }
);
var FF = /* @__PURE__ */ ne('<div data-slot="checkbox-indicator" class="text-current transition-none"><!></div>');
function fS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "checked", 15, !1), s = v(e, "indeterminate", 15, !1), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "checked",
    "indeterminate",
    "class"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get checked() {
      return n();
    },
    set checked(c = !1) {
      n(c), m();
    },
    get indeterminate() {
      return s();
    },
    set indeterminate(c = !1) {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    const c = (g, _) => {
      let b = () => _?.().checked, p = () => _?.().indeterminate;
      var h = FF(), y = ge(h);
      {
        var S = (P) => {
          yu(P, { class: "size-3.5" });
        }, x = (P) => {
          var w = M(), C = D(w);
          {
            var k = ($) => {
              C1($, { class: "size-3.5" });
            };
            ue(
              C,
              ($) => {
                p() && $(k);
              },
              !0
            );
          }
          A(P, w);
        };
        ue(y, (P) => {
          b() ? P(S) : P(x, !1);
        });
      }
      de(h), A(g, h);
    };
    let f = /* @__PURE__ */ O(() => Se("border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive peer flex size-4 shrink-0 items-center justify-center rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", o()));
    Q(u, () => Y_, (g, _) => {
      _(g, ce(
        {
          "data-slot": "checkbox",
          get class() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get checked() {
            return n();
          },
          set checked(b) {
            n(b);
          },
          get indeterminate() {
            return s();
          },
          set indeterminate(b) {
            s(b);
          },
          children: c,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(fS, { ref: {}, checked: {}, indeterminate: {}, class: {} }, [], [], { mode: "open" });
function lg(t, e) {
  W(e, !0);
  let r = v(e, "api", 15, null), n = v(e, "ref", 15, null), s = v(e, "value", 15, ""), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "api",
    "ref",
    "value",
    "class"
  ]);
  var a = {
    get api() {
      return r();
    },
    set api(c = null) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c = null) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c = "") {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", o()));
    Q(u, () => P0, (f, g) => {
      Qe(
        g(f, ce(
          {
            "data-slot": "command",
            get class() {
              return d(c);
            }
          },
          () => i,
          {
            get value() {
              return s();
            },
            set value(_) {
              s(_);
            },
            get ref() {
              return n();
            },
            set ref(_) {
              n(_);
            }
          }
        )),
        (_) => r(_),
        () => r()
      );
    });
  }
  return A(t, l), H(a);
}
K(lg, { api: {}, ref: {}, value: {}, class: {} }, [], [], { mode: "open" });
function RF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => M0, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(RF, { ref: {} }, [], [], { mode: "open" });
function hS(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open"]);
  var s = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => z0, (a, l) => {
    l(a, ce(() => n, {
      get open() {
        return r();
      },
      set open(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(hS, { open: {} }, [], [], { mode: "open" });
function gS(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = M(), s = D(n);
  Q(s, () => nu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(gS, {}, [], [], { mode: "open" });
function pS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-lg leading-none font-semibold", n()));
    Q(a, () => Nb, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-title",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(pS, { ref: {}, class: {} }, [], [], { mode: "open" });
var VF = /* @__PURE__ */ ne("<div><!></div>");
function LF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = VF();
  ve(a, (u) => ({ "data-slot": "dialog-footer", class: u, ...o }), [
    () => Se("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(LF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var jF = /* @__PURE__ */ ne("<div><!></div>");
function mS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = jF();
  ve(a, (u) => ({ "data-slot": "dialog-header", class: u, ...o }), [
    () => Se("flex flex-col gap-2 text-center sm:text-start", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(mS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function vS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", n()));
    Q(a, () => Jb, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-overlay",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(vS, { ref: {}, class: {} }, [], [], { mode: "open" });
var BF = /* @__PURE__ */ ne('<!> <span class="sr-only">Close</span>', 1), zF = /* @__PURE__ */ ne("<!> <!>", 1), qF = /* @__PURE__ */ ne("<!> <!>", 1);
function yS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "portalProps", 7), o = v(e, "children", 7), i = v(e, "showCloseButton", 7, !0), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "portalProps",
    "children",
    "showCloseButton"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get portalProps() {
      return s();
    },
    set portalProps(u) {
      s(u), m();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), m();
    },
    get showCloseButton() {
      return i();
    },
    set showCloseButton(u = !0) {
      i(u), m();
    }
  };
  return gS(t, ce(s, {
    children: (u, c) => {
      var f = qF(), g = D(f);
      Q(g, () => vS, (b, p) => {
        p(b, {});
      });
      var _ = be(g, 2);
      {
        let b = /* @__PURE__ */ O(() => Se("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", n()));
        Q(_, () => q0, (p, h) => {
          h(p, ce(
            {
              "data-slot": "dialog-content",
              get class() {
                return d(b);
              }
            },
            () => a,
            {
              get ref() {
                return r();
              },
              set ref(y) {
                r(y);
              },
              children: (y, S) => {
                var x = zF(), P = D(x);
                te(P, () => o() ?? he);
                var w = be(P, 2);
                {
                  var C = (k) => {
                    var $ = M(), T = D($);
                    Q(T, () => Th, (E, I) => {
                      I(E, {
                        class: "ring-offset-background focus:ring-ring absolute end-4 top-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
                        children: (F, U) => {
                          var B = BF(), R = D(B);
                          E1(R, {}), St(2), A(F, B);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(k, $);
                  };
                  ue(w, (k) => {
                    i() && k(C);
                  });
                }
                A(y, x);
              },
              $$slots: { default: !0 }
            }
          ));
        });
      }
      A(u, f);
    },
    $$slots: { default: !0 }
  })), H(l);
}
K(
  yS,
  {
    ref: {},
    class: {},
    portalProps: {},
    children: {},
    showCloseButton: {}
  },
  [],
  [],
  { mode: "open" }
);
function bS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-muted-foreground text-sm", n()));
    Q(a, () => Qb, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-description",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(bS, { ref: {}, class: {} }, [], [], { mode: "open" });
function UF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Zb, (a, l) => {
    l(a, ce({ "data-slot": "dialog-trigger" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(UF, { ref: {} }, [], [], { mode: "open" });
function KF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Th, (a, l) => {
    l(a, ce({ "data-slot": "dialog-close" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(KF, { ref: {} }, [], [], { mode: "open" });
var WF = /* @__PURE__ */ ne("<!> <!>", 1), HF = /* @__PURE__ */ ne("<!> <!>", 1);
function GF(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "ref", 15, null), s = v(e, "value", 15, ""), o = v(e, "title", 7, "Command Palette"), i = v(e, "description", 7, "Search for a command to run"), a = v(e, "portalProps", 7), l = v(e, "children", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "open",
    "ref",
    "value",
    "title",
    "description",
    "portalProps",
    "children"
  ]);
  var c = {
    get open() {
      return r();
    },
    set open(_ = !1) {
      r(_), m();
    },
    get ref() {
      return n();
    },
    set ref(_ = null) {
      n(_), m();
    },
    get value() {
      return s();
    },
    set value(_ = "") {
      s(_), m();
    },
    get title() {
      return o();
    },
    set title(_ = "Command Palette") {
      o(_), m();
    },
    get description() {
      return i();
    },
    set description(_ = "Search for a command to run") {
      i(_), m();
    },
    get portalProps() {
      return a();
    },
    set portalProps(_) {
      a(_), m();
    },
    get children() {
      return l();
    },
    set children(_) {
      l(_), m();
    }
  }, f = M(), g = D(f);
  return Q(g, () => hS, (_, b) => {
    b(_, ce(() => u, {
      get open() {
        return r();
      },
      set open(p) {
        r(p);
      },
      children: (p, h) => {
        var y = HF(), S = D(y);
        Q(S, () => mS, (P, w) => {
          w(P, {
            class: "sr-only",
            children: (C, k) => {
              var $ = WF(), T = D($);
              Q(T, () => pS, (I, F) => {
                F(I, {
                  children: (U, B) => {
                    St();
                    var R = st();
                    ke(() => Ie(R, o())), A(U, R);
                  },
                  $$slots: { default: !0 }
                });
              });
              var E = be(T, 2);
              Q(E, () => bS, (I, F) => {
                F(I, {
                  children: (U, B) => {
                    St();
                    var R = st();
                    ke(() => Ie(R, i())), A(U, R);
                  },
                  $$slots: { default: !0 }
                });
              }), A(C, $);
            },
            $$slots: { default: !0 }
          });
        });
        var x = be(S, 2);
        Q(x, () => yS, (P, w) => {
          w(P, {
            class: "overflow-hidden p-0",
            get portalProps() {
              return a();
            },
            children: (C, k) => {
              lg(C, ce(
                {
                  class: "**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]]:px-2 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5"
                },
                () => u,
                {
                  get children() {
                    return l();
                  },
                  get value() {
                    return s();
                  },
                  set value($) {
                    s($);
                  },
                  get ref() {
                    return n();
                  },
                  set ref($) {
                    n($);
                  }
                }
              ));
            },
            $$slots: { default: !0 }
          });
        }), A(p, y);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, f), H(c);
}
K(
  GF,
  {
    open: {},
    ref: {},
    value: {},
    title: {},
    description: {},
    portalProps: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
function _S(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("py-6 text-center text-sm", n()));
    Q(a, () => O0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-empty",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(_S, { ref: {}, class: {} }, [], [], { mode: "open" });
var YF = /* @__PURE__ */ ne("<!> <!>", 1);
function wS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "heading", 7), i = v(e, "value", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "heading",
    "value"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get class() {
      return n();
    },
    set class(f) {
      n(f), m();
    },
    get children() {
      return s();
    },
    set children(f) {
      s(f), m();
    },
    get heading() {
      return o();
    },
    set heading(f) {
      o(f), m();
    },
    get value() {
      return i();
    },
    set value(f) {
      i(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => Se("text-foreground overflow-hidden p-1", n())), g = /* @__PURE__ */ O(() => i() ?? o() ?? `----${En()}`);
    Q(c, () => C0, (_, b) => {
      b(_, ce(
        {
          "data-slot": "command-group",
          get class() {
            return d(f);
          },
          get value() {
            return d(g);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          children: (p, h) => {
            var y = YF(), S = D(y);
            {
              var x = (w) => {
                var C = M(), k = D(C);
                Q(k, () => k0, ($, T) => {
                  T($, {
                    class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                    children: (E, I) => {
                      St();
                      var F = st();
                      ke(() => Ie(F, o())), A(E, F);
                    },
                    $$slots: { default: !0 }
                  });
                }), A(w, C);
              };
              ue(S, (w) => {
                o() && w(x);
              });
            }
            var P = be(S, 2);
            Q(P, () => $0, (w, C) => {
              C(w, {
                get children() {
                  return s();
                }
              });
            }), A(p, y);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, u), H(l);
}
K(wS, { ref: {}, class: {}, children: {}, heading: {}, value: {} }, [], [], { mode: "open" });
function SS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(a, () => E0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-item",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(SS, { ref: {}, class: {} }, [], [], { mode: "open" });
var XF = /* @__PURE__ */ ne('<div class="flex h-9 items-center gap-2 border-b ps-3 pe-8" data-slot="command-input-wrapper"><!> <!></div>');
function xS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 15, ""), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c = "") {
      s(c), m();
    }
  }, a = XF(), l = ge(a);
  k1(l, { class: "size-4 shrink-0 opacity-50" });
  var u = be(l, 2);
  {
    let c = /* @__PURE__ */ O(() => Se("placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(u, () => A0, (f, g) => {
      g(f, ce(
        {
          "data-slot": "command-input",
          get class() {
            return d(c);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          get value() {
            return s();
          },
          set value(_) {
            s(_);
          }
        }
      ));
    });
  }
  return de(a), A(t, a), H(i);
}
K(xS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
function PS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto", n()));
    Q(a, () => D0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-list",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(PS, { ref: {}, class: {} }, [], [], { mode: "open" });
function JF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("bg-border -mx-1 h-px", n()));
    Q(a, () => I0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-separator",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(JF, { ref: {}, class: {} }, [], [], { mode: "open" });
var ZF = /* @__PURE__ */ ne("<span><!></span>");
function QF(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = ZF();
  ve(a, (u) => ({ "data-slot": "command-shortcut", class: u, ...o }), [
    () => Se("text-muted-foreground ms-auto text-xs tracking-widest", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(QF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function eR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(a, () => T0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-item",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(eR, { ref: {}, class: {} }, [], [], { mode: "open" });
const tR = qi({
  base: "group/field data-[invalid=true]:text-destructive flex w-full gap-3",
  variants: {
    orientation: {
      vertical: "flex-col [&>*]:w-full [&>.sr-only]:w-auto",
      horizontal: [
        "flex-row items-center",
        "[&>[data-slot=field-label]]:flex-auto",
        "has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ],
      responsive: [
        "flex-col @md/field-group:flex-row @md/field-group:items-center [&>*]:w-full @md/field-group:[&>*]:w-auto [&>.sr-only]:w-auto",
        "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
        "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ]
    }
  },
  defaultVariants: { orientation: "vertical" }
});
var rR = /* @__PURE__ */ ne("<div><!></div>");
function OS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "orientation", 7, "vertical"), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "orientation",
    "children"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get orientation() {
      return s();
    },
    set orientation(c = "vertical") {
      s(c), m();
    },
    get children() {
      return o();
    },
    set children(c) {
      o(c), m();
    }
  }, l = rR();
  ve(
    l,
    (c) => ({
      role: "group",
      "data-slot": "field",
      "data-orientation": s(),
      class: c,
      ...i
    }),
    [
      () => Se(tR({ orientation: s() }), n())
    ]
  );
  var u = ge(l);
  return te(u, () => o() ?? he), de(l), Qe(l, (c) => r(c), () => r()), A(t, l), H(a);
}
K(OS, { ref: {}, class: {}, orientation: {}, children: {} }, [], [], { mode: "open" });
var nR = /* @__PURE__ */ ne("<fieldset><!></fieldset>");
function CS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = nR();
  ve(a, (u) => ({ "data-slot": "field-set", class: u, ...o }), [
    () => Se("flex flex-col gap-6", "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(CS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var sR = /* @__PURE__ */ ne("<legend><!></legend>");
function kS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "variant", 7, "legend"), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "variant",
    "children"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get variant() {
      return s();
    },
    set variant(c = "legend") {
      s(c), m();
    },
    get children() {
      return o();
    },
    set children(c) {
      o(c), m();
    }
  }, l = sR();
  ve(
    l,
    (c) => ({
      "data-slot": "field-legend",
      "data-variant": s(),
      class: c,
      ...i
    }),
    [
      () => Se("mb-3 font-medium", "data-[variant=legend]:text-base", "data-[variant=label]:text-sm", n())
    ]
  );
  var u = ge(l);
  return te(u, () => o() ?? he), de(l), Qe(l, (c) => r(c), () => r()), A(t, l), H(a);
}
K(kS, { ref: {}, class: {}, variant: {}, children: {} }, [], [], { mode: "open" });
var oR = /* @__PURE__ */ ne("<div><!></div>");
function $S(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = oR();
  ve(a, (u) => ({ "data-slot": "field-group", class: u, ...o }), [
    () => Se("group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K($S, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var iR = /* @__PURE__ */ ne("<div><!></div>");
function aR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = iR();
  ve(a, (u) => ({ "data-slot": "field-content", class: u, ...o }), [
    () => Se("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(aR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function AS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", n()));
    Q(a, () => U0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "label",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(AS, { ref: {}, class: {} }, [], [], { mode: "open" });
function ES(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    },
    get class() {
      return n();
    },
    set class(a) {
      n(a), m();
    },
    get children() {
      return s();
    },
    set children(a) {
      s(a), m();
    }
  };
  {
    let a = /* @__PURE__ */ O(() => Se("group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50", "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4", "has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10", n()));
    AS(t, ce(
      {
        "data-slot": "field-label",
        get class() {
          return d(a);
        }
      },
      () => o,
      {
        get ref() {
          return r();
        },
        set ref(l) {
          r(l);
        },
        children: (l, u) => {
          var c = M(), f = D(c);
          te(f, () => s() ?? he), A(l, c);
        },
        $$slots: { default: !0 }
      }
    ));
  }
  return H(i);
}
K(ES, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var lR = /* @__PURE__ */ ne("<div><!></div>");
function TS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = lR();
  ve(a, (u) => ({ "data-slot": "field-title", class: u, ...o }), [
    () => Se("flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(TS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var uR = /* @__PURE__ */ ne("<p><!></p>");
function DS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = uR();
  ve(a, (u) => ({ "data-slot": "field-description", class: u, ...o }), [
    () => Se("text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance", "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5", "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(DS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var cR = /* @__PURE__ */ ne('<span class="bg-background text-muted-foreground relative mx-auto block w-fit px-2" data-slot="field-separator-content"><!></span>'), dR = /* @__PURE__ */ ne("<div><!> <!></div>");
function fR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  const i = /* @__PURE__ */ O(() => !!s());
  var a = {
    get ref() {
      return r();
    },
    set ref(g = null) {
      r(g), m();
    },
    get class() {
      return n();
    },
    set class(g) {
      n(g), m();
    },
    get children() {
      return s();
    },
    set children(g) {
      s(g), m();
    }
  }, l = dR();
  ve(
    l,
    (g) => ({
      "data-slot": "field-separator",
      "data-content": d(i),
      class: g,
      ...o
    }),
    [
      () => Se("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", n())
    ]
  );
  var u = ge(l);
  bu(u, { class: "absolute inset-0 top-1/2" });
  var c = be(u, 2);
  {
    var f = (g) => {
      var _ = cR(), b = ge(_);
      te(b, s), de(_), A(g, _);
    };
    ue(c, (g) => {
      s() && g(f);
    });
  }
  return de(l), Qe(l, (g) => r(g), () => r()), A(t, l), H(a);
}
K(fR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var hR = /* @__PURE__ */ ne("<li> </li>"), gR = /* @__PURE__ */ ne('<ul class="ms-4 flex list-disc flex-col gap-1"></ul>'), pR = /* @__PURE__ */ ne("<div><!></div>");
function MS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "errors", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "errors"
  ]);
  const a = /* @__PURE__ */ O(() => s() ? !0 : !(!o() || o().length === 0 || o().length === 1 && !o()[0]?.message)), l = /* @__PURE__ */ O(() => o() && o().length > 1), u = /* @__PURE__ */ O(() => o() && o().length === 1 && o()[0]?.message);
  var c = {
    get ref() {
      return r();
    },
    set ref(b = null) {
      r(b), m();
    },
    get class() {
      return n();
    },
    set class(b) {
      n(b), m();
    },
    get children() {
      return s();
    },
    set children(b) {
      s(b), m();
    },
    get errors() {
      return o();
    },
    set errors(b) {
      o(b), m();
    }
  }, f = M(), g = D(f);
  {
    var _ = (b) => {
      var p = pR();
      ve(
        p,
        (x) => ({
          role: "alert",
          "data-slot": "field-error",
          class: x,
          ...i
        }),
        [
          () => Se("text-destructive text-sm font-normal", n())
        ]
      );
      var h = ge(p);
      {
        var y = (x) => {
          var P = M(), w = D(P);
          te(w, s), A(x, P);
        }, S = (x) => {
          var P = M(), w = D(P);
          {
            var C = ($) => {
              var T = st();
              ke(() => Ie(T, d(u))), A($, T);
            }, k = ($) => {
              var T = M(), E = D(T);
              {
                var I = (F) => {
                  var U = gR();
                  nt(U, 21, () => o() ?? [], jl, (B, R) => {
                    var Z = M(), Y = D(Z);
                    {
                      var X = (ae) => {
                        var J = hR(), j = ge(J, !0);
                        de(J), ke(() => Ie(j, d(R).message)), A(ae, J);
                      };
                      ue(Y, (ae) => {
                        d(R)?.message && ae(X);
                      });
                    }
                    A(B, Z);
                  }), de(U), A(F, U);
                };
                ue(
                  E,
                  (F) => {
                    d(l) && F(I);
                  },
                  !0
                );
              }
              A($, T);
            };
            ue(
              w,
              ($) => {
                d(u) ? $(C) : $(k, !1);
              },
              !0
            );
          }
          A(x, P);
        };
        ue(h, (x) => {
          s() ? x(y) : x(S, !1);
        });
      }
      de(p), Qe(p, (x) => r(x), () => r()), A(b, p);
    };
    ue(g, (b) => {
      d(a) && b(_);
    });
  }
  return A(t, f), H(c);
}
K(MS, { ref: {}, class: {}, children: {}, errors: {} }, [], [], { mode: "open" });
var mR = /* @__PURE__ */ ne("<input/>"), vR = /* @__PURE__ */ ne("<input/>");
function IS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "type", 7), o = v(e, "files", 15), i = v(e, "class", 7), a = v(e, "data-slot", 7, "input"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "type",
    "files",
    "class",
    "data-slot"
  ]);
  var u = {
    get ref() {
      return r();
    },
    set ref(b = null) {
      r(b), m();
    },
    get value() {
      return n();
    },
    set value(b) {
      n(b), m();
    },
    get type() {
      return s();
    },
    set type(b) {
      s(b), m();
    },
    get files() {
      return o();
    },
    set files(b) {
      o(b), m();
    },
    get class() {
      return i();
    },
    set class(b) {
      i(b), m();
    },
    get "data-slot"() {
      return a();
    },
    set "data-slot"(b = "input") {
      a(b), m();
    }
  }, c = M(), f = D(c);
  {
    var g = (b) => {
      var p = mR();
      ve(
        p,
        (h) => ({
          "data-slot": a(),
          class: h,
          type: "file",
          ...l
        }),
        [
          () => Se("flex h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 pt-1.5 text-sm font-medium shadow-xs ring-offset-background transition-[color,box-shadow] outline-none selection:bg-primary selection:text-primary-foreground placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 dark:bg-input/30", "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50", "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40", i())
        ],
        void 0,
        void 0,
        void 0,
        !0
      ), Qe(p, (h) => r(h), () => r()), uy(p, o), A(b, p);
    }, _ = (b) => {
      var p = vR();
      ve(
        p,
        (h) => ({
          "data-slot": a(),
          class: h,
          type: s(),
          ...l
        }),
        [
          () => Se("flex h-9 w-full min-w-0 rounded-md border border-input bg-background px-3 py-1 text-base shadow-xs ring-offset-background transition-[color,box-shadow] outline-none selection:bg-primary selection:text-primary-foreground placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30", "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50", "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40", i())
        ],
        void 0,
        void 0,
        void 0,
        !0
      ), Qe(p, (h) => r(h), () => r()), Di(p, n), A(b, p);
    };
    ue(f, (b) => {
      s() === "file" ? b(g) : b(_, !1);
    });
  }
  return A(t, c), H(u);
}
K(
  IS,
  {
    ref: {},
    value: {},
    type: {},
    files: {},
    class: {},
    "data-slot": {}
  },
  [],
  [],
  { mode: "open" }
);
function NS(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open"]);
  var s = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => K0, (a, l) => {
    l(a, ce(() => n, {
      get open() {
        return r();
      },
      set open(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(NS, { open: {} }, [], [], { mode: "open" });
function yR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => V0, (a, l) => {
    l(a, ce({ "data-slot": "popover-close" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(yR, { ref: {} }, [], [], { mode: "open" });
function FS(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = M(), s = D(n);
  Q(s, () => nu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(FS, {}, [], [], { mode: "open" });
function RS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "sideOffset", 7, 4), o = v(e, "align", 7, "center"), i = v(e, "portalProps", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "sideOffset",
    "align",
    "portalProps"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(u = 4) {
      s(u), m();
    },
    get align() {
      return o();
    },
    set align(u = "center") {
      o(u), m();
    },
    get portalProps() {
      return i();
    },
    set portalProps(u) {
      i(u), m();
    }
  };
  return FS(t, ce(i, {
    children: (u, c) => {
      var f = M(), g = D(f);
      {
        let _ = /* @__PURE__ */ O(() => Se("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-end-2 data-[side=right]:slide-in-from-start-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--bits-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden", n()));
        Q(g, () => F0, (b, p) => {
          p(b, ce(
            {
              "data-slot": "popover-content",
              get sideOffset() {
                return s();
              },
              get align() {
                return o();
              },
              get class() {
                return d(_);
              }
            },
            () => a,
            {
              get ref() {
                return r();
              },
              set ref(h) {
                r(h);
              }
            }
          ));
        });
      }
      A(u, f);
    },
    $$slots: { default: !0 }
  })), H(l);
}
K(
  RS,
  {
    ref: {},
    class: {},
    sideOffset: {},
    align: {},
    portalProps: {}
  },
  [],
  [],
  { mode: "open" }
);
function VS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("", n()));
    Q(a, () => R0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "popover-trigger",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(VS, { ref: {}, class: {} }, [], [], { mode: "open" });
function LS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 15, ""), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u = "") {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("grid gap-3", n()));
    Q(l, () => H0, (c, f) => {
      f(c, ce(
        {
          "data-slot": "radio-group",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          get value() {
            return s();
          },
          set value(g) {
            s(g);
          }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(LS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var bR = /* @__PURE__ */ ne('<div data-slot="radio-group-indicator" class="relative flex items-center justify-center"><!></div>');
function jS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    const l = (c, f) => {
      let g = () => f?.().checked;
      var _ = bR(), b = ge(_);
      {
        var p = (h) => {
          P1(h, {
            class: "fill-primary absolute start-1/2 top-1/2 size-2 -translate-x-1/2 -translate-y-1/2"
          });
        };
        ue(b, (h) => {
          g() && h(p);
        });
      }
      de(_), A(c, _);
    };
    let u = /* @__PURE__ */ O(() => Se("border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(a, () => G0, (c, f) => {
      f(c, ce(
        {
          "data-slot": "radio-group-item",
          get class() {
            return d(u);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          children: l,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(jS, { ref: {}, class: {} }, [], [], { mode: "open" });
var _R = /* @__PURE__ */ ne("<!> <!>", 1), wR = /* @__PURE__ */ ne("<!> <!>", 1), SR = /* @__PURE__ */ ne("<!> <!>", 1), xR = /* @__PURE__ */ ne("<!> <!>", 1);
function BS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "placeholder", 15), o = v(e, "weekdayFormat", 7, "short"), i = v(e, "class", 7), a = v(e, "buttonVariant", 7, "ghost"), l = v(e, "captionLayout", 7, "label"), u = v(e, "locale", 7, "en-US"), c = v(e, "months", 7), f = v(e, "years", 7), g = v(e, "monthFormat", 7), _ = v(e, "yearFormat", 7, "numeric"), b = v(e, "day", 7), p = v(e, "disableDaysOutsideMonth", 7, !1), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "placeholder",
    "weekdayFormat",
    "class",
    "buttonVariant",
    "captionLayout",
    "locale",
    "months",
    "years",
    "monthFormat",
    "yearFormat",
    "day",
    "disableDaysOutsideMonth"
  ]);
  const y = /* @__PURE__ */ O(() => g() ? g() : l().startsWith("dropdown") ? "short" : "long");
  var S = {
    get ref() {
      return r();
    },
    set ref(w = null) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get placeholder() {
      return s();
    },
    set placeholder(w) {
      s(w), m();
    },
    get weekdayFormat() {
      return o();
    },
    set weekdayFormat(w = "short") {
      o(w), m();
    },
    get class() {
      return i();
    },
    set class(w) {
      i(w), m();
    },
    get buttonVariant() {
      return a();
    },
    set buttonVariant(w = "ghost") {
      a(w), m();
    },
    get captionLayout() {
      return l();
    },
    set captionLayout(w = "label") {
      l(w), m();
    },
    get locale() {
      return u();
    },
    set locale(w = "en-US") {
      u(w), m();
    },
    get months() {
      return c();
    },
    set months(w) {
      c(w), m();
    },
    get years() {
      return f();
    },
    set years(w) {
      f(w), m();
    },
    get monthFormat() {
      return g();
    },
    set monthFormat(w) {
      g(w), m();
    },
    get yearFormat() {
      return _();
    },
    set yearFormat(w = "numeric") {
      _(w), m();
    },
    get day() {
      return b();
    },
    set day(w) {
      b(w), m();
    },
    get disableDaysOutsideMonth() {
      return p();
    },
    set disableDaysOutsideMonth(w = !1) {
      p(w), m();
    }
  }, x = M(), P = D(x);
  {
    const w = (k, $) => {
      let T = () => $?.().months, E = () => $?.().weekdays;
      var I = M(), F = D(I);
      Q(F, () => WS, (U, B) => {
        B(U, {
          children: (R, Z) => {
            var Y = xR(), X = D(Y);
            Q(X, () => QS, (J, j) => {
              j(J, {
                children: (ee, L) => {
                  var N = _R(), V = D(N);
                  Q(V, () => YS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  });
                  var G = be(V, 2);
                  Q(G, () => GS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  }), A(ee, N);
                },
                $$slots: { default: !0 }
              });
            });
            var ae = be(X, 2);
            nt(ae, 18, T, (J) => J, (J, j, ee) => {
              var L = M(), N = D(L);
              Q(N, () => ex, (V, G) => {
                G(V, {
                  children: (fe, se) => {
                    var we = SR(), le = D(we);
                    Q(le, () => KS, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = M(), Ve = D(Oe);
                          Q(Ve, () => ZS, (Ke, Le) => {
                            Le(Ke, {
                              get captionLayout() {
                                return l();
                              },
                              get months() {
                                return c();
                              },
                              get monthFormat() {
                                return d(y);
                              },
                              get years() {
                                return f();
                              },
                              get yearFormat() {
                                return _();
                              },
                              get month() {
                                return j.value;
                              },
                              get locale() {
                                return u();
                              },
                              get monthIndex() {
                                return d(ee);
                              },
                              get placeholder() {
                                return s();
                              },
                              set placeholder(je) {
                                s(je);
                              }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    });
                    var re = be(le, 2);
                    Q(re, () => US, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = wR(), Ve = D(Oe);
                          Q(Ve, () => rx, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                Q($t, () => nd, (lt, ct) => {
                                  ct(lt, {
                                    class: "select-none",
                                    children: (pt, Kt) => {
                                      var vt = M(), Vt = D(vt);
                                      nt(Vt, 16, E, (Mt) => Mt, (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        Q(fn, () => HS, (sr, or) => {
                                          or(sr, {
                                            children: (kr, Xs) => {
                                              St();
                                              var yr = st();
                                              ke((Wr) => Ie(yr, Wr), [() => Wt.slice(0, 2)]), A(kr, yr);
                                            },
                                            $$slots: { default: !0 }
                                          });
                                        }), A(Mt, Ht);
                                      }), A(pt, vt);
                                    },
                                    $$slots: { default: !0 }
                                  });
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          });
                          var Ke = be(Ve, 2);
                          Q(Ke, () => tx, (Le, je) => {
                            je(Le, {
                              children: (We, gt) => {
                                var Ze = M(), $t = D(Ze);
                                nt($t, 16, () => j.weeks, (lt) => lt, (lt, ct) => {
                                  var pt = M(), Kt = D(pt);
                                  Q(Kt, () => nd, (vt, Vt) => {
                                    Vt(vt, {
                                      class: "mt-2 w-full",
                                      children: (Mt, Wt) => {
                                        var Ht = M(), fn = D(Ht);
                                        nt(fn, 16, () => ct, (sr) => sr, (sr, or) => {
                                          var kr = M(), Xs = D(kr);
                                          Q(Xs, () => zS, (yr, Wr) => {
                                            Wr(yr, {
                                              get date() {
                                                return or;
                                              },
                                              get month() {
                                                return j.value;
                                              },
                                              children: (qo, _u) => {
                                                var Uo = M(), wu = D(Uo);
                                                {
                                                  var Su = (ir) => {
                                                    var $r = M(), ps = D($r);
                                                    {
                                                      let ms = /* @__PURE__ */ O(() => ({ day: or, outsideMonth: !r_(or, j.value) }));
                                                      te(ps, b, () => d(ms));
                                                    }
                                                    A(ir, $r);
                                                  }, xu = (ir) => {
                                                    var $r = M(), ps = D($r);
                                                    Q(ps, () => qS, (ms, Pu) => {
                                                      Pu(ms, {});
                                                    }), A(ir, $r);
                                                  };
                                                  ue(wu, (ir) => {
                                                    b() ? ir(Su) : ir(xu, !1);
                                                  });
                                                }
                                                A(qo, Uo);
                                              },
                                              $$slots: { default: !0 }
                                            });
                                          }), A(sr, kr);
                                        }), A(Mt, Ht);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(lt, pt);
                                }), A(We, Ze);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(fe, we);
                  },
                  $$slots: { default: !0 }
                });
              }), A(J, L);
            }), A(R, Y);
          },
          $$slots: { default: !0 }
        });
      }), A(k, I);
    };
    let C = /* @__PURE__ */ O(() => Se("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", i()));
    Q(P, () => Y0, (k, $) => {
      $(k, ce(
        {
          get weekdayFormat() {
            return o();
          },
          get disableDaysOutsideMonth() {
            return p();
          },
          get class() {
            return d(C);
          },
          get locale() {
            return u();
          },
          get monthFormat() {
            return d(y);
          },
          get yearFormat() {
            return _();
          }
        },
        () => h,
        {
          get ref() {
            return r();
          },
          set ref(T) {
            r(T);
          },
          get value() {
            return n();
          },
          set value(T) {
            n(T);
          },
          get placeholder() {
            return s();
          },
          set placeholder(T) {
            s(T);
          },
          children: w,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, x), H(S);
}
K(
  BS,
  {
    ref: {},
    value: {},
    placeholder: {},
    weekdayFormat: {},
    class: {},
    buttonVariant: {},
    captionLayout: {},
    locale: {},
    months: {},
    years: {},
    monthFormat: {},
    yearFormat: {},
    day: {},
    disableDaysOutsideMonth: {}
  },
  [],
  [],
  { mode: "open" }
);
function zS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("dark:[&:has([data-range-start])]:hover:bg-accent dark:[&:has([data-range-end])]:hover:bg-accent [&:has([data-range-middle])]:bg-accent dark:[&:has([data-range-middle])]:hover:bg-accent/50 [&:has([data-selected])]:bg-accent relative size-(--cell-size) p-0 text-center text-sm focus-within:z-20 data-[range-middle]:rounded-e-md [&:first-child[data-selected]_[data-bits-day]]:rounded-s-md [&:has([data-range-end])]:rounded-e-md [&:has([data-range-middle])]:rounded-none first:[&:has([data-range-middle])]:rounded-s-md last:[&:has([data-range-middle])]:rounded-e-md [&:has([data-range-start])]:rounded-s-md [&:last-child[data-selected]_[data-bits-day]]:rounded-e-md", n()));
    Q(a, () => j0, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(zS, { ref: {}, class: {} }, [], [], { mode: "open" });
function qS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se(os({ variant: "ghost" }), "flex size-(--cell-size) flex-col items-center justify-center gap-1 p-0 leading-none font-normal whitespace-nowrap select-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground data-[range-middle]:rounded-none", "data-[range-start]:bg-primary dark:data-[range-start]:hover:bg-accent data-[range-start]:text-primary-foreground", "data-[range-end]:bg-primary dark:data-[range-end]:hover:bg-accent data-[range-end]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:line-through", "dark:data-[range-middle]:hover:bg-accent/0", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", n()));
    Q(a, () => B0, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(qS, { ref: {}, class: {} }, [], [], { mode: "open" });
function US(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("mt-4 flex w-full border-collapse flex-col gap-1", n()));
    Q(a, () => Tf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(US, { ref: {}, class: {} }, [], [], { mode: "open" });
function KS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex h-(--cell-size) w-full items-center justify-center gap-1.5 text-sm font-medium", n()));
    Q(a, () => Ff, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(KS, { ref: {}, class: {} }, [], [], { mode: "open" });
var PR = /* @__PURE__ */ ne("<div><!></div>");
function WS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = PR();
  ve(a, (u) => ({ class: u, ...o }), [
    () => Se("relative flex flex-col gap-4 md:flex-row", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(WS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function nd(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex", n()));
    Q(a, () => Nf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(nd, { ref: {}, class: {} }, [], [], { mode: "open" });
function OR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("px-(--cell-size) text-sm font-medium", n()));
    Q(a, () => Rf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(OR, { ref: {}, class: {} }, [], [], { mode: "open" });
function HS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", n()));
    Q(a, () => If, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(HS, { ref: {}, class: {} }, [], [], { mode: "open" });
const CR = (t) => {
  og(t, { class: "size-4" });
};
function GS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || CR);
    Q(u, () => Lf, (g, _) => {
      _(g, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(GS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
const kR = (t) => {
  sg(t, { class: "size-4" });
};
function YS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se(os({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ O(() => s() || kR);
    Q(u, () => jf, (g, _) => {
      _(g, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(YS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
var $R = /* @__PURE__ */ ne("<option> </option>"), AR = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), ER = /* @__PURE__ */ ne("<span><!></span>");
function XS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "onchange", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "onchange"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c) {
      s(c), m();
    },
    get onchange() {
      return o();
    },
    set onchange(c) {
      o(c), m();
    }
  }, l = ER(), u = ge(l);
  {
    const c = (f, g) => {
      let _ = () => g?.().props, b = () => g?.().monthItems, p = () => g?.().selectedMonthItem;
      var h = AR(), y = D(h);
      ve(y, () => ({ ..._(), value: s(), onchange: o() })), nt(y, 21, b, (w) => w.value, (w, C) => {
        var k = $R(), $ = ge(k, !0);
        de(k);
        var T = {};
        ke(() => {
          Ks(k, s() !== void 0 ? d(C).value === s() : d(C).value === p().value), Ie($, d(C).label), T !== (T = d(C).value) && (k.value = (k.__value = d(C).value) ?? "");
        }), A(w, k);
      }), de(y);
      var S = be(y, 2), x = ge(S), P = be(x);
      gs(P, { class: "size-4" }), de(S), ke((w) => Ie(x, `${w ?? ""} `), [
        () => b().find((w) => w.value === s())?.label || p().label
      ]), A(f, h);
    };
    Q(u, () => Vf, (f, g) => {
      g(f, ce({ class: "absolute inset-0 opacity-0" }, () => i, {
        get ref() {
          return r();
        },
        set ref(_) {
          r(_);
        },
        child: c,
        $$slots: { child: !0 }
      }));
    });
  }
  return de(l), ke((c) => ls(l, 1, c), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, l), H(a);
}
K(XS, { ref: {}, class: {}, value: {}, onchange: {} }, [], [], { mode: "open" });
var TR = /* @__PURE__ */ ne("<option> </option>"), DR = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), MR = /* @__PURE__ */ ne("<span><!></span>");
function JS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u) {
      s(u), m();
    }
  }, a = MR(), l = ge(a);
  {
    const u = (c, f) => {
      let g = () => f?.().props, _ = () => f?.().yearItems, b = () => f?.().selectedYearItem;
      var p = DR(), h = D(p);
      ve(h, () => ({ ...g(), value: s() })), nt(h, 21, _, (P) => P.value, (P, w) => {
        var C = TR(), k = ge(C, !0);
        de(C);
        var $ = {};
        ke(() => {
          Ks(C, s() !== void 0 ? d(w).value === s() : d(w).value === b().value), Ie(k, d(w).label), $ !== ($ = d(w).value) && (C.value = (C.__value = d(w).value) ?? "");
        }), A(P, C);
      }), de(h);
      var y = be(h, 2), S = ge(y), x = be(S);
      gs(x, { class: "size-4" }), de(y), ke((P) => Ie(S, `${P ?? ""} `), [
        () => _().find((P) => P.value === s())?.label || b().label
      ]), A(c, p);
    };
    Q(l, () => Bf, (c, f) => {
      f(c, ce({ class: "absolute inset-0 opacity-0" }, () => o, {
        get ref() {
          return r();
        },
        set ref(g) {
          r(g);
        },
        child: u,
        $$slots: { child: !0 }
      }));
    });
  }
  return de(a), ke((u) => ls(a, 1, u), [
    () => as(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, a), H(i);
}
K(JS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var IR = /* @__PURE__ */ ne("<!> <!>", 1), NR = /* @__PURE__ */ ne("<!> <!>", 1), FR = /* @__PURE__ */ ne("<!> <!>", 1);
function ZS(t, e) {
  W(e, !0);
  const r = (P) => {
    XS(P, {
      get months() {
        return o();
      },
      get monthFormat() {
        return i();
      },
      get value() {
        return u().month;
      },
      onchange: (w) => {
        if (!f()) return;
        const C = Number.parseInt(w.currentTarget.value), k = f().set({ month: C });
        f(k.subtract({ months: g() }));
      }
    });
  }, n = (P) => {
    JS(P, {
      get years() {
        return a();
      },
      get yearFormat() {
        return l();
      },
      get value() {
        return u().year;
      }
    });
  };
  let s = v(e, "captionLayout", 7), o = v(e, "months", 7), i = v(e, "monthFormat", 7), a = v(e, "years", 7), l = v(e, "yearFormat", 7), u = v(e, "month", 7), c = v(e, "locale", 7), f = v(e, "placeholder", 15), g = v(e, "monthIndex", 7, 0);
  function _(P) {
    const w = P.toDate(ft());
    return typeof l() == "function" ? l()(w.getFullYear()) : new jt(c(), { year: l() }).format(w);
  }
  function b(P) {
    const w = P.toDate(ft());
    return typeof i() == "function" ? i()(w.getMonth() + 1) : new jt(c(), { month: i() }).format(w);
  }
  var p = {
    get captionLayout() {
      return s();
    },
    set captionLayout(P) {
      s(P), m();
    },
    get months() {
      return o();
    },
    set months(P) {
      o(P), m();
    },
    get monthFormat() {
      return i();
    },
    set monthFormat(P) {
      i(P), m();
    },
    get years() {
      return a();
    },
    set years(P) {
      a(P), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(P) {
      l(P), m();
    },
    get month() {
      return u();
    },
    set month(P) {
      u(P), m();
    },
    get locale() {
      return c();
    },
    set locale(P) {
      c(P), m();
    },
    get placeholder() {
      return f();
    },
    set placeholder(P) {
      f(P), m();
    },
    get monthIndex() {
      return g();
    },
    set monthIndex(P = 0) {
      g(P), m();
    }
  }, h = M(), y = D(h);
  {
    var S = (P) => {
      var w = IR(), C = D(w);
      r(C);
      var k = be(C, 2);
      n(k), A(P, w);
    }, x = (P) => {
      var w = M(), C = D(w);
      {
        var k = (T) => {
          var E = NR(), I = D(E);
          r(I);
          var F = be(I, 2);
          {
            var U = (B) => {
              var R = st();
              ke((Z) => Ie(R, Z), [() => _(f())]), A(B, R);
            };
            ue(F, (B) => {
              f() && B(U);
            });
          }
          A(T, E);
        }, $ = (T) => {
          var E = M(), I = D(E);
          {
            var F = (B) => {
              var R = FR(), Z = D(R);
              {
                var Y = (ae) => {
                  var J = st();
                  ke((j) => Ie(J, j), [() => b(f())]), A(ae, J);
                };
                ue(Z, (ae) => {
                  f() && ae(Y);
                });
              }
              var X = be(Z, 2);
              n(X), A(B, R);
            }, U = (B) => {
              var R = st();
              ke((Z, Y) => Ie(R, `${Z ?? ""} ${Y ?? ""}`), [() => b(u()), () => _(u())]), A(B, R);
            };
            ue(
              I,
              (B) => {
                s() === "dropdown-years" ? B(F) : B(U, !1);
              },
              !0
            );
          }
          A(T, E);
        };
        ue(
          C,
          (T) => {
            s() === "dropdown-months" ? T(k) : T($, !1);
          },
          !0
        );
      }
      A(P, w);
    };
    ue(y, (P) => {
      s() === "dropdown" ? P(S) : P(x, !1);
    });
  }
  return A(t, h), H(p);
}
K(
  ZS,
  {
    captionLayout: {},
    months: {},
    monthFormat: {},
    years: {},
    yearFormat: {},
    month: {},
    locale: {},
    placeholder: {},
    monthIndex: {}
  },
  [],
  [],
  { mode: "open" }
);
var RR = /* @__PURE__ */ ne("<nav><!></nav>");
function QS(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = RR();
  ve(a, (u) => ({ ...o, class: u }), [
    () => Se("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(QS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var VR = /* @__PURE__ */ ne("<div><!></div>");
function ex(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = VR();
  ve(a, (u) => ({ ...o, class: u }), [() => Se("flex flex-col", n())]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(ex, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function tx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Df, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(tx, { ref: {} }, [], [], { mode: "open" });
function rx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => Mf, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(rx, { ref: {} }, [], [], { mode: "open" });
function nx(t, e) {
  W(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "value", 15), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open", "value"]);
  var o = {
    get open() {
      return r();
    },
    set open(l = !1) {
      r(l), m();
    },
    get value() {
      return n();
    },
    set value(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  return Q(a, () => X0, (l, u) => {
    u(l, ce(() => s, {
      get open() {
        return r();
      },
      set open(c) {
        r(c);
      },
      get value() {
        return n();
      },
      set value(c) {
        n(c);
      }
    }));
  }), A(t, i), H(o);
}
K(nx, { open: {}, value: {} }, [], [], { mode: "open" });
function LR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = M(), i = D(o);
  return Q(i, () => m0, (a, l) => {
    l(a, ce({ "data-slot": "select-group" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), H(s);
}
K(LR, { ref: {} }, [], [], { mode: "open" });
var jR = /* @__PURE__ */ ne("<div><!></div>");
function BR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = jR();
  ve(a, (u) => ({ "data-slot": "select-label", class: u, ...o }), [
    () => Se("text-muted-foreground px-2 py-1.5 text-xs", n())
  ]);
  var l = ge(a);
  return te(l, () => s() ?? he), de(a), Qe(a, (u) => r(u), () => r()), A(t, a), H(i);
}
K(BR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var zR = /* @__PURE__ */ ne('<span class="absolute end-2 flex size-3.5 items-center justify-center"><!></span> <!>', 1);
function sx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "label", 7), i = v(e, "children", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "label",
    "children"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get class() {
      return n();
    },
    set class(f) {
      n(f), m();
    },
    get value() {
      return s();
    },
    set value(f) {
      s(f), m();
    },
    get label() {
      return o();
    },
    set label(f) {
      o(f), m();
    },
    get children() {
      return i();
    },
    set children(f) {
      i(f), m();
    }
  }, u = M(), c = D(u);
  {
    const f = (_, b) => {
      let p = () => b?.().selected, h = () => b?.().highlighted;
      var y = zR(), S = D(y), x = ge(S);
      {
        var P = ($) => {
          yu($, { class: "size-4" });
        };
        ue(x, ($) => {
          p() && $(P);
        });
      }
      de(S);
      var w = be(S, 2);
      {
        var C = ($) => {
          var T = M(), E = D(T);
          te(E, i, () => ({ selected: p(), highlighted: h() })), A($, T);
        }, k = ($) => {
          var T = st();
          ke(() => Ie(T, o() || s())), A($, T);
        };
        ue(w, ($) => {
          i() ? $(C) : $(k, !1);
        });
      }
      A(_, y);
    };
    let g = /* @__PURE__ */ O(() => Se("data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 ps-2 pe-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", n()));
    Q(c, () => p0, (_, b) => {
      b(_, ce(
        {
          get value() {
            return s();
          },
          "data-slot": "select-item",
          get class() {
            return d(g);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          children: f,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, u), H(l);
}
K(sx, { ref: {}, class: {}, value: {}, label: {}, children: {} }, [], [], { mode: "open" });
function ox(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = M(), s = D(n);
  Q(s, () => nu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(ox, {}, [], [], { mode: "open" });
function ix(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex cursor-default items-center justify-center py-1", n()));
    Q(a, () => _0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "select-scroll-up-button",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          },
          children: (f, g) => {
            S1(f, { class: "size-4" });
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(ix, { ref: {}, class: {} }, [], [], { mode: "open" });
function ax(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = M(), a = D(i);
  {
    let l = /* @__PURE__ */ O(() => Se("flex cursor-default items-center justify-center py-1", n()));
    Q(a, () => b0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "select-scroll-down-button",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          },
          children: (f, g) => {
            gs(f, { class: "size-4" });
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), H(o);
}
K(ax, { ref: {}, class: {} }, [], [], { mode: "open" });
var qR = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function lx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "sideOffset", 7, 4), o = v(e, "portalProps", 7), i = v(e, "children", 7), a = v(e, "preventScroll", 7, !0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "sideOffset",
    "portalProps",
    "children",
    "preventScroll"
  ]);
  var u = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(c = 4) {
      s(c), m();
    },
    get portalProps() {
      return o();
    },
    set portalProps(c) {
      o(c), m();
    },
    get children() {
      return i();
    },
    set children(c) {
      i(c), m();
    },
    get preventScroll() {
      return a();
    },
    set preventScroll(c = !0) {
      a(c), m();
    }
  };
  return ox(t, ce(o, {
    children: (c, f) => {
      var g = M(), _ = D(g);
      {
        let b = /* @__PURE__ */ O(() => Se("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-end-2 data-[side=right]:slide-in-from-start-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--bits-select-content-available-height) min-w-[8rem] origin-(--bits-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", n()));
        Q(_, () => g0, (p, h) => {
          h(p, ce(
            {
              get sideOffset() {
                return s();
              },
              get preventScroll() {
                return a();
              },
              "data-slot": "select-content",
              get class() {
                return d(b);
              }
            },
            () => l,
            {
              get ref() {
                return r();
              },
              set ref(y) {
                r(y);
              },
              children: (y, S) => {
                var x = qR(), P = D(x);
                ix(P, {});
                var w = be(P, 2);
                {
                  let k = /* @__PURE__ */ O(() => Se("h-(--bits-select-anchor-height) w-full min-w-(--bits-select-anchor-width) scroll-my-1 p-1"));
                  Q(w, () => y0, ($, T) => {
                    T($, {
                      get class() {
                        return d(k);
                      },
                      children: (E, I) => {
                        var F = M(), U = D(F);
                        te(U, () => i() ?? he), A(E, F);
                      },
                      $$slots: { default: !0 }
                    });
                  });
                }
                var C = be(w, 2);
                ax(C, {}), A(y, x);
              },
              $$slots: { default: !0 }
            }
          ));
        });
      }
      A(c, g);
    },
    $$slots: { default: !0 }
  })), H(u);
}
K(
  lx,
  {
    ref: {},
    class: {},
    sideOffset: {},
    portalProps: {},
    children: {},
    preventScroll: {}
  },
  [],
  [],
  { mode: "open" }
);
var UR = /* @__PURE__ */ ne("<!> <!>", 1);
function ux(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "size", 7, "default"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "size"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get size() {
      return o();
    },
    set size(c = "default") {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    let c = /* @__PURE__ */ O(() => Se("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none select-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(u, () => J0, (f, g) => {
      g(f, ce(
        {
          "data-slot": "select-trigger",
          get "data-size"() {
            return o();
          },
          get class() {
            return d(c);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          children: (_, b) => {
            var p = UR(), h = D(p);
            te(h, () => s() ?? he);
            var y = be(h, 2);
            gs(y, { class: "size-4 opacity-50" }), A(_, p);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(ux, { ref: {}, class: {}, children: {}, size: {} }, [], [], { mode: "open" });
function KR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(i = null) {
      r(i), m();
    },
    get class() {
      return n();
    },
    set class(i) {
      n(i), m();
    }
  };
  {
    let i = /* @__PURE__ */ O(() => Se("bg-border pointer-events-none -mx-1 my-1 h-px", n()));
    bu(t, ce(
      {
        "data-slot": "select-separator",
        get class() {
          return d(i);
        }
      },
      () => s,
      {
        get ref() {
          return r();
        },
        set ref(a) {
          r(a);
        }
      }
    ));
  }
  return H(o);
}
K(KR, { ref: {}, class: {} }, [], [], { mode: "open" });
function WR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("text-muted-foreground px-2 py-1.5 text-xs", n()));
    Q(l, () => v0, (c, f) => {
      f(c, ce(
        {
          "data-slot": "select-group-heading",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          children: (g, _) => {
            var b = M(), p = D(b);
            te(p, () => s() ?? he), A(g, b);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(WR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var HR = /* @__PURE__ */ ne('<span data-slot="slider-track"><!></span> <!>', 1);
function cx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "orientation", 7, "horizontal"), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "orientation",
    "class"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get value() {
      return n();
    },
    set value(c) {
      n(c), m();
    },
    get orientation() {
      return s();
    },
    set orientation(c = "horizontal") {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = M(), u = D(l);
  {
    const c = (g, _) => {
      let b = () => _?.().thumbs;
      var p = HR(), h = D(p), y = ge(h);
      {
        let x = /* @__PURE__ */ O(() => Se("bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"));
        Q(y, () => rw, (P, w) => {
          w(P, {
            "data-slot": "slider-range",
            get class() {
              return d(x);
            }
          });
        });
      }
      de(h);
      var S = be(h, 2);
      nt(S, 16, b, (x) => x, (x, P) => {
        var w = M(), C = D(w);
        Q(C, () => nw, (k, $) => {
          $(k, {
            "data-slot": "slider-thumb",
            get index() {
              return P;
            },
            class: "border-primary ring-ring/50 block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
          });
        }), A(x, w);
      }), ke(
        (x) => {
          An(h, "data-orientation", s()), ls(h, 1, x);
        },
        [
          () => as(Se("bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"))
        ]
      ), A(g, p);
    };
    let f = /* @__PURE__ */ O(() => Se("relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col", o()));
    Q(u, () => tw, (g, _) => {
      _(g, ce(
        {
          "data-slot": "slider",
          get orientation() {
            return s();
          },
          get class() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get value() {
            return n();
          },
          set value(b) {
            n(b);
          },
          children: c,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), H(a);
}
K(cx, { ref: {}, value: {}, orientation: {}, class: {} }, [], [], { mode: "open" });
function dx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "checked", 15, !1), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "checked"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get checked() {
      return s();
    },
    set checked(u = !1) {
      s(u), m();
    }
  }, a = M(), l = D(a);
  {
    let u = /* @__PURE__ */ O(() => Se("data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(l, () => iw, (c, f) => {
      f(c, ce(
        {
          "data-slot": "switch",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          get checked() {
            return s();
          },
          set checked(g) {
            s(g);
          },
          children: (g, _) => {
            var b = M(), p = D(b);
            {
              let h = /* @__PURE__ */ O(() => Se("bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"));
              Q(p, () => aw, (y, S) => {
                S(y, {
                  "data-slot": "switch-thumb",
                  get class() {
                    return d(h);
                  }
                });
              });
            }
            A(g, b);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, a), H(i);
}
K(dx, { ref: {}, class: {}, checked: {} }, [], [], { mode: "open" });
var GR = /* @__PURE__ */ ne("<textarea></textarea>");
function fx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "data-slot", 7, "textarea"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "data-slot"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get value() {
      return n();
    },
    set value(u) {
      n(u), m();
    },
    get class() {
      return s();
    },
    set class(u) {
      s(u), m();
    },
    get "data-slot"() {
      return o();
    },
    set "data-slot"(u = "textarea") {
      o(u), m();
    }
  }, l = GR();
  return Tv(l), ve(l, (u) => ({ "data-slot": o(), class: u, ...i }), [
    () => Se("border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", s())
  ]), Qe(l, (u) => r(u), () => r()), Di(l, n), A(t, l), H(a);
}
K(fx, { ref: {}, value: {}, class: {}, "data-slot": {} }, [], [], { mode: "open" });
const hx = qi({
  base: "hover:bg-muted hover:text-muted-foreground data-[state=on]:bg-accent data-[state=on]:text-accent-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-transparent",
      outline: "border-input hover:bg-accent hover:text-accent-foreground border bg-transparent shadow-xs"
    },
    size: {
      default: "h-9 min-w-9 px-2",
      sm: "h-8 min-w-8 px-1.5",
      lg: "h-10 min-w-10 px-2.5"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
function YR(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "pressed", 15, !1), s = v(e, "class", 7), o = v(e, "size", 7, "default"), i = v(e, "variant", 7, "default"), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "pressed",
    "class",
    "size",
    "variant"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get pressed() {
      return n();
    },
    set pressed(f = !1) {
      n(f), m();
    },
    get class() {
      return s();
    },
    set class(f) {
      s(f), m();
    },
    get size() {
      return o();
    },
    set size(f = "default") {
      o(f), m();
    },
    get variant() {
      return i();
    },
    set variant(f = "default") {
      i(f), m();
    }
  }, u = M(), c = D(u);
  {
    let f = /* @__PURE__ */ O(() => Se(hx({ variant: i(), size: o() }), s()));
    Q(c, () => lw, (g, _) => {
      _(g, ce(
        {
          "data-slot": "toggle",
          get class() {
            return d(f);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get pressed() {
            return n();
          },
          set pressed(b) {
            n(b);
          }
        }
      ));
    });
  }
  return A(t, u), H(l);
}
K(YR, { ref: {}, pressed: {}, class: {}, size: {}, variant: {} }, [], [], { mode: "open" });
function XR(t) {
  Po("toggleGroup", t);
}
function JR() {
  return Is("toggleGroup");
}
function gx(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "size", 7, "default"), i = v(e, "spacing", 7, 0), a = v(e, "variant", 7, "default"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "size",
    "spacing",
    "variant"
  ]);
  XR({ variant: a(), size: o(), spacing: i() });
  var u = {
    get ref() {
      return r();
    },
    set ref(g = null) {
      r(g), m();
    },
    get value() {
      return n();
    },
    set value(g) {
      n(g), m();
    },
    get class() {
      return s();
    },
    set class(g) {
      s(g), m();
    },
    get size() {
      return o();
    },
    set size(g = "default") {
      o(g), m();
    },
    get spacing() {
      return i();
    },
    set spacing(g = 0) {
      i(g), m();
    },
    get variant() {
      return a();
    },
    set variant(g = "default") {
      a(g), m();
    }
  }, c = M(), f = D(c);
  {
    let g = /* @__PURE__ */ O(() => `--gap: ${i()}`), _ = /* @__PURE__ */ O(() => Se("group/toggle-group flex w-fit items-center gap-[--spacing(var(--gap))] rounded-md data-[spacing=default]:data-[variant=outline]:shadow-xs", s()));
    Q(f, () => dw, (b, p) => {
      p(b, ce(
        {
          "data-slot": "toggle-group",
          get "data-variant"() {
            return a();
          },
          get "data-size"() {
            return o();
          },
          get "data-spacing"() {
            return i();
          },
          get style() {
            return d(g);
          },
          get class() {
            return d(_);
          }
        },
        () => l,
        {
          get value() {
            return n();
          },
          set value(h) {
            n(h);
          },
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          }
        }
      ));
    });
  }
  return A(t, c), H(u);
}
K(
  gx,
  {
    ref: {},
    value: {},
    class: {},
    size: {},
    spacing: {},
    variant: {}
  },
  [],
  [],
  { mode: "open" }
);
function px(t, e) {
  W(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "size", 7), i = v(e, "variant", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "size",
    "variant"
  ]);
  const l = JR();
  var u = {
    get ref() {
      return r();
    },
    set ref(g = null) {
      r(g), m();
    },
    get value() {
      return n();
    },
    set value(g) {
      n(g), m();
    },
    get class() {
      return s();
    },
    set class(g) {
      s(g), m();
    },
    get size() {
      return o();
    },
    set size(g) {
      o(g), m();
    },
    get variant() {
      return i();
    },
    set variant(g) {
      i(g), m();
    }
  }, c = M(), f = D(c);
  {
    let g = /* @__PURE__ */ O(() => l.variant || i()), _ = /* @__PURE__ */ O(() => l.size || o()), b = /* @__PURE__ */ O(() => Se(hx({ variant: l.variant || i(), size: l.size || o() }), "w-auto min-w-0 shrink-0 px-3 focus:z-10 focus-visible:z-10 data-[spacing=0]:rounded-none data-[spacing=0]:shadow-none data-[spacing=0]:first:rounded-l-md data-[spacing=0]:last:rounded-r-md data-[spacing=0]:data-[variant=outline]:border-l-0 data-[spacing=0]:data-[variant=outline]:first:border-l", s()));
    Q(f, () => fw, (p, h) => {
      h(p, ce(
        {
          "data-slot": "toggle-group-item",
          get "data-variant"() {
            return d(g);
          },
          get "data-size"() {
            return d(_);
          },
          get "data-spacing"() {
            return l.spacing;
          },
          get class() {
            return d(b);
          },
          get value() {
            return n();
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(y) {
            r(y);
          }
        }
      ));
    });
  }
  return A(t, c), H(u);
}
K(px, { ref: {}, value: {}, class: {}, size: {}, variant: {} }, [], [], { mode: "open" });
var ZR = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function mx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Checkbox), i = /* @__PURE__ */ O(() => d(s).FieldLabel);
  let a = v(e, "value", 15), l = v(e, "options", 7), u = v(e, "config", 7), c = v(e, "handlers", 7);
  const f = m1({
    mapper: () => Lo(l()),
    value: () => a(),
    update: (w) => a(w)
  }), g = /* @__PURE__ */ O(() => new Set(f.current)), _ = /* @__PURE__ */ O(() => c().oninput), b = /* @__PURE__ */ O(() => c().onchange), p = /* @__PURE__ */ O(() => Nn(c(), ["oninput", "onchange"])), h = /* @__PURE__ */ O(() => mr(r, u().path)), y = /* @__PURE__ */ O(() => pr(r, u(), "shadcn4Checkboxes", cn(d(p))({ ...c(), name: d(h), required: u().required })));
  var S = {
    get value() {
      return a();
    },
    set value(w) {
      a(w), m();
    },
    get options() {
      return l();
    },
    set options(w) {
      l(w), m();
    },
    get config() {
      return u();
    },
    set config(w) {
      u(w), m();
    },
    get handlers() {
      return c();
    },
    set handlers(w) {
      c(w), m();
    }
  }, x = M(), P = D(x);
  return nt(P, 17, l, (w) => w.id, (w, C) => {
    var k = ZR(), $ = ge(k);
    {
      let E = /* @__PURE__ */ O(() => d(g).has(d(C).id)), I = /* @__PURE__ */ O(() => d(C).disabled || d(y).disabled);
      Q($, () => d(o), (F, U) => {
        U(F, ce(
          {
            get checked() {
              return d(E);
            },
            get value() {
              return d(C).id;
            },
            onCheckedChange: (B) => {
              f.current = B ? f.current.concat(d(C).id) : f.current.filter((R) => R !== d(C).id), d(_)?.(), d(b)?.();
            }
          },
          () => d(y),
          {
            get id() {
              return d(C).id;
            },
            get disabled() {
              return d(I);
            }
          }
        ));
      });
    }
    var T = be($, 2);
    Q(T, () => d(i), (E, I) => {
      I(E, {
        get for() {
          return d(C).id;
        },
        children: (F, U) => {
          St();
          var B = st();
          ke(() => Ie(B, d(C).label)), A(F, B);
        },
        $$slots: { default: !0 }
      });
    }), de(k), A(w, k);
  }), A(t, x), H(S);
}
K(mx, { value: {}, options: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.checkboxesWidget = mx;
function Cl(...t) {
  return ag(io(t));
}
var QR = /* @__PURE__ */ ne("<span> </span> <!>", 1), e5 = /* @__PURE__ */ ne("<!> ", 1), t5 = /* @__PURE__ */ ne("<!> <!>", 1), r5 = /* @__PURE__ */ ne("<!> <!>", 1), n5 = /* @__PURE__ */ ne("<!> <!>", 1);
function vx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Popover), i = /* @__PURE__ */ O(() => d(s).PopoverContent), a = /* @__PURE__ */ O(() => d(s).PopoverTrigger), l = /* @__PURE__ */ O(() => d(s).Button), u = /* @__PURE__ */ O(() => d(s).CommandInput), c = /* @__PURE__ */ O(() => d(s).Command), f = /* @__PURE__ */ O(() => d(s).CommandList), g = /* @__PURE__ */ O(() => d(s).CommandEmpty), _ = /* @__PURE__ */ O(() => d(s).CommandGroup), b = /* @__PURE__ */ O(() => d(s).CommandItem);
  let p = v(e, "value", 15), h = v(e, "config", 7), y = v(e, "handlers", 7), S = v(e, "options", 7);
  const x = /* @__PURE__ */ O(() => new Map(S().map((Y) => [Y.id, Y.label]))), P = vu({
    mapper: () => Lo(S()),
    value: () => p(),
    update: (Y) => p(Y)
  });
  let w = /* @__PURE__ */ xe(!1), C = /* @__PURE__ */ xe(null);
  function k() {
    q(w, !1), Vl().then(() => {
      d(C).focus();
    });
  }
  const $ = /* @__PURE__ */ O(() => Ni(r, h(), "shadcn4ComboboxInput", y(), {})), T = /* @__PURE__ */ O(() => d(x).get(P.current) ?? d($).placeholder), E = /* @__PURE__ */ O(() => Nt(r, h(), "shadcn4ComboboxEmptyText")), I = /* @__PURE__ */ O(() => y().oninput), F = /* @__PURE__ */ O(() => y().onchange), U = /* @__PURE__ */ O(() => Nn(y(), ["oninput", "onchange"]));
  var B = {
    get value() {
      return p();
    },
    set value(Y) {
      p(Y), m();
    },
    get config() {
      return h();
    },
    set config(Y) {
      h(Y), m();
    },
    get handlers() {
      return y();
    },
    set handlers(Y) {
      y(Y), m();
    },
    get options() {
      return S();
    },
    set options(Y) {
      S(Y), m();
    }
  }, R = M(), Z = D(R);
  return Q(Z, () => d(o), (Y, X) => {
    X(Y, {
      get open() {
        return d(w);
      },
      set open(ae) {
        q(w, ae, !0);
      },
      children: (ae, J) => {
        var j = n5(), ee = D(j);
        {
          const N = (G, fe) => {
            let se = () => fe?.().props;
            var we = M(), le = D(we);
            {
              let re = /* @__PURE__ */ O(() => Ft(
                r,
                h(),
                {
                  variant: "outline",
                  ...se(),
                  role: "combobox",
                  "aria-expanded": d(w)
                },
                wt("shadcn4ComboboxTrigger"),
                cn(d(U)),
                Hs
              ));
              Q(le, () => d(l), (oe, pe) => {
                pe(oe, ce(() => d(re), {
                  children: (ye, Pe) => {
                    var Oe = QR(), Ve = D(Oe), Ke = ge(Ve, !0);
                    de(Ve);
                    var Le = be(Ve, 2);
                    x1(Le, { class: "ml-2 size-4 shrink-0 opacity-50" }), ke(() => Ie(Ke, d(T))), A(ye, Oe);
                  },
                  $$slots: { default: !0 }
                }));
              });
            }
            A(G, we);
          };
          let V = /* @__PURE__ */ O(() => To({}, h(), r));
          Q(ee, () => d(a), (G, fe) => {
            fe(G, ce({ class: "w-full justify-between" }, () => d(V), {
              get ref() {
                return d(C);
              },
              set ref(se) {
                q(C, se, !0);
              },
              child: N,
              $$slots: { child: !0 }
            }));
          });
        }
        var L = be(ee, 2);
        Q(L, () => d(i), (N, V) => {
          V(N, {
            class: "w-[200px] p-0",
            children: (G, fe) => {
              var se = M(), we = D(se);
              Q(we, () => d(c), (le, re) => {
                re(le, {
                  children: (oe, pe) => {
                    var ye = r5(), Pe = D(ye);
                    Q(Pe, () => d(u), (Ve, Ke) => {
                      Ke(Ve, ce(() => d($)));
                    });
                    var Oe = be(Pe, 2);
                    Q(Oe, () => d(f), (Ve, Ke) => {
                      Ke(Ve, {
                        children: (Le, je) => {
                          var We = t5(), gt = D(We);
                          {
                            var Ze = (lt) => {
                              var ct = M(), pt = D(ct);
                              Q(pt, () => d(g), (Kt, vt) => {
                                vt(Kt, {
                                  children: (Vt, Mt) => {
                                    St();
                                    var Wt = st();
                                    ke(() => Ie(Wt, d(E))), A(Vt, Wt);
                                  },
                                  $$slots: { default: !0 }
                                });
                              }), A(lt, ct);
                            };
                            ue(gt, (lt) => {
                              d(E) && lt(Ze);
                            });
                          }
                          var $t = be(gt, 2);
                          Q($t, () => d(_), (lt, ct) => {
                            ct(lt, {
                              children: (pt, Kt) => {
                                var vt = M(), Vt = D(vt);
                                nt(Vt, 17, S, (Mt) => Mt.id, (Mt, Wt) => {
                                  var Ht = M(), fn = D(Ht);
                                  Q(fn, () => d(b), (sr, or) => {
                                    or(sr, {
                                      get value() {
                                        return d(Wt).label;
                                      },
                                      onSelect: () => {
                                        P.current = d(Wt).id, d(I)?.(), d(F)?.(), k();
                                      },
                                      get disabled() {
                                        return d(Wt).disabled;
                                      },
                                      children: (kr, Xs) => {
                                        var yr = e5(), Wr = D(yr);
                                        {
                                          let _u = /* @__PURE__ */ O(() => Cl("mr-2 size-4", P.current !== d(Wt).id && "text-transparent"));
                                          yu(Wr, {
                                            get class() {
                                              return d(_u);
                                            }
                                          });
                                        }
                                        var qo = be(Wr);
                                        ke(() => Ie(qo, ` ${d(Wt).label ?? ""}`)), A(kr, yr);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(Mt, Ht);
                                }), A(pt, vt);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(Le, We);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(oe, ye);
                  },
                  $$slots: { default: !0 }
                });
              }), A(G, se);
            },
            $$slots: { default: !0 }
          });
        }), A(ae, j);
      },
      $$slots: { default: !0 }
    });
  }), A(t, R), H(B);
}
K(vx, { value: {}, config: {}, handlers: {}, options: {} }, [], [], { mode: "open" });
nr.comboboxWidget = vx;
var s5 = /* @__PURE__ */ ne("<span> </span> <!>", 1), o5 = /* @__PURE__ */ ne("<!> <!>", 1);
function yx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Popover), i = /* @__PURE__ */ O(() => d(s).PopoverTrigger), a = /* @__PURE__ */ O(() => d(s).Button), l = /* @__PURE__ */ O(() => d(s).PopoverContent), u = /* @__PURE__ */ O(() => d(s).Calendar);
  let c = v(e, "value", 15), f = v(e, "config", 7), g = v(e, "handlers", 7);
  const _ = /* @__PURE__ */ O(() => g().oninput), b = /* @__PURE__ */ O(() => g().onchange), p = /* @__PURE__ */ O(() => Nn(g(), ["oninput", "onchange"])), h = /* @__PURE__ */ O(() => pr(r, f(), "shadcn4DatePicker", {
    initialFocus: !0,
    onValueChange: () => {
      d(_)?.(), d(b)?.();
    }
  })), y = /* @__PURE__ */ O(() => c() !== void 0 ? Si(c()) : void 0), S = /* @__PURE__ */ O(() => {
    const k = Nt(r, f(), "shadcn4DateFormatter");
    if (k !== void 0)
      return k;
    const $ = new Intl.DateTimeFormat(void 0, { year: "numeric", month: "2-digit", day: "numeric" });
    return (T) => $.format(T);
  }), x = /* @__PURE__ */ O(() => {
    const k = d(y);
    return k === void 0 ? d(h).placeholder : d(S)(k.toDate(ft()));
  });
  var P = {
    get value() {
      return c();
    },
    set value(k) {
      c(k), m();
    },
    get config() {
      return f();
    },
    set config(k) {
      f(k), m();
    },
    get handlers() {
      return g();
    },
    set handlers(k) {
      g(k), m();
    }
  }, w = M(), C = D(w);
  return Q(C, () => d(o), (k, $) => {
    $(k, {
      children: (T, E) => {
        var I = o5(), F = D(I);
        {
          const B = (R, Z) => {
            let Y = () => Z?.().props;
            var X = M(), ae = D(X);
            {
              let J = /* @__PURE__ */ O(() => Ft(r, f(), {}, wt("shadcn4DatePickerTrigger"), cn(d(p)), Hs));
              Q(ae, () => d(a), (j, ee) => {
                ee(j, ce(
                  Y,
                  {
                    variant: "outline",
                    class: "w-full justify-between font-normal"
                  },
                  () => d(J),
                  {
                    children: (L, N) => {
                      var V = s5(), G = D(V), fe = ge(G, !0);
                      de(G);
                      var se = be(G, 2);
                      gs(se, {}), ke(() => Ie(fe, d(x))), A(L, V);
                    },
                    $$slots: { default: !0 }
                  }
                ));
              });
            }
            A(R, X);
          };
          Q(F, () => d(i), (R, Z) => {
            Z(R, { child: B, $$slots: { child: !0 } });
          });
        }
        var U = be(F, 2);
        Q(U, () => d(l), (B, R) => {
          R(B, {
            children: (Z, Y) => {
              var X = M(), ae = D(X), J = () => d(y), j = (ee) => c(ee?.toDate(ft()).toLocaleDateString("en-CA"));
              Q(ae, () => d(u), (ee, L) => {
                L(ee, ce(
                  {
                    get value() {
                      return J();
                    },
                    set value(N) {
                      j(N);
                    }
                  },
                  () => d(h),
                  { type: "single" }
                ));
              }), A(Z, X);
            },
            $$slots: { default: !0 }
          });
        }), A(T, I);
      },
      $$slots: { default: !0 }
    });
  }), A(t, w), H(P);
}
K(yx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.datePickerWidget = yx;
const sd = qi({
  base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-xs",
      destructive: "bg-destructive hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white shadow-xs",
      outline: "bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80 shadow-xs",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
var i5 = /* @__PURE__ */ ne("<a><!></a>"), a5 = /* @__PURE__ */ ne("<button><!></button>");
function l5(t, e) {
  W(e, !0);
  let r = v(e, "class", 7), n = v(e, "variant", 7, "default"), s = v(e, "size", 7, "default"), o = v(e, "ref", 15, null), i = v(e, "href", 7, void 0), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7), u = v(e, "children", 7), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "class",
    "variant",
    "size",
    "ref",
    "href",
    "type",
    "disabled",
    "children"
  ]);
  var f = {
    get class() {
      return r();
    },
    set class(h) {
      r(h), m();
    },
    get variant() {
      return n();
    },
    set variant(h = "default") {
      n(h), m();
    },
    get size() {
      return s();
    },
    set size(h = "default") {
      s(h), m();
    },
    get ref() {
      return o();
    },
    set ref(h = null) {
      o(h), m();
    },
    get href() {
      return i();
    },
    set href(h = void 0) {
      i(h), m();
    },
    get type() {
      return a();
    },
    set type(h = "button") {
      a(h), m();
    },
    get disabled() {
      return l();
    },
    set disabled(h) {
      l(h), m();
    },
    get children() {
      return u();
    },
    set children(h) {
      u(h), m();
    }
  }, g = M(), _ = D(g);
  {
    var b = (h) => {
      var y = i5();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          href: l() ? void 0 : i(),
          "aria-disabled": l(),
          role: l() ? "link" : void 0,
          tabindex: l() ? -1 : void 0,
          ...c
        }),
        [
          () => Cl(sd({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), Qe(y, (x) => o(x), () => o()), A(h, y);
    }, p = (h) => {
      var y = a5();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          type: a(),
          disabled: l(),
          ...c
        }),
        [
          () => Cl(sd({ variant: n(), size: s() }), r())
        ]
      );
      var S = ge(y);
      te(S, () => u() ?? he), de(y), Qe(y, (x) => o(x), () => o()), A(h, y);
    };
    ue(_, (h) => {
      i() ? h(b) : h(p, !1);
    });
  }
  return A(t, g), H(f);
}
K(
  l5,
  {
    class: {},
    variant: {},
    size: {},
    ref: {},
    href: {},
    type: {},
    disabled: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var u5 = /* @__PURE__ */ ne("<!> ", 1), c5 = /* @__PURE__ */ ne("<!> <!>", 1);
function ug(t, e) {
  W(e, !0);
  const r = Ee(), n = ut();
  let s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "handlers", 7);
  const a = /* @__PURE__ */ O(() => i().oninput), l = /* @__PURE__ */ O(() => i().onchange), u = /* @__PURE__ */ O(() => Nn(i(), ["oninput", "onchange"])), c = /* @__PURE__ */ O(() => n.components), f = /* @__PURE__ */ O(() => d(c).Popover), g = /* @__PURE__ */ O(() => d(c).PopoverTrigger), _ = /* @__PURE__ */ O(() => d(c).PopoverContent), b = /* @__PURE__ */ O(() => d(c).RangeCalendar), p = /* @__PURE__ */ O(() => pr(r, o(), "shadcn4DateRangePicker", {
    numberOfMonths: 2,
    onValueChange: () => {
      d(a)?.(), d(l)?.();
    }
  })), h = /* @__PURE__ */ O(() => {
    const w = Nt(r, o(), "shadcn4DateRangeFormatter");
    if (w !== void 0)
      return w;
    const C = Nt(r, o(), "shadcn4DateRangePickerPlaceholder"), k = new jt("en-US", { dateStyle: "medium" });
    return ({ start: $, end: T }) => $ && T ? `${k.format($.toDate(ft()))} - ${k.format(T.toDate(ft()))}` : $ ? k.format($.toDate(ft())) : C;
  }), y = /* @__PURE__ */ O(() => ({
    start: typeof s()?.start == "string" ? Si(s().start) : void 0,
    end: typeof s()?.end == "string" ? Si(s().end) : void 0
  }));
  var S = {
    get value() {
      return s();
    },
    set value(w) {
      s(w), m();
    },
    get config() {
      return o();
    },
    set config(w) {
      o(w), m();
    },
    get handlers() {
      return i();
    },
    set handlers(w) {
      i(w), m();
    }
  }, x = M(), P = D(x);
  return Q(P, () => d(f), (w, C) => {
    C(w, {
      children: (k, $) => {
        var T = c5(), E = D(T);
        {
          let F = /* @__PURE__ */ O(() => Cl(
            sd({
              variant: "outline",
              class: "justify-start text-start font-normal"
            }),
            !s() && "text-muted-foreground"
          ));
          Q(E, () => d(g), (U, B) => {
            B(U, ce(() => d(u), {
              get class() {
                return d(F);
              },
              children: (R, Z) => {
                var Y = u5(), X = D(Y);
                w1(X, { class: "me-2 size-4" });
                var ae = be(X);
                ke((J) => Ie(ae, ` ${J ?? ""}`), [() => d(h)(d(y))]), A(R, Y);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var I = be(E, 2);
        Q(I, () => d(_), (F, U) => {
          U(F, {
            class: "w-auto p-0",
            align: "start",
            children: (B, R) => {
              var Z = M(), Y = D(Z), X = () => d(y), ae = (J) => {
                const j = ft();
                s({
                  start: J?.start?.toDate(j).toLocaleDateString("en-CA"),
                  end: J?.end?.toDate(j).toLocaleDateString("en-CA")
                });
              };
              Q(Y, () => d(b), (J, j) => {
                j(J, ce(() => d(p), {
                  get value() {
                    return X();
                  },
                  set value(ee) {
                    ae(ee);
                  }
                }));
              }), A(B, Z);
            },
            $$slots: { default: !0 }
          });
        }), A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), H(S);
}
K(ug, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.dateRangePickerWidget = ug;
nr.shadcn4DateRangePickerWidget = ug;
var d5 = /* @__PURE__ */ ne("<input/>");
function f5(t, e) {
  W(e, !0);
  let r = v(e, "handlers", 7), n = v(e, "multiple", 7), s = v(e, "loading", 7), o = v(e, "processing", 7), i = v(e, "config", 7), a = v(e, "value", 15);
  const l = Ee(), u = /* @__PURE__ */ O(() => Ni(l, i(), "file", r(), {
    multiple: n(),
    class: "sjsf-file",
    "data-loading": s(),
    "data-processing": o()
  }));
  var c = {
    get handlers() {
      return r();
    },
    set handlers(g) {
      r(g), m();
    },
    get multiple() {
      return n();
    },
    set multiple(g) {
      n(g), m();
    },
    get loading() {
      return s();
    },
    set loading(g) {
      s(g), m();
    },
    get processing() {
      return o();
    },
    set processing(g) {
      o(g), m();
    },
    get config() {
      return i();
    },
    set config(g) {
      i(g), m();
    },
    get value() {
      return a();
    },
    set value(g) {
      a(g), m();
    }
  }, f = d5();
  return ve(f, () => ({ type: "file", ...d(u) }), void 0, void 0, void 0, void 0, !0), uy(f, a), A(t, f), H(c);
}
K(
  f5,
  {
    handlers: {},
    multiple: {},
    loading: {},
    processing: {},
    config: {},
    value: {}
  },
  [],
  [],
  { mode: "open" }
);
function bx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Input);
  let i = v(e, "config", 7), a = v(e, "handlers", 7), l = v(e, "multiple", 7), u = v(e, "loading", 7), c = v(e, "processing", 7), f = v(e, "value", 15);
  var g = {
    get config() {
      return i();
    },
    set config(p) {
      i(p), m();
    },
    get handlers() {
      return a();
    },
    set handlers(p) {
      a(p), m();
    },
    get multiple() {
      return l();
    },
    set multiple(p) {
      l(p), m();
    },
    get loading() {
      return u();
    },
    set loading(p) {
      u(p), m();
    },
    get processing() {
      return c();
    },
    set processing(p) {
      c(p), m();
    },
    get value() {
      return f();
    },
    set value(p) {
      f(p), m();
    }
  }, _ = M(), b = D(_);
  {
    let p = /* @__PURE__ */ O(() => Ni(r, i(), "file", a(), { multiple: l() }));
    Q(b, () => d(o), (h, y) => {
      y(h, ce(() => d(p), {
        type: "file",
        get "data-loading"() {
          return u();
        },
        get "data-processing"() {
          return c();
        },
        get files() {
          return f();
        },
        set files(S) {
          f(S);
        }
      }));
    });
  }
  return A(t, _), H(g);
}
K(
  bx,
  {
    config: {},
    handlers: {},
    multiple: {},
    loading: {},
    processing: {},
    value: {}
  },
  [],
  [],
  { mode: "open" }
);
nr.fileWidget = bx;
var h5 = /* @__PURE__ */ ne("<span> </span>"), g5 = /* @__PURE__ */ ne("<!> <!>", 1);
function _x(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Select), i = /* @__PURE__ */ O(() => d(s).SelectTrigger), a = /* @__PURE__ */ O(() => d(s).SelectContent), l = /* @__PURE__ */ O(() => d(s).SelectItem);
  let u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7), g = v(e, "config", 7);
  const _ = /* @__PURE__ */ O(() => new Map(f().map(($) => [$.id, $.label]))), b = m1({
    mapper: () => Lo(f()),
    value: () => c(),
    update: ($) => c($)
  }), p = /* @__PURE__ */ O(() => u().oninput), h = /* @__PURE__ */ O(() => u().onchange), y = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), S = /* @__PURE__ */ O(() => pr(r, g(), "shadcn4MultiSelect", {
    onValueChange: () => {
      d(p)?.(), d(h)?.();
    },
    required: g().required
  })), x = /* @__PURE__ */ O(() => b.current.map(($) => d(_).get($)).join(", ") || d(S).placeholder), P = /* @__PURE__ */ O(() => mr(r, g().path));
  var w = {
    get handlers() {
      return u();
    },
    set handlers($) {
      u($), m();
    },
    get value() {
      return c();
    },
    set value($) {
      c($), m();
    },
    get options() {
      return f();
    },
    set options($) {
      f($), m();
    },
    get config() {
      return g();
    },
    set config($) {
      g($), m();
    }
  }, C = M(), k = D(C);
  return Q(k, () => d(o), ($, T) => {
    T($, ce(() => d(S), {
      type: "multiple",
      get value() {
        return b.current;
      },
      set value(E) {
        b.current = E;
      },
      children: (E, I) => {
        var F = g5(), U = D(F);
        {
          let R = /* @__PURE__ */ O(() => pr(r, g(), "shadcn4MultiSelectTrigger", cn(d(y))({ id: d(P), name: d(P) })));
          Q(U, () => d(i), (Z, Y) => {
            Y(Z, ce({ class: "w-full" }, () => d(R), {
              children: (X, ae) => {
                var J = h5(), j = ge(J, !0);
                de(J), ke(() => Ie(j, d(x))), A(X, J);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var B = be(U, 2);
        Q(B, () => d(a), (R, Z) => {
          Z(R, {
            children: (Y, X) => {
              var ae = M(), J = D(ae);
              nt(J, 17, f, (j) => j.id, (j, ee) => {
                var L = M(), N = D(L);
                Q(N, () => d(l), (V, G) => {
                  G(V, {
                    get value() {
                      return d(ee).id;
                    },
                    get label() {
                      return d(ee).label;
                    },
                    get disabled() {
                      return d(ee).disabled;
                    }
                  });
                }), A(j, L);
              }), A(Y, ae);
            },
            $$slots: { default: !0 }
          });
        }), A(E, F);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, C), H(w);
}
K(_x, { handlers: {}, value: {}, options: {}, config: {} }, [], [], { mode: "open" });
nr.multiSelectWidget = _x;
function wx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).ToggleGroup), i = /* @__PURE__ */ O(() => d(s).ToggleGroupItem);
  let a = v(e, "value", 15), l = v(e, "config", 7), u = v(e, "handlers", 7), c = v(e, "options", 7);
  const f = vu({
    mapper: () => Lo(c()),
    value: () => a(),
    update: (x) => a(x)
  }), g = /* @__PURE__ */ O(() => u().oninput), _ = /* @__PURE__ */ O(() => u().onchange), b = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), p = /* @__PURE__ */ O(() => pr(r, l(), "shadcn4RadioButtons", {
    type: "single",
    id: mr(r, l().path),
    variant: "outline",
    onValueChange: () => {
      d(g)?.(), d(_)?.();
    }
  }));
  var h = {
    get value() {
      return a();
    },
    set value(x) {
      a(x), m();
    },
    get config() {
      return l();
    },
    set config(x) {
      l(x), m();
    },
    get handlers() {
      return u();
    },
    set handlers(x) {
      u(x), m();
    },
    get options() {
      return c();
    },
    set options(x) {
      c(x), m();
    }
  }, y = M(), S = D(y);
  return Q(S, () => d(o), (x, P) => {
    P(x, ce(() => d(p), {
      get value() {
        return f.current;
      },
      set value(w) {
        f.current = w;
      },
      children: (w, C) => {
        var k = M(), $ = D(k);
        nt($, 17, c, (T) => T.id, (T, E) => {
          var I = M(), F = D(I);
          {
            let U = /* @__PURE__ */ O(() => Ft(r, l(), { value: d(E).id }, wt("shadcn4RadioButtonsItem"), cn(d(b)), Hs));
            Q(F, () => d(i), (B, R) => {
              R(B, ce(() => d(U), {
                children: (Z, Y) => {
                  St();
                  var X = st();
                  ke(() => Ie(X, d(E).label)), A(Z, X);
                },
                $$slots: { default: !0 }
              }));
            });
          }
          A(T, I);
        }), A(w, k);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, y), H(h);
}
K(wx, { value: {}, config: {}, handlers: {}, options: {} }, [], [], { mode: "open" });
nr.radioButtonsWidget = wx;
var p5 = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function Sx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).RadioGroup), i = /* @__PURE__ */ O(() => d(s).RadioGroupItem), a = /* @__PURE__ */ O(() => d(s).FieldLabel);
  let l = v(e, "config", 7), u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7);
  const g = vu({
    mapper: () => Lo(f()),
    value: () => c(),
    update: (S) => c(S)
  }), _ = /* @__PURE__ */ O(() => pr(r, l(), "shadcn4RadioGroup", { onValueChange: u().onchange })), b = /* @__PURE__ */ O(() => Ft(r, l(), { onclick: u().oninput, onblur: u().onblur }, wt("shadcn4RadioItem"), Hs));
  var p = {
    get config() {
      return l();
    },
    set config(S) {
      l(S), m();
    },
    get handlers() {
      return u();
    },
    set handlers(S) {
      u(S), m();
    },
    get value() {
      return c();
    },
    set value(S) {
      c(S), m();
    },
    get options() {
      return f();
    },
    set options(S) {
      f(S), m();
    }
  }, h = M(), y = D(h);
  return Q(y, () => d(o), (S, x) => {
    x(S, ce(() => d(_), {
      get value() {
        return g.current;
      },
      set value(P) {
        g.current = P;
      },
      children: (P, w) => {
        var C = M(), k = D(C);
        nt(k, 17, f, ($) => $.id, ($, T) => {
          var E = p5(), I = ge(E);
          Q(I, () => d(i), (U, B) => {
            B(U, ce(() => d(b), {
              get value() {
                return d(T).id;
              },
              get id() {
                return d(T).id;
              },
              get disabled() {
                return d(T).disabled;
              }
            }));
          });
          var F = be(I, 2);
          Q(F, () => d(a), (U, B) => {
            B(U, {
              get for() {
                return d(T).id;
              },
              children: (R, Z) => {
                St();
                var Y = st();
                ke(() => Ie(Y, d(T).label)), A(R, Y);
              },
              $$slots: { default: !0 }
            });
          }), de(E), A($, E);
        }), A(P, C);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, h), H(p);
}
K(Sx, { config: {}, handlers: {}, value: {}, options: {} }, [], [], { mode: "open" });
nr.radioWidget = Sx;
function xx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Slider);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ O(() => mr(r, a().path));
  var c = {
    get value() {
      return i();
    },
    set value(p) {
      i(p), m();
    },
    get config() {
      return a();
    },
    set config(p) {
      a(p), m();
    },
    get handlers() {
      return l();
    },
    set handlers(p) {
      l(p), m();
    }
  }, f = M(), g = D(f), _ = () => i() ?? 0, b = (p) => i(p);
  {
    let p = /* @__PURE__ */ O(() => pr(r, a(), "shadcn4Range", {
      id: d(u),
      min: a().schema.minimum,
      max: a().schema.maximum,
      step: a().schema.multipleOf,
      onValueChange: l().oninput,
      onValueCommit: l().onchange
    }));
    Q(g, () => d(o), (h, y) => {
      y(h, ce(
        {
          get value() {
            return _();
          },
          set value(S) {
            b(S);
          }
        },
        () => d(p),
        { type: "single" }
      ));
    });
  }
  return A(t, f), H(c);
}
K(xx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.rangeWidget = xx;
function Px(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "handlers", 7);
  const o = Ee(), i = ut(), a = /* @__PURE__ */ O(() => i.components), l = /* @__PURE__ */ O(() => d(a).Slider), u = /* @__PURE__ */ O(() => mr(o, n().path));
  var c = {
    get value() {
      return r();
    },
    set value(p) {
      r(p), m();
    },
    get config() {
      return n();
    },
    set config(p) {
      n(p), m();
    },
    get handlers() {
      return s();
    },
    set handlers(p) {
      s(p), m();
    }
  }, f = M(), g = D(f), _ = () => [r()?.start ?? 0, r()?.end ?? 0], b = (p) => {
    r({ start: p[0], end: p[1] });
  };
  {
    let p = /* @__PURE__ */ O(() => pr(o, n(), "shadcn4RangeSlider", {
      id: d(u),
      min: n().schema.minimum,
      max: n().schema.maximum,
      step: n().schema.multipleOf,
      onValueChange: s().oninput,
      onValueCommit: s().onchange
    }));
    Q(g, () => d(l), (h, y) => {
      y(h, ce(
        {
          get value() {
            return _();
          },
          set value(S) {
            b(S);
          }
        },
        () => d(p),
        { type: "multiple" }
      ));
    });
  }
  return A(t, f), H(c);
}
K(Px, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.rangeSliderWidget = Px;
var m5 = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function Ox(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Switch), i = /* @__PURE__ */ O(() => d(s).FieldLabel);
  let a = v(e, "value", 15), l = v(e, "config", 7), u = v(e, "handlers", 7);
  const c = /* @__PURE__ */ O(() => u().oninput), f = /* @__PURE__ */ O(() => u().onchange), g = /* @__PURE__ */ O(() => Nn(u(), ["oninput", "onchange"])), _ = /* @__PURE__ */ O(() => mr(r, l().path));
  var b = {
    get value() {
      return a();
    },
    set value(P) {
      a(P), m();
    },
    get config() {
      return l();
    },
    set config(P) {
      l(P), m();
    },
    get handlers() {
      return u();
    },
    set handlers(P) {
      u(P), m();
    }
  }, p = m5(), h = ge(p), y = () => a() ?? !1, S = (P) => a(P);
  {
    let P = /* @__PURE__ */ O(() => pr(r, l(), "shadcn4Switch", cn(d(g))({
      id: d(_),
      name: d(_),
      required: l().required,
      onCheckedChange: () => {
        d(c)?.(), d(f)?.();
      }
    })));
    Q(h, () => d(o), (w, C) => {
      C(w, ce(
        {
          get checked() {
            return y();
          },
          set checked(k) {
            S(k);
          }
        },
        () => d(P)
      ));
    });
  }
  var x = be(h, 2);
  return Q(x, () => d(i), (P, w) => {
    w(P, {
      get for() {
        return d(_);
      },
      children: (C, k) => {
        St();
        var $ = st();
        ke(() => Ie($, l().title)), A(C, $);
      },
      $$slots: { default: !0 }
    });
  }), de(p), A(t, p), H(b);
}
K(Ox, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.switchWidget = Ox;
var v5 = /* @__PURE__ */ ne("<textarea></textarea>");
function y5(t, e) {
  W(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "handlers", 7);
  const o = Ee(), i = /* @__PURE__ */ O(() => hb(o, n(), "textarea", s(), { class: "sjsf-textarea" }));
  var a = {
    get value() {
      return r();
    },
    set value(u) {
      r(u), m();
    },
    get config() {
      return n();
    },
    set config(u) {
      n(u), m();
    },
    get handlers() {
      return s();
    },
    set handlers(u) {
      s(u), m();
    }
  }, l = v5();
  return Tv(l), ve(l, () => ({ ...d(i) })), Di(l, r), A(t, l), H(a);
}
K(y5, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
function Cx(t, e) {
  W(e, !0);
  const r = Ee(), n = ut(), s = /* @__PURE__ */ O(() => n.components), o = /* @__PURE__ */ O(() => d(s).Textarea);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  var u = {
    get value() {
      return i();
    },
    set value(g) {
      i(g), m();
    },
    get config() {
      return a();
    },
    set config(g) {
      a(g), m();
    },
    get handlers() {
      return l();
    },
    set handlers(g) {
      l(g), m();
    }
  }, c = M(), f = D(c);
  {
    let g = /* @__PURE__ */ O(() => hb(r, a(), "textarea", l(), {}));
    Q(f, () => d(o), (_, b) => {
      b(_, ce(() => d(g), {
        get value() {
          return i();
        },
        set value(p) {
          i(p);
        }
      }));
    });
  }
  return A(t, c), H(u);
}
K(Cx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
nr.textareaWidget = Cx;
function b5() {
  pI({
    components: {
      ButtonGroup: G1,
      Field: OS,
      FieldLabel: ES,
      FieldError: MS,
      FieldDescription: DS,
      FieldGroup: $S,
      FieldLegend: kS,
      FieldTitle: TS,
      FieldSet: CS,
      Button: Y1,
      Checkbox: fS,
      Input: IS,
      Select: nx,
      SelectContent: lx,
      SelectItem: sx,
      SelectTrigger: ux,
      Textarea: fx,
      RadioGroup: LS,
      RadioGroupItem: jS,
      // @ts-expect-error - Can be safely ignored
      Command: lg,
      CommandEmpty: _S,
      CommandGroup: wS,
      CommandInput: xS,
      CommandItem: SS,
      CommandList: PS,
      Calendar: X1,
      ToggleGroup: gx,
      ToggleGroupItem: px,
      Slider: cx,
      Switch: dx,
      Popover: NS,
      PopoverContent: RS,
      PopoverTrigger: VS,
      RangeCalendar: BS
    }
  });
}
const _5 = nb(UI, {
  formataQrField: D1
});
function w5(t, e) {
  return vb({
    resolver: aI,
    theme: _5,
    icons: fN,
    idBuilder: cM,
    validator: sM,
    merger: fM,
    translation: pM,
    schema: t.schema,
    uiSchema: t.uiSchema,
    onSubmitError: lM(),
    onSubmit: (r) => {
      e().dispatchEvent(
        new CustomEvent("submit", {
          bubbles: !0,
          composed: !0,
          cancelable: !0,
          detail: vM.serialize(r)
        })
      );
    }
  });
}
const S5 = "@layer properties{:host{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-pan-x:initial;--tw-pan-y:initial;--tw-pinch-zoom:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-divide-x-reverse:0;--tw-border-style:solid;--tw-divide-y-reverse:0;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-pan-x:initial;--tw-pan-y:initial;--tw-pinch-zoom:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-divide-x-reverse:0;--tw-border-style:solid;--tw-divide-y-reverse:0;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;--color-slate-50:oklch(98.4% .003 247.858);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-lg:32rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--tracking-widest:.1em;--leading-snug:1.375;--leading-normal:1.5;--radius-xs:.125rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{border-color:var(--border);outline-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){*{outline-color:color-mix(in oklab,var(--ring)50%,transparent)}}body{background-color:var(--background);color:var(--foreground)}}@layer components;@layer utilities{.\\@container\\/field-group{container:field-group/inline-size}.\\@container{container-type:inline-size}.pointer-events-none{pointer-events:none}.collapse{visibility:collapse}.invisible{visibility:hidden}.visible{visibility:visible}.sr-only{clip-path:inset(50%);white-space:nowrap;border-width:0;width:1px;height:1px;margin:-1px;padding:0;position:absolute;overflow:hidden}.not-sr-only{clip-path:none;white-space:normal;width:auto;height:auto;margin:0;padding:0;position:static;overflow:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.inset-0{inset:calc(var(--spacing)*0)}.inset-x-0{inset-inline:calc(var(--spacing)*0)}.start-1{inset-inline-start:calc(var(--spacing)*1)}.start-1\\/2{inset-inline-start:50%}.end-2{inset-inline-end:calc(var(--spacing)*2)}.end-4{inset-inline-end:calc(var(--spacing)*4)}.top-0{top:calc(var(--spacing)*0)}.top-1{top:calc(var(--spacing)*1)}.top-1\\/2{top:50%}.top-4{top:calc(var(--spacing)*4)}.top-\\[50\\%\\]{top:50%}.right-2{right:calc(var(--spacing)*2)}.left-1{left:calc(var(--spacing)*1)}.left-\\[50\\%\\]{left:50%}.isolate{isolation:isolate}.isolation-auto{isolation:auto}.z-50{z-index:50}.container{width:100%}@media(min-width:40rem){.container{max-width:40rem}}@media(min-width:48rem){.container{max-width:48rem}}@media(min-width:64rem){.container{max-width:64rem}}@media(min-width:80rem){.container{max-width:80rem}}@media(min-width:96rem){.container{max-width:96rem}}.\\!m-0{margin:calc(var(--spacing)*0)!important}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.mx-auto{margin-inline:auto}.-my-2{margin-block:calc(var(--spacing)*-2)}.my-1{margin-block:calc(var(--spacing)*1)}.ms-4{margin-inline-start:calc(var(--spacing)*4)}.ms-auto{margin-inline-start:auto}.me-2{margin-inline-end:calc(var(--spacing)*2)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-4{margin-top:calc(var(--spacing)*4)}.mr-2{margin-right:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.ml-2{margin-left:calc(var(--spacing)*2)}.ml-4{margin-left:calc(var(--spacing)*4)}.ml-auto{margin-left:auto}.block{display:block}.contents{display:contents}.flex{display:flex}.flow-root{display:flow-root}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.inline-grid{display:inline-grid}.inline-table{display:inline-table}.list-item{display:list-item}.table{display:table}.table-caption{display:table-caption}.table-cell{display:table-cell}.table-column{display:table-column}.table-column-group{display:table-column-group}.table-footer-group{display:table-footer-group}.table-header-group{display:table-header-group}.table-row{display:table-row}.table-row-group{display:table-row-group}.field-sizing-content{field-sizing:content}.aspect-square{aspect-ratio:1}.size-\\(--cell-size\\){width:var(--cell-size);height:var(--cell-size)}.size-2{width:calc(var(--spacing)*2);height:calc(var(--spacing)*2)}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-3\\.5{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-9{width:calc(var(--spacing)*9);height:calc(var(--spacing)*9)}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.size-48{width:calc(var(--spacing)*48);height:calc(var(--spacing)*48)}.h-\\(--bits-select-anchor-height\\){height:var(--bits-select-anchor-height)}.h-\\(--cell-size\\){height:var(--cell-size)}.h-5{height:calc(var(--spacing)*5)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-\\[1\\.15rem\\]{height:1.15rem}.h-full{height:100%}.h-px{height:1px}.max-h-\\(--bits-select-content-available-height\\){max-height:var(--bits-select-content-available-height)}.max-h-\\[300px\\]{max-height:300px}.min-h-5{min-height:calc(var(--spacing)*5)}.min-h-16{min-height:calc(var(--spacing)*16)}.w-\\(--cell-size\\){width:var(--cell-size)}.w-8{width:calc(var(--spacing)*8)}.w-72{width:calc(var(--spacing)*72)}.w-\\[200px\\]{width:200px}.w-auto{width:auto}.w-fit{width:fit-content}.w-full{width:100%}.max-w-\\[calc\\(100\\%-2rem\\)\\]{max-width:calc(100% - 2rem)}.min-w-\\(--bits-select-anchor-width\\){min-width:var(--bits-select-anchor-width)}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-8{min-width:calc(var(--spacing)*8)}.min-w-9{min-width:calc(var(--spacing)*9)}.min-w-10{min-width:calc(var(--spacing)*10)}.min-w-\\[8rem\\]{min-width:8rem}.flex-1{flex:1}.shrink{flex-shrink:1}.shrink-0{flex-shrink:0}.grow{flex-grow:1}.border-collapse{border-collapse:collapse}.origin-\\(--bits-popover-content-transform-origin\\){transform-origin:var(--bits-popover-content-transform-origin)}.origin-\\(--bits-select-content-transform-origin\\){transform-origin:var(--bits-select-content-transform-origin)}.-translate-x-1{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-x-\\[-50\\%\\]{--tw-translate-x:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-\\[-50\\%\\]{--tw-translate-y:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-none{translate:none}.scale-3d{scale:var(--tw-scale-x)var(--tw-scale-y)var(--tw-scale-z)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-default{cursor:default}.touch-pinch-zoom{--tw-pinch-zoom:pinch-zoom;touch-action:var(--tw-pan-x,)var(--tw-pan-y,)var(--tw-pinch-zoom,)}.touch-none{touch-action:none}.resize{resize:both}.scroll-my-1{scroll-margin-block:calc(var(--spacing)*1)}.scroll-py-1{scroll-padding-block:calc(var(--spacing)*1)}.list-disc{list-style-type:disc}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-rows-\\[1fr\\]{grid-template-rows:1fr}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-start{justify-content:flex-start}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-6{gap:calc(var(--spacing)*6)}.gap-7{gap:calc(var(--spacing)*7)}.gap-\\[--spacing\\(var\\(--gap\\)\\)\\]{gap:calc(var(--spacing)*var(--gap))}:where(.space-y-reverse>:not(:last-child)){--tw-space-y-reverse:1}.gap-x-1{column-gap:calc(var(--spacing)*1)}.gap-x-1\\.5{column-gap:calc(var(--spacing)*1.5)}:where(.space-x-3>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*3)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-x-reverse)))}:where(.space-x-reverse>:not(:last-child)){--tw-space-x-reverse:1}:where(.divide-x>:not(:last-child)){--tw-divide-x-reverse:0;border-inline-style:var(--tw-border-style);border-inline-start-width:calc(1px*var(--tw-divide-x-reverse));border-inline-end-width:calc(1px*calc(1 - var(--tw-divide-x-reverse)))}:where(.divide-y>:not(:last-child)){--tw-divide-y-reverse:0;border-bottom-style:var(--tw-border-style);border-top-style:var(--tw-border-style);border-top-width:calc(1px*var(--tw-divide-y-reverse));border-bottom-width:calc(1px*calc(1 - var(--tw-divide-y-reverse)))}:where(.divide-y-reverse>:not(:last-child)){--tw-divide-y-reverse:1}.self-stretch{align-self:stretch}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:.25rem}.rounded-\\[4px\\]{border-radius:4px}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-none{border-radius:0}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xs{border-radius:var(--radius-xs)}.rounded-s{border-start-start-radius:.25rem;border-end-start-radius:.25rem}.rounded-ss{border-start-start-radius:.25rem}.rounded-e{border-start-end-radius:.25rem;border-end-end-radius:.25rem}.rounded-se{border-start-end-radius:.25rem}.rounded-ee{border-end-end-radius:.25rem}.rounded-es{border-end-start-radius:.25rem}.rounded-t{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.rounded-l{border-top-left-radius:.25rem;border-bottom-left-radius:.25rem}.rounded-tl{border-top-left-radius:.25rem}.rounded-r{border-top-right-radius:.25rem;border-bottom-right-radius:.25rem}.rounded-tr{border-top-right-radius:.25rem}.rounded-b{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.rounded-br{border-bottom-right-radius:.25rem}.rounded-bl{border-bottom-left-radius:.25rem}.border{border-style:var(--tw-border-style);border-width:1px}.border-x{border-inline-style:var(--tw-border-style);border-inline-width:1px}.border-y{border-block-style:var(--tw-border-style);border-block-width:1px}.border-s{border-inline-start-style:var(--tw-border-style);border-inline-start-width:1px}.border-e{border-inline-end-style:var(--tw-border-style);border-inline-end-width:1px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-r{border-right-style:var(--tw-border-style);border-right-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-l{border-left-style:var(--tw-border-style);border-left-width:1px}.border-input{border-color:var(--input)}.border-primary{border-color:var(--primary)}.border-transparent{border-color:#0000}.bg-background{background-color:var(--background)}.bg-black{background-color:var(--color-black)}.bg-black\\/50{background-color:#00000080}@supports (color:color-mix(in lab,red,red)){.bg-black\\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-border{background-color:var(--border)}.bg-destructive{background-color:var(--destructive)}.bg-input{background-color:var(--input)}.bg-muted{background-color:var(--muted)}.bg-popover{background-color:var(--popover)}.bg-primary{background-color:var(--primary)}.bg-secondary{background-color:var(--secondary)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.bg-repeat{background-repeat:repeat}.mask-no-clip{-webkit-mask-clip:no-clip;mask-clip:no-clip}.mask-repeat{-webkit-mask-repeat:repeat;mask-repeat:repeat}.fill-primary{fill:var(--primary)}.object-contain{object-fit:contain}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.px-\\(--cell-size\\){padding-inline:var(--cell-size)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-6{padding-inline:calc(var(--spacing)*6)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-6{padding-block:calc(var(--spacing)*6)}.ps-2{padding-inline-start:calc(var(--spacing)*2)}.ps-3{padding-inline-start:calc(var(--spacing)*3)}.pe-1{padding-inline-end:calc(var(--spacing)*1)}.pe-8{padding-inline-end:calc(var(--spacing)*8)}.pt-1{padding-top:calc(var(--spacing)*1)}.pt-1\\.5{padding-top:calc(var(--spacing)*1.5)}.pr-1{padding-right:calc(var(--spacing)*1)}.pr-8{padding-right:calc(var(--spacing)*8)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.text-center{text-align:center}.text-start{text-align:start}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[0\\.8rem\\]{font-size:.8rem}.leading-none{--tw-leading:1;line-height:1}.leading-normal{--tw-leading:var(--leading-normal);line-height:var(--leading-normal)}.leading-snug{--tw-leading:var(--leading-snug);line-height:var(--leading-snug)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-widest{--tw-tracking:var(--tracking-widest);letter-spacing:var(--tracking-widest)}.text-wrap{text-wrap:wrap}.text-clip{text-overflow:clip}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.text-current{color:currentColor}.text-destructive{color:var(--destructive)}.text-foreground{color:var(--foreground)}.text-muted-foreground{color:var(--muted-foreground)}.text-popover-foreground{color:var(--popover-foreground)}.text-primary{color:var(--primary)}.text-primary-foreground{color:var(--primary-foreground)}.text-secondary-foreground{color:var(--secondary-foreground)}.text-transparent{color:#0000}.text-white{color:var(--color-white)}.capitalize{text-transform:capitalize}.lowercase{text-transform:lowercase}.normal-case{text-transform:none}.uppercase{text-transform:uppercase}.italic{font-style:italic}.not-italic{font-style:normal}.diagonal-fractions{--tw-numeric-fraction:diagonal-fractions;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.lining-nums{--tw-numeric-figure:lining-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.oldstyle-nums{--tw-numeric-figure:oldstyle-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.ordinal{--tw-ordinal:ordinal;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.proportional-nums{--tw-numeric-spacing:proportional-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.slashed-zero{--tw-slashed-zero:slashed-zero;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.stacked-fractions{--tw-numeric-fraction:stacked-fractions;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.tabular-nums{--tw-numeric-spacing:tabular-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.normal-nums{font-variant-numeric:normal}.line-through{text-decoration-line:line-through}.no-underline{text-decoration-line:none}.overline{text-decoration-line:overline}.underline{text-decoration-line:underline}.underline-offset-4{text-underline-offset:4px}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.subpixel-antialiased{-webkit-font-smoothing:auto;-moz-osx-font-smoothing:auto}.opacity-0{opacity:0}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-none{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-0{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(0px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.inset-ring{--tw-inset-ring-shadow:inset 0 0 0 1px var(--tw-inset-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-ring,.ring-ring\\/50{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.ring-ring\\/50{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.ring-offset-background{--tw-ring-offset-color:var(--background)}.outline-hidden{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.outline-hidden{outline-offset:2px;outline:2px solid #0000}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow{--tw-drop-shadow-size:drop-shadow(0 1px 2px var(--tw-drop-shadow-color,#0000001a))drop-shadow(0 1px 1px var(--tw-drop-shadow-color,#0000000f));--tw-drop-shadow:drop-shadow(0 1px 2px #0000001a)drop-shadow(0 1px 1px #0000000f);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.grayscale{--tw-grayscale:grayscale(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.sepia{--tw-sepia:sepia(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter\\!{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)!important}.backdrop-blur{--tw-backdrop-blur:blur(8px);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-grayscale{--tw-backdrop-grayscale:grayscale(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-invert{--tw-backdrop-invert:invert(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-sepia{--tw-backdrop-sepia:sepia(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-\\[color\\,box-shadow\\]{transition-property:color,box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-shadow{transition-property:box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-none{transition-property:none}.duration-200{--tw-duration:.2s;transition-duration:.2s}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.\\[--cell-size\\:--spacing\\(8\\)\\]{--cell-size:calc(var(--spacing)*8)}:where(.divide-x-reverse>:not(:last-child)){--tw-divide-x-reverse:1}.ring-inset{--tw-ring-inset:inset}.zoom-in{--tw-enter-scale:0}.zoom-out{--tw-exit-scale:0}.group-has-\\[\\[data-orientation\\=horizontal\\]\\]\\/field\\:text-balance:is(:where(.group\\/field):has([data-orientation=horizontal]) *){text-wrap:balance}.group-data-\\[disabled\\=true\\]\\:pointer-events-none:is(:where(.group)[data-disabled=true] *){pointer-events:none}.group-data-\\[disabled\\=true\\]\\:opacity-50:is(:where(.group)[data-disabled=true] *),.group-data-\\[disabled\\=true\\]\\/field\\:opacity-50:is(:where(.group\\/field)[data-disabled=true] *){opacity:.5}.group-data-\\[variant\\=outline\\]\\/field-group\\:-mb-2:is(:where(.group\\/field-group)[data-variant=outline] *){margin-bottom:calc(var(--spacing)*-2)}.peer-disabled\\:cursor-not-allowed:is(:where(.peer):disabled~*){cursor:not-allowed}.peer-disabled\\:opacity-50:is(:where(.peer):disabled~*){opacity:.5}.selection\\:bg-primary ::selection{background-color:var(--primary)}.selection\\:bg-primary::selection{background-color:var(--primary)}.selection\\:text-primary-foreground ::selection{color:var(--primary-foreground)}.selection\\:text-primary-foreground::selection{color:var(--primary-foreground)}.placeholder\\:text-muted-foreground::placeholder{color:var(--muted-foreground)}.last\\:mt-0:last-child{margin-top:calc(var(--spacing)*0)}.focus-within\\:z-20:focus-within{z-index:20}@media(hover:hover){.hover\\:bg-accent:hover{background-color:var(--accent)}.hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}.hover\\:bg-muted:hover{background-color:var(--muted)}.hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}.hover\\:bg-secondary\\/80:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-secondary\\/80:hover{background-color:color-mix(in oklab,var(--secondary)80%,transparent)}}.hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}.hover\\:text-muted-foreground:hover{color:var(--muted-foreground)}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}.hover\\:ring-4:hover{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}.focus\\:relative:focus{position:relative}.focus\\:z-10:focus{z-index:10}.focus\\:border-ring:focus{border-color:var(--ring)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-ring:focus,.focus\\:ring-ring\\/50:focus{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus\\:ring-ring\\/50:focus{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus\\:ring-offset-2:focus{--tw-ring-offset-width:2px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}.focus\\:outline-hidden:focus{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.focus\\:outline-hidden:focus{outline-offset:2px;outline:2px solid #0000}}.focus-visible\\:z-10:focus-visible{z-index:10}.focus-visible\\:border-ring:focus-visible{border-color:var(--ring)}.focus-visible\\:ring-4:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-\\[3px\\]:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus-visible\\:outline-hidden:focus-visible{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.focus-visible\\:outline-hidden:focus-visible{outline-offset:2px;outline:2px solid #0000}}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.has-focus\\:border-ring:has(:focus){border-color:var(--ring)}.has-focus\\:ring-\\[3px\\]:has(:focus){--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.has-focus\\:ring-ring\\/50:has(:focus){--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.has-focus\\:ring-ring\\/50:has(:focus){--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.has-data-\\[state\\=checked\\]\\:border-primary:has([data-state=checked]){border-color:var(--primary)}.has-data-\\[state\\=checked\\]\\:bg-primary\\/5:has([data-state=checked]){background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.has-data-\\[state\\=checked\\]\\:bg-primary\\/5:has([data-state=checked]){background-color:color-mix(in oklab,var(--primary)5%,transparent)}}.has-\\[\\>\\[data-slot\\=button-group\\]\\]\\:gap-2:has(>[data-slot=button-group]){gap:calc(var(--spacing)*2)}.has-\\[\\>\\[data-slot\\=checkbox-group\\]\\]\\:gap-3:has(>[data-slot=checkbox-group]){gap:calc(var(--spacing)*3)}.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:items-start:has(>[data-slot=field-content]){align-items:flex-start}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:w-full:has(>[data-slot=field]){width:100%}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:flex-col:has(>[data-slot=field]){flex-direction:column}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:rounded-md:has(>[data-slot=field]){border-radius:calc(var(--radius) - 2px)}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:border:has(>[data-slot=field]){border-style:var(--tw-border-style);border-width:1px}.has-\\[\\>\\[data-slot\\=radio-group\\]\\]\\:gap-3:has(>[data-slot=radio-group]){gap:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-2\\.5:has(>svg){padding-inline:calc(var(--spacing)*2.5)}.has-\\[\\>svg\\]\\:px-3:has(>svg){padding-inline:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-4:has(>svg){padding-inline:calc(var(--spacing)*4)}.aria-disabled\\:pointer-events-none[aria-disabled=true]{pointer-events:none}.aria-disabled\\:opacity-50[aria-disabled=true]{opacity:.5}.aria-invalid\\:border-destructive[aria-invalid=true]{border-color:var(--destructive)}.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.aria-selected\\:bg-accent[aria-selected=true]{background-color:var(--accent)}.aria-selected\\:text-accent-foreground[aria-selected=true]{color:var(--accent-foreground)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:text-muted-foreground[data-disabled]{color:var(--muted-foreground)}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[disabled\\=true\\]\\:pointer-events-none[data-disabled=true]{pointer-events:none}.data-\\[disabled\\=true\\]\\:opacity-50[data-disabled=true]{opacity:.5}.data-\\[highlighted\\]\\:bg-accent[data-highlighted]{background-color:var(--accent)}.data-\\[highlighted\\]\\:text-accent-foreground[data-highlighted]{color:var(--accent-foreground)}.data-\\[invalid\\=true\\]\\:text-destructive[data-invalid=true]{color:var(--destructive)}.data-\\[orientation\\=horizontal\\]\\:h-1\\.5[data-orientation=horizontal]{height:calc(var(--spacing)*1.5)}.data-\\[orientation\\=horizontal\\]\\:h-full[data-orientation=horizontal]{height:100%}.data-\\[orientation\\=horizontal\\]\\:h-px[data-orientation=horizontal]{height:1px}.data-\\[orientation\\=horizontal\\]\\:w-full[data-orientation=horizontal]{width:100%}.data-\\[orientation\\=vertical\\]\\:h-auto[data-orientation=vertical]{height:auto}.data-\\[orientation\\=vertical\\]\\:h-full[data-orientation=vertical]{height:100%}.data-\\[orientation\\=vertical\\]\\:min-h-44[data-orientation=vertical]{min-height:calc(var(--spacing)*44)}.data-\\[orientation\\=vertical\\]\\:min-h-full[data-orientation=vertical]{min-height:100%}.data-\\[orientation\\=vertical\\]\\:w-1\\.5[data-orientation=vertical]{width:calc(var(--spacing)*1.5)}.data-\\[orientation\\=vertical\\]\\:w-auto[data-orientation=vertical]{width:auto}.data-\\[orientation\\=vertical\\]\\:w-full[data-orientation=vertical]{width:100%}.data-\\[orientation\\=vertical\\]\\:w-px[data-orientation=vertical]{width:1px}.data-\\[orientation\\=vertical\\]\\:flex-col[data-orientation=vertical]{flex-direction:column}.data-\\[placeholder\\]\\:text-muted-foreground[data-placeholder]{color:var(--muted-foreground)}.data-\\[range-end\\]\\:bg-primary[data-range-end]{background-color:var(--primary)}.data-\\[range-end\\]\\:text-primary-foreground[data-range-end]{color:var(--primary-foreground)}.data-\\[range-middle\\]\\:rounded-none[data-range-middle]{border-radius:0}.data-\\[range-middle\\]\\:rounded-e-md[data-range-middle]{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.data-\\[range-start\\]\\:bg-primary[data-range-start]{background-color:var(--primary)}.data-\\[range-start\\]\\:text-primary-foreground[data-range-start]{color:var(--primary-foreground)}.data-\\[selected\\]\\:bg-primary[data-selected]{background-color:var(--primary)}.data-\\[selected\\]\\:text-primary-foreground[data-selected]{color:var(--primary-foreground)}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=left\\]\\:slide-in-from-end-2[data-side=left]:where(:dir(ltr),[dir=ltr]){--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=left\\]\\:slide-in-from-end-2[data-side=left]:where(:dir(rtl),[dir=rtl]){--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=right\\]\\:slide-in-from-start-2[data-side=right]:where(:dir(ltr),[dir=ltr]){--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=right\\]\\:slide-in-from-start-2[data-side=right]:where(:dir(rtl),[dir=rtl]){--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y:calc(2*var(--spacing))}.data-\\[size\\=default\\]\\:h-9[data-size=default]{height:calc(var(--spacing)*9)}.data-\\[size\\=sm\\]\\:h-8[data-size=sm]{height:calc(var(--spacing)*8)}.data-\\[slot\\=checkbox-group\\]\\:gap-3[data-slot=checkbox-group]{gap:calc(var(--spacing)*3)}:is(.\\*\\*\\:data-\\[slot\\=command-input-wrapper\\]\\:h-12 *)[data-slot=command-input-wrapper]{height:calc(var(--spacing)*12)}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:line-clamp-1>*)[data-slot=select-value]{-webkit-line-clamp:1;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:flex>*)[data-slot=select-value]{display:flex}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:items-center>*)[data-slot=select-value]{align-items:center}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:gap-2>*)[data-slot=select-value]{gap:calc(var(--spacing)*2)}.data-\\[spacing\\=0\\]\\:rounded-none[data-spacing=\"0\"]{border-radius:0}.data-\\[spacing\\=0\\]\\:shadow-none[data-spacing=\"0\"]{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.data-\\[spacing\\=0\\]\\:first\\:rounded-l-md[data-spacing=\"0\"]:first-child{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.data-\\[spacing\\=0\\]\\:last\\:rounded-r-md[data-spacing=\"0\"]:last-child{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.data-\\[state\\=checked\\]\\:translate-x-\\[calc\\(100\\%-2px\\)\\][data-state=checked]{--tw-translate-x: calc(100% - 2px) ;translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=checked\\]\\:border-primary[data-state=checked]{border-color:var(--primary)}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:var(--primary)}.data-\\[state\\=checked\\]\\:text-primary-foreground[data-state=checked]{color:var(--primary-foreground)}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity:0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale:.95}.data-\\[state\\=on\\]\\:bg-accent[data-state=on]{background-color:var(--accent)}.data-\\[state\\=on\\]\\:text-accent-foreground[data-state=on]{color:var(--accent-foreground)}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity:0}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale:.95}.data-\\[state\\=unchecked\\]\\:translate-x-0[data-state=unchecked]{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=unchecked\\]\\:bg-input[data-state=unchecked]{background-color:var(--input)}.data-\\[unavailable\\]\\:text-muted-foreground[data-unavailable]{color:var(--muted-foreground)}.data-\\[unavailable\\]\\:line-through[data-unavailable]{text-decoration-line:line-through}.data-\\[variant\\=label\\]\\:text-sm[data-variant=label]{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.data-\\[variant\\=legend\\]\\:text-base[data-variant=legend]{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.data-\\[spacing\\=0\\]\\:data-\\[variant\\=outline\\]\\:border-l-0[data-spacing=\"0\"][data-variant=outline]{border-left-style:var(--tw-border-style);border-left-width:0}.data-\\[spacing\\=0\\]\\:data-\\[variant\\=outline\\]\\:first\\:border-l[data-spacing=\"0\"][data-variant=outline]:first-child{border-left-style:var(--tw-border-style);border-left-width:1px}.data-\\[spacing\\=default\\]\\:data-\\[variant\\=outline\\]\\:shadow-xs[data-spacing=default][data-variant=outline]{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.nth-last-2\\:-mt-1:nth-last-child(2){margin-top:calc(var(--spacing)*-1)}@media(min-width:40rem){.sm\\:max-w-lg{max-width:var(--container-lg)}.sm\\:flex-row{flex-direction:row}.sm\\:justify-end{justify-content:flex-end}.sm\\:text-start{text-align:start}}@media(min-width:48rem){.md\\:flex-row{flex-direction:row}.md\\:text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}}@container field-group (min-width:28rem){.\\@md\\/field-group\\:flex-row{flex-direction:row}.\\@md\\/field-group\\:items-center{align-items:center}.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:items-start:has(>[data-slot=field-content]){align-items:flex-start}}.rtl\\:rotate-180:where(:dir(rtl),[dir=rtl],[dir=rtl] *){rotate:180deg}.dark\\:border-input:is(.dark *){border-color:var(--input)}.dark\\:bg-destructive\\/60:is(.dark *){background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-destructive\\/60:is(.dark *){background-color:color-mix(in oklab,var(--destructive)60%,transparent)}}.dark\\:bg-input\\/30:is(.dark *){background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-input\\/30:is(.dark *){background-color:color-mix(in oklab,var(--input)30%,transparent)}}.dark\\:bg-popover:is(.dark *){background-color:var(--popover)}.dark\\:text-popover-foreground:is(.dark *){color:var(--popover-foreground)}@media(hover:hover){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--input)50%,transparent)}}.dark\\:hover\\:text-accent-foreground:is(.dark *):hover{color:var(--accent-foreground)}}.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:has-data-\\[state\\=checked\\]\\:bg-primary\\/10:is(.dark *):has([data-state=checked]){background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.dark\\:has-data-\\[state\\=checked\\]\\:bg-primary\\/10:is(.dark *):has([data-state=checked]){background-color:color-mix(in oklab,var(--primary)10%,transparent)}}.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}@media(hover:hover){.dark\\:data-\\[range-end\\]\\:hover\\:bg-accent:is(.dark *)[data-range-end]:hover,.dark\\:data-\\[range-middle\\]\\:hover\\:bg-accent\\/0:is(.dark *)[data-range-middle]:hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[range-middle\\]\\:hover\\:bg-accent\\/0:is(.dark *)[data-range-middle]:hover{background-color:color-mix(in oklab,var(--accent)0%,transparent)}}.dark\\:data-\\[range-start\\]\\:hover\\:bg-accent:is(.dark *)[data-range-start]:hover,.dark\\:data-\\[selected\\]\\:hover\\:bg-accent\\/50:is(.dark *)[data-selected]:hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[selected\\]\\:hover\\:bg-accent\\/50:is(.dark *)[data-selected]:hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}}.dark\\:data-\\[state\\=checked\\]\\:bg-primary:is(.dark *)[data-state=checked]{background-color:var(--primary)}.dark\\:data-\\[state\\=checked\\]\\:bg-primary-foreground:is(.dark *)[data-state=checked]{background-color:var(--primary-foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-foreground:is(.dark *)[data-state=unchecked]{background-color:var(--foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:color-mix(in oklab,var(--input)80%,transparent)}}.\\[\\&_\\[data-command-group\\]\\]\\:px-2 [data-command-group]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[data-command-group\\]\\:not\\(\\[hidden\\]\\)_\\~\\[data-command-group\\]\\]\\:pt-0 [data-command-group]:not([hidden])~[data-command-group]{padding-top:calc(var(--spacing)*0)}.\\[\\&_\\[data-command-input-wrapper\\]_svg\\]\\:h-5 [data-command-input-wrapper] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-input-wrapper\\]_svg\\]\\:w-5 [data-command-input-wrapper] svg{width:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-input\\]\\]\\:h-12 [data-command-input]{height:calc(var(--spacing)*12)}.\\[\\&_\\[data-command-item\\]\\]\\:px-2 [data-command-item]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[data-command-item\\]\\]\\:py-3 [data-command-item]{padding-block:calc(var(--spacing)*3)}.\\[\\&_\\[data-command-item\\]_svg\\]\\:h-5 [data-command-item] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-item\\]_svg\\]\\:w-5 [data-command-item] svg{width:calc(var(--spacing)*5)}.\\[\\&_svg\\]\\:pointer-events-none svg{pointer-events:none}.\\[\\&_svg\\]\\:shrink-0 svg{flex-shrink:0}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\\'size-\\\'\\]\\)\\]\\:size-4 svg:not([class*=size-]){width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\\'text-\\\'\\]\\)\\]\\:text-muted-foreground svg:not([class*=text-]){color:var(--muted-foreground)}.\\[\\&\\:first-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-s-md:first-child[data-selected] [data-bits-day]{border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}.\\[\\&\\:has\\(\\>\\:nth-child\\(2\\)\\)\\]\\:grid-cols-\\[1fr_1fr_auto\\]:has(>:nth-child(2)){grid-template-columns:1fr 1fr auto}.\\[\\&\\:has\\(\\[data-range-end\\]\\)\\]\\:rounded-e-md:has([data-range-end]){border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-end\\]\\)\\]\\:hover\\:bg-accent:is(.dark *):has([data-range-end]):hover{background-color:var(--accent)}}.\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-none:has([data-range-middle]){border-radius:0}.\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:bg-accent:has([data-range-middle]){background-color:var(--accent)}.first\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-s-md:first-child:has([data-range-middle]){border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}.last\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-e-md:last-child:has([data-range-middle]){border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:hover\\:bg-accent\\/50:is(.dark *):has([data-range-middle]):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:hover\\:bg-accent\\/50:is(.dark *):has([data-range-middle]):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}}.\\[\\&\\:has\\(\\[data-range-start\\]\\)\\]\\:rounded-s-md:has([data-range-start]){border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-start\\]\\)\\]\\:hover\\:bg-accent:is(.dark *):has([data-range-start]):hover{background-color:var(--accent)}}.\\[\\&\\:has\\(\\[data-selected\\]\\)\\]\\:bg-accent:has([data-selected]){background-color:var(--accent)}:is(.\\*\\:\\[span\\]\\:last\\:flex>*):is(span):last-child{display:flex}:is(.\\*\\:\\[span\\]\\:last\\:items-center>*):is(span):last-child{align-items:center}:is(.\\*\\:\\[span\\]\\:last\\:gap-2>*):is(span):last-child{gap:calc(var(--spacing)*2)}.\\[\\&\\:last-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-e-md:last-child[data-selected] [data-bits-day]{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.\\[\\&\\>\\*\\]\\:w-full>*{width:100%}.\\[\\&\\>\\*\\]\\:focus-visible\\:relative>:focus-visible{position:relative}.\\[\\&\\>\\*\\]\\:focus-visible\\:z-10>:focus-visible{z-index:10}.\\[\\&\\>\\*\\]\\:data-\\[slot\\=field\\]\\:p-4>[data-slot=field]{padding:calc(var(--spacing)*4)}@container field-group (min-width:28rem){.\\@md\\/field-group\\:\\[\\&\\>\\*\\]\\:w-auto>*{width:auto}}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-s-none>:not(:first-child){border-start-start-radius:0;border-end-start-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-t-none>:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-s-0>:not(:first-child){border-inline-start-style:var(--tw-border-style);border-inline-start-width:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-t-0>:not(:first-child){border-top-style:var(--tw-border-style);border-top-width:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-e-none>:not(:last-child){border-start-end-radius:0;border-end-end-radius:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-b-none>:not(:last-child){border-bottom-right-radius:0;border-bottom-left-radius:0}.\\[\\&\\>\\.sr-only\\]\\:w-auto>.sr-only{width:auto}.\\[\\&\\>\\[data-slot\\=field-group\\]\\]\\:gap-4>[data-slot=field-group]{gap:calc(var(--spacing)*4)}.\\[\\&\\>\\[data-slot\\=field-label\\]\\]\\:flex-auto>[data-slot=field-label]{flex:auto}@container field-group (min-width:28rem){.\\@md\\/field-group\\:\\[\\&\\>\\[data-slot\\=field-label\\]\\]\\:flex-auto>[data-slot=field-label]{flex:auto}}.has-\\[select\\[aria-hidden\\=true\\]\\:last-child\\]\\:\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:last-of-type\\]\\:rounded-e-md:has(:is(select[aria-hidden=true]:last-child))>[data-slot=select-trigger]:last-of-type{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:not\\(\\[class\\*\\=\\\'w-\\\'\\]\\)\\]\\:w-fit>[data-slot=select-trigger]:not([class*=w-]){width:fit-content}.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content])>[role=checkbox],.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content]) [role=radio]{margin-top:1px}@container field-group (min-width:28rem){.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content])>[role=checkbox],.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content]) [role=radio]{margin-top:1px}}.\\[\\&\\>a\\]\\:underline>a{text-decoration-line:underline}.\\[\\&\\>a\\]\\:underline-offset-4>a{text-underline-offset:4px}.\\[\\&\\>a\\:hover\\]\\:text-primary>a:hover{color:var(--primary)}.\\[\\&\\>input\\]\\:flex-1>input{flex:1}.\\[\\&\\>span\\]\\:text-xs>span{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.\\[\\&\\>span\\]\\:opacity-70>span{opacity:.7}.\\[\\&\\>svg\\]\\:size-3\\.5>svg{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.\\[\\&\\>svg\\]\\:text-muted-foreground>svg,.\\[\\&\\[data-outside-month\\]\\:not\\(\\[data-selected\\]\\)\\]\\:text-muted-foreground[data-outside-month]:not([data-selected]){color:var(--muted-foreground)}@media(hover:hover){.\\[\\&\\[data-outside-month\\]\\:not\\(\\[data-selected\\]\\)\\]\\:hover\\:text-accent-foreground[data-outside-month]:not([data-selected]):hover{color:var(--accent-foreground)}}.\\[\\&\\[data-today\\]\\:not\\(\\[data-selected\\]\\)\\]\\:bg-accent[data-today]:not([data-selected]){background-color:var(--accent)}.\\[\\&\\[data-today\\]\\:not\\(\\[data-selected\\]\\)\\]\\:text-accent-foreground[data-today]:not([data-selected]){color:var(--accent-foreground)}.\\[\\&\\[data-today\\]\\[data-disabled\\]\\]\\:text-muted-foreground[data-today][data-disabled]{color:var(--muted-foreground)}[data-slot=card-content] .\\[\\[data-slot\\=card-content\\]_\\&\\]\\:bg-transparent,[data-slot=popover-content] .\\[\\[data-slot\\=popover-content\\]_\\&\\]\\:bg-transparent{background-color:#0000}[data-variant=legend]+.\\[\\[data-variant\\=legend\\]\\+\\&\\]\\:-mt-1\\.5{margin-top:calc(var(--spacing)*-1.5)}}@property --tw-animation-delay{syntax:\"*\";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:\"*\";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:\"*\";inherits:false}@property --tw-animation-fill-mode{syntax:\"*\";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:\"*\";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:\"*\";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:\"*\";inherits:false;initial-value:0}:root,:host{--radius:.625rem;--background:oklch(100% 0 0);--foreground:oklch(12.9% .042 264.695);--card:oklch(100% 0 0);--card-foreground:oklch(12.9% .042 264.695);--popover:oklch(100% 0 0);--popover-foreground:oklch(12.9% .042 264.695);--primary:oklch(20.8% .042 265.755);--primary-foreground:oklch(98.4% .003 247.858);--secondary:oklch(96.8% .007 247.896);--secondary-foreground:oklch(20.8% .042 265.755);--muted:oklch(96.8% .007 247.896);--muted-foreground:oklch(55.4% .046 257.417);--accent:oklch(96.8% .007 247.896);--accent-foreground:oklch(20.8% .042 265.755);--destructive:oklch(57.7% .245 27.325);--border:oklch(92.9% .013 255.508);--input:oklch(92.9% .013 255.508);--ring:oklch(70.4% .04 256.788);--chart-1:oklch(64.6% .222 41.116);--chart-2:oklch(60% .118 184.704);--chart-3:oklch(39.8% .07 227.392);--chart-4:oklch(82.8% .189 84.429);--chart-5:oklch(76.9% .188 70.08);--sidebar:oklch(98.4% .003 247.858);--sidebar-foreground:oklch(12.9% .042 264.695);--sidebar-primary:oklch(20.8% .042 265.755);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(96.8% .007 247.896);--sidebar-accent-foreground:oklch(20.8% .042 265.755);--sidebar-border:oklch(92.9% .013 255.508);--sidebar-ring:oklch(70.4% .04 256.788)}.dark{--background:oklch(12.9% .042 264.695);--foreground:oklch(98.4% .003 247.858);--card:oklch(20.8% .042 265.755);--card-foreground:oklch(98.4% .003 247.858);--popover:oklch(20.8% .042 265.755);--popover-foreground:oklch(98.4% .003 247.858);--primary:oklch(92.9% .013 255.508);--primary-foreground:oklch(20.8% .042 265.755);--secondary:oklch(27.9% .041 260.031);--secondary-foreground:oklch(98.4% .003 247.858);--muted:oklch(27.9% .041 260.031);--muted-foreground:oklch(70.4% .04 256.788);--accent:oklch(27.9% .041 260.031);--accent-foreground:oklch(98.4% .003 247.858);--destructive:oklch(70.4% .191 22.216);--border:oklch(100% 0 0/.1);--input:oklch(100% 0 0/.15);--ring:oklch(55.1% .027 264.364);--chart-1:oklch(48.8% .243 264.376);--chart-2:oklch(69.6% .17 162.48);--chart-3:oklch(76.9% .188 70.08);--chart-4:oklch(62.7% .265 303.9);--chart-5:oklch(64.5% .246 16.439);--sidebar:oklch(20.8% .042 265.755);--sidebar-foreground:oklch(98.4% .003 247.858);--sidebar-primary:oklch(48.8% .243 264.376);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(27.9% .041 260.031);--sidebar-accent-foreground:oklch(98.4% .003 247.858);--sidebar-border:oklch(100% 0 0/.1);--sidebar-ring:oklch(55.1% .027 264.364)}@property --tw-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-z{syntax:\"*\";inherits:false;initial-value:0}@property --tw-scale-x{syntax:\"*\";inherits:false;initial-value:1}@property --tw-scale-y{syntax:\"*\";inherits:false;initial-value:1}@property --tw-scale-z{syntax:\"*\";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:\"*\";inherits:false}@property --tw-rotate-y{syntax:\"*\";inherits:false}@property --tw-rotate-z{syntax:\"*\";inherits:false}@property --tw-skew-x{syntax:\"*\";inherits:false}@property --tw-skew-y{syntax:\"*\";inherits:false}@property --tw-pan-x{syntax:\"*\";inherits:false}@property --tw-pan-y{syntax:\"*\";inherits:false}@property --tw-pinch-zoom{syntax:\"*\";inherits:false}@property --tw-space-y-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-space-x-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-divide-x-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-border-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-divide-y-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-leading{syntax:\"*\";inherits:false}@property --tw-font-weight{syntax:\"*\";inherits:false}@property --tw-tracking{syntax:\"*\";inherits:false}@property --tw-ordinal{syntax:\"*\";inherits:false}@property --tw-slashed-zero{syntax:\"*\";inherits:false}@property --tw-numeric-figure{syntax:\"*\";inherits:false}@property --tw-numeric-spacing{syntax:\"*\";inherits:false}@property --tw-numeric-fraction{syntax:\"*\";inherits:false}@property --tw-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:\"*\";inherits:false}@property --tw-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:\"*\";inherits:false}@property --tw-inset-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:\"*\";inherits:false}@property --tw-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:\"*\";inherits:false}@property --tw-inset-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:\"*\";inherits:false}@property --tw-ring-offset-width{syntax:\"<length>\";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:\"*\";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-blur{syntax:\"*\";inherits:false}@property --tw-brightness{syntax:\"*\";inherits:false}@property --tw-contrast{syntax:\"*\";inherits:false}@property --tw-grayscale{syntax:\"*\";inherits:false}@property --tw-hue-rotate{syntax:\"*\";inherits:false}@property --tw-invert{syntax:\"*\";inherits:false}@property --tw-opacity{syntax:\"*\";inherits:false}@property --tw-saturate{syntax:\"*\";inherits:false}@property --tw-sepia{syntax:\"*\";inherits:false}@property --tw-drop-shadow{syntax:\"*\";inherits:false}@property --tw-drop-shadow-color{syntax:\"*\";inherits:false}@property --tw-drop-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:\"*\";inherits:false}@property --tw-backdrop-blur{syntax:\"*\";inherits:false}@property --tw-backdrop-brightness{syntax:\"*\";inherits:false}@property --tw-backdrop-contrast{syntax:\"*\";inherits:false}@property --tw-backdrop-grayscale{syntax:\"*\";inherits:false}@property --tw-backdrop-hue-rotate{syntax:\"*\";inherits:false}@property --tw-backdrop-invert{syntax:\"*\";inherits:false}@property --tw-backdrop-opacity{syntax:\"*\";inherits:false}@property --tw-backdrop-saturate{syntax:\"*\";inherits:false}@property --tw-backdrop-sepia{syntax:\"*\";inherits:false}@property --tw-duration{syntax:\"*\";inherits:false}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));filter:blur(var(--tw-enter-blur,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));filter:blur(var(--tw-exit-blur,0))}}\n";
function x5(t) {
  if (!t) return;
  const e = new CSSStyleSheet();
  e.replaceSync(S5), t.adoptedStyleSheets = [e];
}
var P5 = /* @__PURE__ */ ne("<div><!></div> <!>", 1);
function O5(t, e) {
  W(e, !0);
  let r = v(e, "schema", 7), n = v(e, "uiSchema", 7), s = v(e, "darkMode", 7), o = v(e, "preventPageReload", 7);
  b5(), ko(() => {
    x5(e.$$host?.shadowRoot);
  });
  const i = /* @__PURE__ */ O(() => w5({ schema: r(), uiSchema: n() }, () => e.$$host));
  Xe(() => {
    o() && $k(d(i));
  });
  let a = /* @__PURE__ */ xe(void 0);
  var l = {
    get schema() {
      return r();
    },
    set schema(_) {
      r(_), m();
    },
    get uiSchema() {
      return n();
    },
    set uiSchema(_) {
      n(_), m();
    },
    get darkMode() {
      return s();
    },
    set darkMode(_) {
      s(_), m();
    },
    get preventPageReload() {
      return o();
    },
    set preventPageReload(_) {
      o(_), m();
    }
  }, u = P5(), c = D(u), f = ge(c);
  e_(f, {
    get defaultPortalTo() {
      return d(a);
    },
    children: (_, b) => {
      Ld(_, {
        get form() {
          return d(i);
        }
      });
    },
    $$slots: { default: !0 }
  }), de(c), Qe(c, (_) => q(a, _), () => d(a));
  var g = be(c, 2);
  return ue(g, (_) => {
  }), ke(() => ls(c, 1, as([s() && "dark"]))), A(t, u), H(l);
}
customElements.define("formata-form", K(
  O5,
  {
    schema: { attribute: "schema", reflect: !0, type: "Object" },
    uiSchema: { attribute: "ui-schema", reflect: !0, type: "Object" },
    preventPageReload: {
      attribute: "prevent-page-reload",
      reflect: !0,
      type: "Boolean"
    },
    darkMode: { attribute: "dark-mode", reflect: !0, type: "Boolean" }
  },
  [],
  [],
  { mode: "open" }
));
export {
  O5 as Form
};
