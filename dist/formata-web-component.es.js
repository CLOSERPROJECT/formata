typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add("5");
const cx = 1, dx = 2, Jm = 4, fx = 8, hx = 16, gx = 1, px = 2, mx = 4, vx = 8, yx = 16, bx = 1, _x = 2, Zm = "[", Cl = "[!", td = "]", io = {}, xt = /* @__PURE__ */ Symbol(), wx = "http://www.w3.org/1999/xhtml", Sx = "http://www.w3.org/2000/svg", Qm = "@attach", lc = !1;
var kl = Array.isArray, xx = Array.prototype.indexOf, ao = Array.prototype.includes, $l = Array.from, Ja = Object.keys, Za = Object.defineProperty, bn = Object.getOwnPropertyDescriptor, ev = Object.getOwnPropertyDescriptors, tv = Object.prototype, Px = Array.prototype, Al = Object.getPrototypeOf, og = Object.isExtensible;
function Ho(t) {
  return typeof t == "function";
}
const ge = () => {
};
function Ox(t) {
  return t();
}
function uc(t) {
  for (var e = 0; e < t.length; e++)
    t[e]();
}
function rv() {
  var t, e, r = new Promise((n, s) => {
    t = n, e = s;
  });
  return { promise: r, resolve: t, reject: e };
}
function Cx(t, e) {
  if (Array.isArray(t))
    return t;
  if (!(Symbol.iterator in t))
    return Array.from(t);
  const r = [];
  for (const n of t)
    if (r.push(n), r.length === e) break;
  return r;
}
const At = 2, Qa = 4, ki = 8, rd = 1 << 24, Tn = 16, Br = 32, os = 64, nd = 128, br = 512, Ot = 1024, Et = 2048, Mr = 4096, fr = 8192, _n = 16384, El = 32768, Pn = 65536, ig = 1 << 17, nv = 1 << 18, Rs = 1 << 19, sv = 1 << 20, mn = 1 << 25, As = 32768, cc = 1 << 21, sd = 1 << 22, Kn = 1 << 23, Jr = /* @__PURE__ */ Symbol("$state"), od = /* @__PURE__ */ Symbol("legacy props"), kx = /* @__PURE__ */ Symbol(""), to = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}(), $x = 1, $i = 3, Vs = 8;
function id(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Ax() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function Ex(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Tx() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function Dx(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Mx() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Ix() {
  throw new Error("https://svelte.dev/e/hydration_failed");
}
function Nx(t) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function Fx() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Rx() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Vx() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Lx() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
function Tl(t) {
  console.warn("https://svelte.dev/e/hydration_mismatch");
}
function jx() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function Bx() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let Ie = !1;
function Bt(t) {
  Ie = t;
}
let ze;
function wt(t) {
  if (t === null)
    throw Tl(), io;
  return ze = t;
}
function On() {
  return wt(/* @__PURE__ */ sn(ze));
}
function de(t) {
  if (Ie) {
    if (/* @__PURE__ */ sn(ze) !== null)
      throw Tl(), io;
    ze = t;
  }
}
function vt(t = 1) {
  if (Ie) {
    for (var e = t, r = ze; e--; )
      r = /** @type {TemplateNode} */
      /* @__PURE__ */ sn(r);
    ze = r;
  }
}
function el(t = !0) {
  for (var e = 0, r = ze; ; ) {
    if (r.nodeType === Vs) {
      var n = (
        /** @type {Comment} */
        r.data
      );
      if (n === td) {
        if (e === 0) return r;
        e -= 1;
      } else (n === Zm || n === Cl) && (e += 1);
    }
    var s = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ sn(r)
    );
    t && r.remove(), r = s;
  }
}
function ov(t) {
  if (!t || t.nodeType !== Vs)
    throw Tl(), io;
  return (
    /** @type {Comment} */
    t.data
  );
}
function iv(t) {
  return t === this.v;
}
function zx(t, e) {
  return t != t ? e == e : t !== e || t !== null && typeof t == "object" || typeof t == "function";
}
function av(t) {
  return !zx(t, this.v);
}
let So = !1, qx = !1;
function Ux() {
  So = !0;
}
const Kx = [];
function xo(t, e = !1, r = !1) {
  return za(t, /* @__PURE__ */ new Map(), "", Kx, null, r);
}
function za(t, e, r, n, s = null, o = !1) {
  if (typeof t == "object" && t !== null) {
    var i = e.get(t);
    if (i !== void 0) return i;
    if (t instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(t)
    );
    if (t instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(t)
    );
    if (kl(t)) {
      var a = (
        /** @type {Snapshot<any>} */
        Array(t.length)
      );
      e.set(t, a), s !== null && e.set(s, a);
      for (var l = 0; l < t.length; l += 1) {
        var u = t[l];
        l in t && (a[l] = za(u, e, r, n, null, o));
      }
      return a;
    }
    if (Al(t) === tv) {
      a = {}, e.set(t, a), s !== null && e.set(s, a);
      for (var c in t)
        a[c] = za(
          // @ts-expect-error
          t[c],
          e,
          r,
          n,
          null,
          o
        );
      return a;
    }
    if (t instanceof Date)
      return (
        /** @type {Snapshot<T>} */
        structuredClone(t)
      );
    if (typeof /** @type {T & { toJSON?: any } } */
    t.toJSON == "function" && !o)
      return za(
        /** @type {T & { toJSON(): any } } */
        t.toJSON(),
        e,
        r,
        n,
        // Associate the instance with the toJSON clone
        t
      );
  }
  if (t instanceof EventTarget)
    return (
      /** @type {Snapshot<T>} */
      t
    );
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(t)
    );
  } catch {
    return (
      /** @type {Snapshot<T>} */
      t
    );
  }
}
let it = null;
function lo(t) {
  it = t;
}
function Es(t) {
  return (
    /** @type {T} */
    Dl().get(t)
  );
}
function Po(t, e) {
  return Dl().set(t, e), e;
}
function Hx(t) {
  return Dl().has(t);
}
function Wx() {
  return Dl();
}
function H(t, e = !1, r) {
  it = {
    p: it,
    i: !1,
    c: null,
    e: null,
    s: t,
    x: null,
    l: So && !e ? { s: null, u: null, $: [] } : null
  };
}
function W(t) {
  var e = (
    /** @type {ComponentContext} */
    it
  ), r = e.e;
  if (r !== null) {
    e.e = null;
    for (var n of r)
      Ev(n);
  }
  return t !== void 0 && (e.x = t), e.i = !0, it = e.p, t ?? /** @type {T} */
  {};
}
function Oo() {
  return !So || it !== null && it.l === null;
}
function Dl(t) {
  return it === null && id(), it.c ??= new Map(Gx(it) || void 0);
}
function Gx(t) {
  let e = t.p;
  for (; e !== null; ) {
    const r = e.c;
    if (r !== null)
      return r;
    e = e.p;
  }
  return null;
}
let Ss = [];
function lv() {
  var t = Ss;
  Ss = [], uc(t);
}
function Tr(t) {
  if (Ss.length === 0 && !ui) {
    var e = Ss;
    queueMicrotask(() => {
      e === Ss && lv();
    });
  }
  Ss.push(t);
}
function Yx() {
  for (; Ss.length > 0; )
    lv();
}
function uv(t) {
  var e = Xe;
  if (e === null)
    return Ge.f |= Kn, t;
  if ((e.f & El) === 0) {
    if ((e.f & nd) === 0)
      throw t;
    e.b.error(t);
  } else
    uo(t, e);
}
function uo(t, e) {
  for (; e !== null; ) {
    if ((e.f & nd) !== 0)
      try {
        e.b.error(t);
        return;
      } catch (r) {
        t = r;
      }
    e = e.parent;
  }
  throw t;
}
const Xx = -7169;
function dt(t, e) {
  t.f = t.f & Xx | e;
}
function ad(t) {
  (t.f & br) !== 0 || t.deps === null ? dt(t, Ot) : dt(t, Mr);
}
function cv(t) {
  if (t !== null)
    for (const e of t)
      (e.f & At) === 0 || (e.f & As) === 0 || (e.f ^= As, cv(
        /** @type {Derived} */
        e.deps
      ));
}
function dv(t, e, r) {
  (t.f & Et) !== 0 ? e.add(t) : (t.f & Mr) !== 0 && r.add(t), cv(t.deps), dt(t, Ot);
}
const Ui = /* @__PURE__ */ new Set();
let nt = null, dc = null, kr = null, lr = [], Ml = null, fc = !1, ui = !1;
class wn {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #r = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #n = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #s = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #i = /* @__PURE__ */ new Set();
  /**
   * A map of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`.
   * The value contains child effects that were dirty/maybe_dirty before being reset,
   * so they can be rescheduled if the branch survives.
   * @type {Map<Effect, { d: Effect[], m: Effect[] }>}
   */
  #a = /* @__PURE__ */ new Map();
  is_fork = !1;
  #u = !1;
  is_deferred() {
    return this.is_fork || this.#n > 0;
  }
  /**
   * Add an effect to the #skipped_branches map and reset its children
   * @param {Effect} effect
   */
  skip_effect(e) {
    this.#a.has(e) || this.#a.set(e, { d: [], m: [] });
  }
  /**
   * Remove an effect from the #skipped_branches map and reschedule
   * any tracked dirty/maybe_dirty child effects
   * @param {Effect} effect
   */
  unskip_effect(e) {
    var r = this.#a.get(e);
    if (r) {
      this.#a.delete(e);
      for (var n of r.d)
        dt(n, Et), Ar(n);
      for (n of r.m)
        dt(n, Mr), Ar(n);
    }
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    lr = [], this.apply();
    var r = [], n = [];
    for (const s of e)
      this.#l(s, r, n);
    if (this.is_deferred()) {
      this.#c(n), this.#c(r);
      for (const [s, o] of this.#a)
        pv(s, o);
    } else {
      for (const s of this.#e) s();
      this.#e.clear(), this.#r === 0 && this.#d(), dc = this, nt = null, ag(n), ag(r), dc = null, this.#s?.resolve();
    }
    kr = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {Effect[]} effects
   * @param {Effect[]} render_effects
   */
  #l(e, r, n) {
    e.f ^= Ot;
    for (var s = e.first, o = null; s !== null; ) {
      var i = s.f, a = (i & (Br | os)) !== 0, l = a && (i & Ot) !== 0, u = l || (i & fr) !== 0 || this.#a.has(s);
      if (!u && s.fn !== null) {
        a ? s.f ^= Ot : o !== null && (i & (Qa | ki | rd)) !== 0 ? o.b.defer_effect(s) : (i & Qa) !== 0 ? r.push(s) : Ti(s) && ((i & Tn) !== 0 && this.#i.add(s), fi(s));
        var c = s.first;
        if (c !== null) {
          s = c;
          continue;
        }
      }
      var f = s.parent;
      for (s = s.next; s === null && f !== null; )
        f === o && (o = null), s = f.next, f = f.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #c(e) {
    for (var r = 0; r < e.length; r += 1)
      dv(e[r], this.#o, this.#i);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, r) {
    r !== xt && !this.previous.has(e) && this.previous.set(e, r), (e.f & Kn) === 0 && (this.current.set(e, e.v), kr?.set(e, e.v));
  }
  activate() {
    nt = this, this.apply();
  }
  deactivate() {
    nt === this && (nt = null, kr = null);
  }
  flush() {
    if (this.activate(), lr.length > 0) {
      if (fv(), nt !== null && nt !== this)
        return;
    } else this.#r === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #d() {
    if (Ui.size > 1) {
      this.previous.clear();
      var e = kr, r = !0;
      for (const s of Ui) {
        if (s === this) {
          r = !1;
          continue;
        }
        const o = [];
        for (const [a, l] of this.current) {
          if (s.current.has(a))
            if (r && l !== s.current.get(a))
              s.current.set(a, l);
            else
              continue;
          o.push(a);
        }
        if (o.length === 0)
          continue;
        const i = [...s.current.keys()].filter((a) => !this.current.has(a));
        if (i.length > 0) {
          var n = lr;
          lr = [];
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const u of o)
            hv(u, i, a, l);
          if (lr.length > 0) {
            nt = s, s.apply();
            for (const u of lr)
              s.#l(u, [], []);
            s.deactivate();
          }
          lr = n;
        }
      }
      nt = null, kr = e;
    }
    this.committed = !0, Ui.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#r += 1, e && (this.#n += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#r -= 1, e && (this.#n -= 1), !this.#u && (this.#u = !0, Tr(() => {
      this.#u = !1, this.is_deferred() ? lr.length > 0 && this.flush() : this.revive();
    }));
  }
  revive() {
    for (const e of this.#o)
      this.#i.delete(e), dt(e, Et), Ar(e);
    for (const e of this.#i)
      dt(e, Mr), Ar(e);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#s ??= rv()).promise;
  }
  static ensure() {
    if (nt === null) {
      const e = nt = new wn();
      Ui.add(nt), ui || Tr(() => {
        nt === e && e.flush();
      });
    }
    return nt;
  }
  apply() {
  }
}
function m(t) {
  var e = ui;
  ui = !0;
  try {
    for (var r; ; ) {
      if (Yx(), lr.length === 0 && (nt?.flush(), lr.length === 0))
        return Ml = null, /** @type {T} */
        r;
      fv();
    }
  } finally {
    ui = e;
  }
}
function fv() {
  fc = !0;
  var t = null;
  try {
    for (var e = 0; lr.length > 0; ) {
      var r = wn.ensure();
      if (e++ > 1e3) {
        var n, s;
        Jx();
      }
      r.process(lr), Hn.clear();
    }
  } finally {
    fc = !1, Ml = null;
  }
}
function Jx() {
  try {
    Mx();
  } catch (t) {
    uo(t, Ml);
  }
}
let gn = null;
function ag(t) {
  var e = t.length;
  if (e !== 0) {
    for (var r = 0; r < e; ) {
      var n = t[r++];
      if ((n.f & (_n | fr)) === 0 && Ti(n) && (gn = /* @__PURE__ */ new Set(), fi(n), n.deps === null && n.first === null && n.nodes === null && (n.teardown === null && n.ac === null ? Nv(n) : n.fn = null), gn?.size > 0)) {
        Hn.clear();
        for (const s of gn) {
          if ((s.f & (_n | fr)) !== 0) continue;
          const o = [s];
          let i = s.parent;
          for (; i !== null; )
            gn.has(i) && (gn.delete(i), o.push(i)), i = i.parent;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a];
            (l.f & (_n | fr)) === 0 && fi(l);
          }
        }
        gn.clear();
      }
    }
    gn = null;
  }
}
function hv(t, e, r, n) {
  if (!r.has(t) && (r.add(t), t.reactions !== null))
    for (const s of t.reactions) {
      const o = s.f;
      (o & At) !== 0 ? hv(
        /** @type {Derived} */
        s,
        e,
        r,
        n
      ) : (o & (sd | Tn)) !== 0 && (o & Et) === 0 && gv(s, e, n) && (dt(s, Et), Ar(
        /** @type {Effect} */
        s
      ));
    }
}
function gv(t, e, r) {
  const n = r.get(t);
  if (n !== void 0) return n;
  if (t.deps !== null)
    for (const s of t.deps) {
      if (ao.call(e, s))
        return !0;
      if ((s.f & At) !== 0 && gv(
        /** @type {Derived} */
        s,
        e,
        r
      ))
        return r.set(
          /** @type {Derived} */
          s,
          !0
        ), !0;
    }
  return r.set(t, !1), !1;
}
function Ar(t) {
  for (var e = Ml = t; e.parent !== null; ) {
    e = e.parent;
    var r = e.f;
    if (fc && e === Xe && (r & Tn) !== 0 && (r & nv) === 0)
      return;
    if ((r & (os | Br)) !== 0) {
      if ((r & Ot) === 0) return;
      e.f ^= Ot;
    }
  }
  lr.push(e);
}
function pv(t, e) {
  if (!((t.f & Br) !== 0 && (t.f & Ot) !== 0)) {
    (t.f & Et) !== 0 ? e.d.push(t) : (t.f & Mr) !== 0 && e.m.push(t), dt(t, Ot);
    for (var r = t.first; r !== null; )
      pv(r, e), r = r.next;
  }
}
function ld(t) {
  let e = 0, r = Xn(0), n;
  return () => {
    fd() && (d(r), Ei(() => (e === 0 && (n = ot(() => t(() => Ur(r)))), e += 1, () => {
      Tr(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Ur(r));
      });
    })));
  };
}
var Zx = Pn | Rs | nd;
function Qx(t, e, r) {
  new eP(t, e, r);
}
class eP {
  /** @type {Boundary | null} */
  parent;
  is_pending = !1;
  /** @type {TemplateNode} */
  #e;
  /** @type {TemplateNode | null} */
  #t = Ie ? ze : null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #n;
  /** @type {Effect} */
  #s;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #i = null;
  /** @type {Effect | null} */
  #a = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #l = null;
  #c = 0;
  #d = 0;
  #g = !1;
  #m = !1;
  /** @type {Set<Effect>} */
  #p = /* @__PURE__ */ new Set();
  /** @type {Set<Effect>} */
  #f = /* @__PURE__ */ new Set();
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #h = null;
  #b = ld(() => (this.#h = Xn(this.#c), () => {
    this.#h = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, r, n) {
    this.#e = e, this.#r = r, this.#n = n, this.parent = /** @type {Effect} */
    Xe.b, this.is_pending = !!this.#r.pending, this.#s = Ls(() => {
      if (Xe.b = this, Ie) {
        const o = this.#t;
        On(), /** @type {Comment} */
        o.nodeType === Vs && /** @type {Comment} */
        o.data === Cl ? this.#v() : (this.#y(), this.#d === 0 && (this.is_pending = !1));
      } else {
        var s = this.#S();
        try {
          this.#o = Xt(() => n(s));
        } catch (o) {
          this.error(o);
        }
        this.#d > 0 ? this.#x() : this.is_pending = !1;
      }
      return () => {
        this.#l?.remove();
      };
    }, Zx), Ie && (this.#e = ze);
  }
  #y() {
    try {
      this.#o = Xt(() => this.#n(this.#e));
    } catch (e) {
      this.error(e);
    }
  }
  #v() {
    const e = this.#r.pending;
    e && (this.#i = Xt(() => e(this.#e)), Tr(() => {
      var r = this.#S();
      this.#o = this.#w(() => (wn.ensure(), Xt(() => this.#n(r)))), this.#d > 0 ? this.#x() : (Cs(
        /** @type {Effect} */
        this.#i,
        () => {
          this.#i = null;
        }
      ), this.is_pending = !1);
    }));
  }
  #S() {
    var e = this.#e;
    return this.is_pending && (this.#l = zt(), this.#e.before(this.#l), e = this.#l), e;
  }
  /**
   * Defer an effect inside a pending boundary until the boundary resolves
   * @param {Effect} effect
   */
  defer_effect(e) {
    dv(e, this.#p, this.#f);
  }
  /**
   * Returns `false` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_rendered() {
    return !this.is_pending && (!this.parent || this.parent.is_rendered());
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #w(e) {
    var r = Xe, n = Ge, s = it;
    en(this.#s), Sr(this.#s), lo(this.#s.ctx);
    try {
      return e();
    } catch (o) {
      return uv(o), null;
    } finally {
      en(r), Sr(n), lo(s);
    }
  }
  #x() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#o !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#l
    ), Vv(this.#o, this.#u)), this.#i === null && (this.#i = Xt(() => e(this.#e)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #_(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#_(e);
      return;
    }
    if (this.#d += e, this.#d === 0) {
      this.is_pending = !1;
      for (const r of this.#p)
        dt(r, Et), Ar(r);
      for (const r of this.#f)
        dt(r, Mr), Ar(r);
      this.#p.clear(), this.#f.clear(), this.#i && Cs(this.#i, () => {
        this.#i = null;
      }), this.#u && (this.#e.before(this.#u), this.#u = null);
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#_(e), this.#c += e, !(!this.#h || this.#g) && (this.#g = !0, Tr(() => {
      this.#g = !1, this.#h && co(this.#h, this.#c);
    }));
  }
  get_effect_pending() {
    return this.#b(), d(
      /** @type {Source<number>} */
      this.#h
    );
  }
  /** @param {unknown} error */
  error(e) {
    var r = this.#r.onerror;
    let n = this.#r.failed;
    if (this.#m || !r && !n)
      throw e;
    this.#o && (Ct(this.#o), this.#o = null), this.#i && (Ct(this.#i), this.#i = null), this.#a && (Ct(this.#a), this.#a = null), Ie && (wt(
      /** @type {TemplateNode} */
      this.#t
    ), vt(), wt(el()));
    var s = !1, o = !1;
    const i = () => {
      if (s) {
        Bx();
        return;
      }
      s = !0, o && Lx(), wn.ensure(), this.#c = 0, this.#a !== null && Cs(this.#a, () => {
        this.#a = null;
      }), this.is_pending = this.has_pending_snippet(), this.#o = this.#w(() => (this.#m = !1, Xt(() => this.#n(this.#e)))), this.#d > 0 ? this.#x() : this.is_pending = !1;
    };
    Tr(() => {
      try {
        o = !0, r?.(e, i), o = !1;
      } catch (a) {
        uo(a, this.#s && this.#s.parent);
      }
      n && (this.#a = this.#w(() => {
        wn.ensure(), this.#m = !0;
        try {
          return Xt(() => {
            n(
              this.#e,
              () => e,
              () => i
            );
          });
        } catch (a) {
          return uo(
            a,
            /** @type {Effect} */
            this.#s.parent
          ), null;
        } finally {
          this.#m = !1;
        }
      }));
    });
  }
}
function mv(t, e, r, n) {
  const s = Oo() ? Ai : ud;
  var o = t.filter((p) => !p.settled);
  if (r.length === 0 && o.length === 0) {
    n(e.map(s));
    return;
  }
  var i = nt, a = (
    /** @type {Effect} */
    Xe
  ), l = tP(), u = o.length === 1 ? o[0].promise : o.length > 1 ? Promise.all(o.map((p) => p.promise)) : null;
  function c(p) {
    l();
    try {
      n(p);
    } catch (_) {
      (a.f & _n) === 0 && uo(_, a);
    }
    i?.deactivate(), hc();
  }
  if (r.length === 0) {
    u.then(() => c(e.map(s)));
    return;
  }
  function f() {
    l(), Promise.all(r.map((p) => /* @__PURE__ */ rP(p))).then((p) => c([...e.map(s), ...p])).catch((p) => uo(p, a));
  }
  u ? u.then(f) : f();
}
function tP() {
  var t = Xe, e = Ge, r = it, n = nt;
  return function(o = !0) {
    en(t), Sr(e), lo(r), o && n?.activate();
  };
}
function hc() {
  en(null), Sr(null), lo(null);
}
// @__NO_SIDE_EFFECTS__
function Ai(t) {
  var e = At | Et, r = Ge !== null && (Ge.f & At) !== 0 ? (
    /** @type {Derived} */
    Ge
  ) : null;
  return Xe !== null && (Xe.f |= Rs), {
    ctx: it,
    deps: null,
    effects: null,
    equals: iv,
    f: e,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      xt
    ),
    wv: 0,
    parent: r ?? Xe,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function rP(t, e, r) {
  let n = (
    /** @type {Effect | null} */
    Xe
  );
  n === null && Ax();
  var s = (
    /** @type {Boundary} */
    n.b
  ), o = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), i = Xn(
    /** @type {V} */
    xt
  ), a = !Ge, l = /* @__PURE__ */ new Map();
  return cP(() => {
    var u = rv();
    o = u.promise;
    try {
      Promise.resolve(t()).then(u.resolve, u.reject).then(() => {
        c === nt && c.committed && c.deactivate(), hc();
      });
    } catch (_) {
      u.reject(_), hc();
    }
    var c = (
      /** @type {Batch} */
      nt
    );
    if (a) {
      var f = s.is_rendered();
      s.update_pending_count(1), c.increment(f), l.get(c)?.reject(to), l.delete(c), l.set(c, u);
    }
    const p = (_, b = void 0) => {
      if (c.activate(), b)
        b !== to && (i.f |= Kn, co(i, b));
      else {
        (i.f & Kn) !== 0 && (i.f ^= Kn), co(i, _);
        for (const [g, h] of l) {
          if (l.delete(g), g === c) break;
          h.reject(to);
        }
      }
      a && (s.update_pending_count(-1), c.decrement(f));
    };
    u.promise.then(p, (_) => p(null, _ || "unknown"));
  }), hd(() => {
    for (const u of l.values())
      u.reject(to);
  }), new Promise((u) => {
    function c(f) {
      function p() {
        f === o ? u(i) : c(o);
      }
      f.then(p, p);
    }
    c(o);
  });
}
// @__NO_SIDE_EFFECTS__
function C(t) {
  const e = /* @__PURE__ */ Ai(t);
  return Lv(e), e;
}
// @__NO_SIDE_EFFECTS__
function ud(t) {
  const e = /* @__PURE__ */ Ai(t);
  return e.equals = av, e;
}
function vv(t) {
  var e = t.effects;
  if (e !== null) {
    t.effects = null;
    for (var r = 0; r < e.length; r += 1)
      Ct(
        /** @type {Effect} */
        e[r]
      );
  }
}
function nP(t) {
  for (var e = t.parent; e !== null; ) {
    if ((e.f & At) === 0)
      return (e.f & _n) === 0 ? (
        /** @type {Effect} */
        e
      ) : null;
    e = e.parent;
  }
  return null;
}
function cd(t) {
  var e, r = Xe;
  en(nP(t));
  try {
    t.f &= ~As, vv(t), e = qv(t);
  } finally {
    en(r);
  }
  return e;
}
function yv(t) {
  var e = cd(t);
  if (!t.equals(e) && (t.wv = Bv(), (!nt?.is_fork || t.deps === null) && (t.v = e, t.deps === null))) {
    dt(t, Ot);
    return;
  }
  Jn || (kr !== null ? (fd() || nt?.is_fork) && kr.set(t, e) : ad(t));
}
let gc = /* @__PURE__ */ new Set();
const Hn = /* @__PURE__ */ new Map();
let bv = !1;
function Xn(t, e) {
  var r = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: iv,
    rv: 0,
    wv: 0
  };
  return r;
}
// @__NO_SIDE_EFFECTS__
function xe(t, e) {
  const r = Xn(t);
  return Lv(r), r;
}
// @__NO_SIDE_EFFECTS__
function _v(t, e = !1, r = !0) {
  const n = Xn(t);
  return e || (n.equals = av), So && r && it !== null && it.l !== null && (it.l.s ??= []).push(n), n;
}
function q(t, e, r = !1) {
  Ge !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Er || (Ge.f & ig) !== 0) && Oo() && (Ge.f & (At | Tn | sd | ig)) !== 0 && (_r === null || !ao.call(_r, t)) && Vx();
  let n = r ? Pt(e) : e;
  return co(t, n);
}
function co(t, e) {
  if (!t.equals(e)) {
    var r = t.v;
    Jn ? Hn.set(t, e) : Hn.set(t, r), t.v = e;
    var n = wn.ensure();
    if (n.capture(t, r), (t.f & At) !== 0) {
      const s = (
        /** @type {Derived} */
        t
      );
      (t.f & Et) !== 0 && cd(s), ad(s);
    }
    t.wv = Bv(), wv(t, Et), Oo() && Xe !== null && (Xe.f & Ot) !== 0 && (Xe.f & (Br | os)) === 0 && (vr === null ? hP([t]) : vr.push(t)), !n.is_fork && gc.size > 0 && !bv && sP();
  }
  return e;
}
function sP() {
  bv = !1;
  for (const t of gc)
    (t.f & Ot) !== 0 && dt(t, Mr), Ti(t) && fi(t);
  gc.clear();
}
function Ur(t) {
  q(t, t.v + 1);
}
function wv(t, e) {
  var r = t.reactions;
  if (r !== null)
    for (var n = Oo(), s = r.length, o = 0; o < s; o++) {
      var i = r[o], a = i.f;
      if (!(!n && i === Xe)) {
        var l = (a & Et) === 0;
        if (l && dt(i, e), (a & At) !== 0) {
          var u = (
            /** @type {Derived} */
            i
          );
          kr?.delete(u), (a & As) === 0 && (a & br && (i.f |= As), wv(u, Mr));
        } else l && ((a & Tn) !== 0 && gn !== null && gn.add(
          /** @type {Effect} */
          i
        ), Ar(
          /** @type {Effect} */
          i
        ));
      }
    }
}
function Pt(t) {
  if (typeof t != "object" || t === null || Jr in t)
    return t;
  const e = Al(t);
  if (e !== tv && e !== Px)
    return t;
  var r = /* @__PURE__ */ new Map(), n = kl(t), s = /* @__PURE__ */ xe(0), o = Sn, i = (a) => {
    if (Sn === o)
      return a();
    var l = Ge, u = Sn;
    Sr(null), fg(o);
    var c = a();
    return Sr(l), fg(u), c;
  };
  return n && r.set("length", /* @__PURE__ */ xe(
    /** @type {any[]} */
    t.length
  )), new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(a, l, u) {
        (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Fx();
        var c = r.get(l);
        return c === void 0 ? c = i(() => {
          var f = /* @__PURE__ */ xe(u.value);
          return r.set(l, f), f;
        }) : q(c, u.value, !0), !0;
      },
      deleteProperty(a, l) {
        var u = r.get(l);
        if (u === void 0) {
          if (l in a) {
            const c = i(() => /* @__PURE__ */ xe(xt));
            r.set(l, c), Ur(s);
          }
        } else
          q(u, xt), Ur(s);
        return !0;
      },
      get(a, l, u) {
        if (l === Jr)
          return t;
        var c = r.get(l), f = l in a;
        if (c === void 0 && (!f || bn(a, l)?.writable) && (c = i(() => {
          var _ = Pt(f ? a[l] : xt), b = /* @__PURE__ */ xe(_);
          return b;
        }), r.set(l, c)), c !== void 0) {
          var p = d(c);
          return p === xt ? void 0 : p;
        }
        return Reflect.get(a, l, u);
      },
      getOwnPropertyDescriptor(a, l) {
        var u = Reflect.getOwnPropertyDescriptor(a, l);
        if (u && "value" in u) {
          var c = r.get(l);
          c && (u.value = d(c));
        } else if (u === void 0) {
          var f = r.get(l), p = f?.v;
          if (f !== void 0 && p !== xt)
            return {
              enumerable: !0,
              configurable: !0,
              value: p,
              writable: !0
            };
        }
        return u;
      },
      has(a, l) {
        if (l === Jr)
          return !0;
        var u = r.get(l), c = u !== void 0 && u.v !== xt || Reflect.has(a, l);
        if (u !== void 0 || Xe !== null && (!c || bn(a, l)?.writable)) {
          u === void 0 && (u = i(() => {
            var p = c ? Pt(a[l]) : xt, _ = /* @__PURE__ */ xe(p);
            return _;
          }), r.set(l, u));
          var f = d(u);
          if (f === xt)
            return !1;
        }
        return c;
      },
      set(a, l, u, c) {
        var f = r.get(l), p = l in a;
        if (n && l === "length")
          for (var _ = u; _ < /** @type {Source<number>} */
          f.v; _ += 1) {
            var b = r.get(_ + "");
            b !== void 0 ? q(b, xt) : _ in a && (b = i(() => /* @__PURE__ */ xe(xt)), r.set(_ + "", b));
          }
        if (f === void 0)
          (!p || bn(a, l)?.writable) && (f = i(() => /* @__PURE__ */ xe(void 0)), q(f, Pt(u)), r.set(l, f));
        else {
          p = f.v !== xt;
          var g = i(() => Pt(u));
          q(f, g);
        }
        var h = Reflect.getOwnPropertyDescriptor(a, l);
        if (h?.set && h.set.call(c, u), !p) {
          if (n && typeof l == "string") {
            var y = (
              /** @type {Source<number>} */
              r.get("length")
            ), S = Number(l);
            Number.isInteger(S) && S >= y.v && q(y, S + 1);
          }
          Ur(s);
        }
        return !0;
      },
      ownKeys(a) {
        d(s);
        var l = Reflect.ownKeys(a).filter((f) => {
          var p = r.get(f);
          return p === void 0 || p.v !== xt;
        });
        for (var [u, c] of r)
          c.v !== xt && !(u in a) && l.push(u);
        return l;
      },
      setPrototypeOf() {
        Rx();
      }
    }
  );
}
function lg(t) {
  try {
    if (t !== null && typeof t == "object" && Jr in t)
      return t[Jr];
  } catch {
  }
  return t;
}
function oP(t, e) {
  return Object.is(lg(t), lg(e));
}
var ug, Sv, xv, Pv;
function pc() {
  if (ug === void 0) {
    ug = window, Sv = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, e = Node.prototype, r = Text.prototype;
    xv = bn(e, "firstChild").get, Pv = bn(e, "nextSibling").get, og(t) && (t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__style = void 0, t.__e = void 0), og(r) && (r.__t = void 0);
  }
}
function zt(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function Ir(t) {
  return (
    /** @type {TemplateNode | null} */
    xv.call(t)
  );
}
// @__NO_SIDE_EFFECTS__
function sn(t) {
  return (
    /** @type {TemplateNode | null} */
    Pv.call(t)
  );
}
function he(t, e) {
  if (!Ie)
    return /* @__PURE__ */ Ir(t);
  var r = /* @__PURE__ */ Ir(ze);
  if (r === null)
    r = ze.appendChild(zt());
  else if (e && r.nodeType !== $i) {
    var n = zt();
    return r?.before(n), wt(n), n;
  }
  return e && Il(
    /** @type {Text} */
    r
  ), wt(r), r;
}
function D(t, e = !1) {
  if (!Ie) {
    var r = /* @__PURE__ */ Ir(t);
    return r instanceof Comment && r.data === "" ? /* @__PURE__ */ sn(r) : r;
  }
  if (e) {
    if (ze?.nodeType !== $i) {
      var n = zt();
      return ze?.before(n), wt(n), n;
    }
    Il(
      /** @type {Text} */
      ze
    );
  }
  return ze;
}
function be(t, e = 1, r = !1) {
  let n = Ie ? ze : t;
  for (var s; e--; )
    s = n, n = /** @type {TemplateNode} */
    /* @__PURE__ */ sn(n);
  if (!Ie)
    return n;
  if (r) {
    if (n?.nodeType !== $i) {
      var o = zt();
      return n === null ? s?.after(o) : n.before(o), wt(o), o;
    }
    Il(
      /** @type {Text} */
      n
    );
  }
  return wt(n), n;
}
function dd(t) {
  t.textContent = "";
}
function Ov() {
  return !1;
}
function iP(t = "") {
  return document.createComment(t);
}
function Il(t) {
  if (
    /** @type {string} */
    t.nodeValue.length < 65536
  )
    return;
  let e = t.nextSibling;
  for (; e !== null && e.nodeType === $i; )
    e.remove(), t.nodeValue += /** @type {string} */
    e.nodeValue, e = t.nextSibling;
}
function aP(t, e) {
  if (e) {
    const r = document.body;
    t.autofocus = !0, Tr(() => {
      document.activeElement === r && t.focus();
    });
  }
}
function Cv(t) {
  Ie && /* @__PURE__ */ Ir(t) !== null && dd(t);
}
let cg = !1;
function kv() {
  cg || (cg = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
    { capture: !0 }
  ));
}
function Nl(t) {
  var e = Ge, r = Xe;
  Sr(null), en(null);
  try {
    return t();
  } finally {
    Sr(e), en(r);
  }
}
function $v(t, e, r, n = r) {
  t.addEventListener(e, () => Nl(r));
  const s = t.__on_r;
  s ? t.__on_r = () => {
    s(), n(!0);
  } : t.__on_r = () => n(!0), kv();
}
function Av(t) {
  Xe === null && (Ge === null && Dx(), Tx()), Jn && Ex();
}
function lP(t, e) {
  var r = e.last;
  r === null ? e.last = e.first = t : (r.next = t, t.prev = r, e.last = t);
}
function xr(t, e, r) {
  var n = Xe;
  n !== null && (n.f & fr) !== 0 && (t |= fr);
  var s = {
    ctx: it,
    deps: null,
    nodes: null,
    f: t | Et | br,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: n,
    b: n && n.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (r)
    try {
      fi(s), s.f |= El;
    } catch (a) {
      throw Ct(s), a;
    }
  else e !== null && Ar(s);
  var o = s;
  if (r && o.deps === null && o.teardown === null && o.nodes === null && o.first === o.last && // either `null`, or a singular child
  (o.f & Rs) === 0 && (o = o.first, (t & Tn) !== 0 && (t & Pn) !== 0 && o !== null && (o.f |= Pn)), o !== null && (o.parent = n, n !== null && lP(o, n), Ge !== null && (Ge.f & At) !== 0 && (t & os) === 0)) {
    var i = (
      /** @type {Derived} */
      Ge
    );
    (i.effects ??= []).push(o);
  }
  return s;
}
function fd() {
  return Ge !== null && !Er;
}
function hd(t) {
  const e = xr(ki, null, !1);
  return dt(e, Ot), e.teardown = t, e;
}
function Ze(t) {
  Av();
  var e = (
    /** @type {Effect} */
    Xe.f
  ), r = !Ge && (e & Br) !== 0 && (e & El) === 0;
  if (r) {
    var n = (
      /** @type {ComponentContext} */
      it
    );
    (n.e ??= []).push(t);
  } else
    return Ev(t);
}
function Ev(t) {
  return xr(Qa | sv, t, !1);
}
function Co(t) {
  return Av(), xr(ki | sv, t, !0);
}
function Tv(t) {
  wn.ensure();
  const e = xr(os | Rs, t, !0);
  return () => {
    Ct(e);
  };
}
function uP(t) {
  wn.ensure();
  const e = xr(os | Rs, t, !0);
  return (r = {}) => new Promise((n) => {
    r.outro ? Cs(e, () => {
      Ct(e), n(void 0);
    }) : (Ct(e), n(void 0));
  });
}
function Fl(t) {
  return xr(Qa, t, !1);
}
function cP(t) {
  return xr(sd | Rs, t, !0);
}
function Ei(t, e = 0) {
  return xr(ki | e, t, !0);
}
function ke(t, e = [], r = [], n = []) {
  mv(n, e, r, (s) => {
    xr(ki, () => t(...s.map(d)), !0);
  });
}
function Ls(t, e = 0) {
  var r = xr(Tn | e, t, !0);
  return r;
}
function Dv(t, e = 0) {
  var r = xr(rd | e, t, !0);
  return r;
}
function Xt(t) {
  return xr(Br | Rs, t, !0);
}
function Mv(t) {
  var e = t.teardown;
  if (e !== null) {
    const r = Jn, n = Ge;
    dg(!0), Sr(null);
    try {
      e.call(null);
    } finally {
      dg(r), Sr(n);
    }
  }
}
function Iv(t, e = !1) {
  var r = t.first;
  for (t.first = t.last = null; r !== null; ) {
    const s = r.ac;
    s !== null && Nl(() => {
      s.abort(to);
    });
    var n = r.next;
    (r.f & os) !== 0 ? r.parent = null : Ct(r, e), r = n;
  }
}
function dP(t) {
  for (var e = t.first; e !== null; ) {
    var r = e.next;
    (e.f & Br) === 0 && Ct(e), e = r;
  }
}
function Ct(t, e = !0) {
  var r = !1;
  (e || (t.f & nv) !== 0) && t.nodes !== null && t.nodes.end !== null && (fP(
    t.nodes.start,
    /** @type {TemplateNode} */
    t.nodes.end
  ), r = !0), Iv(t, e && !r), tl(t, 0), dt(t, _n);
  var n = t.nodes && t.nodes.t;
  if (n !== null)
    for (const o of n)
      o.stop();
  Mv(t);
  var s = t.parent;
  s !== null && s.first !== null && Nv(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes = t.ac = null;
}
function fP(t, e) {
  for (; t !== null; ) {
    var r = t === e ? null : /* @__PURE__ */ sn(t);
    t.remove(), t = r;
  }
}
function Nv(t) {
  var e = t.parent, r = t.prev, n = t.next;
  r !== null && (r.next = n), n !== null && (n.prev = r), e !== null && (e.first === t && (e.first = n), e.last === t && (e.last = r));
}
function Cs(t, e, r = !0) {
  var n = [];
  Fv(t, n, !0);
  var s = () => {
    r && Ct(t), e && e();
  }, o = n.length;
  if (o > 0) {
    var i = () => --o || s();
    for (var a of n)
      a.out(i);
  } else
    s();
}
function Fv(t, e, r) {
  if ((t.f & fr) === 0) {
    t.f ^= fr;
    var n = t.nodes && t.nodes.t;
    if (n !== null)
      for (const a of n)
        (a.is_global || r) && e.push(a);
    for (var s = t.first; s !== null; ) {
      var o = s.next, i = (s.f & Pn) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (s.f & Br) !== 0 && (t.f & Tn) !== 0;
      Fv(s, e, i ? r : !1), s = o;
    }
  }
}
function gd(t) {
  Rv(t, !0);
}
function Rv(t, e) {
  if ((t.f & fr) !== 0) {
    t.f ^= fr, (t.f & Ot) === 0 && (dt(t, Et), Ar(t));
    for (var r = t.first; r !== null; ) {
      var n = r.next, s = (r.f & Pn) !== 0 || (r.f & Br) !== 0;
      Rv(r, s ? e : !1), r = n;
    }
    var o = t.nodes && t.nodes.t;
    if (o !== null)
      for (const i of o)
        (i.is_global || e) && i.in();
  }
}
function Vv(t, e) {
  if (t.nodes)
    for (var r = t.nodes.start, n = t.nodes.end; r !== null; ) {
      var s = r === n ? null : /* @__PURE__ */ sn(r);
      e.append(r), r = s;
    }
}
let qa = !1, Jn = !1;
function dg(t) {
  Jn = t;
}
let Ge = null, Er = !1;
function Sr(t) {
  Ge = t;
}
let Xe = null;
function en(t) {
  Xe = t;
}
let _r = null;
function Lv(t) {
  Ge !== null && (_r === null ? _r = [t] : _r.push(t));
}
let Yt = null, ar = 0, vr = null;
function hP(t) {
  vr = t;
}
let jv = 1, xs = 0, Sn = xs;
function fg(t) {
  Sn = t;
}
function Bv() {
  return ++jv;
}
function Ti(t) {
  var e = t.f;
  if ((e & Et) !== 0)
    return !0;
  if (e & At && (t.f &= ~As), (e & Mr) !== 0) {
    for (var r = (
      /** @type {Value[]} */
      t.deps
    ), n = r.length, s = 0; s < n; s++) {
      var o = r[s];
      if (Ti(
        /** @type {Derived} */
        o
      ) && yv(
        /** @type {Derived} */
        o
      ), o.wv > t.wv)
        return !0;
    }
    (e & br) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    kr === null && dt(t, Ot);
  }
  return !1;
}
function zv(t, e, r = !0) {
  var n = t.reactions;
  if (n !== null && !(_r !== null && ao.call(_r, t)))
    for (var s = 0; s < n.length; s++) {
      var o = n[s];
      (o.f & At) !== 0 ? zv(
        /** @type {Derived} */
        o,
        e,
        !1
      ) : e === o && (r ? dt(o, Et) : (o.f & Ot) !== 0 && dt(o, Mr), Ar(
        /** @type {Effect} */
        o
      ));
    }
}
function qv(t) {
  var e = Yt, r = ar, n = vr, s = Ge, o = _r, i = it, a = Er, l = Sn, u = t.f;
  Yt = /** @type {null | Value[]} */
  null, ar = 0, vr = null, Ge = (u & (Br | os)) === 0 ? t : null, _r = null, lo(t.ctx), Er = !1, Sn = ++xs, t.ac !== null && (Nl(() => {
    t.ac.abort(to);
  }), t.ac = null);
  try {
    t.f |= cc;
    var c = (
      /** @type {Function} */
      t.fn
    ), f = c(), p = t.deps, _ = nt?.is_fork;
    if (Yt !== null) {
      var b;
      if (_ || tl(t, ar), p !== null && ar > 0)
        for (p.length = ar + Yt.length, b = 0; b < Yt.length; b++)
          p[ar + b] = Yt[b];
      else
        t.deps = p = Yt;
      if (fd() && (t.f & br) !== 0)
        for (b = ar; b < p.length; b++)
          (p[b].reactions ??= []).push(t);
    } else !_ && p !== null && ar < p.length && (tl(t, ar), p.length = ar);
    if (Oo() && vr !== null && !Er && p !== null && (t.f & (At | Mr | Et)) === 0)
      for (b = 0; b < /** @type {Source[]} */
      vr.length; b++)
        zv(
          vr[b],
          /** @type {Effect} */
          t
        );
    if (s !== null && s !== t) {
      if (xs++, s.deps !== null)
        for (let g = 0; g < r; g += 1)
          s.deps[g].rv = xs;
      if (e !== null)
        for (const g of e)
          g.rv = xs;
      vr !== null && (n === null ? n = vr : n.push(.../** @type {Source[]} */
      vr));
    }
    return (t.f & Kn) !== 0 && (t.f ^= Kn), f;
  } catch (g) {
    return uv(g);
  } finally {
    t.f ^= cc, Yt = e, ar = r, vr = n, Ge = s, _r = o, lo(i), Er = a, Sn = l;
  }
}
function gP(t, e) {
  let r = e.reactions;
  if (r !== null) {
    var n = xx.call(r, t);
    if (n !== -1) {
      var s = r.length - 1;
      s === 0 ? r = e.reactions = null : (r[n] = r[s], r.pop());
    }
  }
  if (r === null && (e.f & At) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Yt === null || !ao.call(Yt, e))) {
    var o = (
      /** @type {Derived} */
      e
    );
    (o.f & br) !== 0 && (o.f ^= br, o.f &= ~As), ad(o), vv(o), tl(o, 0);
  }
}
function tl(t, e) {
  var r = t.deps;
  if (r !== null)
    for (var n = e; n < r.length; n++)
      gP(t, r[n]);
}
function fi(t) {
  var e = t.f;
  if ((e & _n) === 0) {
    dt(t, Ot);
    var r = Xe, n = qa;
    Xe = t, qa = !0;
    try {
      (e & (Tn | rd)) !== 0 ? dP(t) : Iv(t), Mv(t);
      var s = qv(t);
      t.teardown = typeof s == "function" ? s : null, t.wv = jv;
      var o;
      lc && qx && (t.f & Et) !== 0 && t.deps;
    } finally {
      qa = n, Xe = r;
    }
  }
}
async function Rl() {
  await Promise.resolve(), m();
}
function d(t) {
  var e = t.f, r = (e & At) !== 0;
  if (Ge !== null && !Er) {
    var n = Xe !== null && (Xe.f & _n) !== 0;
    if (!n && (_r === null || !ao.call(_r, t))) {
      var s = Ge.deps;
      if ((Ge.f & cc) !== 0)
        t.rv < xs && (t.rv = xs, Yt === null && s !== null && s[ar] === t ? ar++ : Yt === null ? Yt = [t] : Yt.push(t));
      else {
        (Ge.deps ??= []).push(t);
        var o = t.reactions;
        o === null ? t.reactions = [Ge] : ao.call(o, Ge) || o.push(Ge);
      }
    }
  }
  if (Jn && Hn.has(t))
    return Hn.get(t);
  if (r) {
    var i = (
      /** @type {Derived} */
      t
    );
    if (Jn) {
      var a = i.v;
      return ((i.f & Ot) === 0 && i.reactions !== null || Kv(i)) && (a = cd(i)), Hn.set(i, a), a;
    }
    var l = (i.f & br) === 0 && !Er && Ge !== null && (qa || (Ge.f & br) !== 0), u = i.deps === null;
    Ti(i) && (l && (i.f |= br), yv(i)), l && !u && Uv(i);
  }
  if (kr?.has(t))
    return kr.get(t);
  if ((t.f & Kn) !== 0)
    throw t.v;
  return t.v;
}
function Uv(t) {
  if (t.deps !== null) {
    t.f |= br;
    for (const e of t.deps)
      (e.reactions ??= []).push(t), (e.f & At) !== 0 && (e.f & br) === 0 && Uv(
        /** @type {Derived} */
        e
      );
  }
}
function Kv(t) {
  if (t.v === xt) return !0;
  if (t.deps === null) return !1;
  for (const e of t.deps)
    if (Hn.has(e) || (e.f & At) !== 0 && Kv(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function ot(t) {
  var e = Er;
  try {
    return Er = !0, t();
  } finally {
    Er = e;
  }
}
function Dn(t, e) {
  var r = {};
  for (var n in t)
    e.includes(n) || (r[n] = t[n]);
  for (var s of Object.getOwnPropertySymbols(t))
    Object.propertyIsEnumerable.call(t, s) && !e.includes(s) && (r[s] = t[s]);
  return r;
}
function pP(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (Jr in t)
      mc(t);
    else if (!Array.isArray(t))
      for (let e in t) {
        const r = t[e];
        typeof r == "object" && r && Jr in r && mc(r);
      }
  }
}
function mc(t, e = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !e.has(t)) {
    e.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        mc(t[n], e);
      } catch {
      }
    const r = Al(t);
    if (r !== Object.prototype && r !== Array.prototype && r !== Map.prototype && r !== Set.prototype && r !== Date.prototype) {
      const n = ev(r);
      for (let s in n) {
        const o = n[s].get;
        if (o)
          try {
            o.call(t);
          } catch {
          }
      }
    }
  }
}
const Hv = /* @__PURE__ */ new Set(), vc = /* @__PURE__ */ new Set();
function Wv(t, e, r, n = {}) {
  function s(o) {
    if (n.capture || si.call(e, o), !o.cancelBubble)
      return Nl(() => r?.call(this, o));
  }
  return t.startsWith("pointer") || t.startsWith("touch") || t === "wheel" ? Tr(() => {
    e.addEventListener(t, s, n);
  }) : e.addEventListener(t, s, n), s;
}
function Ye(t, e, r, n = {}) {
  var s = Wv(e, t, r, n);
  return () => {
    t.removeEventListener(e, s, n);
  };
}
function mP(t) {
  for (var e = 0; e < t.length; e++)
    Hv.add(t[e]);
  for (var r of vc)
    r(t);
}
let hg = null;
function si(t) {
  var e = this, r = (
    /** @type {Node} */
    e.ownerDocument
  ), n = t.type, s = t.composedPath?.() || [], o = (
    /** @type {null | Element} */
    s[0] || t.target
  );
  hg = t;
  var i = 0, a = hg === t && t.__root;
  if (a) {
    var l = s.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      t.__root = e;
      return;
    }
    var u = s.indexOf(e);
    if (u === -1)
      return;
    l <= u && (i = l);
  }
  if (o = /** @type {Element} */
  s[i] || t.target, o !== e) {
    Za(t, "currentTarget", {
      configurable: !0,
      get() {
        return o || r;
      }
    });
    var c = Ge, f = Xe;
    Sr(null), en(null);
    try {
      for (var p, _ = []; o !== null; ) {
        var b = o.assignedSlot || o.parentNode || /** @type {any} */
        o.host || null;
        try {
          var g = o["__" + n];
          g != null && (!/** @type {any} */
          o.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === o) && g.call(o, t);
        } catch (h) {
          p ? _.push(h) : p = h;
        }
        if (t.cancelBubble || b === e || b === null)
          break;
        o = b;
      }
      if (p) {
        for (let h of _)
          queueMicrotask(() => {
            throw h;
          });
        throw p;
      }
    } finally {
      t.__root = e, delete t.currentTarget, Sr(c), en(f);
    }
  }
}
function Gv(t) {
  var e = document.createElement("template");
  return e.innerHTML = t.replaceAll("<!>", "<!---->"), e.content;
}
function Dr(t, e) {
  var r = (
    /** @type {Effect} */
    Xe
  );
  r.nodes === null && (r.nodes = { start: t, end: e, a: null, t: null });
}
// @__NO_SIDE_EFFECTS__
function ne(t, e) {
  var r = (e & bx) !== 0, n = (e & _x) !== 0, s, o = !t.startsWith("<!>");
  return () => {
    if (Ie)
      return Dr(ze, null), ze;
    s === void 0 && (s = Gv(o ? t : "<!>" + t), r || (s = /** @type {TemplateNode} */
    /* @__PURE__ */ Ir(s)));
    var i = (
      /** @type {TemplateNode} */
      n || Sv ? document.importNode(s, !0) : s.cloneNode(!0)
    );
    if (r) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Ir(i)
      ), l = (
        /** @type {TemplateNode} */
        i.lastChild
      );
      Dr(a, l);
    } else
      Dr(i, i);
    return i;
  };
}
// @__NO_SIDE_EFFECTS__
function vP(t, e, r = "svg") {
  var n = !t.startsWith("<!>"), s = `<${r}>${n ? t : "<!>" + t}</${r}>`, o;
  return () => {
    if (Ie)
      return Dr(ze, null), ze;
    if (!o) {
      var i = (
        /** @type {DocumentFragment} */
        Gv(s)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ Ir(i)
      );
      o = /** @type {Element} */
      /* @__PURE__ */ Ir(a);
    }
    var l = (
      /** @type {TemplateNode} */
      o.cloneNode(!0)
    );
    return Dr(l, l), l;
  };
}
// @__NO_SIDE_EFFECTS__
function yP(t, e) {
  return /* @__PURE__ */ vP(t, e, "svg");
}
function tt(t = "") {
  if (!Ie) {
    var e = zt(t + "");
    return Dr(e, e), e;
  }
  var r = ze;
  return r.nodeType !== $i ? (r.before(r = zt()), wt(r)) : Il(
    /** @type {Text} */
    r
  ), Dr(r, r), r;
}
function I() {
  if (Ie)
    return Dr(ze, null), ze;
  var t = document.createDocumentFragment(), e = document.createComment(""), r = zt();
  return t.append(e, r), Dr(e, r), t;
}
function A(t, e) {
  if (Ie) {
    var r = (
      /** @type {Effect & { nodes: EffectNodes }} */
      Xe
    );
    ((r.f & El) === 0 || r.nodes.end === null) && (r.nodes.end = ze), On();
    return;
  }
  t !== null && t.before(
    /** @type {Node} */
    e
  );
}
function Te() {
  if (Ie && ze && ze.nodeType === Vs && ze.textContent?.startsWith("$")) {
    const t = ze.textContent.substring(1);
    return On(), t;
  }
  return (window.__svelte ??= {}).uid ??= 1, `c${window.__svelte.uid++}`;
}
function bP(t) {
  return t.endsWith("capture") && t !== "gotpointercapture" && t !== "lostpointercapture";
}
const _P = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function wP(t) {
  return _P.includes(t);
}
const SP = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function xP(t) {
  return t = t.toLowerCase(), SP[t] ?? t;
}
const PP = ["touchstart", "touchmove"];
function OP(t) {
  return PP.includes(t);
}
const CP = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function kP(t) {
  return CP.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    t
  );
}
function Me(t, e) {
  var r = e == null ? "" : typeof e == "object" ? e + "" : e;
  r !== (t.__t ??= t.nodeValue) && (t.__t = r, t.nodeValue = r + "");
}
function pd(t, e) {
  return Yv(t, e);
}
function $P(t, e) {
  pc(), e.intro = e.intro ?? !1;
  const r = e.target, n = Ie, s = ze;
  try {
    for (var o = /* @__PURE__ */ Ir(r); o && (o.nodeType !== Vs || /** @type {Comment} */
    o.data !== Zm); )
      o = /* @__PURE__ */ sn(o);
    if (!o)
      throw io;
    Bt(!0), wt(
      /** @type {Comment} */
      o
    );
    const i = Yv(t, { ...e, anchor: o });
    return Bt(!1), /**  @type {Exports} */
    i;
  } catch (i) {
    if (i instanceof Error && i.message.split(`
`).some((a) => a.startsWith("https://svelte.dev/e/")))
      throw i;
    return i !== io && console.warn("Failed to hydrate: ", i), e.recover === !1 && Ix(), pc(), dd(r), Bt(!1), pd(t, e);
  } finally {
    Bt(n), wt(s);
  }
}
const Ys = /* @__PURE__ */ new Map();
function Yv(t, { target: e, anchor: r, props: n = {}, events: s, context: o, intro: i = !0 }) {
  pc();
  var a = /* @__PURE__ */ new Set(), l = (f) => {
    for (var p = 0; p < f.length; p++) {
      var _ = f[p];
      if (!a.has(_)) {
        a.add(_);
        var b = OP(_);
        e.addEventListener(_, si, { passive: b });
        var g = Ys.get(_);
        g === void 0 ? (document.addEventListener(_, si, { passive: b }), Ys.set(_, 1)) : Ys.set(_, g + 1);
      }
    }
  };
  l($l(Hv)), vc.add(l);
  var u = void 0, c = uP(() => {
    var f = r ?? e.appendChild(zt());
    return Qx(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (p) => {
        if (o) {
          H({});
          var _ = (
            /** @type {ComponentContext} */
            it
          );
          _.c = o;
        }
        if (s && (n.$$events = s), Ie && Dr(
          /** @type {TemplateNode} */
          p,
          null
        ), u = t(p, n) || {}, Ie && (Xe.nodes.end = ze, ze === null || ze.nodeType !== Vs || /** @type {Comment} */
        ze.data !== td))
          throw Tl(), io;
        o && W();
      }
    ), () => {
      for (var p of a) {
        e.removeEventListener(p, si);
        var _ = (
          /** @type {number} */
          Ys.get(p)
        );
        --_ === 0 ? (document.removeEventListener(p, si), Ys.delete(p)) : Ys.set(p, _);
      }
      vc.delete(l), f !== r && f.parentNode?.removeChild(f);
    };
  });
  return yc.set(u, c), u;
}
let yc = /* @__PURE__ */ new WeakMap();
function Xv(t, e) {
  const r = yc.get(t);
  return r ? (yc.delete(t), r(e)) : Promise.resolve();
}
class Di {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /**
   * Map of keys to effects that are currently rendered in the DOM.
   * These effects are visible and actively part of the document tree.
   * Example:
   * ```
   * {#if condition}
   * 	foo
   * {:else}
   * 	bar
   * {/if}
   * ```
   * Can result in the entries `true->Effect` and `false->Effect`
   * @type {Map<Key, Effect>}
   */
  #t = /* @__PURE__ */ new Map();
  /**
   * Similar to #onscreen with respect to the keys, but contains branches that are not yet
   * in the DOM, because their insertion is deferred.
   * @type {Map<Key, Branch>}
   */
  #r = /* @__PURE__ */ new Map();
  /**
   * Keys of effects that are currently outroing
   * @type {Set<Key>}
   */
  #n = /* @__PURE__ */ new Set();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #s = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, r = !0) {
    this.anchor = e, this.#s = r;
  }
  #o = () => {
    var e = (
      /** @type {Batch} */
      nt
    );
    if (this.#e.has(e)) {
      var r = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(r);
      if (n)
        gd(n), this.#n.delete(r);
      else {
        var s = this.#r.get(r);
        s && (this.#t.set(r, s.effect), this.#r.delete(r), s.fragment.lastChild.remove(), this.anchor.before(s.fragment), n = s.effect);
      }
      for (const [o, i] of this.#e) {
        if (this.#e.delete(o), o === e)
          break;
        const a = this.#r.get(i);
        a && (Ct(a.effect), this.#r.delete(i));
      }
      for (const [o, i] of this.#t) {
        if (o === r || this.#n.has(o)) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(o)) {
            var u = document.createDocumentFragment();
            Vv(i, u), u.append(zt()), this.#r.set(o, { effect: i, fragment: u });
          } else
            Ct(i);
          this.#n.delete(o), this.#t.delete(o);
        };
        this.#s || !n ? (this.#n.add(o), Cs(i, a, !1)) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #i = (e) => {
    this.#e.delete(e);
    const r = Array.from(this.#e.values());
    for (const [n, s] of this.#r)
      r.includes(n) || (Ct(s.effect), this.#r.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, r) {
    var n = (
      /** @type {Batch} */
      nt
    ), s = Ov();
    if (r && !this.#t.has(e) && !this.#r.has(e))
      if (s) {
        var o = document.createDocumentFragment(), i = zt();
        o.append(i), this.#r.set(e, {
          effect: Xt(() => r(i)),
          fragment: o
        });
      } else
        this.#t.set(
          e,
          Xt(() => r(this.anchor))
        );
    if (this.#e.set(n, e), s) {
      for (const [a, l] of this.#t)
        a === e ? n.unskip_effect(l) : n.skip_effect(l);
      for (const [a, l] of this.#r)
        a === e ? n.unskip_effect(l.effect) : n.skip_effect(l.effect);
      n.oncommit(this.#o), n.ondiscard(this.#i);
    } else
      Ie && (this.anchor = ze), this.#o();
  }
}
function te(t, e, ...r) {
  var n = new Di(t);
  Ls(() => {
    const s = e() ?? null;
    n.ensure(s, s && ((o) => s(o, ...r)));
  }, Pn);
}
function ko(t) {
  it === null && id(), So && it.l !== null ? EP(it).m.push(t) : Ze(() => {
    const e = ot(t);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function AP(t) {
  it === null && id(), ko(() => () => ot(t));
}
function EP(t) {
  var e = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
function Jv() {
  return Symbol(Qm);
}
function ue(t, e, r = !1) {
  Ie && On();
  var n = new Di(t), s = r ? Pn : 0;
  function o(i, a) {
    if (Ie) {
      const u = ov(t) === Cl;
      if (i === u) {
        var l = el();
        wt(l), n.anchor = l, Bt(!1), n.ensure(i, a), Bt(!0);
        return;
      }
    }
    n.ensure(i, a);
  }
  Ls(() => {
    var i = !1;
    e((a, l = !0) => {
      i = !0, o(l, a);
    }), i || o(!1, null);
  }, s);
}
function Vl(t, e, r) {
  Ie && On();
  var n = new Di(t), s = !Oo();
  Ls(() => {
    var o = e();
    s && o !== null && typeof o == "object" && (o = /** @type {V} */
    {}), n.ensure(o, r);
  });
}
function Ll(t, e) {
  return e;
}
function TP(t, e, r) {
  for (var n = [], s = e.length, o, i = e.length, a = 0; a < s; a++) {
    let f = e[a];
    Cs(
      f,
      () => {
        if (o) {
          if (o.pending.delete(f), o.done.add(f), o.pending.size === 0) {
            var p = (
              /** @type {Set<EachOutroGroup>} */
              t.outrogroups
            );
            bc($l(o.done)), p.delete(o), p.size === 0 && (t.outrogroups = null);
          }
        } else
          i -= 1;
      },
      !1
    );
  }
  if (i === 0) {
    var l = n.length === 0 && r !== null;
    if (l) {
      var u = (
        /** @type {Element} */
        r
      ), c = (
        /** @type {Element} */
        u.parentNode
      );
      dd(c), c.append(u), t.items.clear();
    }
    bc(e, !l);
  } else
    o = {
      pending: new Set(e),
      done: /* @__PURE__ */ new Set()
    }, (t.outrogroups ??= /* @__PURE__ */ new Set()).add(o);
}
function bc(t, e = !0) {
  for (var r = 0; r < t.length; r++)
    Ct(t[r], e);
}
var gg;
function st(t, e, r, n, s, o = null) {
  var i = t, a = /* @__PURE__ */ new Map(), l = (e & Jm) !== 0;
  if (l) {
    var u = (
      /** @type {Element} */
      t
    );
    i = Ie ? wt(/* @__PURE__ */ Ir(u)) : u.appendChild(zt());
  }
  Ie && On();
  var c = null, f = /* @__PURE__ */ ud(() => {
    var y = r();
    return kl(y) ? y : y == null ? [] : $l(y);
  }), p, _ = !0;
  function b() {
    h.fallback = c, DP(h, p, i, e, n), c !== null && (p.length === 0 ? (c.f & mn) === 0 ? gd(c) : (c.f ^= mn, oi(c, null, i)) : Cs(c, () => {
      c = null;
    }));
  }
  var g = Ls(() => {
    p = /** @type {V[]} */
    d(f);
    var y = p.length;
    let S = !1;
    if (Ie) {
      var x = ov(i) === Cl;
      x !== (y === 0) && (i = el(), wt(i), Bt(!1), S = !0);
    }
    for (var P = /* @__PURE__ */ new Set(), w = (
      /** @type {Batch} */
      nt
    ), O = Ov(), k = 0; k < y; k += 1) {
      Ie && ze.nodeType === Vs && /** @type {Comment} */
      ze.data === td && (i = /** @type {Comment} */
      ze, S = !0, Bt(!1));
      var $ = p[k], T = n($, k), E = _ ? null : a.get(T);
      E ? (E.v && co(E.v, $), E.i && co(E.i, k), O && w.unskip_effect(E.e)) : (E = MP(
        a,
        _ ? i : gg ??= zt(),
        $,
        T,
        k,
        s,
        e,
        r
      ), _ || (E.e.f |= mn), a.set(T, E)), P.add(T);
    }
    if (y === 0 && o && !c && (_ ? c = Xt(() => o(i)) : (c = Xt(() => o(gg ??= zt())), c.f |= mn)), Ie && y > 0 && wt(el()), !_)
      if (O) {
        for (const [M, R] of a)
          P.has(M) || w.skip_effect(R.e);
        w.oncommit(b), w.ondiscard(() => {
        });
      } else
        b();
    S && Bt(!0), d(f);
  }), h = { effect: g, items: a, outrogroups: null, fallback: c };
  _ = !1, Ie && (i = ze);
}
function Wo(t) {
  for (; t !== null && (t.f & Br) === 0; )
    t = t.next;
  return t;
}
function DP(t, e, r, n, s) {
  var o = (n & fx) !== 0, i = e.length, a = t.items, l = Wo(t.effect.first), u, c = null, f, p = [], _ = [], b, g, h, y;
  if (o)
    for (y = 0; y < i; y += 1)
      b = e[y], g = s(b, y), h = /** @type {EachItem} */
      a.get(g).e, (h.f & mn) === 0 && (h.nodes?.a?.measure(), (f ??= /* @__PURE__ */ new Set()).add(h));
  for (y = 0; y < i; y += 1) {
    if (b = e[y], g = s(b, y), h = /** @type {EachItem} */
    a.get(g).e, t.outrogroups !== null)
      for (const E of t.outrogroups)
        E.pending.delete(h), E.done.delete(h);
    if ((h.f & mn) !== 0)
      if (h.f ^= mn, h === l)
        oi(h, null, r);
      else {
        var S = c ? c.next : l;
        h === t.effect.last && (t.effect.last = h.prev), h.prev && (h.prev.next = h.next), h.next && (h.next.prev = h.prev), Fn(t, c, h), Fn(t, h, S), oi(h, S, r), c = h, p = [], _ = [], l = Wo(c.next);
        continue;
      }
    if ((h.f & fr) !== 0 && (gd(h), o && (h.nodes?.a?.unfix(), (f ??= /* @__PURE__ */ new Set()).delete(h))), h !== l) {
      if (u !== void 0 && u.has(h)) {
        if (p.length < _.length) {
          var x = _[0], P;
          c = x.prev;
          var w = p[0], O = p[p.length - 1];
          for (P = 0; P < p.length; P += 1)
            oi(p[P], x, r);
          for (P = 0; P < _.length; P += 1)
            u.delete(_[P]);
          Fn(t, w.prev, O.next), Fn(t, c, w), Fn(t, O, x), l = x, c = O, y -= 1, p = [], _ = [];
        } else
          u.delete(h), oi(h, l, r), Fn(t, h.prev, h.next), Fn(t, h, c === null ? t.effect.first : c.next), Fn(t, c, h), c = h;
        continue;
      }
      for (p = [], _ = []; l !== null && l !== h; )
        (u ??= /* @__PURE__ */ new Set()).add(l), _.push(l), l = Wo(l.next);
      if (l === null)
        continue;
    }
    (h.f & mn) === 0 && p.push(h), c = h, l = Wo(h.next);
  }
  if (t.outrogroups !== null) {
    for (const E of t.outrogroups)
      E.pending.size === 0 && (bc($l(E.done)), t.outrogroups?.delete(E));
    t.outrogroups.size === 0 && (t.outrogroups = null);
  }
  if (l !== null || u !== void 0) {
    var k = [];
    if (u !== void 0)
      for (h of u)
        (h.f & fr) === 0 && k.push(h);
    for (; l !== null; )
      (l.f & fr) === 0 && l !== t.fallback && k.push(l), l = Wo(l.next);
    var $ = k.length;
    if ($ > 0) {
      var T = (n & Jm) !== 0 && i === 0 ? r : null;
      if (o) {
        for (y = 0; y < $; y += 1)
          k[y].nodes?.a?.measure();
        for (y = 0; y < $; y += 1)
          k[y].nodes?.a?.fix();
      }
      TP(t, k, T);
    }
  }
  o && Tr(() => {
    if (f !== void 0)
      for (h of f)
        h.nodes?.a?.apply();
  });
}
function MP(t, e, r, n, s, o, i, a) {
  var l = (i & cx) !== 0 ? (i & hx) === 0 ? /* @__PURE__ */ _v(r, !1, !1) : Xn(r) : null, u = (i & dx) !== 0 ? Xn(s) : null;
  return {
    v: l,
    i: u,
    e: Xt(() => (o(e, l ?? r, u ?? s, a), () => {
      t.delete(n);
    }))
  };
}
function oi(t, e, r) {
  if (t.nodes)
    for (var n = t.nodes.start, s = t.nodes.end, o = e && (e.f & mn) === 0 ? (
      /** @type {EffectNodes} */
      e.nodes.start
    ) : r; n !== null; ) {
      var i = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ sn(n)
      );
      if (o.before(n), n === s)
        return;
      n = i;
    }
}
function Fn(t, e, r) {
  e === null ? t.effect.first = r : e.next = r, r === null ? t.effect.last = e : r.prev = e;
}
function Q(t, e, r) {
  Ie && On();
  var n = new Di(t);
  Ls(() => {
    var s = e() ?? null;
    n.ensure(s, s && ((o) => r(o, s)));
  }, Pn);
}
function IP(t, e, r, n, s, o) {
  let i = Ie;
  Ie && On();
  var a = null;
  Ie && ze.nodeType === $x && (a = /** @type {Element} */
  ze, On());
  var l = (
    /** @type {TemplateNode} */
    Ie ? ze : t
  ), u = new Di(l, !1);
  Ls(() => {
    const c = e() || null;
    var f = Sx;
    if (c === null) {
      u.ensure(null, null);
      return;
    }
    return u.ensure(c, (p) => {
      if (c) {
        if (a = Ie ? (
          /** @type {Element} */
          a
        ) : document.createElementNS(f, c), Dr(a, a), n) {
          Ie && kP(c) && a.append(document.createComment(""));
          var _ = Ie ? /* @__PURE__ */ Ir(a) : a.appendChild(zt());
          Ie && (_ === null ? Bt(!1) : wt(_)), n(a, _);
        }
        Xe.nodes.end = a, p.before(a);
      }
      Ie && wt(p);
    }), () => {
    };
  }, Pn), hd(() => {
  }), i && (Bt(!0), wt(l));
}
function NP(t, e) {
  Fl(() => {
    var r = t.getRootNode(), n = (
      /** @type {ShadowRoot} */
      r.host ? (
        /** @type {ShadowRoot} */
        r
      ) : (
        /** @type {Document} */
        r.head ?? /** @type {Document} */
        r.ownerDocument.head
      )
    );
    if (!n.querySelector("#" + e.hash)) {
      const s = document.createElement("style");
      s.id = e.hash, s.textContent = e.code, n.appendChild(s);
    }
  });
}
function FP(t, e) {
  var r = void 0, n;
  Dv(() => {
    r !== (r = e()) && (n && (Ct(n), n = null), r && (n = Xt(() => {
      Fl(() => (
        /** @type {(node: Element) => void} */
        r(t)
      ));
    })));
  });
}
function Zv(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (r = Zv(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function so() {
  for (var t, e, r = 0, n = "", s = arguments.length; r < s; r++) (t = arguments[r]) && (e = Zv(t)) && (n && (n += " "), n += e);
  return n;
}
function js(t) {
  return typeof t == "object" ? so(t) : t ?? "";
}
const pg = [...` 	
\r\fÂ \v\uFEFF`];
function RP(t, e, r) {
  var n = t == null ? "" : "" + t;
  if (r) {
    for (var s in r)
      if (r[s])
        n = n ? n + " " + s : s;
      else if (n.length)
        for (var o = s.length, i = 0; (i = n.indexOf(s, i)) >= 0; ) {
          var a = i + o;
          (i === 0 || pg.includes(n[i - 1])) && (a === n.length || pg.includes(n[a])) ? n = (i === 0 ? "" : n.substring(0, i)) + n.substring(a + 1) : i = a;
        }
  }
  return n === "" ? null : n;
}
function mg(t, e = !1) {
  var r = e ? " !important;" : ";", n = "";
  for (var s in t) {
    var o = t[s];
    o != null && o !== "" && (n += " " + s + ": " + o + r);
  }
  return n;
}
function Su(t) {
  return t[0] !== "-" || t[1] !== "-" ? t.toLowerCase() : t;
}
function VP(t, e) {
  if (e) {
    var r = "", n, s;
    if (Array.isArray(e) ? (n = e[0], s = e[1]) : n = e, t) {
      t = String(t).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var o = !1, i = 0, a = !1, l = [];
      n && l.push(...Object.keys(n).map(Su)), s && l.push(...Object.keys(s).map(Su));
      var u = 0, c = -1;
      const g = t.length;
      for (var f = 0; f < g; f++) {
        var p = t[f];
        if (a ? p === "/" && t[f - 1] === "*" && (a = !1) : o ? o === p && (o = !1) : p === "/" && t[f + 1] === "*" ? a = !0 : p === '"' || p === "'" ? o = p : p === "(" ? i++ : p === ")" && i--, !a && o === !1 && i === 0) {
          if (p === ":" && c === -1)
            c = f;
          else if (p === ";" || f === g - 1) {
            if (c !== -1) {
              var _ = Su(t.substring(u, c).trim());
              if (!l.includes(_)) {
                p !== ";" && f++;
                var b = t.substring(u, f).trim();
                r += " " + b + ";";
              }
            }
            u = f + 1, c = -1;
          }
        }
      }
    }
    return n && (r += mg(n)), s && (r += mg(s, !0)), r = r.trim(), r === "" ? null : r;
  }
  return t == null ? null : String(t);
}
function Bs(t, e, r, n, s, o) {
  var i = t.__className;
  if (Ie || i !== r || i === void 0) {
    var a = RP(r, n, o);
    (!Ie || a !== t.getAttribute("class")) && (a == null ? t.removeAttribute("class") : e ? t.className = a : t.setAttribute("class", a)), t.__className = r;
  } else if (o && s !== o)
    for (var l in o) {
      var u = !!o[l];
      (s == null || u !== !!s[l]) && t.classList.toggle(l, u);
    }
  return o;
}
function xu(t, e = {}, r, n) {
  for (var s in r) {
    var o = r[s];
    e[s] !== o && (r[s] == null ? t.style.removeProperty(s) : t.style.setProperty(s, o, n));
  }
}
function LP(t, e, r, n) {
  var s = t.__style;
  if (Ie || s !== e) {
    var o = VP(e, n);
    (!Ie || o !== t.getAttribute("style")) && (o == null ? t.removeAttribute("style") : t.style.cssText = o), t.__style = e;
  } else n && (Array.isArray(n) ? (xu(t, r?.[0], n[0]), xu(t, r?.[1], n[1], "important")) : xu(t, r, n));
  return n;
}
function _c(t, e, r = !1) {
  if (t.multiple) {
    if (e == null)
      return;
    if (!kl(e))
      return jx();
    for (var n of t.options)
      n.selected = e.includes(vg(n));
    return;
  }
  for (n of t.options) {
    var s = vg(n);
    if (oP(s, e)) {
      n.selected = !0;
      return;
    }
  }
  (!r || e !== void 0) && (t.selectedIndex = -1);
}
function jP(t) {
  var e = new MutationObserver(() => {
    _c(t, t.__value);
  });
  e.observe(t, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), hd(() => {
    e.disconnect();
  });
}
function vg(t) {
  return "__value" in t ? t.__value : t.value;
}
const Go = /* @__PURE__ */ Symbol("class"), Yo = /* @__PURE__ */ Symbol("style"), Qv = /* @__PURE__ */ Symbol("is custom element"), ey = /* @__PURE__ */ Symbol("is html");
function ty(t) {
  if (Ie) {
    var e = !1, r = () => {
      if (!e) {
        if (e = !0, t.hasAttribute("value")) {
          var n = t.value;
          Cn(t, "value", null), t.value = n;
        }
        if (t.hasAttribute("checked")) {
          var s = t.checked;
          Cn(t, "checked", null), t.checked = s;
        }
      }
    };
    t.__on_r = r, Tr(r), kv();
  }
}
function BP(t, e) {
  var r = md(t);
  r.value === (r.value = // treat null and undefined the same for the initial value
  e ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  t.value === e && (e !== 0 || t.nodeName !== "PROGRESS") || (t.value = e ?? "");
}
function zs(t, e) {
  e ? t.hasAttribute("selected") || t.setAttribute("selected", "") : t.removeAttribute("selected");
}
function Cn(t, e, r, n) {
  var s = md(t);
  Ie && (s[e] = t.getAttribute(e), e === "src" || e === "srcset" || e === "href" && t.nodeName === "LINK") || s[e] !== (s[e] = r) && (e === "loading" && (t[kx] = r), r == null ? t.removeAttribute(e) : typeof r != "string" && ry(t).includes(e) ? t[e] = r : t.setAttribute(e, r));
}
function zP(t, e, r, n, s = !1, o = !1) {
  if (Ie && s && t.tagName === "INPUT") {
    var i = (
      /** @type {HTMLInputElement} */
      t
    ), a = i.type === "checkbox" ? "defaultChecked" : "defaultValue";
    a in r || ty(i);
  }
  var l = md(t), u = l[Qv], c = !l[ey];
  let f = Ie && u;
  f && Bt(!1);
  var p = e || {}, _ = t.tagName === "OPTION";
  for (var b in e)
    b in r || (r[b] = null);
  r.class ? r.class = js(r.class) : r[Go] && (r.class = null), r[Yo] && (r.style ??= null);
  var g = ry(t);
  for (const O in r) {
    let k = r[O];
    if (_ && O === "value" && k == null) {
      t.value = t.__value = "", p[O] = k;
      continue;
    }
    if (O === "class") {
      var h = t.namespaceURI === "http://www.w3.org/1999/xhtml";
      Bs(t, h, k, n, e?.[Go], r[Go]), p[O] = k, p[Go] = r[Go];
      continue;
    }
    if (O === "style") {
      LP(t, k, e?.[Yo], r[Yo]), p[O] = k, p[Yo] = r[Yo];
      continue;
    }
    var y = p[O];
    if (!(k === y && !(k === void 0 && t.hasAttribute(O)))) {
      p[O] = k;
      var S = O[0] + O[1];
      if (S !== "$$")
        if (S === "on") {
          const $ = {}, T = "$$" + O;
          let E = O.slice(2);
          var x = wP(E);
          if (bP(E) && (E = E.slice(0, -7), $.capture = !0), !x && y) {
            if (k != null) continue;
            t.removeEventListener(E, p[T], $), p[T] = null;
          }
          if (k != null)
            if (x)
              t[`__${E}`] = k, mP([E]);
            else {
              let M = function(R) {
                p[O].call(this, R);
              };
              p[T] = Wv(E, t, M, $);
            }
          else x && (t[`__${E}`] = void 0);
        } else if (O === "style")
          Cn(t, O, k);
        else if (O === "autofocus")
          aP(
            /** @type {HTMLElement} */
            t,
            !!k
          );
        else if (!u && (O === "__value" || O === "value" && k != null))
          t.value = t.__value = k;
        else if (O === "selected" && _)
          zs(
            /** @type {HTMLOptionElement} */
            t,
            k
          );
        else {
          var P = O;
          c || (P = xP(P));
          var w = P === "defaultValue" || P === "defaultChecked";
          if (k == null && !u && !w)
            if (l[O] = null, P === "value" || P === "checked") {
              let $ = (
                /** @type {HTMLInputElement} */
                t
              );
              const T = e === void 0;
              if (P === "value") {
                let E = $.defaultValue;
                $.removeAttribute(P), $.defaultValue = E, $.value = $.__value = T ? E : null;
              } else {
                let E = $.defaultChecked;
                $.removeAttribute(P), $.defaultChecked = E, $.checked = T ? E : !1;
              }
            } else
              t.removeAttribute(O);
          else w || g.includes(P) && (u || typeof k != "string") ? (t[P] = k, P in l && (l[P] = xt)) : typeof k != "function" && Cn(t, P, k);
        }
    }
  }
  return f && Bt(!0), p;
}
function ve(t, e, r = [], n = [], s = [], o, i = !1, a = !1) {
  mv(s, r, n, (l) => {
    var u = void 0, c = {}, f = t.nodeName === "SELECT", p = !1;
    if (Dv(() => {
      var b = e(...l.map(d)), g = zP(
        t,
        u,
        b,
        o,
        i,
        a
      );
      p && f && "value" in b && _c(
        /** @type {HTMLSelectElement} */
        t,
        b.value
      );
      for (let y of Object.getOwnPropertySymbols(c))
        b[y] || Ct(c[y]);
      for (let y of Object.getOwnPropertySymbols(b)) {
        var h = b[y];
        y.description === Qm && (!u || h !== u[y]) && (c[y] && Ct(c[y]), c[y] = Xt(() => FP(t, () => h))), g[y] = h;
      }
      u = g;
    }), f) {
      var _ = (
        /** @type {HTMLSelectElement} */
        t
      );
      Fl(() => {
        _c(
          _,
          /** @type {Record<string | symbol, any>} */
          u.value,
          !0
        ), jP(_);
      });
    }
    p = !0;
  });
}
function md(t) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    t.__attributes ??= {
      [Qv]: t.nodeName.includes("-"),
      [ey]: t.namespaceURI === wx
    }
  );
}
var yg = /* @__PURE__ */ new Map();
function ry(t) {
  var e = t.getAttribute("is") || t.nodeName, r = yg.get(e);
  if (r) return r;
  yg.set(e, r = []);
  for (var n, s = t, o = Element.prototype; o !== s; ) {
    n = ev(s);
    for (var i in n)
      n[i].set && r.push(i);
    s = Al(s);
  }
  return r;
}
let Pu = null;
function qP() {
  if (Pu === null) {
    var t = document.createElement("select");
    t.innerHTML = "<option><span>t</span></option>", Pu = /** @type {Element} */
    t.firstChild?.firstChild?.nodeType === 1;
  }
  return Pu;
}
function ny(t, e) {
  var r = Ie;
  qP() || (Bt(!1), t.textContent = "", t.append(iP("")));
  try {
    e();
  } finally {
    r && (Ie ? de(t) : (Bt(!0), wt(t)));
  }
}
function fo(t, e, r = e) {
  var n = /* @__PURE__ */ new WeakSet();
  $v(t, "input", async (s) => {
    var o = s ? t.defaultValue : t.value;
    if (o = Ou(t) ? Cu(o) : o, r(o), nt !== null && n.add(nt), await Rl(), o !== (o = e())) {
      var i = t.selectionStart, a = t.selectionEnd, l = t.value.length;
      if (t.value = o ?? "", a !== null) {
        var u = t.value.length;
        i === a && a === l && u > l ? (t.selectionStart = u, t.selectionEnd = u) : (t.selectionStart = i, t.selectionEnd = Math.min(a, u));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (Ie && t.defaultValue !== t.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  ot(e) == null && t.value) && (r(Ou(t) ? Cu(t.value) : t.value), nt !== null && n.add(nt)), Ei(() => {
    var s = e();
    if (t === document.activeElement) {
      var o = (
        /** @type {Batch} */
        dc ?? nt
      );
      if (n.has(o))
        return;
    }
    Ou(t) && s === Cu(t.value) || t.type === "date" && !s && !t.value || s !== t.value && (t.value = s ?? "");
  });
}
function Ou(t) {
  var e = t.type;
  return e === "number" || e === "range";
}
function Cu(t) {
  return t === "" ? null : +t;
}
function sy(t, e, r = e) {
  $v(t, "change", () => {
    r(t.files);
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  Ie && t.files && r(t.files), Ei(() => {
    t.files = e();
  });
}
function bg(t, e) {
  return t === e || t?.[Jr] === e;
}
function et(t = {}, e, r, n) {
  return Fl(() => {
    var s, o;
    return Ei(() => {
      s = o, o = [], ot(() => {
        t !== r(...o) && (e(t, ...o), s && bg(r(...s), t) && e(null, ...s));
      });
    }), () => {
      Tr(() => {
        o && bg(r(...o), t) && e(null, ...o);
      });
    };
  }), t;
}
function vd(t = !1) {
  const e = (
    /** @type {ComponentContextLegacy} */
    it
  ), r = e.l.u;
  if (!r) return;
  let n = () => pP(e.s);
  if (t) {
    let s = 0, o = (
      /** @type {Record<string, any>} */
      {}
    );
    const i = /* @__PURE__ */ Ai(() => {
      let a = !1;
      const l = e.s;
      for (const u in l)
        l[u] !== o[u] && (o[u] = l[u], a = !0);
      return a && s++, s;
    });
    n = () => d(i);
  }
  r.b.length && Co(() => {
    _g(e, n), uc(r.b);
  }), Ze(() => {
    const s = ot(() => r.m.map(Ox));
    return () => {
      for (const o of s)
        typeof o == "function" && o();
    };
  }), r.a.length && Ze(() => {
    _g(e, n), uc(r.a);
  });
}
function _g(t, e) {
  if (t.l.s)
    for (const r of t.l.s) d(r);
  e();
}
let Ki = !1;
function UP(t) {
  var e = Ki;
  try {
    return Ki = !1, [t(), Ki];
  } finally {
    Ki = e;
  }
}
const KP = {
  get(t, e) {
    if (!t.exclude.includes(e))
      return t.props[e];
  },
  set(t, e) {
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    if (!t.exclude.includes(e) && e in t.props)
      return {
        enumerable: !0,
        configurable: !0,
        value: t.props[e]
      };
  },
  has(t, e) {
    return t.exclude.includes(e) ? !1 : e in t.props;
  },
  ownKeys(t) {
    return Reflect.ownKeys(t.props).filter((e) => !t.exclude.includes(e));
  }
};
// @__NO_SIDE_EFFECTS__
function ie(t, e, r) {
  return new Proxy(
    { props: t, exclude: e },
    KP
  );
}
const HP = {
  get(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Ho(n) && (n = n()), typeof n == "object" && n !== null && e in n) return n[e];
    }
  },
  set(t, e, r) {
    let n = t.props.length;
    for (; n--; ) {
      let s = t.props[n];
      Ho(s) && (s = s());
      const o = bn(s, e);
      if (o && o.set)
        return o.set(r), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(t, e) {
    let r = t.props.length;
    for (; r--; ) {
      let n = t.props[r];
      if (Ho(n) && (n = n()), typeof n == "object" && n !== null && e in n) {
        const s = bn(n, e);
        return s && !s.configurable && (s.configurable = !0), s;
      }
    }
  },
  has(t, e) {
    if (e === Jr || e === od) return !1;
    for (let r of t.props)
      if (Ho(r) && (r = r()), r != null && e in r) return !0;
    return !1;
  },
  ownKeys(t) {
    const e = [];
    for (let r of t.props)
      if (Ho(r) && (r = r()), !!r) {
        for (const n in r)
          e.includes(n) || e.push(n);
        for (const n of Object.getOwnPropertySymbols(r))
          e.includes(n) || e.push(n);
      }
    return e;
  }
};
function ce(...t) {
  return new Proxy({ props: t }, HP);
}
function v(t, e, r, n) {
  var s = !So || (r & px) !== 0, o = (r & vx) !== 0, i = (r & yx) !== 0, a = (
    /** @type {V} */
    n
  ), l = !0, u = () => (l && (l = !1, a = i ? ot(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), a), c;
  if (o) {
    var f = Jr in t || od in t;
    c = bn(t, e)?.set ?? (f && e in t ? (x) => t[e] = x : void 0);
  }
  var p, _ = !1;
  o ? [p, _] = UP(() => (
    /** @type {V} */
    t[e]
  )) : p = /** @type {V} */
  t[e], p === void 0 && n !== void 0 && (p = u(), c && (s && Nx(), c(p)));
  var b;
  if (s ? b = () => {
    var x = (
      /** @type {V} */
      t[e]
    );
    return x === void 0 ? u() : (l = !0, x);
  } : b = () => {
    var x = (
      /** @type {V} */
      t[e]
    );
    return x !== void 0 && (a = /** @type {V} */
    void 0), x === void 0 ? a : x;
  }, s && (r & mx) === 0)
    return b;
  if (c) {
    var g = t.$$legacy;
    return (
      /** @type {() => V} */
      (function(x, P) {
        return arguments.length > 0 ? ((!s || !P || g || _) && c(P ? b() : x), x) : b();
      })
    );
  }
  var h = !1, y = ((r & gx) !== 0 ? Ai : ud)(() => (h = !1, b()));
  o && d(y);
  var S = (
    /** @type {Effect} */
    Xe
  );
  return (
    /** @type {() => V} */
    (function(x, P) {
      if (arguments.length > 0) {
        const w = P ? d(y) : s && o ? Pt(x) : x;
        return q(y, w), h = !0, a !== void 0 && (a = w), x;
      }
      return Jn && h || (S.f & _n) !== 0 ? y.v : d(y);
    })
  );
}
function WP(t) {
  return new GP(t);
}
class GP {
  /** @type {any} */
  #e;
  /** @type {Record<string, any>} */
  #t;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(e) {
    var r = /* @__PURE__ */ new Map(), n = (o, i) => {
      var a = /* @__PURE__ */ _v(i, !1, !1);
      return r.set(o, a), a;
    };
    const s = new Proxy(
      { ...e.props || {}, $$events: {} },
      {
        get(o, i) {
          return d(r.get(i) ?? n(i, Reflect.get(o, i)));
        },
        has(o, i) {
          return i === od ? !0 : (d(r.get(i) ?? n(i, Reflect.get(o, i))), Reflect.has(o, i));
        },
        set(o, i, a) {
          return q(r.get(i) ?? n(i, a), a), Reflect.set(o, i, a);
        }
      }
    );
    this.#t = (e.hydrate ? $P : pd)(e.component, {
      target: e.target,
      anchor: e.anchor,
      props: s,
      context: e.context,
      intro: e.intro ?? !1,
      recover: e.recover
    }), (!e?.props?.$$host || e.sync === !1) && m(), this.#e = s.$$events;
    for (const o of Object.keys(this.#t))
      o === "$set" || o === "$destroy" || o === "$on" || Za(this, o, {
        get() {
          return this.#t[o];
        },
        /** @param {any} value */
        set(i) {
          this.#t[o] = i;
        },
        enumerable: !0
      });
    this.#t.$set = /** @param {Record<string, any>} next */
    (o) => {
      Object.assign(s, o);
    }, this.#t.$destroy = () => {
      Xv(this.#t);
    };
  }
  /** @param {Record<string, any>} props */
  $set(e) {
    this.#t.$set(e);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(e, r) {
    this.#e[e] = this.#e[e] || [];
    const n = (...s) => r.call(this, ...s);
    return this.#e[e].push(n), () => {
      this.#e[e] = this.#e[e].filter(
        /** @param {any} fn */
        (s) => s !== n
      );
    };
  }
  $destroy() {
    this.#t.$destroy();
  }
}
let oy;
typeof HTMLElement == "function" && (oy = class extends HTMLElement {
  /** The Svelte component constructor */
  $$ctor;
  /** Slots */
  $$s;
  /** @type {any} The Svelte component instance */
  $$c;
  /** Whether or not the custom element is connected */
  $$cn = !1;
  /** @type {Record<string, any>} Component props data */
  $$d = {};
  /** `true` if currently in the process of reflecting component props back to attributes */
  $$r = !1;
  /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
  $$p_d = {};
  /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
  $$l = {};
  /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
  $$l_u = /* @__PURE__ */ new Map();
  /** @type {any} The managed render effect for reflecting attributes */
  $$me;
  /** @type {ShadowRoot | null} The ShadowRoot of the custom element */
  $$shadowRoot = null;
  /**
   * @param {*} $$componentCtor
   * @param {*} $$slots
   * @param {ShadowRootInit | undefined} shadow_root_init
   */
  constructor(t, e, r) {
    super(), this.$$ctor = t, this.$$s = e, r && (this.$$shadowRoot = this.attachShadow(r));
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  addEventListener(t, e, r) {
    if (this.$$l[t] = this.$$l[t] || [], this.$$l[t].push(e), this.$$c) {
      const n = this.$$c.$on(t, e);
      this.$$l_u.set(e, n);
    }
    super.addEventListener(t, e, r);
  }
  /**
   * @param {string} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} [options]
   */
  removeEventListener(t, e, r) {
    if (super.removeEventListener(t, e, r), this.$$c) {
      const n = this.$$l_u.get(e);
      n && (n(), this.$$l_u.delete(e));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let t = function(n) {
        return (s) => {
          const o = document.createElement("slot");
          n !== "default" && (o.name = n), A(s, o);
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const e = {}, r = YP(this);
      for (const n of this.$$s)
        n in r && (n === "default" && !this.$$d.children ? (this.$$d.children = t(n), e.default = !0) : e[n] = t(n));
      for (const n of this.attributes) {
        const s = this.$$g_p(n.name);
        s in this.$$d || (this.$$d[s] = Ua(s, n.value, this.$$p_d, "toProp"));
      }
      for (const n in this.$$p_d)
        !(n in this.$$d) && this[n] !== void 0 && (this.$$d[n] = this[n], delete this[n]);
      this.$$c = WP({
        component: this.$$ctor,
        target: this.$$shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: e,
          $$host: this
        }
      }), this.$$me = Tv(() => {
        Ei(() => {
          this.$$r = !0;
          for (const n of Ja(this.$$c)) {
            if (!this.$$p_d[n]?.reflect) continue;
            this.$$d[n] = this.$$c[n];
            const s = Ua(
              n,
              this.$$d[n],
              this.$$p_d,
              "toAttribute"
            );
            s == null ? this.removeAttribute(this.$$p_d[n].attribute || n) : this.setAttribute(this.$$p_d[n].attribute || n, s);
          }
          this.$$r = !1;
        });
      });
      for (const n in this.$$l)
        for (const s of this.$$l[n]) {
          const o = this.$$c.$on(n, s);
          this.$$l_u.set(s, o);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  /**
   * @param {string} attr
   * @param {string} _oldValue
   * @param {string} newValue
   */
  attributeChangedCallback(t, e, r) {
    this.$$r || (t = this.$$g_p(t), this.$$d[t] = Ua(t, r, this.$$p_d, "toProp"), this.$$c?.$set({ [t]: this.$$d[t] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
    });
  }
  /**
   * @param {string} attribute_name
   */
  $$g_p(t) {
    return Ja(this.$$p_d).find(
      (e) => this.$$p_d[e].attribute === t || !this.$$p_d[e].attribute && e.toLowerCase() === t
    ) || t;
  }
});
function Ua(t, e, r, n) {
  const s = r[t]?.type;
  if (e = s === "Boolean" && typeof e != "boolean" ? e != null : e, !n || !r[t])
    return e;
  if (n === "toAttribute")
    switch (s) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (s) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      // conversion already handled above
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function YP(t) {
  const e = {};
  return t.childNodes.forEach((r) => {
    e[
      /** @type {Element} node */
      r.slot || "default"
    ] = !0;
  }), e;
}
function K(t, e, r, n, s, o) {
  let i = class extends oy {
    constructor() {
      super(t, r, s), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Ja(e).map(
        (a) => (e[a].attribute || a).toLowerCase()
      );
    }
  };
  return Ja(e).forEach((a) => {
    Za(i.prototype, a, {
      get() {
        return this.$$c && a in this.$$c ? this.$$c[a] : this.$$d[a];
      },
      set(l) {
        l = Ua(a, l, e), this.$$d[a] = l;
        var u = this.$$c;
        if (u) {
          var c = bn(u, a)?.get;
          c ? u[a] = l : u.$set({ [a]: l });
        }
      }
    });
  }), n.forEach((a) => {
    Za(i.prototype, a, {
      get() {
        return this.$$c?.[a];
      }
    });
  }), t.element = /** @type {any} */
  i, i;
}
const Nr = "$ref", wg = "$id", Sg = "properties", XP = "items", iy = "dependencies", ay = "if", ly = "allOf", ro = "anyOf", no = "oneOf", JP = "__sjsf_rootSchema", jl = "__additional_property", uy = "data-url";
function ZP(t) {
  return t.properties !== void 0;
}
function QP(t) {
  return typeof t == "object" && !Array.isArray(t);
}
function eO(t, e) {
  return Array.from(new Array(t), (r, n) => e(n));
}
function xg(t) {
  return Array.from(new Set(t));
}
function ku(t, e) {
  const r = t.length;
  if (r === 0)
    return e;
  let n = e.length;
  if (n === 0)
    return t;
  if (r < n) {
    const o = t;
    t = e, e = o, n = r;
  }
  const s = new Set(t);
  for (let o = 0; o < n; o++)
    s.add(e[o]);
  return Array.from(s);
}
function tO(t, e) {
  const r = [];
  if (t.length === 0 || e.length === 0)
    return r;
  if (t.length > e.length) {
    const s = t;
    t = e, e = s;
  }
  const n = new Set(e);
  for (let s = 0; s < t.length && n.size > 0; s++) {
    const o = t[s];
    n.delete(o) && r.push(o);
  }
  return r;
}
function Ts(t) {
  return t !== null && typeof t == "object";
}
const rO = Object.prototype;
function hi(t) {
  const e = Object.getPrototypeOf(t);
  return e === rO || e === null;
}
function wc(t) {
  return Ts(t) && hi(t);
}
function Zr(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return !1;
  return !0;
}
const nO = [
  "array",
  "boolean",
  "integer",
  "null",
  "number",
  "object",
  "string"
], sO = new Set(nO);
function oO(t) {
  return sO.has(t);
}
const yd = [
  "$defs",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies"
];
new Set(yd);
const bd = [
  "items",
  "allOf",
  "oneOf",
  "anyOf"
];
new Set(bd);
const _d = [
  "items",
  "additionalItems",
  "additionalProperties",
  "propertyNames",
  "contains",
  "if",
  "then",
  "else",
  "not"
];
new Set(_d);
[
  ...yd,
  ...bd,
  ..._d
];
function er(t) {
  return typeof t == "object";
}
function Bn(t) {
  return er(t) ? Zr(t) : t === !0;
}
function Ka(t, e, r = { type: "root", path: [] }) {
  if (!er(t))
    return e(t, r);
  const n = {
    ...t
  };
  for (const i of bd) {
    const a = t[i];
    if (a === void 0 || !Array.isArray(a))
      continue;
    const l = {
      type: "array",
      parent: t,
      key: i,
      index: 0,
      path: r.path.concat(i, 0)
    };
    n[i] = a.map((u, c) => (l.index = c, l.path[l.path.length - 1] = c, Ka(u, e, l)));
  }
  const s = /* @__PURE__ */ new Map();
  for (const i of yd) {
    const a = t[i];
    if (a === void 0)
      continue;
    const l = {
      type: "record",
      parent: t,
      key: i,
      property: "",
      path: r.path.concat(i, "")
    }, u = Object.keys(a), c = u.length;
    for (let f = 0; f < c; f++) {
      const p = u[f], _ = a[p];
      if (Array.isArray(_)) {
        s.set(p, _);
        continue;
      }
      l.property = p, l.path[l.path.length - 1] = p, s.set(p, Ka(_, e, l));
    }
    n[i] = Object.fromEntries(s), s.clear();
  }
  const o = {
    type: "sub",
    parent: t,
    key: "items",
    path: r.path.concat("")
  };
  for (const i of _d) {
    const a = t[i];
    a === void 0 || Array.isArray(a) || (o.key = i, o.path[o.path.length - 1] = i, n[i] = Ka(a, e, o));
  }
  return e(n, r);
}
function cy(t, e) {
  return (r) => {
    if (t.has(r))
      return t.get(r);
    const n = e(r);
    return t.set(r, n), n;
  };
}
const Bl = cy;
function dy() {
}
function rl(t) {
  return t;
}
const fy = (t, e) => t ? fy(e % t, t) : e, iO = (t, e) => Math.abs(t * e) / fy(t, e);
function aO(t, e) {
  return t === e ? t : `^(?=.*(?:${t}))(?=.*(?:${e})).*$`;
}
function* $u(t, e, r) {
  const n = t.length, s = e.length;
  if (n > 0 && s > 0)
    for (let o = 0; o < n; o++) {
      const i = t[o];
      for (let a = 0; a < s; a++)
        yield r(i, e[a]);
    }
}
function Au(t, e) {
  return t || e;
}
function Pg(t) {
  return (e, r) => {
    const n = { ...e }, s = Object.keys(r), o = s.length;
    for (let i = 0; i < o; i++) {
      const a = s[i];
      n[a] = e[a] === void 0 ? r[a] : t(e[a], r[a]);
    }
    return n;
  };
}
function lO(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t)
    for (const n of r[0])
      e.set(n, r[1]);
  return e;
}
function hs(t, e, r) {
  r === void 0 || Bn(r) ? delete t[e] : t[e] = r;
}
const uO = [
  "properties",
  "patternProperties",
  "additionalProperties"
];
function Og(t) {
  const e = Object.keys(t), r = e.length, n = [];
  for (let s = 0; s < r; s++) {
    const o = e[s];
    n.push({
      regExp: new RegExp(o),
      schema: t[o]
    });
  }
  return [n, e];
}
const Cg = [[], []];
function kg(t, e, r) {
  const n = r.length;
  for (let s = 0; s < n; s++) {
    const o = r[s];
    if (!o.regExp.test(e))
      continue;
    const i = o.schema;
    if (i === !1)
      return !0;
    t.push(i);
  }
  return !1;
}
const cO = [
  "items",
  "additionalItems"
], dO = [
  "if",
  "then",
  "else"
];
function $g(t, e) {
  return e.if !== void 0 && (t.if = e.if), e.then !== void 0 && (t.then = e.then), e.else !== void 0 && (t.else = e.else), t;
}
function Eu(t, e) {
  if (t === e)
    return t;
  switch (t) {
    case "number":
      if (e === "integer")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    case "integer":
      if (e === "number")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    default:
      return;
  }
}
function gs(t, e, r) {
  return [t, e, r];
}
function fO(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [r, n, s] of t) {
    const o = (i) => {
      if (!s(i))
        throw new Error(`Schema keys '${r}' and '${n}' are conflicting (${r}: ${JSON.stringify(i[r])}, ${n}: ${JSON.stringify(i[n])})`);
    };
    for (const i of [
      [r, n],
      [n, r]
    ]) {
      let a = e.get(i[0]);
      a === void 0 && (a = [], e.set(i[0], a)), a.push({ oppositeKey: i[1], check: o });
    }
  }
  return e;
}
const hO = [
  gs("minimum", "maximum", (t) => t.maximum >= t.minimum),
  gs("exclusiveMinimum", "maximum", (t) => t.maximum > t.exclusiveMinimum),
  gs("minimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.minimum),
  gs("exclusiveMinimum", "exclusiveMaximum", (t) => t.exclusiveMaximum > t.exclusiveMinimum),
  gs("minLength", "maxLength", (t) => t.maxLength >= t.minLength),
  gs("minItems", "maxItems", (t) => t.maxItems >= t.minItems),
  gs("minProperties", "maxProperties", (t) => t.maxProperties >= t.minProperties)
];
function gO({ mergePatterns: t = aO, isSubRegExp: e = Object.is, intersectJson: r = tO, deduplicateJsonSchemaDef: n = rl, defaultMerger: s = rl, assigners: o = [], mergers: i, checks: a = hO } = {}) {
  function l(P) {
    const w = P.length;
    let O = P[0];
    for (let k = 1; k < w; k++) {
      const $ = y(O, P[k]);
      if ($ === !1)
        return !1;
      Bn($) || (O = $);
    }
    return O;
  }
  function u(P, w, O, k, $, T, E) {
    if (P.length = 0, O === !1)
      return !1;
    if (P.push(O), $ !== void 0) {
      if ($ === !1)
        return !1;
      P.push($);
    }
    if (kg(P, w, T))
      return !1;
    const R = P.length < 2;
    if (E === !1) {
      if (R)
        return;
      if (kg(P, w, k))
        return !1;
    } else R && E !== void 0 && P.push(E);
    return P.length === 1 ? P[0] : l(P);
  }
  function c(P, w, O, k, $, T) {
    const E = O.length;
    if (E > 0 && $ !== !1)
      if (T)
        Object.assign(P, w);
      else
        for (let M = 0; M < E; M++) {
          const R = O[M];
          k.has(R) || (P[R] = y(w[R], $));
        }
    return P;
  }
  const f = (P, { properties: w = {}, patternProperties: O, additionalProperties: k = !0 }, { properties: $ = {}, patternProperties: T, additionalProperties: E = !0 }) => {
    const M = Bn(k), R = Bn(E);
    if (M && R)
      return hs(P, "properties", S(w, $)), hs(P, "patternProperties", O && T ? S(O, T) : O ?? T), delete P.additionalProperties, P;
    const U = y(k, E);
    hs(P, "additionalProperties", U);
    const B = {}, F = Object.keys(w), Z = F.length, [Y, X] = O ? Og(O) : Cg, [ae, J] = T ? Og(T) : Cg, j = [], ee = /* @__PURE__ */ new Set(), L = R ? void 0 : E;
    for (let we = 0; we < Z; we++) {
      const le = F[we];
      ee.add(le);
      const re = u(j, le, w[le], Y, $[le], ae, L);
      re !== void 0 && (B[le] = re);
    }
    const N = Object.keys($), V = N.length, G = M ? void 0 : k;
    for (let we = 0; we < V; we++) {
      const le = N[we];
      if (ee.has(le))
        continue;
      const re = u(j, le, $[le], ae, void 0, Y, G);
      re !== void 0 && (B[le] = re);
    }
    hs(P, "properties", B);
    let fe = {};
    const se = /* @__PURE__ */ new Set();
    if (X.length > 0 && J.length > 0) {
      const we = $u(X, J, (le, re) => {
        e(le, re) && se.add(le), e(re, le) && se.add(re), fe[t(le, re)] = y(O[le], T[re]);
      });
      for (; !we.next().done; )
        ;
    }
    return fe = c(fe, O, X, se, E, R), fe = c(fe, T, J, se, k, M), hs(P, "patternProperties", fe), P;
  }, p = (P, { items: w = [], additionalItems: O }, { items: k = [], additionalItems: $ }) => {
    const T = Array.isArray(w), E = Array.isArray(k), M = [];
    if (P.items = M, T && E) {
      const [R, U, B] = w.length < k.length ? [w.length, O, k] : [k.length, $, w];
      let F = 0;
      for (; F < R; F++)
        M.push(y(w[F], k[F]));
      if (U === !1)
        P.additionalItems = !1;
      else {
        const Z = U === void 0 || Bn(U);
        for (; F < B.length; F++)
          M.push(Z ? B[F] : y(B[F], U));
        hs(P, "additionalItems", O !== void 0 && $ !== void 0 ? y(O, $) : O ?? $);
      }
    } else if (T || E) {
      const [R, U, B] = T ? [w, k, O] : [k, w, $];
      hs(P, "additionalItems", B && y(B, U));
      for (let F = 0; F < R.length; F++)
        M.push(y(R[F], U));
    } else
      delete P.additionalItems, P.items = y(w, k);
    return P;
  }, _ = (P, w, O) => {
    $g(P, w);
    const k = $g({}, O);
    return P.allOf === void 0 ? P.allOf = [k] : P.allOf = P.allOf.concat(k), P;
  };
  function b(P, w) {
    return n(Array.from($u(P, w, y)));
  }
  const g = lO([
    [uO, f],
    [cO, p],
    [dO, _],
    ...o
  ]), h = fO(a);
  function y(P, w) {
    if (P === !1 || w === !1)
      return !1;
    if (Bn(P))
      return Bn(w) ? !0 : w;
    if (Bn(w))
      return P;
    let O = { ...P };
    const k = /* @__PURE__ */ new Set(), $ = /* @__PURE__ */ new Set(), T = Object.keys(w), E = T.length;
    for (let M = 0; M < E; M++) {
      const R = T[M], U = w[R];
      if (U === void 0)
        continue;
      const B = h.get(R);
      if (B !== void 0) {
        const X = B.length;
        for (let ae = 0; ae < X; ae++) {
          const J = B[ae];
          P[J.oppositeKey] !== void 0 && $.add(J.check);
        }
      }
      const F = P[R];
      if (F === void 0) {
        O[R] = U;
        continue;
      }
      const Z = g.get(R);
      if (Z) {
        k.add(Z);
        continue;
      }
      const Y = x[R] ?? s;
      O[R] = Y(F, U);
    }
    for (const M of k)
      O = M(O, P, w);
    for (const M of $)
      M(O);
    return O;
  }
  const S = Pg(y), x = {
    $id: s,
    $ref: s,
    $schema: s,
    $comment: s,
    $defs: S,
    definitions: S,
    type: (P, w) => {
      if (P === w)
        return P;
      const O = Array.isArray(P), k = Array.isArray(w);
      if (!O && !k) {
        const $ = Eu(P, w);
        if ($ !== void 0)
          return $;
      } else if (O || k) {
        const $ = /* @__PURE__ */ new Set();
        if (O && k)
          for (const E of $u(P, w, Eu))
            E !== void 0 && $.add(E);
        else {
          const E = O ? P : w, M = O ? w : P, R = E.length;
          for (let U = 0; U < R; U++) {
            const B = Eu(M, E[U]);
            B !== void 0 && $.add(B);
          }
        }
        const T = $.size;
        if (T === 1)
          return $.values().next().value;
        if (T > 1)
          return Array.from($);
      }
      throw new Error(`It is not possible to create an intersection of the following incompatible types: ${P.toString()}, ${w.toString()}`);
    },
    default: s,
    description: s,
    title: s,
    const: s,
    format: s,
    contentEncoding: s,
    contentMediaType: s,
    not: (P, w) => {
      const O = n([P, w]);
      return O.length === 1 ? O[0] : { anyOf: O };
    },
    pattern: t,
    readOnly: Au,
    writeOnly: Au,
    enum: (P, w) => {
      const O = r(P, w);
      if (O.length === 0)
        throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(P)}", "${JSON.stringify(w)}"`);
      return O;
    },
    anyOf: b,
    oneOf: b,
    allOf: (P, w) => n(P.concat(w)),
    propertyNames: y,
    contains: y,
    dependencies: Pg((P, w) => Array.isArray(P) ? Array.isArray(w) ? ku(P, w) : y(w, { required: P }) : Array.isArray(w) ? y(P, { required: w }) : y(P, w)),
    examples: (P, w) => {
      if (!Array.isArray(P) || !Array.isArray(w))
        throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(P)}" and "${JSON.stringify(w)}"`);
      return ku(P, w);
    },
    multipleOf: (P, w) => {
      let O = 1;
      for (; !Number.isInteger(P) || !Number.isInteger(w); )
        O *= 10, P *= 10, w *= 10;
      return iO(P, w) / O;
    },
    exclusiveMaximum: Math.min,
    maximum: Math.min,
    maxItems: Math.min,
    maxLength: Math.min,
    maxProperties: Math.min,
    exclusiveMinimum: Math.max,
    minimum: Math.max,
    minItems: Math.max,
    minLength: Math.max,
    minProperties: Math.max,
    uniqueItems: Au,
    required: ku,
    ...i
  };
  return {
    mergeSchemaDefinitions: y,
    mergeArrayOfSchemaDefinitions: l
  };
}
function pO(t) {
  const e = [], r = [t];
  for (; r.length > 0; ) {
    const n = r.pop();
    if (typeof n == "boolean" || n.allOf === void 0) {
      e.push(n);
      continue;
    }
    const { allOf: s, ...o } = n;
    e.push(o);
    for (let i = s.length - 1; i >= 0; i--)
      r.push(s[i]);
  }
  return e;
}
function mO(t) {
  return (e) => t(pO(e));
}
function gi(t) {
  if (t === null)
    return "null";
  if (Array.isArray(t))
    return "array";
  const e = typeof t;
  switch (e) {
    case "boolean":
    // TODO: Integer type inference ?
    // eslint-disable-next-line no-fallthrough
    case "number":
    case "object":
    case "string":
      return e;
    default:
      return "unknown";
  }
}
function zl(t) {
  if (t.type)
    return t.type;
  if (t.const !== void 0)
    return gi(t.const);
  if (t.properties || t.additionalProperties || t.propertyNames || t.patternProperties)
    return "object";
  if (Array.isArray(t.enum) && t.enum.length > 0)
    return xg(t.enum.map(gi));
  const e = t.allOf ?? t.anyOf ?? t.oneOf;
  if (e) {
    let r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      er(s) && (r = r.concat(zl(s)));
    }
    return xg(r);
  }
  return "unknown";
}
function vO(t) {
  return t === "null" || Array.isArray(t) && t.includes("null");
}
function hy(t) {
  return vO(zl(t));
}
function yO(t) {
  if (t.length === 0)
    throw new Error("Unsupported schema types: empty type array");
  const e = t[0];
  return t.length === 1 ? e : e === "null" ? t[1] : e;
}
const ho = (t) => {
  const e = zl(t);
  return Array.isArray(e) ? yO(e) : e;
};
function Ag(t) {
  return t === "boolean" || t === "integer" || t === "number" || t === "string" || t === "null";
}
function bO(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Xo = {}, Eg;
function _O() {
  if (Eg) return Xo;
  Eg = 1;
  var t = /~/, e = /~[01]/g;
  function r(u) {
    switch (u) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + u);
  }
  function n(u) {
    return t.test(u) ? u.replace(e, r) : u;
  }
  function s(u, c, f) {
    for (var p, _, b = 1, g = c.length; b < g; ) {
      if (c[b] === "constructor" || c[b] === "prototype" || c[b] === "__proto__") return u;
      if (p = n(c[b++]), _ = g > b, typeof u[p] > "u" && (Array.isArray(u) && p === "-" && (p = u.length), _ && (c[b] !== "" && c[b] < 1 / 0 || c[b] === "-" ? u[p] = [] : u[p] = {})), !_) break;
      u = u[p];
    }
    var h = u[p];
    return f === void 0 ? delete u[p] : u[p] = f, h;
  }
  function o(u) {
    if (typeof u == "string") {
      if (u = u.split("/"), u[0] === "") return u;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(u)) {
      for (const c of u)
        if (typeof c != "string" && typeof c != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return u;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function i(u, c) {
    if (typeof u != "object") throw new Error("Invalid input object.");
    c = o(c);
    var f = c.length;
    if (f === 1) return u;
    for (var p = 1; p < f; ) {
      if (u = u[n(c[p++])], f === p) return u;
      if (typeof u != "object" || u === null) return;
    }
  }
  function a(u, c, f) {
    if (typeof u != "object") throw new Error("Invalid input object.");
    if (c = o(c), c.length === 0) throw new Error("Invalid JSON pointer for set.");
    return s(u, c, f);
  }
  function l(u) {
    var c = o(u);
    return {
      get: function(f) {
        return i(f, c);
      },
      set: function(f, p) {
        return a(f, c, p);
      }
    };
  }
  return Xo.get = i, Xo.set = a, Xo.compile = l, Xo;
}
var wO = _O();
const SO = /* @__PURE__ */ bO(wO);
function gy(t, e) {
  if (!t.startsWith("#"))
    throw new Error(`Invalid reference: ${t}, must start with #`);
  const r = SO.get(e, decodeURIComponent(t.substring(1)));
  if (r === void 0)
    throw new Error(`Could not find a definition for ${t}.`);
  return r;
}
function wd(t, e, r, n = /* @__PURE__ */ new Set()) {
  const s = gy(e, r);
  if (!er(s))
    throw new Error(`Definition for ${e} should be a schema (object)`);
  const o = s[Nr];
  if (o) {
    if (n.has(o)) {
      if (n.size === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const u = Array.from(n), c = u[0];
      throw u.push(e, c), new Error(`Definition for ${c} contains a circular reference through ${u.join(" -> ")}`);
    }
    const i = wd(t, o, r, new Set(n).add(e));
    if (Object.keys(s).length < 2)
      return i;
    const { [Nr]: a, ...l } = s;
    return t.mergeSchemas(l, i);
  }
  return s;
}
function Be(t) {
  return wc(t);
}
function xO(t) {
  return Array.isArray(t);
}
function Sc(t) {
  if (typeof t == "string" || Array.isArray(t))
    return t.length === 0;
  if (!Ts(t))
    return !0;
  if (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
    return t.byteLength === 0;
  const e = Object.getPrototypeOf(t);
  return e === Object.prototype || e === null ? Zr(t) : Object.prototype.hasOwnProperty.call(e, "size") ? t.size === 0 : !0;
}
function Tg(t) {
  return typeof t == "string" ? t : JSON.stringify(t);
}
function Ds(t) {
  return t.discriminator?.propertyName;
}
function py(t, e, r) {
  if (r && Be(t)) {
    const n = t[r];
    if (n === void 0)
      return;
    for (let s = 0; s < e.length; s++) {
      const i = e[s].properties?.[r] ?? {};
      if (i === !0)
        return s;
      if (!(i === !1 || i.type === "object" || i.type === "array") && (i.const === n || i.enum?.includes(n)))
        return s;
    }
  }
}
function PO({ required: t, ...e }) {
  return {
    allOf: [
      e,
      {
        anyOf: Object.keys(e.properties).map((r) => ({
          required: [r]
        }))
      }
    ]
  };
}
const OO = /* @__PURE__ */ new WeakMap(), CO = Bl(OO, PO);
function my(t, e, r, n, s, o) {
  if (!ZP(t))
    return e.isValid(t, n, r);
  const i = s !== void 0 ? t.properties[s] : void 0;
  return i !== void 0 ? e.isValid(i, n, o) : e.isValid(CO(t), n, r);
}
function kO(t, e, r, n, s) {
  if (e === void 0)
    return 0;
  const o = py(e, r, s);
  if (o !== void 0)
    return o;
  const i = Be(e) && s !== void 0;
  for (let a = 0; a < r.length; a++)
    if (my(r[a], t, e, n, i ? s : void 0, i ? e[s] : void 0))
      return a;
  return 0;
}
function xc(t, e, r, n, s) {
  let o = 0;
  if (n) {
    const i = n.properties;
    if (i && Be(s))
      for (const [a, l] of Object.entries(i)) {
        const u = s[a];
        if (typeof l == "boolean")
          continue;
        if (l[Nr] !== void 0) {
          const f = Fr(t, e, l, r, u);
          o += xc(t, e, r, f, u);
          continue;
        }
        const c = l.oneOf || l.anyOf;
        if (c && u) {
          const f = Ds(l);
          o += pi(t, e, r, u, c.filter(er), -1, f);
          continue;
        }
        if (l.type === "object") {
          Be(u) && (o += 1), o += xc(t, e, r, l, u);
          continue;
        }
        if (u !== void 0 && l.type === gi(u)) {
          o += 1;
          const f = l.default ?? l.const;
          f !== void 0 && (o += u === f ? 1 : -1);
          continue;
        }
      }
    else s !== void 0 && typeof n.type == "string" && n.type === gi(s) && (o += 1);
  }
  return o;
}
function pi(t, e, r, n, s, o = -1, i) {
  if (s.length === 0)
    return o;
  const a = s.map((_) => Ps(e, _, r)), l = py(n, s, i);
  if (typeof l == "number")
    return l;
  const u = [];
  if (n !== void 0) {
    const _ = Be(n) && i !== void 0;
    for (let b = 0; b < a.length; b++)
      my(a[b], t, n, r, _ ? i : void 0, _ ? n[i] : void 0) && u.push(b);
    if (u.length === 1)
      return u[0];
  }
  if (u.length === 0)
    for (let _ = 0; _ < a.length; _++)
      u.push(_);
  const c = /* @__PURE__ */ new Set();
  let f = 0, p = o;
  for (let _ = 0; _ < u.length; _++) {
    const b = u[_], g = a[b], h = xc(t, e, r, g, n);
    c.add(h), h > f && (f = h, p = b);
  }
  return u.length > 1 && c.size === 1 && o >= 0 ? o : p;
}
function $O(t, e, r) {
  const n = Object.keys(t);
  let s;
  for (let o = n.length; o-- !== 0; )
    if (s = n[o], !r(t[s], e[s]))
      return !1;
  return Object.keys(e).length === n.length;
}
function AO(t, e, r) {
  const n = Object.keys(t), s = Object.keys(e);
  if (n.length !== s.length)
    return !1;
  let o;
  for (let i = n.length; i-- !== 0; )
    if (o = n[i], o !== s[i] || !r(t[o], e[o]))
      return !1;
  return !0;
}
function vy(t) {
  return function e(r, n) {
    if (r === n)
      return !0;
    if (Ts(r) && Ts(n)) {
      if (Array.isArray(r)) {
        if (!Array.isArray(n))
          return !1;
        const { length: s } = r;
        if (s !== n.length)
          return !1;
        for (let o = s; o-- !== 0; )
          if (!ql(r[o], n[o]))
            return !1;
        return !0;
      }
      return Array.isArray(n) || !hi(r) || !hi(n) ? !1 : t(r, n, e);
    }
    return r !== r && n !== n;
  };
}
const ql = vy($O), EO = ql, TO = vy(AO);
function Fr(t, e, r, n = {}, s, o = !1) {
  return Hr(t, e, r, n, s, void 0, void 0, o)[0];
}
function Ps(t, e, r, n = /* @__PURE__ */ new Set(), s) {
  let o = e;
  const i = o[Nr];
  if (i) {
    if (n.has(i))
      return o;
    n.add(i);
    const { [Nr]: u, ...c } = o, f = wd(t, i, r);
    return Ps(t, Zr(c) ? f : t.mergeSchemas(f, c), r, n, s);
  }
  const a = o[Sg];
  if (a) {
    const u = /* @__PURE__ */ new Map(), c = [];
    for (const [p, _] of Object.entries(a))
      if (typeof _ == "boolean")
        u.set(p, _);
      else {
        const b = new Set(n);
        u.set(p, Ps(t, _, r, b, s)), c.push(b);
      }
    const f = n.size;
    for (const p of c)
      p.size !== f && p.forEach(n.add, n);
    o = {
      ...o,
      [Sg]: Object.fromEntries(u)
    };
  }
  const l = o[XP];
  if (l && !Array.isArray(l) && typeof l != "boolean" && (o = {
    ...o,
    items: Ps(t, l, r, n, s)
  }), s) {
    let u, c;
    ro in e && Array.isArray(e[ro]) ? (u = ro, c = o[ro]) : no in e && Array.isArray(e[no]) && (u = no, c = o[no]), u && c && (o = {
      ...o,
      [u]: c.map((f) => typeof f == "boolean" ? f : Ps(t, f, r, n, s))
    });
  }
  return o;
}
function yy(t, e, r, n, s, o, i, a) {
  const l = Ps(e, r, n, o, a);
  return EO(r, l) ? [r] : Hr(t, e, l, n, i, s, o, a);
}
function Hr(t, e, r, n, s, o = !1, i = /* @__PURE__ */ new Set(), a) {
  return IO(t, e, r, n, o, i, s, a).flatMap((u) => {
    let c = u;
    if (ay in c)
      return DO(t, e, c, n, o, i, s);
    const f = c.allOf;
    if (f) {
      if (o) {
        const { allOf: y, ...S } = c, x = [];
        for (let P = 0; P < f.length; P++) {
          const w = f[P];
          typeof w != "boolean" && x.push(w);
        }
        return x.push(S), x;
      }
      try {
        const y = [], S = [];
        c.allOf?.forEach((x) => {
          er(x) && x.contains ? y.push(x) : S.push(x);
        }), y.length && (c = { ...c, allOf: S }), c = e.mergeAllOf(c), y.length && (c.allOf = y);
      } catch (y) {
        console.warn(`could not merge subschemas in allOf:
`, y);
        const { allOf: S, ...x } = c;
        return x;
      }
    }
    const p = c.patternProperties, _ = p !== void 0, b = c.additionalProperties !== void 0 && c.additionalProperties !== !1;
    if (!_ && !b)
      return c;
    const g = { ...c.properties }, h = Be(s);
    if (_)
      for (const y of Object.keys(g)) {
        const S = Sy(p, y);
        S.length > 0 && (S.push(g[y]), g[y] = Fr(t, e, { allOf: S }, n, h ? s[y] : void 0));
      }
    return MO(t, e, {
      ...c,
      properties: g
    }, n, h ? s : void 0);
  });
}
function DO(t, e, r, n, s, o, i) {
  const { if: a, then: l, else: u, ...c } = r, f = a !== void 0 && t.isValid(a, n, i || {});
  let p = [c], _ = [];
  if (s)
    l && typeof l != "boolean" && (_ = _.concat(Hr(t, e, l, n, i, s, o))), u && typeof u != "boolean" && (_ = _.concat(Hr(t, e, u, n, i, s, o)));
  else {
    const b = f ? l : u;
    b && typeof b != "boolean" && (_ = _.concat(Hr(t, e, b, n, i, s, o)));
  }
  return _.length && (p = Zr(c) ? _ : _.map((b) => e.mergeSchemas(c, b))), p.flatMap((b) => Hr(t, e, b, n, i, s, o));
}
function MO(t, e, r, n, s) {
  const { additionalProperties: o, patternProperties: i } = r, a = typeof o != "boolean" && o, l = o === !0 || a && Object.keys(o).length === 0;
  function u(c) {
    if (i !== void 0) {
      const f = Sy(i, c);
      if (f.length > 0)
        return {
          ...Fr(t, e, { allOf: f }, n, s?.[c])
        };
    }
    if (a) {
      if (Nr in o)
        return {
          ...Fr(t, e, { $ref: o[Nr] }, n, s)
        };
      if ("type" in o)
        return { ...o };
      if (ro in o || no in o)
        return {
          type: "object",
          ...o
        };
    }
    if (l) {
      const f = s?.[c];
      if (f !== void 0) {
        const p = gi(f);
        return oO(p) ? { type: p } : {};
      }
    }
    return { type: "null" };
  }
  if (s !== void 0)
    for (const c of Object.keys(s)) {
      if (c in r.properties)
        continue;
      const f = u(c);
      f[jl] = !0, r.properties[c] = f;
    }
  return r;
}
function IO(t, e, r, n, s, o, i, a) {
  const l = yy(t, e, r, n, s, o, i, a);
  if (l.length > 1 || l[0] !== r)
    return l;
  if (iy in r)
    return by(t, e, r, n, s, o, i).flatMap((c) => Hr(t, e, c, n, i, s, o));
  if (ly in r && Array.isArray(r.allOf)) {
    const u = r.allOf.filter((f) => typeof f != "boolean").map((f) => Hr(t, e, f, n, i, s, o));
    return wy(u).map((f) => ({
      ...r,
      allOf: f
    }));
  }
  return [r];
}
function by(t, e, r, n, s, o, i) {
  const { dependencies: a, ...l } = r;
  return NO(t, e, l, n, s, i).flatMap((c) => _y(t, e, a, c, n, s, o, i));
}
function NO(t, e, r, n, s, o) {
  let i;
  const { oneOf: a, anyOf: l, ...u } = r;
  if (Array.isArray(a) ? i = a : Array.isArray(l) && (i = l), i) {
    const c = o === void 0 && s ? {} : o, f = Ds(r);
    i = i.map((b) => Ps(e, b, n));
    const p = kO(t, c, i, n, f), _ = Zr(u);
    if (s)
      return _ ? i : i.map((b) => e.mergeSchemas(u, b));
    r = _ ? i[p] : e.mergeSchemas(u, i[p]);
  }
  return [r];
}
function _y(t, e, r, n, s, o, i, a) {
  let l = [n];
  for (const u in r) {
    if (!o && (!Be(a) || a[u] === void 0) || n.properties && !(u in n.properties))
      continue;
    const { [u]: c, ...f } = r;
    return Array.isArray(c) ? l[0] = e.mergeSchemas(n, {
      required: c
    }) : typeof c != "boolean" && c && (l = FO(t, e, n, s, u, c, o, i, a)), l.flatMap((p) => _y(t, e, f, p, s, o, i, a));
  }
  return l;
}
function FO(t, e, r, n, s, o, i, a, l) {
  return Hr(t, e, o, n, l, i, a).flatMap((c) => {
    const { oneOf: f, ...p } = c, _ = Zr(p) ? r : e.mergeSchemas(r, p);
    if (f === void 0)
      return _;
    const b = f.map((h) => typeof h == "boolean" || !(Nr in h) ? [h] : yy(t, e, h, n, i, a, l));
    return wy(b).flatMap((h) => RO(t, e, _, n, s, h, i, a, l));
  });
}
function RO(t, e, r, n, s, o, i, a, l) {
  const u = o.filter((c) => {
    if (typeof c == "boolean" || !c || !c.properties)
      return !1;
    const { [s]: f } = c.properties;
    if (f) {
      const p = {
        type: "object",
        properties: {
          [s]: f
        }
      };
      return t.isValid(p, n, l) || i;
    }
    return !1;
  });
  return !i && u.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [r]) : u.flatMap((c) => {
    const f = c, { [s]: p, ..._ } = f.properties, b = { ...f, properties: _ };
    return Hr(t, e, b, n, l, i, a).map((h) => e.mergeSchemas(r, h));
  });
}
function wy(t) {
  return t.reduce(
    (r, n) => n.length > 1 ? n.flatMap((s) => eO(r.length, (o) => [...r[o]].concat(s))) : (r.forEach((s) => s.push(n[0])), r),
    [[]]
    // Start with an empty list
  );
}
function Sy(t, e) {
  const r = [];
  for (const [n, s] of Object.entries(t))
    new RegExp(n).test(e) && r.push(s);
  return r;
}
function Sd(t) {
  return t.const !== void 0 || Array.isArray(t.enum) && t.enum.length === 1;
}
function xy(t) {
  const e = t.enum;
  if (Array.isArray(e) && e.length === 1)
    return e[0];
  const r = t.const;
  if (r !== void 0)
    return r;
  throw new Error("schema cannot be inferred as a constant");
}
function xd(t, e, r, n) {
  const s = Fr(t, e, r, n);
  if (Array.isArray(s.enum))
    return !0;
  const o = s.oneOf || s.anyOf;
  return Array.isArray(o) ? o.every((i) => typeof i != "boolean" && Sd(i)) : !1;
}
function VO({ enum: t, oneOf: e, anyOf: r }) {
  if (t !== void 0)
    return t;
  const n = e ?? r;
  if (n !== void 0)
    return n.map((s, o) => {
      if (!er(s))
        throw new Error(`Invalid enum definition in altSchema.${o}`);
      return xy(s);
    });
}
function Py(t, e, { items: r, uniqueItems: n }, s) {
  return n === !0 && Be(r) && xd(t, e, r, s);
}
function Oy(t) {
  const { items: e } = t;
  return Array.isArray(e) && e.length > 0 && e.every(Be);
}
function Dg(t) {
  return t == null;
}
function mi(t, e, r = !1, n = !1, s = !1) {
  if (Array.isArray(e)) {
    const o = Array.isArray(t) ? t : [], i = s ? o : e, a = s ? e : o, l = i.map((u, c) => a[c] !== void 0 ? mi(o[c], e[c], r, n, s) : u);
    return (r || s) && l.length < a.length && l.push(...a.slice(l.length)), l;
  }
  if (Be(e)) {
    const o = Object.assign({}, t), i = Be(t) ? t : {};
    for (const [a, l] of Object.entries(e)) {
      const u = a in i, c = i[a];
      if (Be(c) && Be(l) && !Object.values(c).some(Be)) {
        o[a] = {
          ...c,
          ...l
        };
        continue;
      }
      o[a] = mi(
        i[a],
        l,
        r,
        n,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        // CHANGED: key is always in form data, maybe this condition should be value === undefined
        // overrideFormDataWithDefaults &&
        //   (keyExistsInDefaults || !keyExistsInFormData)
        s && u
      );
    }
    return o;
  }
  return n && (t !== void 0 && Dg(e) || typeof e == "number" && isNaN(e)) || s && !Dg(e) ? t : e;
}
function Cy(t, e, r = !1) {
  const n = Object.assign({}, t);
  for (const [s, o] of Object.entries(e)) {
    const i = t ? t[s] : {};
    Be(i) && Be(o) ? n[s] = Cy(i, o, r) : r && Array.isArray(i) && Array.isArray(o) ? n[s] = i.concat(r === "preventDuplicates" ? o.filter((a) => !i.includes(a)) : o) : n[s] = o;
  }
  return n;
}
function ky(t) {
  switch (t) {
    case "array":
      return [];
    case "object":
      return {};
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "null":
      return null;
    default:
      return;
  }
}
function LO(t, e, r, n = void 0, s = {}, o = !1, i = {}, a = !1) {
  const l = Fr(t, e, r, s, n), u = Wn(t, e, l, {
    rootSchema: s,
    includeUndefinedValues: o,
    experimental_defaultFormStateBehavior: i,
    rawFormData: n,
    parentDefaults: void 0,
    // CHANGED: We use `required: true` at the root instead of `requiredAsRoot`
    required: !0,
    isSchemaRoot: !0,
    stack: /* @__PURE__ */ new Set(),
    shouldMergeDefaultsIntoFormData: !0,
    initialDefaultsGenerated: a
  });
  if (l.type !== "object" && Be(l.default) && // CHANGED: Added those conditions for typesafety, while original intentions is unknown
  (u === void 0 || typeof u == "object") && (n === void 0 || typeof n == "object"))
    return {
      ...u,
      ...n
    };
  if (Be(n) || Array.isArray(n)) {
    const { mergeDefaultsIntoFormData: c } = i || {};
    return mi(
      u,
      n,
      !0,
      c === "useDefaultIfFormDataUndefined",
      !0
      // set to true to override formData with defaults if they exist.
    );
  }
  return u;
}
function Wn(t, e, r, n) {
  const { parentDefaults: s, rawFormData: o, rootSchema: i, includeUndefinedValues: a, stack: l, experimental_defaultFormStateBehavior: u, required: c, isSchemaRoot: f, shouldMergeDefaultsIntoFormData: p, initialDefaultsGenerated: _ } = n, b = Be(o), g = b ? o : {}, h = Be(r) ? r : {};
  let y = s, S = null, x = g, P = u, w = l;
  const { default: O, $ref: k, oneOf: $, anyOf: T, allOf: E } = h;
  if (Sd(h) && u.constAsDefaults !== "never")
    y = h.const ?? h.enum?.[0];
  else if (Be(y) && Be(O) && !T && !$ && !k)
    y = Cy(y, O);
  else if (O !== void 0 && $ === void 0 && T === void 0 && k === void 0)
    y = O;
  else if (k !== void 0) {
    l.has(k) || (w = new Set(l).add(k), S = wd(e, k, i));
    const R = Zr(g);
    S && y === void 0 && R && (y = O), p && S && !b && (x = o);
  } else if (iy in h) {
    const R = {
      ...Ay(t, e, h, {
        ...n,
        rawFormData: g
      }, y),
      ...g
    };
    S = by(t, e, h, i, !1, /* @__PURE__ */ new Set(), R)[0];
  } else if (Oy(h))
    y = h.items.map((R, U) => Wn(t, e, R, {
      rootSchema: i,
      includeUndefinedValues: a,
      stack: l,
      experimental_defaultFormStateBehavior: u,
      parentDefaults: Array.isArray(s) ? s[U] : void 0,
      rawFormData: g,
      required: c,
      isSchemaRoot: !1,
      shouldMergeDefaultsIntoFormData: p,
      // CHANGED: this property is not provided in the original code
      initialDefaultsGenerated: _
    }));
  else if ($ !== void 0) {
    const { oneOf: R, ...U } = h;
    if ($.length === 0)
      return;
    const B = zl(h);
    (Array.isArray(B) ? B.every(Ag) : Ag(B)) && P?.constAsDefaults === "skipOneOf" && (P = {
      ...P,
      constAsDefaults: "never"
    });
    const F = $[pi(t, e, i, o ?? O, $.filter(er), 0, Ds(h))];
    if (typeof F == "boolean")
      return;
    S = Zr(U) ? F : e.mergeSchemas(U, F);
  } else if (T !== void 0) {
    const { anyOf: R, ...U } = h;
    if (T.length === 0)
      return;
    const B = T[pi(t, e, i, o ?? O, T.filter(er), 0, Ds(h))];
    if (typeof B == "boolean")
      return;
    S = Zr(U) ? B : e.mergeSchemas(U, B);
  }
  if (S)
    return Wn(t, e, S, {
      isSchemaRoot: f,
      rootSchema: i,
      includeUndefinedValues: a,
      stack: w,
      experimental_defaultFormStateBehavior: P,
      parentDefaults: y,
      rawFormData: o ?? x,
      required: c,
      shouldMergeDefaultsIntoFormData: p,
      initialDefaultsGenerated: _
    });
  y === void 0 && (y = h.default);
  let M = BO(t, e, h, n, y) ?? y;
  if (p) {
    const { arrayMinItems: R = {} } = u || {}, { mergeExtraDefaults: U } = R, B = jO(t, e, h, i, o, u);
    (!Be(o) || E !== void 0) && (M = mi(M, B, U, !0));
  }
  return M;
}
function jO(t, e, r, n, s, o) {
  let i = s;
  return s !== void 0 && !Sd(r) && xd(t, e, r, n) && (i = VO(r)?.some((f) => ql(f, s)) ? s : void 0), r.const !== void 0 && o?.constAsDefaults === "always" && (i = r.const), i;
}
function $y(t, e) {
  const { default: r, type: n } = t;
  return Array.isArray(n) && n.includes("null") && Sc(e) && r === null ? null : e;
}
function Mg(t, e, r, n, s, o, i, a, l, u) {
  const { emptyObjectFields: c = "populateAllDefaults" } = u;
  if (n === !0 || s)
    t.set(e, r);
  else if (n === "excludeObjectChildren")
    (o && r !== void 0 || (Array.isArray(r) ? r.length > 0 : !Ts(r) || !Zr(r))) && t.set(e, r);
  else if (c !== "skipDefaults") {
    const f = i ? l.has(e) : a;
    Be(r) ? c === "skipEmptyDefaults" ? Sc(r) || t.set(e, r) : (!Sc(r) || l.has(e)) && (f || c !== "populateRequiredDefaults") && t.set(e, r) : (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field
      r !== void 0 && (c === "populateAllDefaults" || c === "skipEmptyDefaults" || f && l.has(e)) && t.set(e, r)
    );
  }
}
var go;
(function(t) {
  t[t.Ignore = 0] = "Ignore", t[t.Invert = 1] = "Invert", t[t.Fallback = 2] = "Fallback";
})(go || (go = {}));
function Tu(t, e = go.Ignore, r = -1) {
  if (r >= 0) {
    if (Array.isArray(t.items) && r < t.items.length) {
      const n = t.items[r];
      if (typeof n != "boolean")
        return n;
    }
  } else if (t.items && !Array.isArray(t.items) && typeof t.items != "boolean")
    return t.items;
  return e !== go.Ignore && Be(t.additionalItems) ? t.additionalItems : {};
}
function BO(t, e, r, n, s) {
  switch (ho(r)) {
    // We need to recurse for object schema inner default values.
    case "object": {
      const { rawFormData: o } = n;
      return Ay(t, e, r, {
        ...n,
        rawFormData: Be(o) ? o : {}
      }, s);
    }
    case "array":
      return zO(t, e, r, n, Array.isArray(s) ? s : void 0);
    default:
      return;
  }
}
function Ay(t, e, r, { rootSchema: n, includeUndefinedValues: s, stack: o, experimental_defaultFormStateBehavior: i, required: a, isSchemaRoot: l, rawFormData: u, shouldMergeDefaultsIntoFormData: c, initialDefaultsGenerated: f }, p) {
  const b = i?.allOf === "populateDefaults" && ly in r || i?.emptyObjectFields !== "skipEmptyDefaults" && ay in r ? Fr(t, e, r, n, u) : r, g = new Set(b.required), h = Be(b.const) ? b.const : {}, y = /* @__PURE__ */ new Map(), S = b.properties, x = Be(p) ? p : void 0, P = Be(u) ? u : void 0;
  if (S !== void 0)
    for (const [O, k] of Object.entries(S)) {
      if (typeof k == "boolean")
        continue;
      const $ = Wn(t, e, k, {
        rootSchema: n,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        includeUndefinedValues: s === !0,
        parentDefaults: x?.[O],
        rawFormData: P?.[O],
        required: g.has(O),
        isSchemaRoot: !1,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      }), T = (k.const !== void 0 || h[O] !== void 0) && i.constAsDefaults !== "never";
      Mg(y, O, $, s, T, k.type === "null", l, a, new Set(b.required), i);
    }
  const w = b.additionalProperties;
  if (w !== void 0 && !f) {
    let O = new Set(Be(p) ? S === void 0 ? Object.keys(p) : Object.keys(p).filter((E) => !(E in S)) : void 0);
    const k = Object.keys(u), $ = new Set(S === void 0 ? k : k.filter((E) => !(E in S)));
    O = O.union($);
    const T = typeof w == "boolean" ? {} : w;
    O.forEach((E) => {
      const M = Wn(t, e, T, {
        rootSchema: n,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        includeUndefinedValues: s === !0,
        parentDefaults: x?.[E],
        rawFormData: P?.[E],
        required: g.has(E),
        isSchemaRoot: l,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      });
      Mg(y, E, M, s, !1, !1, l, a, $, {});
    });
  }
  return $y(r, Object.fromEntries(y));
}
function zO(t, e, r, { rawFormData: n, rootSchema: s, stack: o, experimental_defaultFormStateBehavior: i, required: a, shouldMergeDefaultsIntoFormData: l, initialDefaultsGenerated: u }, c) {
  const { populate: f, mergeExtraDefaults: p, computeSkipPopulate: _ = () => !1 } = i?.arrayMinItems ?? {}, b = f === "never", g = f === "requiredOnly", h = f === "all" || !b && !g, S = i?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
  if (c !== void 0 && (c = c.map((w, O) => {
    const k = Tu(r, go.Fallback, O), $ = Array.isArray(n) ? n[O] : void 0;
    return Wn(t, e, k, {
      rootSchema: s,
      stack: o,
      experimental_defaultFormStateBehavior: i,
      parentDefaults: w,
      required: a,
      includeUndefinedValues: !1,
      rawFormData: $,
      isSchemaRoot: !1,
      shouldMergeDefaultsIntoFormData: l,
      initialDefaultsGenerated: u
    });
  })), Array.isArray(n)) {
    const w = Tu(r);
    if (b)
      c = n;
    else {
      const O = n.map(($, T) => Wn(t, e, w, {
        rootSchema: s,
        stack: o,
        experimental_defaultFormStateBehavior: i,
        rawFormData: $,
        parentDefaults: c?.[T],
        required: a,
        includeUndefinedValues: !1,
        isSchemaRoot: !1,
        shouldMergeDefaultsIntoFormData: l,
        initialDefaultsGenerated: u
      }));
      c = mi(c, O, (g && a || h) && p === !0);
    }
  }
  if (r.const === void 0 || i.constAsDefaults === "never") {
    if (b)
      return c ?? S;
    if (g && !a)
      return c;
  }
  let x;
  const P = c?.length ?? 0;
  if (!r.minItems || Py(t, e, r, s) || _(t, r, s) || r.minItems <= P)
    x = c || !a ? c : S;
  else {
    const w = Tu(r, go.Invert), O = w.default, k = Array.from({ length: r.minItems - P }, () => Wn(t, e, w, {
      parentDefaults: O,
      rootSchema: s,
      stack: o,
      experimental_defaultFormStateBehavior: i,
      includeUndefinedValues: !1,
      rawFormData: void 0,
      isSchemaRoot: !1,
      required: a,
      shouldMergeDefaultsIntoFormData: l,
      initialDefaultsGenerated: u
    }));
    x = P ? c.concat(k) : k;
  }
  return $y(r, x);
}
const qO = (t) => t.length > 1 ? `properties '${t.join("', '")}'` : `property '${t[0]}'`;
function UO(t, e) {
  const r = Object.keys(t);
  if (e === void 0)
    return r;
  const n = e.filter((a) => a === "*" || t[a]), s = new Set(n), o = r.filter((a) => !s.has(a)), i = n.indexOf("*");
  if (i === -1) {
    if (o.length)
      throw new Error(`uiSchema order list does not contain ${qO(o)}`);
    return n;
  }
  if (i !== n.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  return n.splice(i, 1, ...o), n;
}
function KO(t, e) {
  const r = t[e];
  return typeof r == "boolean" || !r ? !1 : jl in r;
}
function Ey({ type: t, format: e }) {
  return t === "string" && e === uy;
}
function HO(t, e, r, n) {
  const { items: s } = r;
  if (QP(s)) {
    const o = Fr(t, e, s, n);
    return Ey(o);
  }
  return !1;
}
function WO(t, e) {
  return (Be(t.additionalProperties) || t.patternProperties !== void 0) && Be(e) && (t.maxProperties === void 0 || Object.keys(e).length < t.maxProperties);
}
const zn = /* @__PURE__ */ Symbol("no Value");
function Hi(t, e, r, n, s) {
  return r[Nr] !== void 0 ? Fr(t, e, r, n, s) : r;
}
function GO(t, e, r, n, s, o, i) {
  const a = e.type, l = r.type;
  if (!a || a === l) {
    const u = t.maxItems ?? -1;
    return l === "object" ? i.reduce((c, f) => {
      const p = Pd(n, s, o, r, e, f);
      return p !== void 0 && (u < 0 || c.length < u) && c.push(p), c;
    }, []) : u > 0 && i.length > u ? i.slice(0, u) : i;
  }
  return zn;
}
function Pd(t, e, r, n, s, o) {
  let i;
  const a = n.properties, l = Be(o);
  if (a !== void 0) {
    const u = {}, c = s.properties;
    c !== void 0 && l && Object.keys(c).forEach((_) => {
      _ in o && (u[_] = void 0);
    });
    const f = Object.keys(a), p = {};
    f.forEach((_) => {
      const b = l ? o[_] : void 0, g = c?.[_];
      let h = typeof g == "object" ? g : {};
      const y = a?.[_];
      let S = typeof y == "object" ? y : {};
      h = Hi(t, e, h, r, b), S = Hi(t, e, S, r, b);
      const x = h.type, P = S.type;
      if (!x || x === P)
        if (_ in u && delete u[_], P === "object" || P === "array" && Array.isArray(b)) {
          const w = Pd(t, e, r, S, h, b);
          (w !== void 0 || P === "array") && (p[_] = w);
        } else {
          const w = S.default ?? zn, O = h.default ?? zn;
          w !== zn && w !== b && (O === b ? u[_] = w : S.readOnly === !0 && (u[_] = void 0));
          const k = S.const ?? zn, $ = h.const ?? zn;
          k !== zn && k !== b && (u[_] = $ === b ? k : void 0);
        }
    }), i = {
      ...l ? o : void 0,
      ...u,
      ...p
    };
  } else if (s.type === "array" && n.type === "array" && Array.isArray(o)) {
    const u = s.items, c = n.items;
    if (Be(u) && Be(c)) {
      const f = GO(n, Hi(t, e, u, r, o), Hi(t, e, c, r, o), t, e, r, o);
      f !== zn && (i = f);
    } else typeof u == "boolean" && typeof c == "boolean" && u === c && (i = o);
  }
  return i;
}
function YO(t, e) {
  return Ka(t, (r) => {
    if (!er(r))
      return r;
    const n = r[Nr];
    return n !== void 0 && n.startsWith("#") && (r[Nr] = `${e}${n}`), r;
  });
}
function XO(t) {
  return t.split("/").slice(1).map((e) => e.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function JO(t, e) {
  const r = [];
  if (t === "")
    return r;
  const n = XO(t);
  let s = e;
  for (const o of n)
    if (Array.isArray(s) && /^\d+$/.test(o)) {
      const i = Number(o);
      r.push(i), s = s[i];
    } else
      r.push(o), s = s?.[o];
  return r;
}
function Ig(t, e, r, n, s, o) {
  function i(l, u, c, f) {
    const p = l.map((h) => typeof h == "boolean" ? h ? {} : { not: {} } : h), _ = pi(t, e, r, f, p, -1, Ds(u)), b = a(p[_], c, f);
    if (b !== void 0)
      return b;
    let g;
    for (const h of p) {
      if (!er(h))
        continue;
      const y = a(h, c, f);
      if (y !== void 0) {
        if (er(y))
          return y;
        g = y;
      }
    }
    return g;
  }
  function a(l, u, c) {
    for (let f = 0; f < u.length; f++) {
      if (l === void 0 || !er(l))
        return;
      if (l.$ref)
        return a(gy(l.$ref, r), u.slice(f), c);
      if (l.allOf) {
        const g = e.mergeAllOf(l);
        if (!g.allOf)
          return a(g, u.slice(f), c);
      }
      const p = l.anyOf ?? l.oneOf ?? l.allOf;
      if (p) {
        const g = i(p, l, u.slice(f), c);
        if (g !== void 0)
          return g;
      }
      const _ = u[f], b = typeof _;
      if (b === "number") {
        const { items: g, additionalItems: h } = l;
        l = (Array.isArray(g) ? g[_] : g) ?? h, c = xO(c) ? c[_] : void 0;
        continue;
      }
      if (b === "string") {
        const { properties: g, patternProperties: h, additionalProperties: y, dependencies: S, then: x, else: P } = l;
        l = (g && g[_]) ?? (h && Object.entries(h).find(([w]) => new RegExp(w).test(_))?.[1]) ?? y ?? (S && i(Object.values(S).filter(wc), l, u.slice(f), c)) ?? ((x || P) && i([x, P].filter(wc), l, u.slice(f), c)), c = Be(c) ? c[_] : void 0;
        continue;
      }
      return;
    }
    return l;
  }
  return a(n, s, o);
}
function Du(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function ZO(t) {
  return typeof t?.$ref == "string";
}
function nl(t, e) {
  return ZO(e) ? t["ui:definitions"]?.[e.$ref] : e;
}
function QO(t, e, r, n) {
  const s = r["ui:options"], o = s && n in s ? s[n] : t["ui:globalOptions"]?.[n];
  return typeof o == "string" && o.startsWith("registry:") ? e[o.substring(9)] : o;
}
function Od(t, e, r) {
  let n = nl(t, e);
  for (let s = 0; s < r.length; s++) {
    if (n === void 0)
      return;
    const o = n.anyOf ?? n.oneOf;
    if (o) {
      let c;
      const f = r.slice(s);
      for (const p of o)
        if (c = Od(t, p, f), c !== void 0)
          return c;
    }
    const i = r[s], { items: a, additionalItems: l, additionalProperties: u } = n;
    n = nl(t, n[i] ?? (Array.isArray(a) ? a[i] : a) ?? u ?? l);
  }
  return n;
}
function eC(t, e) {
  return Od(t, t, e)?.["ui:options"]?.title;
}
class Cd extends Map {
  /** @type {Map<K, Source<number>>} */
  #e = /* @__PURE__ */ new Map();
  #t = /* @__PURE__ */ xe(0);
  #r = /* @__PURE__ */ xe(0);
  #n = Sn || -1;
  /**
   * @param {Iterable<readonly [K, V]> | null | undefined} [value]
   */
  constructor(e) {
    if (super(), e) {
      for (var [r, n] of e)
        super.set(r, n);
      this.#r.v = super.size;
    }
  }
  /**
   * If the source is being created inside the same reaction as the SvelteMap instance,
   * we use `state` so that it will not be a dependency of the reaction. Otherwise we
   * use `source` so it will be.
   *
   * @template T
   * @param {T} value
   * @returns {Source<T>}
   */
  #s(e) {
    return Sn === this.#n ? /* @__PURE__ */ xe(e) : Xn(e);
  }
  /** @param {K} key */
  has(e) {
    var r = this.#e, n = r.get(e);
    if (n === void 0) {
      var s = super.get(e);
      if (s !== void 0)
        n = this.#s(0), r.set(e, n);
      else
        return d(this.#t), !1;
    }
    return d(n), !0;
  }
  /**
   * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn
   * @param {any} [this_arg]
   */
  forEach(e, r) {
    this.#o(), super.forEach(e, r);
  }
  /** @param {K} key */
  get(e) {
    var r = this.#e, n = r.get(e);
    if (n === void 0) {
      var s = super.get(e);
      if (s !== void 0)
        n = this.#s(0), r.set(e, n);
      else {
        d(this.#t);
        return;
      }
    }
    return d(n), super.get(e);
  }
  /**
   * @param {K} key
   * @param {V} value
   * */
  set(e, r) {
    var n = this.#e, s = n.get(e), o = super.get(e), i = super.set(e, r), a = this.#t;
    if (s === void 0)
      s = this.#s(0), n.set(e, s), q(this.#r, super.size), Ur(a);
    else if (o !== r) {
      Ur(s);
      var l = a.reactions === null ? null : new Set(a.reactions), u = l === null || !s.reactions?.every(
        (c) => (
          /** @type {NonNullable<typeof v_reactions>} */
          l.has(c)
        )
      );
      u && Ur(a);
    }
    return i;
  }
  /** @param {K} key */
  delete(e) {
    var r = this.#e, n = r.get(e), s = super.delete(e);
    return n !== void 0 && (r.delete(e), q(this.#r, super.size), q(n, -1), Ur(this.#t)), s;
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var e = this.#e;
      q(this.#r, 0);
      for (var r of e.values())
        q(r, -1);
      Ur(this.#t), e.clear();
    }
  }
  #o() {
    d(this.#t);
    var e = this.#e;
    if (this.#r.v !== e.size) {
      for (var r of super.keys())
        if (!e.has(r)) {
          var n = this.#s(0);
          e.set(r, n);
        }
    }
    for ([, n] of this.#e)
      d(n);
  }
  keys() {
    return d(this.#t), super.keys();
  }
  values() {
    return this.#o(), super.values();
  }
  entries() {
    return this.#o(), super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return d(this.#r), super.size;
  }
}
class Ul {
}
let is = 0;
const tC = 1 << is++, rC = 1 << is++, nC = 1 << is++, sC = 1 << is++, oC = 1 << is++, iC = 1 << is++, aC = 1 << is++, kd = 1 << is++;
let $o = 0;
const lC = 1 << $o++, uC = 1 << $o++, sl = 1 << $o++, Ng = 1 << $o++, Fg = 1 << $o++;
(1 << $o++) - 1;
function cC(t) {
  return "validateFieldValue" in t;
}
function dC(t) {
  return "validateFieldValueAsync" in t;
}
function fC(t) {
  return "validateAdditionalPropertyKey" in t;
}
function hC(t) {
  return "validateFileListAsync" in t;
}
const Rg = "__sjsf_id_prefix", Ty = "root", $d = "__sjsf_pseudo_element", Mu = $d.length, Pc = "S", Oc = "N";
function Ad(t) {
  return `${$d}${typeof t == "string" ? Pc : Oc}${t}`;
}
function gC(t) {
  if (typeof t != "string" || !t.startsWith($d))
    return;
  const e = t.substring(Mu + 1);
  switch (t[Mu]) {
    case Pc:
      return e;
    case Oc:
      return Number(e);
    default:
      throw new Error(`Unexpected pseudo element suffix "${t[Mu]}", expected "${Pc}" or "${Oc}"`);
  }
}
function Dy(t) {
  return (e, r) => {
    const n = t(e, r);
    return n === void 0 ? `Label "${e}" is not translated` : typeof n == "string" ? n : n(r);
  };
}
function My(t, e, r, n = 0) {
  return t === void 0 && (t = {
    values: /* @__PURE__ */ new Map(),
    value: void 0
  }), e.length === n ? t.value = r : t.values.set(e[n], My(t.values.get(e[n]), e, r, n + 1)), t;
}
function pC(t, e) {
  let r = 0;
  for (; t !== void 0 && r < e.length; )
    t = t.values.get(e[r++]);
  return t;
}
const Iy = /* @__PURE__ */ Symbol("form-context"), Un = /* @__PURE__ */ Symbol("form-value"), Ny = /* @__PURE__ */ Symbol("form-id-prefix"), Ao = /* @__PURE__ */ Symbol("form-errors"), Fy = /* @__PURE__ */ Symbol("form-id-from-path"), Ed = /* @__PURE__ */ Symbol("form-paths-trie-ref"), Ry = /* @__PURE__ */ Symbol("form-mark-schema-change"), Cc = /* @__PURE__ */ Symbol("form-keyed-arrays"), Td = /* @__PURE__ */ Symbol("form-fields-validation-mode"), Zt = /* @__PURE__ */ Symbol("form-schema"), kc = /* @__PURE__ */ Symbol("form-retrieved-schema"), Kl = /* @__PURE__ */ Symbol("form-root-path"), Hl = /* @__PURE__ */ Symbol("form-ui-schema-root"), po = /* @__PURE__ */ Symbol("form-ui-schema"), Vy = /* @__PURE__ */ Symbol("form-ui-options-registry"), Eo = /* @__PURE__ */ Symbol("form-ui-extra-options"), Rr = /* @__PURE__ */ Symbol("form-validator"), tn = /* @__PURE__ */ Symbol("form-merger"), Ly = /* @__PURE__ */ Symbol("form-icons"), jy = /* @__PURE__ */ Symbol("form-disabled"), By = /* @__PURE__ */ Symbol("form-data-url-to-blob"), zy = /* @__PURE__ */ Symbol("form-translation"), $c = /* @__PURE__ */ Symbol("form-translate"), qy = /* @__PURE__ */ Symbol("form-resolver"), Ac = /* @__PURE__ */ Symbol("form-theme"), vi = /* @__PURE__ */ Symbol("form-fields-state-map");
function Wl(t, e) {
  const r = e, n = pC(t.current, e);
  if (n === void 0)
    t.current = My(t.current, e, r);
  else {
    const s = n.value;
    if (s !== void 0)
      return s;
    n.value = r;
  }
  return r;
}
function mC(t, e, r) {
  return ((t.get(e) ?? 0) & r) > 0;
}
class vC {
  ref;
  #e = new Cd();
  constructor(e) {
    this.ref = e;
  }
  assign(e) {
    this.#e.clear();
    for (const r of e) {
      let n = r[1];
      const s = new Set(n);
      n.length > s.size && (n = Array.from(s)), this.#e.set(r[0], {
        set: s,
        array: n
      });
    }
    return this;
  }
  updateErrors(e) {
    this.#e.clear();
    for (const { path: r, message: n } of e) {
      const s = Wl(this.ref, r), o = this.#e.get(s);
      if (o) {
        const i = o.set.size;
        o.set.add(n), i < o.set.size && o.array.push(n);
      } else {
        const i = [n];
        this.#e.set(s, {
          set: new Set(i),
          array: i
        });
      }
    }
    return this;
  }
  getFieldErrors(e) {
    return this.#e.get(e)?.array;
  }
  updateFieldErrors(e, r) {
    if (typeof r == "function") {
      const n = this.#e.get(e)?.array ?? [];
      r = r(n);
    }
    if (r.length > 0) {
      const n = new Set(r);
      this.#e.set(e, {
        set: n,
        array: r.length > n.size ? Array.from(n) : r
      });
    } else
      this.#e.delete(e);
    return r.length === 0;
  }
  hasErrors() {
    return this.#e.size > 0;
  }
  clear() {
    this.#e.clear();
  }
  *[Symbol.iterator]() {
    for (const e of this.#e)
      yield [e[0], e[1].array];
  }
}
function De() {
  return Es(Iy);
}
function Uy(t) {
  Po(Iy, t);
}
function pr(t, e) {
  return t[Fy](e);
}
function Ky(t, e) {
  return Wl(t[Ed], e);
}
function Gl(t, e, r) {
  return Ky(t, e.concat(r));
}
function Mi(t, e, r) {
  return Gl(t, e, Ad(r));
}
function mo(t, e, r) {
  return pr(t, Mi(t, e, r));
}
function Vg(t, e) {
  return pr(t, Ky(t, e));
}
function yC(t, e) {
  return xd(t[Rr], t[tn], e, t[Zt]);
}
function bC(t, e) {
  return Py(t[Rr], t[tn], e, t[Zt]);
}
function _C(t, e) {
  return HO(t[Rr], t[tn], e, t[Zt]);
}
function $r(t, e, r, n) {
  return Fr(t[Rr], t[tn], e, t[Zt], r, n);
}
function wC(t, e, r, n) {
  return Pd(t[Rr], t[tn], t[Zt], e, r, n);
}
function SC(t, e, r, n, s) {
  return pi(t[Rr], t[tn], t[Zt], e, r, n, s);
}
function Dd(t, e) {
  return t[tn].mergeFormDataAndSchemaDefaults(e);
}
function xC(t) {
  t[Ry]();
}
function Hy(t, e) {
  return (r, n) => t(r, n) ?? e(r, n);
}
function Ii(t) {
  return (e) => t[e];
}
function Lg(t, e) {
  return Hy(Ii(e), t);
}
function Wy(t, e) {
  return Hy(t, Ii(e));
}
function Gn(t, e) {
  return nl(t[Hl], e) ?? {};
}
function To(t, e, r) {
  return QO(t[Hl], t[Vy], e, r);
}
function Wr(t, e) {
  return To(t, e, "title");
}
function It(t, e, r) {
  return t[Eo]?.(r, e) ?? To(t, e.uiSchema, r);
}
function PC(t, e, r, n) {
  const s = t[Eo]?.(r, e);
  if (s) {
    const i = n(s);
    if (i !== void 0)
      return i;
  }
  const o = To(t, e.uiSchema, r);
  if (o !== void 0)
    return n(o);
}
function St(t) {
  return (e, r, n) => Object.assign(e, To(n, r.uiSchema, t), n[Eo]?.(t, r));
}
function Gy(t, e) {
  return (r, n, s) => {
    const o = To(s, n.uiSchema, t), i = s[Eo]?.(t, n);
    return Object.assign(r, o && e(o), i && e(i));
  };
}
function Ms(t, e) {
  let r = t[zy];
  const n = To(t, e.uiSchema, "translations");
  r = n ? Lg(r, n) : r;
  const s = t[Eo]?.("translations", e);
  return r = s ? Lg(r, s) : r, Dy(r);
}
function on(t, e, r) {
  const n = PC(t, e, "actions", (s) => s[r]);
  return n !== void 0 ? n : It(t, e, "action");
}
const OC = [];
function qt(t, e) {
  return t[Ao].getFieldErrors(e) ?? OC;
}
function CC(t, e) {
  ot(() => {
    t[Ao].updateErrors(e);
  });
}
function ci(t, e, r) {
  return ot(() => t[Ao].updateFieldErrors(e, r));
}
function Yy(t) {
  return t[Td];
}
function Mn(t, e, r) {
  t.fieldsValidation.run(e, r);
}
function kC(t, e, r, n) {
  return ot(() => {
    const s = t[Rr];
    if (!fC(s))
      return !0;
    const o = s.validateAdditionalPropertyKey(r, e.schema);
    return ci(t, n.path, o);
  });
}
async function Yl(t, e, r, n) {
  const s = await ot(() => {
    const o = e[Rr];
    return hC(o) ? o.validateFileListAsync(t, n, r) : !0;
  });
  return s === !0 || ci(e, r.path, s);
}
function Os(t, e, r) {
  const n = t[vi].get(e) ?? 0;
  t[vi].set(e, n | r);
}
const $C = [];
function qs(t, e, r) {
  const n = /* @__PURE__ */ C(() => e().path);
  ko(() => {
    const c = d(n);
    return () => {
      t[vi].delete(c), t[Ao].updateFieldErrors(c, $C);
    };
  });
  const s = /* @__PURE__ */ C(() => t[Td]), o = /* @__PURE__ */ C(() => t[vi].get(d(n)) ?? 0), i = (c) => {
    if (!(!(d(s) & c) || d(s) & kd && !t.isSubmitted || d(s) & iC && !(d(o) & sl) || d(s) & aC && !(d(o) & Ng)))
      return r;
  }, a = /* @__PURE__ */ C(() => i(tC)), l = /* @__PURE__ */ C(() => i(rC)), u = /* @__PURE__ */ C(() => i(nC));
  return {
    onfocus() {
      Os(t, d(n), lC);
    },
    oninput() {
      Os(t, d(n), uC), d(a)?.();
    },
    onchange() {
      Os(t, d(n), sl), d(l)?.();
    },
    onblur() {
      Os(t, d(n), Ng), d(u)?.();
    }
  };
}
const AC = /* @__PURE__ */ new WeakMap(), an = Bl(AC, (t) => {
  const e = Jv(), r = (n) => {
    const s = t.onfocus && Ye(n, "focus", t.onfocus), o = t.oninput && Ye(n, "input", t.oninput), i = t.onchange && Ye(n, "change", t.onchange), a = t.onblur && Ye(n, "blur", t.onblur);
    return () => {
      s?.(), o?.(), i?.(), a?.();
    };
  };
  return (n) => (n[e] = r, n);
});
function Nt(t, e, r, ...n) {
  for (let s = 0; s < n.length; s++)
    r = n[s](r, e, t);
  return r;
}
function EC(t) {
  return (e) => Object.assign(e, t);
}
function Do(t, e, r) {
  return t.disabled ||= r[jy], t;
}
const Xy = [
  "description",
  "help",
  "errors"
], TC = Xy.concat("examples");
function Us(t, e, r) {
  return t["aria-invalid"] = r[Ao].getFieldErrors(e.path) !== void 0, t;
}
function Md(t, e, r) {
  return t["aria-describedby"] = (Array.isArray(e.schema.examples) ? TC : Xy).map((n) => mo(r, e.path, n)).join(" "), t;
}
function DC(t, e, r) {
  return t["aria-readonly"] = e.schema.readOnly, t;
}
function MC(t, e, r) {
  return t["aria-required"] = e.required, t;
}
function IC(t) {
  switch (t) {
    case "date-time":
      return "datetime-local";
    case "uri":
      return "url";
    case "color":
    case "date":
    case "time":
    case "email":
      return t;
    default:
      return;
  }
}
function NC(t, e, r) {
  const { required: n, schema: s, path: o } = e, i = pr(r, o);
  t.id = i, t.name = i;
  const a = IC(s.format);
  return a !== void 0 && (t.type = a), t.required = n, t.minlength = s.minLength, t.maxlength = s.maxLength, t.pattern = s.pattern, t.min = s.minimum, t.max = s.maximum, t.step = s.multipleOf ?? (s.type === "number" ? "any" : void 0), t.list = Array.isArray(s.examples) ? mo(r, e.path, "examples") : void 0, t.readonly = s.readOnly, t;
}
function FC(t, e, r) {
  const { path: n, required: s, schema: o } = e, i = pr(r, n);
  return t.id = i, t.name = i, t.required = s, t.minlength = o.minLength, t.maxlength = o.maxLength, t.readonly = o.readOnly, t;
}
function RC(t, e, r) {
  return t.for = pr(r, e.path), t;
}
function Xl(t) {
  return (e, r, n) => (e.id = mo(n, r.path, t), e);
}
function VC(t) {
  return (e) => (e.tabindex = t, e);
}
function LC(t) {
  return (e) => (e["data-layout"] = t, e);
}
function jC(t) {
  return (e) => (e.type = t, e);
}
function Jy(t, e, r, n) {
  return Nt(t, e, n, Xl("description"), St(r));
}
function Zy(t, e, r, n) {
  return Nt(t, e, n, Xl("errors"), VC(-1), St(r));
}
function Qy(t, e, r, n, s) {
  return Nt(t, e, s, St(r), EC(n));
}
function eb(t, e, r, n) {
  return Nt(t, e, n, Xl("help"), St(r));
}
function BC(t, e, r, n) {
  return Nt(t, e, n, RC, St(r));
}
function Ec(t, e, r, n) {
  return Nt(t, e, n, Xl("title"), St(r));
}
function tb(t, e, r, n, s, o) {
  return Nt(
    t,
    e,
    o,
    LC(s),
    St(r),
    // @ts-expect-error Type `T` is resolved as `never` because this package
    // lacks suitable definitions for UI options,
    // but they are available in `theme` packages.
    Gy(n, (i) => i[s])
  );
}
function zC(t, e, r, n, s) {
  return Nt(t, e, s, jC(n), St(r), Do);
}
function gr(t, e, r, n) {
  return Nt(t, e, n, St(r), Do, Us, Md, DC, MC);
}
function Ni(t, e, r, n, s) {
  return Nt(t, e, s, NC, an(n), St(r), Do, Us, Md);
}
function rb(t, e, r, n, s) {
  return Nt(t, e, s, FC, an(n), St(r), Do, Us, Md);
}
async function nb(t, e, r, n) {
  const { name: s, blob: o } = await t[By](e, n);
  r.items.add(new File([o], s, { type: o.type }));
}
function qC(t, e, r, n) {
  const s = [];
  for (const o of n)
    s.push(nb(t, e, r, o));
  return Promise.all(s);
}
const UC = (t, e = ge) => {
  var r = KC(), n = he(r, !0);
  de(r), ke(() => Me(n, e())), A(t, r);
};
function jg(t) {
  return (e) => Id(e, { message: t });
}
var KC = /* @__PURE__ */ ne('<pre style="color: red;"> </pre>');
function Id(t, e) {
  H(e, !0);
  const r = v(e, "message", 7);
  var n = {
    get message() {
      return r();
    },
    set message(s) {
      r(s), m();
    }
  };
  return UC(t, r), W(n);
}
K(Id, { message: {} }, [], [], { mode: "open" });
function Le(t, e, r) {
  const n = r.uiSchema["ui:components"]?.[e];
  switch (typeof n) {
    case "undefined":
      return t[Ac](e, r) ?? // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      jg(t[$c]("component-not-found", { type: e }));
    case "string":
      return t[Ac](n, r) ?? // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      jg(t[$c]("component-not-found", {
        // @ts-expect-error ts cannot infer type properly by some reason
        type: n
      }));
    default:
      return n;
  }
}
function vo(t, e) {
  return Le(t, t[qy](e), e);
}
function HC(t, e, r, n) {
  let s = Number.MIN_SAFE_INTEGER;
  return () => {
    let o;
    const i = e();
    return i ? (o = t[Cc].get(i), o === void 0 && (o = n(i, () => s++), t[Cc].set(i, o))) : o = r(), o;
  };
}
const yi = () => "abort", WC = ({ status: t }) => t !== "processing";
class GC {
  state;
  constructor(e) {
    this.state = e;
  }
}
class YC {
  state;
  constructor(e) {
    this.state = e;
  }
}
function yo(t) {
  const e = /* @__PURE__ */ C(() => t.delayedMs ?? 500), r = /* @__PURE__ */ C(() => t.timeoutMs ?? 8e3), n = /* @__PURE__ */ C(() => t.combinator ?? WC);
  let s = /* @__PURE__ */ xe({ status: "idle" }), o, i;
  function a() {
    clearTimeout(o), clearTimeout(i);
  }
  function l(b) {
    b.abortController.abort();
  }
  function u(b, g) {
    if (d(s).status === "failed")
      throw new YC(d(s));
    d(s).status === "processing" && d(s).promise === b && (a(), g());
  }
  function c(b) {
    if (d(s).status === "processing") {
      if (b !== "abort")
        return d(s).abortController;
      l(d(s));
    }
    return new AbortController();
  }
  async function f(b, g) {
    if (b === !1)
      throw new GC(d(s));
    const h = c(b), y = t.execute(h.signal, ...g);
    if (b === "untrack")
      return y;
    const S = y.then(
      (x) => (u(S, () => {
        q(s, { status: "success" }), t.onSuccess?.(x, ...g);
      }), x),
      (x) => (u(S, () => {
        q(s, { status: "failed", reason: "error", error: x }), t.onFailure?.(d(s), ...g);
      }), Promise.reject(x))
    );
    return q(s, {
      status: "processing",
      delayed: _.isDelayed,
      args: g,
      promise: S,
      abortController: h
    }), a(), o = setTimeout(
      () => {
        d(s).status !== "processing" || d(s).promise !== S || q(s, { ...d(s), delayed: !0 });
      },
      d(e)
    ), i = setTimeout(
      () => {
        d(s).status !== "processing" || d(s).promise !== S || (l(d(s)), q(s, { status: "failed", reason: "timeout" }), t.onFailure?.(d(s), ...g));
      },
      d(r)
    ), S;
  }
  function p(b) {
    return ot(() => f(d(n)(d(s)), b));
  }
  const _ = {
    get state() {
      return d(s);
    },
    get status() {
      return d(s).status;
    },
    get isSuccess() {
      return d(s).status === "success";
    },
    get isFailed() {
      return d(s).status === "failed";
    },
    get isProcessed() {
      return d(s).status === "processing";
    },
    get isDelayed() {
      return d(s).status === "processing" && d(s).delayed;
    },
    matches(b) {
      return d(s).status === b;
    },
    run(...b) {
      p(b).catch(dy);
    },
    runAsync(...b) {
      return p(b);
    },
    abort() {
      ot(() => {
        if (d(s).status !== "processing") return;
        const { args: b } = d(s);
        l(d(s)), a(), q(s, { status: "failed", reason: "aborted" }), t.onFailure?.(d(s), ...b);
      });
    }
  };
  return _;
}
function XC([t, e]) {
  return {
    get current() {
      return t();
    },
    set current(r) {
      e(r);
    }
  };
}
function sb({
  initialOutput: t,
  getInput: e,
  setInput: r,
  toInput: n,
  toOutput: s,
  isEqual: o = Object.is
}) {
  let i;
  const a = yo({
    combinator: yi,
    execute: n,
    onSuccess(c) {
      i = c, r(c);
    }
  });
  let l = /* @__PURE__ */ xe(t);
  const u = yo({
    combinator: yi,
    execute: s,
    onSuccess(c) {
      q(l, c);
    }
  });
  return Ze(() => {
    const c = e();
    o(c, i) || (a.abort(), u.run(c));
  }), {
    get current() {
      return d(l);
    },
    set current(c) {
      u.abort(), q(l, c), a.run(c);
    },
    get inputProcessing() {
      return a.isProcessed;
    },
    get outputProcessing() {
      return u.isProcessed;
    }
  };
}
const Tc = "name=", Bg = "data:", Nd = ";base64,", JC = 8192;
function ZC(t, e = "unknown") {
  if (!t.startsWith(Bg))
    throw new Error("File is invalid: URI must be a dataURI");
  const n = t.slice(Bg.length).split(Nd);
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [s, o] = n, i = s.split(";"), a = {
    mime: i[0],
    name: e,
    base64content: o
  };
  if (i.length > 1) {
    const l = i.slice(1).find((u) => u.startsWith(Tc));
    l !== void 0 && (a.name = decodeURIComponent(l.substring(Tc.length)));
  }
  return a;
}
function QC(t, e = JC) {
  return async (r, n) => {
    const { mime: s, base64content: o, name: i } = ZC(n);
    try {
      const a = atob(o);
      await t({ signal: r });
      const l = new Uint8Array(a.length);
      for (let c = 0; c < a.length; c++)
        c % e === 0 && await t({ signal: r }), l[c] = a.charCodeAt(c);
      return { blob: new Blob([l], { type: s }), name: i };
    } catch (a) {
      throw a instanceof DOMException && a.name === "AbortError" ? a : new Error("File is invalid: " + a.message);
    }
  };
}
function ek(t) {
  return `;${Tc}${encodeURIComponent(t)}${Nd}`;
}
function tk(t, e) {
  const r = new FileReader(), n = () => {
    r.abort();
  };
  return t.addEventListener("abort", n), new Promise((s, o) => {
    r.onerror = o, r.onabort = o, r.onload = (i) => {
      let a = i.target?.result;
      if (typeof a != "string") {
        o(new Error("File is invalid: result must be a string"));
        return;
      }
      a = a.replace(Nd, ek(e.name)), s(a);
    }, r.readAsDataURL(e);
  }).finally(() => {
    t.removeEventListener("abort", n);
  });
}
const ob = tk, eo = /* @__PURE__ */ Symbol("unchanged");
function rk(t) {
  return function e(r, n) {
    if (r === n)
      return eo;
    if (typeof r == "object" && typeof n == "object") {
      const s = Array.isArray(r), o = Array.isArray(n);
      if (s && o) {
        const i = Math.min(r.length, n.length);
        let a = 0;
        for (; a < i; a++) {
          const l = e(r[a], n[a]);
          l !== eo && (r[a] = l);
        }
        if (r.length !== n.length) {
          const l = t.get(r) ?? r;
          for (; a < n.length; a++)
            l.push(n[a]);
          l.splice(n.length);
        }
        return eo;
      }
      if (!s && !o && r !== null && n !== null && hi(r) && hi(n)) {
        const i = Object.keys(r);
        let a = i.length;
        for (let u = 0; u < a; u++) {
          const c = i[u];
          c in n || delete r[c];
        }
        const l = Object.keys(n);
        a = l.length;
        for (let u = 0; u < a; u++) {
          const c = l[u], f = e(r[c], n[c]);
          f !== eo && (r[c] = f);
        }
        return eo;
      }
    }
    return n;
  };
}
const nk = "uiOptionsRegistry";
function sk(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
function ib(t) {
  const e = /* @__PURE__ */ C(() => t.idPrefix ?? Ty), r = /* @__PURE__ */ C(() => t.uiSchema ?? {}), n = /* @__PURE__ */ C(() => nl(d(r), t.uiSchema) ?? {}), s = /* @__PURE__ */ C(() => t[nk] ?? {}), o = /* @__PURE__ */ C(() => (t.schema, { current: void 0 })), i = /* @__PURE__ */ C(() => Wl(d(o), [])), a = /* @__PURE__ */ C(() => Du(t.validator, {
    uiSchema: d(r),
    uiOptionsRegistry: d(s),
    schema: t.schema,
    merger: () => d(l)
  })), l = /* @__PURE__ */ C(() => Du(t.merger, {
    validator: d(a),
    schema: t.schema,
    uiSchema: d(r),
    uiOptionsRegistry: d(s)
  })), u = /* @__PURE__ */ C(() => t.value ? XC(t.value) : sk(d(l).mergeFormDataAndSchemaDefaults({ formData: t.initialValue, schema: t.schema }))), c = /* @__PURE__ */ C(() => Du(t.idBuilder, {
    idPrefix: d(e),
    schema: t.schema,
    uiSchema: d(r),
    uiOptionsRegistry: d(s),
    merger: d(l),
    validator: d(a),
    valueRef: d(u)
  })), f = /* @__PURE__ */ C(() => Fr(d(a), d(l), t.schema, t.schema, d(u).current)), p = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ C(() => Bl(p, (j) => d(c).fromPath(j))), b = /* @__PURE__ */ C(() => {
    const j = new vC(d(o)), ee = t.initialErrors;
    return ee === void 0 ? j : Array.isArray(ee) ? j.updateErrors(ee) : j.assign(ee);
  }), g = /* @__PURE__ */ C(() => t.disabled ?? !1), h = /* @__PURE__ */ C(() => t.fieldsValidationMode ?? 0), y = /* @__PURE__ */ C(() => t.keyedArraysMap ?? /* @__PURE__ */ new WeakMap()), S = /* @__PURE__ */ C(() => rk(d(y))), x = /* @__PURE__ */ C(() => t.schedulerYield ?? (typeof scheduler < "u" && "yield" in scheduler) ? scheduler.yield.bind(scheduler) : ({ signal: j }) => new Promise((ee, L) => {
    setTimeout(
      () => {
        j.aborted ? L(j.reason) : ee();
      },
      0
    );
  })), P = /* @__PURE__ */ C(() => QC(d(x))), w = /* @__PURE__ */ C(() => Dy(t.translation)), O = new Cd(), k = /* @__PURE__ */ C(() => O.size > 0), $ = /* @__PURE__ */ C(() => mC(O, d(i), Fg));
  let T = !0, E = /* @__PURE__ */ C(() => {
    t.schema;
    const j = T;
    return T = !1, j;
  });
  const M = /* @__PURE__ */ C(() => "validateFormValueAsync" in d(a) ? (j, ee, L) => d(a).validateFormValueAsync(j, ee, L) : (j, ee, L) => Promise.resolve(d(a).validateFormValue(ee, L))), R = yo({
    async execute(j) {
      return Os(Y, d(i), Fg), await d(M)(j, t.validateByRetrievedSchema ? d(f) : t.schema, xo(d(u).current));
    },
    onSuccess(j, ee) {
      if (CC(Y, j.errors ?? []), j.errors === void 0) {
        t.onSubmit?.(j.value, ee), O.clear();
        return;
      }
      t.onSubmitError?.(j, ee, Y);
    },
    onFailure(j, ee) {
      ci(Y, d(i), [d(w)("validation-process-error", { error: j })]), t.onSubmissionFailure?.(j, ee);
    },
    get combinator() {
      return t.submissionCombinator;
    },
    get delayedMs() {
      return t.submissionDelayedMs;
    },
    get timeoutMs() {
      return t.submissionTimeoutMs;
    }
  }), U = /* @__PURE__ */ C(() => dC(d(a)) ? (j, ee, L) => d(a).validateFieldValueAsync(j, ee, L) : cC(d(a)) ? (j, ee, L) => Promise.resolve(d(a).validateFieldValue(ee, L)) : () => Promise.resolve([])), B = yo({
    execute(j, ee, L) {
      const N = t.fieldsValidationDebounceMs ?? 300;
      if (N < 0)
        return d(U)(j, ee, L);
      const V = Promise.withResolvers(), G = setTimeout(
        () => {
          V.resolve(d(U)(j, ee, L));
        },
        N
      ), fe = () => {
        clearTimeout(G), V.reject(new DOMException("field validation has been aborted", "AbortError"));
      };
      return j.addEventListener("abort", fe), V.promise.finally(() => {
        j.removeEventListener("abort", fe);
      });
    },
    onSuccess(j, ee) {
      ci(Y, ee.path, j);
    },
    onFailure(j, ee, L) {
      j.reason !== "aborted" && ci(Y, ee.path, [d(w)("validation-process-error", { error: j })]), t.onFieldsValidationFailure?.(j, ee, L);
    },
    get combinator() {
      return t.fieldsValidationCombinator ?? yi;
    },
    get delayedMs() {
      return t.fieldsValidationDelayedMs;
    },
    get timeoutMs() {
      return t.fieldsValidationTimeoutMs;
    }
  });
  function F(j) {
    j.preventDefault(), R.run(j);
  }
  function Z(j) {
    j?.preventDefault(), O.clear(), d(b).clear(), d(u).current = d(l).mergeFormDataAndSchemaDefaults({ formData: t.initialValue, schema: t.schema }), t.onReset?.(j);
  }
  const Y = {
    submission: R,
    fieldsValidation: B,
    get isSubmitted() {
      return d($);
    },
    get isChanged() {
      return d(k);
    },
    submit: F,
    reset: Z,
    // INTERNALS
    [vi]: O,
    get [Ny]() {
      return d(e);
    },
    get [Ao]() {
      return d(b);
    },
    get [Ed]() {
      return d(o);
    },
    get [Fy]() {
      return d(_);
    },
    get [Kl]() {
      return d(i);
    },
    get [Un]() {
      return d(u).current;
    },
    set [Un](j) {
      d(u).current = j;
    },
    get [Td]() {
      return d(h);
    },
    get [By]() {
      return d(P);
    },
    get [Cc]() {
      return d(y);
    },
    get [Zt]() {
      return t.schema;
    },
    get [kc]() {
      return d(f);
    },
    get [Hl]() {
      return d(r);
    },
    get [po]() {
      return d(n);
    },
    get [Eo]() {
      return t.extraUiOptions;
    },
    get [Vy]() {
      return d(s);
    },
    get [jy]() {
      return d(g);
    },
    get [Rr]() {
      return d(a);
    },
    get [tn]() {
      return d(l);
    },
    get [qy]() {
      return d(X);
    },
    get [Ac]() {
      return t.theme;
    },
    get [zy]() {
      return t.translation;
    },
    get [$c]() {
      return d(w);
    },
    get [Ly]() {
      return t.icons;
    },
    [Ry]() {
      ae || (ae = !0, queueMicrotask(J));
    }
  }, X = /* @__PURE__ */ C(() => t.resolver(Y));
  let ae = !1;
  function J() {
    ae = !1;
    const j = d(l).mergeFormDataAndSchemaDefaults({
      formData: d(u).current,
      schema: t.schema,
      initialDefaultsGenerated: d(E)
    });
    q(E, !0);
    const ee = d(S)(d(u).current, j);
    ee !== eo && (d(u).current = ee);
  }
  return Y;
}
var ok = /* @__PURE__ */ ne('<input type="hidden"/>');
function ab(t, e) {
  H(e, !0);
  const r = v(e, "form", 7), n = v(e, "name", 7, Rg);
  var s = {
    get form() {
      return r();
    },
    set form(i) {
      r(i), m();
    },
    get name() {
      return n();
    },
    set name(i = Rg) {
      n(i), m();
    }
  }, o = ok();
  return ty(o), ke(() => {
    Cn(o, "name", n()), BP(o, r()[Ny]);
  }), A(t, o), W(s);
}
K(ab, { form: {}, name: {} }, [], [], { mode: "open" });
var ik = /* @__PURE__ */ ne("<!> <!>", 1);
function lb(t, e) {
  H(e, !0);
  const r = De(), n = /* @__PURE__ */ C(() => ({
    path: r[Kl],
    title: Wr(r, r[po]) ?? r[kc].title ?? "",
    schema: r[kc],
    uiSchema: r[po],
    required: !0
  })), s = /* @__PURE__ */ C(() => vo(r, d(n)));
  var o = ik(), i = D(o);
  ab(i, {
    get form() {
      return r;
    }
  });
  var a = be(i, 2);
  {
    let l = /* @__PURE__ */ C(() => Ms(r, d(n)));
    Q(a, () => d(s), (u, c) => {
      c(u, {
        type: "field",
        get config() {
          return d(n);
        },
        uiOption: (f) => It(r, d(n), f),
        get translate() {
          return d(l);
        },
        get value() {
          return r[Un];
        },
        set value(f) {
          r[Un] = f;
        }
      });
    });
  }
  A(t, o), W();
}
K(lb, {}, [], [], { mode: "open" });
function vn(t, e) {
  H(e, !0);
  const r = De(), n = v(e, "id", 7), s = v(e, "config", 7), o = v(e, "translate", 7), i = v(e, "args", 23, () => ({})), a = /* @__PURE__ */ C(() => o()(n(), i())), l = /* @__PURE__ */ C(() => ({
    config: s(),
    params: i(),
    translation: d(a)
  })), u = /* @__PURE__ */ C(() => r[Ly]?.(n(), d(
    //@ts-expect-error TODO: fix if possible
    l
  )));
  var c = {
    get id() {
      return n();
    },
    set id(g) {
      n(g), m();
    },
    get config() {
      return s();
    },
    set config(g) {
      s(g), m();
    },
    get translate() {
      return o();
    },
    set translate(g) {
      o(g), m();
    },
    get args() {
      return i();
    },
    set args(g = {}) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, () => d(u), () => d(l)), A(g, h);
    }, b = (g) => {
      var h = tt();
      ke(() => Me(h, d(a))), A(g, h);
    };
    ue(p, (g) => {
      d(u) ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(vn, { id: {}, config: {}, translate: {}, args: {} }, [], [], { mode: "open" });
function ub(t, e) {
  H(e, !0);
  const r = De(), n = /* @__PURE__ */ C(() => ({
    path: Mi(r, r[Kl], "submit"),
    title: "",
    schema: r[Zt],
    uiSchema: r[po],
    required: !1
  })), s = /* @__PURE__ */ C(() => Le(r, "submitButton", d(n)));
  var o = I(), i = D(o);
  Q(i, () => d(s), (a, l) => {
    l(a, {
      get config() {
        return d(n);
      },
      children: (u, c) => {
        {
          let f = /* @__PURE__ */ C(() => Ms(r, d(n)));
          vn(u, {
            get config() {
              return d(n);
            },
            id: "submit",
            get translate() {
              return d(f);
            }
          });
        }
      },
      $$slots: { default: !0 }
    });
  }), A(t, o), W();
}
K(ub, {}, [], [], { mode: "open" });
function cb(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15), n = v(e, "children", 7), s = v(e, "attributes", 7);
  const o = De(), i = /* @__PURE__ */ C(() => ({
    path: Mi(o, o[Kl], "form"),
    title: "",
    schema: o[Zt],
    uiSchema: o[po],
    required: !1
  })), a = /* @__PURE__ */ C(() => Le(o, "form", d(i)));
  var l = {
    get ref() {
      return r();
    },
    set ref(f) {
      r(f), m();
    },
    get children() {
      return n();
    },
    set children(f) {
      n(f), m();
    },
    get attributes() {
      return s();
    },
    set attributes(f) {
      s(f), m();
    }
  }, u = I(), c = D(u);
  return Q(c, () => d(a), (f, p) => {
    p(f, {
      get config() {
        return d(i);
      },
      get children() {
        return n();
      },
      get attributes() {
        return s();
      },
      get ref() {
        return r();
      },
      set ref(_) {
        r(_);
      }
    });
  }), A(t, u), W(l);
}
K(cb, { ref: {}, children: {}, attributes: {} }, [], [], { mode: "open" });
var ak = /* @__PURE__ */ ne("<!> <!>", 1);
function Fd(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15), n = v(e, "form", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "form"]);
  Uy(n());
  var o = {
    get ref() {
      return r();
    },
    set ref(i) {
      r(i), m();
    },
    get form() {
      return n();
    },
    set form(i) {
      n(i), m();
    }
  };
  return cb(t, {
    get attributes() {
      return s;
    },
    get ref() {
      return r();
    },
    set ref(i) {
      r(i);
    },
    children: (i, a) => {
      var l = ak(), u = D(l);
      lb(u, {});
      var c = be(u, 2);
      ub(c, {}), A(i, l);
    },
    $$slots: { default: !0 }
  }), W(o);
}
K(Fd, { ref: {}, form: {} }, [], [], { mode: "open" });
function lk(t, e) {
  H(e, !0);
  const n = ib(/* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]));
  AP(() => {
    n.submission.abort(), n.fieldsValidation.abort();
  }), Fd(t, {
    get form() {
      return n;
    }
  }), W();
}
K(lk, {}, [], [], { mode: "open" });
var uk = /* @__PURE__ */ ne("<option></option>"), ck = /* @__PURE__ */ ne("<datalist></datalist>");
function Rd(t, e) {
  H(e, !0);
  const r = v(e, "id", 7), n = v(e, "config", 7), s = /* @__PURE__ */ C(() => {
    const { default: u, examples: c } = n().schema;
    if (!(!Array.isArray(c) || !r()))
      return u !== void 0 && !c.includes(u) ? [u].concat(c) : c;
  });
  var o = {
    get id() {
      return r();
    },
    set id(u) {
      r(u), m();
    },
    get config() {
      return n();
    },
    set config(u) {
      n(u), m();
    }
  }, i = I(), a = D(i);
  {
    var l = (u) => {
      var c = ck();
      st(c, 20, () => d(s), (f) => f, (f, p) => {
        var _ = uk(), b = {};
        ke(() => {
          b !== (b = p) && (_.value = (_.__value = p) ?? "");
        }), A(f, _);
      }), de(c), ke(() => Cn(c, "id", r())), A(u, c);
    };
    ue(a, (u) => {
      d(s) && u(l);
    });
  }
  return A(t, i), W(o);
}
K(Rd, { id: {}, config: {} }, [], [], { mode: "open" });
function dk(t, e) {
  H(e, !0);
  const r = v(e, "form", 7), n = v(e, "path", 7), s = v(e, "required", 7), o = v(e, "uiSchema", 7), i = v(e, "render", 7), a = /* @__PURE__ */ C(() => Wl(r()[Ed], n())), l = /* @__PURE__ */ C(() => {
    if (d(a).length === 0)
      return {
        get current() {
          return r()[Un];
        },
        set current(E) {
          r()[Un] = E;
        }
      };
    let O = r()[Un], k = -1;
    const $ = d(a).length - 1;
    for (; Ts(O) && ++k < $; )
      O = O[d(a)[k]];
    if (k !== $)
      throw console.error("Current form state", xo(r()[Un])), new Error(`Path "[${d(a).join(", ")}]" is not populated or invalid, check current form state`);
    const T = d(a)[$];
    return {
      get current() {
        return O[T];
      },
      set current(E) {
        O[T] = E;
      }
    };
  }), u = /* @__PURE__ */ C(() => {
    if (d(a).length < 2)
      return r()[Zt];
    const k = Ig(r()[Rr], r()[tn], r()[Zt], r()[Zt], d(a).slice(0, -1), d(l).current);
    return k === void 0 || typeof k == "boolean" ? {} : k;
  }), c = /* @__PURE__ */ C(() => {
    if (d(a).length === 0)
      return r()[Zt];
    let O = d(l).current;
    const k = d(a).slice(0, -1);
    for (let T = 0; T < k.length && O !== void 0; T++) {
      const E = k[T];
      typeof E == "number" ? O = Array.isArray(O) ? O[E] : void 0 : O = Be(O) ? O[E] : void 0;
    }
    const $ = Ig(r()[Rr], r()[tn], r()[Zt], d(u), d(a).slice(-1), O);
    return $ === void 0 || typeof $ == "boolean" ? {} : $;
  }), f = /* @__PURE__ */ C(() => $r(r(), d(c), d(l).current)), p = /* @__PURE__ */ C(() => o() ?? Od(r()[Hl], r()[po], d(a)) ?? {}), _ = /* @__PURE__ */ C(() => {
    if (s() !== void 0)
      return s();
    if (d(a).length === 0)
      return !1;
    const O = d(a)[d(a).length - 1], { required: k, items: $, minItems: T } = d(u);
    if (Array.isArray(k))
      return k.includes(O);
    const E = Number(O);
    if (Number.isInteger(E) && E >= 0) {
      if (T !== void 0)
        return E < T;
      if (Array.isArray($))
        return E < $.length;
    }
    return !1;
  }), b = /* @__PURE__ */ C(() => ({
    path: d(a),
    title: Wr(r(), d(p)) ?? d(f).title ?? "",
    schema: d(f),
    uiSchema: d(p),
    required: d(_)
  })), g = /* @__PURE__ */ C(() => Ms(r(), d(b))), h = (O) => It(r(), d(b), O);
  Uy(r());
  var y = {
    get form() {
      return r();
    },
    set form(O) {
      r(O), m();
    },
    get path() {
      return n();
    },
    set path(O) {
      n(O), m();
    },
    get required() {
      return s();
    },
    set required(O) {
      s(O), m();
    },
    get uiSchema() {
      return o();
    },
    set uiSchema(O) {
      o(O), m();
    },
    get render() {
      return i();
    },
    set render(O) {
      i(O), m();
    }
  }, S = I(), x = D(S);
  {
    var P = (O) => {
      var k = I(), $ = D(k);
      te($, i, () => ({
        type: "field",
        config: d(b),
        translate: d(g),
        uiOption: h,
        valueRef: d(l)
      })), A(O, k);
    }, w = (O) => {
      const k = /* @__PURE__ */ C(() => vo(r(), d(b)));
      var $ = I(), T = D($);
      Q(T, () => d(k), (E, M) => {
        M(E, {
          type: "field",
          get config() {
            return d(b);
          },
          uiOption: h,
          get translate() {
            return d(g);
          },
          get value() {
            return d(l).current;
          },
          set value(R) {
            d(l).current = R;
          }
        });
      }), A(O, $);
    };
    ue(x, (O) => {
      i() ? O(P) : O(w, !1);
    });
  }
  return A(t, S), W(y);
}
K(dk, { form: {}, path: {}, required: {}, uiSchema: {}, render: {} }, [], [], { mode: "open" });
function fk(t) {
  Ze(() => Ye(window, "beforeunload", (e) => {
    t.isChanged && (e.preventDefault(), e.returnValue = "");
  }));
}
const hk = {
  allErrors: !0,
  multipleOfPrecision: 8,
  strict: !1,
  verbose: !0,
  discriminator: !0
}, gk = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, pk = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function mk(t) {
  return t.addFormat("color", gk), t.addFormat(uy, pk), t;
}
function vk(t) {
  return t.addKeyword(jl), t;
}
function yk(t) {
  return vk(mk(t));
}
function bk(t, e, r = /* @__PURE__ */ new WeakMap()) {
  let n = "", s = !1;
  const o = cy(r, (i) => {
    let a = i;
    return s && (a = YO(i, n), delete a[wg]), t.compile(a);
  });
  return (i, a) => {
    n = a[wg] ?? JP;
    let l = t.getSchema(n)?.schema;
    return l !== void 0 && l !== a && (t.removeSchema(n), r.delete(i), l = void 0), l === void 0 && t.addSchema(a, n), s = i !== a, o(i);
  };
}
function _k(t, e) {
  const n = Bl(/* @__PURE__ */ new WeakMap(), (s) => t.compile({ ...s, $async: e }));
  return (s) => n(s.schema);
}
var Wi = { exports: {} }, Iu = {}, cn = {}, ps = {}, Nu = {}, Fu = {}, Ru = {}, zg;
function ol() {
  return zg || (zg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
    class e {
    }
    t._CodeOrName = e, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends e {
      constructor(S) {
        if (super(), !t.IDENTIFIER.test(S))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = S;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    t.Name = r;
    class n extends e {
      constructor(S) {
        super(), this._items = typeof S == "string" ? [S] : S;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const S = this._items[0];
        return S === "" || S === '""';
      }
      get str() {
        var S;
        return (S = this._str) !== null && S !== void 0 ? S : this._str = this._items.reduce((x, P) => `${x}${P}`, "");
      }
      get names() {
        var S;
        return (S = this._names) !== null && S !== void 0 ? S : this._names = this._items.reduce((x, P) => (P instanceof r && (x[P.str] = (x[P.str] || 0) + 1), x), {});
      }
    }
    t._Code = n, t.nil = new n("");
    function s(y, ...S) {
      const x = [y[0]];
      let P = 0;
      for (; P < S.length; )
        a(x, S[P]), x.push(y[++P]);
      return new n(x);
    }
    t._ = s;
    const o = new n("+");
    function i(y, ...S) {
      const x = [_(y[0])];
      let P = 0;
      for (; P < S.length; )
        x.push(o), a(x, S[P]), x.push(o, _(y[++P]));
      return l(x), new n(x);
    }
    t.str = i;
    function a(y, S) {
      S instanceof n ? y.push(...S._items) : S instanceof r ? y.push(S) : y.push(f(S));
    }
    t.addCodeArg = a;
    function l(y) {
      let S = 1;
      for (; S < y.length - 1; ) {
        if (y[S] === o) {
          const x = u(y[S - 1], y[S + 1]);
          if (x !== void 0) {
            y.splice(S - 1, 3, x);
            continue;
          }
          y[S++] = "+";
        }
        S++;
      }
    }
    function u(y, S) {
      if (S === '""')
        return y;
      if (y === '""')
        return S;
      if (typeof y == "string")
        return S instanceof r || y[y.length - 1] !== '"' ? void 0 : typeof S != "string" ? `${y.slice(0, -1)}${S}"` : S[0] === '"' ? y.slice(0, -1) + S.slice(1) : void 0;
      if (typeof S == "string" && S[0] === '"' && !(y instanceof r))
        return `"${y}${S.slice(1)}`;
    }
    function c(y, S) {
      return S.emptyStr() ? y : y.emptyStr() ? S : i`${y}${S}`;
    }
    t.strConcat = c;
    function f(y) {
      return typeof y == "number" || typeof y == "boolean" || y === null ? y : _(Array.isArray(y) ? y.join(",") : y);
    }
    function p(y) {
      return new n(_(y));
    }
    t.stringify = p;
    function _(y) {
      return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    t.safeStringify = _;
    function b(y) {
      return typeof y == "string" && t.IDENTIFIER.test(y) ? new n(`.${y}`) : s`[${y}]`;
    }
    t.getProperty = b;
    function g(y) {
      if (typeof y == "string" && t.IDENTIFIER.test(y))
        return new n(`${y}`);
      throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
    }
    t.getEsmExportName = g;
    function h(y) {
      return new n(y.toString());
    }
    t.regexpCode = h;
  })(Ru)), Ru;
}
var Vu = {}, qg;
function Ug() {
  return qg || (qg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
    const e = ol();
    class r extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var n;
    (function(l) {
      l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
    })(n || (t.UsedValueState = n = {})), t.varKinds = {
      const: new e.Name("const"),
      let: new e.Name("let"),
      var: new e.Name("var")
    };
    class s {
      constructor({ prefixes: u, parent: c } = {}) {
        this._names = {}, this._prefixes = u, this._parent = c;
      }
      toName(u) {
        return u instanceof e.Name ? u : this.name(u);
      }
      name(u) {
        return new e.Name(this._newName(u));
      }
      _newName(u) {
        const c = this._names[u] || this._nameGroup(u);
        return `${u}${c.index++}`;
      }
      _nameGroup(u) {
        var c, f;
        if (!((f = (c = this._parent) === null || c === void 0 ? void 0 : c._prefixes) === null || f === void 0) && f.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    t.Scope = s;
    class o extends e.Name {
      constructor(u, c) {
        super(c), this.prefix = u;
      }
      setValue(u, { property: c, itemIndex: f }) {
        this.value = u, this.scopePath = (0, e._)`.${new e.Name(c)}[${f}]`;
      }
    }
    t.ValueScopeName = o;
    const i = (0, e._)`\n`;
    class a extends s {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? i : e.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new o(u, this._newName(u));
      }
      value(u, c) {
        var f;
        if (c.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const p = this.toName(u), { prefix: _ } = p, b = (f = c.key) !== null && f !== void 0 ? f : c.ref;
        let g = this._values[_];
        if (g) {
          const S = g.get(b);
          if (S)
            return S;
        } else
          g = this._values[_] = /* @__PURE__ */ new Map();
        g.set(b, p);
        const h = this._scope[_] || (this._scope[_] = []), y = h.length;
        return h[y] = c.ref, p.setValue(c, { property: _, itemIndex: y }), p;
      }
      getValue(u, c) {
        const f = this._values[u];
        if (f)
          return f.get(c);
      }
      scopeRefs(u, c = this._values) {
        return this._reduceValues(c, (f) => {
          if (f.scopePath === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return (0, e._)`${u}${f.scopePath}`;
        });
      }
      scopeCode(u = this._values, c, f) {
        return this._reduceValues(u, (p) => {
          if (p.value === void 0)
            throw new Error(`CodeGen: name "${p}" has no value`);
          return p.value.code;
        }, c, f);
      }
      _reduceValues(u, c, f = {}, p) {
        let _ = e.nil;
        for (const b in u) {
          const g = u[b];
          if (!g)
            continue;
          const h = f[b] = f[b] || /* @__PURE__ */ new Map();
          g.forEach((y) => {
            if (h.has(y))
              return;
            h.set(y, n.Started);
            let S = c(y);
            if (S) {
              const x = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
              _ = (0, e._)`${_}${x} ${y} = ${S};${this.opts._n}`;
            } else if (S = p?.(y))
              _ = (0, e._)`${_}${S}${this.opts._n}`;
            else
              throw new r(y);
            h.set(y, n.Completed);
          });
        }
        return _;
      }
    }
    t.ValueScope = a;
  })(Vu)), Vu;
}
var Kg;
function We() {
  return Kg || (Kg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
    const e = ol(), r = Ug();
    var n = ol();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var s = Ug();
    Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
      return s.Scope;
    } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
      return s.ValueScope;
    } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
      return s.ValueScopeName;
    } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
      return s.varKinds;
    } }), t.operators = {
      GT: new e._Code(">"),
      GTE: new e._Code(">="),
      LT: new e._Code("<"),
      LTE: new e._Code("<="),
      EQ: new e._Code("==="),
      NEQ: new e._Code("!=="),
      NOT: new e._Code("!"),
      OR: new e._Code("||"),
      AND: new e._Code("&&"),
      ADD: new e._Code("+")
    };
    class o {
      optimizeNodes() {
        return this;
      }
      optimizeNames(N, V) {
        return this;
      }
    }
    class i extends o {
      constructor(N, V, G) {
        super(), this.varKind = N, this.name = V, this.rhs = G;
      }
      render({ es5: N, _n: V }) {
        const G = N ? r.varKinds.var : this.varKind, fe = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${G} ${this.name}${fe};` + V;
      }
      optimizeNames(N, V) {
        if (N[this.name.str])
          return this.rhs && (this.rhs = B(this.rhs, N, V)), this;
      }
      get names() {
        return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
      }
    }
    class a extends o {
      constructor(N, V, G) {
        super(), this.lhs = N, this.rhs = V, this.sideEffects = G;
      }
      render({ _n: N }) {
        return `${this.lhs} = ${this.rhs};` + N;
      }
      optimizeNames(N, V) {
        if (!(this.lhs instanceof e.Name && !N[this.lhs.str] && !this.sideEffects))
          return this.rhs = B(this.rhs, N, V), this;
      }
      get names() {
        const N = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
        return U(N, this.rhs);
      }
    }
    class l extends a {
      constructor(N, V, G, fe) {
        super(N, G, fe), this.op = V;
      }
      render({ _n: N }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + N;
      }
    }
    class u extends o {
      constructor(N) {
        super(), this.label = N, this.names = {};
      }
      render({ _n: N }) {
        return `${this.label}:` + N;
      }
    }
    class c extends o {
      constructor(N) {
        super(), this.label = N, this.names = {};
      }
      render({ _n: N }) {
        return `break${this.label ? ` ${this.label}` : ""};` + N;
      }
    }
    class f extends o {
      constructor(N) {
        super(), this.error = N;
      }
      render({ _n: N }) {
        return `throw ${this.error};` + N;
      }
      get names() {
        return this.error.names;
      }
    }
    class p extends o {
      constructor(N) {
        super(), this.code = N;
      }
      render({ _n: N }) {
        return `${this.code};` + N;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(N, V) {
        return this.code = B(this.code, N, V), this;
      }
      get names() {
        return this.code instanceof e._CodeOrName ? this.code.names : {};
      }
    }
    class _ extends o {
      constructor(N = []) {
        super(), this.nodes = N;
      }
      render(N) {
        return this.nodes.reduce((V, G) => V + G.render(N), "");
      }
      optimizeNodes() {
        const { nodes: N } = this;
        let V = N.length;
        for (; V--; ) {
          const G = N[V].optimizeNodes();
          Array.isArray(G) ? N.splice(V, 1, ...G) : G ? N[V] = G : N.splice(V, 1);
        }
        return N.length > 0 ? this : void 0;
      }
      optimizeNames(N, V) {
        const { nodes: G } = this;
        let fe = G.length;
        for (; fe--; ) {
          const se = G[fe];
          se.optimizeNames(N, V) || (F(N, se.names), G.splice(fe, 1));
        }
        return G.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((N, V) => R(N, V.names), {});
      }
    }
    class b extends _ {
      render(N) {
        return "{" + N._n + super.render(N) + "}" + N._n;
      }
    }
    class g extends _ {
    }
    class h extends b {
    }
    h.kind = "else";
    class y extends b {
      constructor(N, V) {
        super(V), this.condition = N;
      }
      render(N) {
        let V = `if(${this.condition})` + super.render(N);
        return this.else && (V += "else " + this.else.render(N)), V;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const N = this.condition;
        if (N === !0)
          return this.nodes;
        let V = this.else;
        if (V) {
          const G = V.optimizeNodes();
          V = this.else = Array.isArray(G) ? new h(G) : G;
        }
        if (V)
          return N === !1 ? V instanceof y ? V : V.nodes : this.nodes.length ? this : new y(Z(N), V instanceof y ? [V] : V.nodes);
        if (!(N === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(N, V) {
        var G;
        if (this.else = (G = this.else) === null || G === void 0 ? void 0 : G.optimizeNames(N, V), !!(super.optimizeNames(N, V) || this.else))
          return this.condition = B(this.condition, N, V), this;
      }
      get names() {
        const N = super.names;
        return U(N, this.condition), this.else && R(N, this.else.names), N;
      }
    }
    y.kind = "if";
    class S extends b {
    }
    S.kind = "for";
    class x extends S {
      constructor(N) {
        super(), this.iteration = N;
      }
      render(N) {
        return `for(${this.iteration})` + super.render(N);
      }
      optimizeNames(N, V) {
        if (super.optimizeNames(N, V))
          return this.iteration = B(this.iteration, N, V), this;
      }
      get names() {
        return R(super.names, this.iteration.names);
      }
    }
    class P extends S {
      constructor(N, V, G, fe) {
        super(), this.varKind = N, this.name = V, this.from = G, this.to = fe;
      }
      render(N) {
        const V = N.es5 ? r.varKinds.var : this.varKind, { name: G, from: fe, to: se } = this;
        return `for(${V} ${G}=${fe}; ${G}<${se}; ${G}++)` + super.render(N);
      }
      get names() {
        const N = U(super.names, this.from);
        return U(N, this.to);
      }
    }
    class w extends S {
      constructor(N, V, G, fe) {
        super(), this.loop = N, this.varKind = V, this.name = G, this.iterable = fe;
      }
      render(N) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(N);
      }
      optimizeNames(N, V) {
        if (super.optimizeNames(N, V))
          return this.iterable = B(this.iterable, N, V), this;
      }
      get names() {
        return R(super.names, this.iterable.names);
      }
    }
    class O extends b {
      constructor(N, V, G) {
        super(), this.name = N, this.args = V, this.async = G;
      }
      render(N) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(N);
      }
    }
    O.kind = "func";
    class k extends _ {
      render(N) {
        return "return " + super.render(N);
      }
    }
    k.kind = "return";
    class $ extends b {
      render(N) {
        let V = "try" + super.render(N);
        return this.catch && (V += this.catch.render(N)), this.finally && (V += this.finally.render(N)), V;
      }
      optimizeNodes() {
        var N, V;
        return super.optimizeNodes(), (N = this.catch) === null || N === void 0 || N.optimizeNodes(), (V = this.finally) === null || V === void 0 || V.optimizeNodes(), this;
      }
      optimizeNames(N, V) {
        var G, fe;
        return super.optimizeNames(N, V), (G = this.catch) === null || G === void 0 || G.optimizeNames(N, V), (fe = this.finally) === null || fe === void 0 || fe.optimizeNames(N, V), this;
      }
      get names() {
        const N = super.names;
        return this.catch && R(N, this.catch.names), this.finally && R(N, this.finally.names), N;
      }
    }
    class T extends b {
      constructor(N) {
        super(), this.error = N;
      }
      render(N) {
        return `catch(${this.error})` + super.render(N);
      }
    }
    T.kind = "catch";
    class E extends b {
      render(N) {
        return "finally" + super.render(N);
      }
    }
    E.kind = "finally";
    class M {
      constructor(N, V = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...V, _n: V.lines ? `
` : "" }, this._extScope = N, this._scope = new r.Scope({ parent: N }), this._nodes = [new g()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(N) {
        return this._scope.name(N);
      }
      // reserves unique name in the external scope
      scopeName(N) {
        return this._extScope.name(N);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(N, V) {
        const G = this._extScope.value(N, V);
        return (this._values[G.prefix] || (this._values[G.prefix] = /* @__PURE__ */ new Set())).add(G), G;
      }
      getScopeValue(N, V) {
        return this._extScope.getValue(N, V);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(N) {
        return this._extScope.scopeRefs(N, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(N, V, G, fe) {
        const se = this._scope.toName(V);
        return G !== void 0 && fe && (this._constants[se.str] = G), this._leafNode(new i(N, se, G)), se;
      }
      // `const` declaration (`var` in es5 mode)
      const(N, V, G) {
        return this._def(r.varKinds.const, N, V, G);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(N, V, G) {
        return this._def(r.varKinds.let, N, V, G);
      }
      // `var` declaration with optional assignment
      var(N, V, G) {
        return this._def(r.varKinds.var, N, V, G);
      }
      // assignment code
      assign(N, V, G) {
        return this._leafNode(new a(N, V, G));
      }
      // `+=` code
      add(N, V) {
        return this._leafNode(new l(N, t.operators.ADD, V));
      }
      // appends passed SafeExpr to code or executes Block
      code(N) {
        return typeof N == "function" ? N() : N !== e.nil && this._leafNode(new p(N)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...N) {
        const V = ["{"];
        for (const [G, fe] of N)
          V.length > 1 && V.push(","), V.push(G), (G !== fe || this.opts.es5) && (V.push(":"), (0, e.addCodeArg)(V, fe));
        return V.push("}"), new e._Code(V);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(N, V, G) {
        if (this._blockNode(new y(N)), V && G)
          this.code(V).else().code(G).endIf();
        else if (V)
          this.code(V).endIf();
        else if (G)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(N) {
        return this._elseNode(new y(N));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new h());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(y, h);
      }
      _for(N, V) {
        return this._blockNode(N), V && this.code(V).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(N, V) {
        return this._for(new x(N), V);
      }
      // `for` statement for a range of values
      forRange(N, V, G, fe, se = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const we = this._scope.toName(N);
        return this._for(new P(se, we, V, G), () => fe(we));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(N, V, G, fe = r.varKinds.const) {
        const se = this._scope.toName(N);
        if (this.opts.es5) {
          const we = V instanceof e.Name ? V : this.var("_arr", V);
          return this.forRange("_i", 0, (0, e._)`${we}.length`, (le) => {
            this.var(se, (0, e._)`${we}[${le}]`), G(se);
          });
        }
        return this._for(new w("of", fe, se, V), () => G(se));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(N, V, G, fe = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(N, (0, e._)`Object.keys(${V})`, G);
        const se = this._scope.toName(N);
        return this._for(new w("in", fe, se, V), () => G(se));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(S);
      }
      // `label` statement
      label(N) {
        return this._leafNode(new u(N));
      }
      // `break` statement
      break(N) {
        return this._leafNode(new c(N));
      }
      // `return` statement
      return(N) {
        const V = new k();
        if (this._blockNode(V), this.code(N), V.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(k);
      }
      // `try` statement
      try(N, V, G) {
        if (!V && !G)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const fe = new $();
        if (this._blockNode(fe), this.code(N), V) {
          const se = this.name("e");
          this._currNode = fe.catch = new T(se), V(se);
        }
        return G && (this._currNode = fe.finally = new E(), this.code(G)), this._endBlockNode(T, E);
      }
      // `throw` statement
      throw(N) {
        return this._leafNode(new f(N));
      }
      // start self-balancing block
      block(N, V) {
        return this._blockStarts.push(this._nodes.length), N && this.code(N).endBlock(V), this;
      }
      // end the current self-balancing block
      endBlock(N) {
        const V = this._blockStarts.pop();
        if (V === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const G = this._nodes.length - V;
        if (G < 0 || N !== void 0 && G !== N)
          throw new Error(`CodeGen: wrong number of nodes: ${G} vs ${N} expected`);
        return this._nodes.length = V, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(N, V = e.nil, G, fe) {
        return this._blockNode(new O(N, V, G)), fe && this.code(fe).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(O);
      }
      optimize(N = 1) {
        for (; N-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(N) {
        return this._currNode.nodes.push(N), this;
      }
      _blockNode(N) {
        this._currNode.nodes.push(N), this._nodes.push(N);
      }
      _endBlockNode(N, V) {
        const G = this._currNode;
        if (G instanceof N || V && G instanceof V)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${V ? `${N.kind}/${V.kind}` : N.kind}"`);
      }
      _elseNode(N) {
        const V = this._currNode;
        if (!(V instanceof y))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = V.else = N, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const N = this._nodes;
        return N[N.length - 1];
      }
      set _currNode(N) {
        const V = this._nodes;
        V[V.length - 1] = N;
      }
    }
    t.CodeGen = M;
    function R(L, N) {
      for (const V in N)
        L[V] = (L[V] || 0) + (N[V] || 0);
      return L;
    }
    function U(L, N) {
      return N instanceof e._CodeOrName ? R(L, N.names) : L;
    }
    function B(L, N, V) {
      if (L instanceof e.Name)
        return G(L);
      if (!fe(L))
        return L;
      return new e._Code(L._items.reduce((se, we) => (we instanceof e.Name && (we = G(we)), we instanceof e._Code ? se.push(...we._items) : se.push(we), se), []));
      function G(se) {
        const we = V[se.str];
        return we === void 0 || N[se.str] !== 1 ? se : (delete N[se.str], we);
      }
      function fe(se) {
        return se instanceof e._Code && se._items.some((we) => we instanceof e.Name && N[we.str] === 1 && V[we.str] !== void 0);
      }
    }
    function F(L, N) {
      for (const V in N)
        L[V] = (L[V] || 0) - (N[V] || 0);
    }
    function Z(L) {
      return typeof L == "boolean" || typeof L == "number" || L === null ? !L : (0, e._)`!${ee(L)}`;
    }
    t.not = Z;
    const Y = j(t.operators.AND);
    function X(...L) {
      return L.reduce(Y);
    }
    t.and = X;
    const ae = j(t.operators.OR);
    function J(...L) {
      return L.reduce(ae);
    }
    t.or = J;
    function j(L) {
      return (N, V) => N === e.nil ? V : V === e.nil ? N : (0, e._)`${ee(N)} ${L} ${ee(V)}`;
    }
    function ee(L) {
      return L instanceof e.Name ? L : (0, e._)`(${L})`;
    }
  })(Fu)), Fu;
}
var qe = {}, Hg;
function Qe() {
  if (Hg) return qe;
  Hg = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.checkStrictMode = qe.getErrorPath = qe.Type = qe.useFunc = qe.setEvaluated = qe.evaluatedPropsToName = qe.mergeEvaluated = qe.eachItem = qe.unescapeJsonPointer = qe.escapeJsonPointer = qe.escapeFragment = qe.unescapeFragment = qe.schemaRefOrVal = qe.schemaHasRulesButRef = qe.schemaHasRules = qe.checkUnknownRules = qe.alwaysValidSchema = qe.toHash = void 0;
  const t = We(), e = ol();
  function r(w) {
    const O = {};
    for (const k of w)
      O[k] = !0;
    return O;
  }
  qe.toHash = r;
  function n(w, O) {
    return typeof O == "boolean" ? O : Object.keys(O).length === 0 ? !0 : (s(w, O), !o(O, w.self.RULES.all));
  }
  qe.alwaysValidSchema = n;
  function s(w, O = w.schema) {
    const { opts: k, self: $ } = w;
    if (!k.strictSchema || typeof O == "boolean")
      return;
    const T = $.RULES.keywords;
    for (const E in O)
      T[E] || P(w, `unknown keyword: "${E}"`);
  }
  qe.checkUnknownRules = s;
  function o(w, O) {
    if (typeof w == "boolean")
      return !w;
    for (const k in w)
      if (O[k])
        return !0;
    return !1;
  }
  qe.schemaHasRules = o;
  function i(w, O) {
    if (typeof w == "boolean")
      return !w;
    for (const k in w)
      if (k !== "$ref" && O.all[k])
        return !0;
    return !1;
  }
  qe.schemaHasRulesButRef = i;
  function a({ topSchemaRef: w, schemaPath: O }, k, $, T) {
    if (!T) {
      if (typeof k == "number" || typeof k == "boolean")
        return k;
      if (typeof k == "string")
        return (0, t._)`${k}`;
    }
    return (0, t._)`${w}${O}${(0, t.getProperty)($)}`;
  }
  qe.schemaRefOrVal = a;
  function l(w) {
    return f(decodeURIComponent(w));
  }
  qe.unescapeFragment = l;
  function u(w) {
    return encodeURIComponent(c(w));
  }
  qe.escapeFragment = u;
  function c(w) {
    return typeof w == "number" ? `${w}` : w.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  qe.escapeJsonPointer = c;
  function f(w) {
    return w.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  qe.unescapeJsonPointer = f;
  function p(w, O) {
    if (Array.isArray(w))
      for (const k of w)
        O(k);
    else
      O(w);
  }
  qe.eachItem = p;
  function _({ mergeNames: w, mergeToName: O, mergeValues: k, resultToName: $ }) {
    return (T, E, M, R) => {
      const U = M === void 0 ? E : M instanceof t.Name ? (E instanceof t.Name ? w(T, E, M) : O(T, E, M), M) : E instanceof t.Name ? (O(T, M, E), E) : k(E, M);
      return R === t.Name && !(U instanceof t.Name) ? $(T, U) : U;
    };
  }
  qe.mergeEvaluated = {
    props: _({
      mergeNames: (w, O, k) => w.if((0, t._)`${k} !== true && ${O} !== undefined`, () => {
        w.if((0, t._)`${O} === true`, () => w.assign(k, !0), () => w.assign(k, (0, t._)`${k} || {}`).code((0, t._)`Object.assign(${k}, ${O})`));
      }),
      mergeToName: (w, O, k) => w.if((0, t._)`${k} !== true`, () => {
        O === !0 ? w.assign(k, !0) : (w.assign(k, (0, t._)`${k} || {}`), g(w, k, O));
      }),
      mergeValues: (w, O) => w === !0 ? !0 : { ...w, ...O },
      resultToName: b
    }),
    items: _({
      mergeNames: (w, O, k) => w.if((0, t._)`${k} !== true && ${O} !== undefined`, () => w.assign(k, (0, t._)`${O} === true ? true : ${k} > ${O} ? ${k} : ${O}`)),
      mergeToName: (w, O, k) => w.if((0, t._)`${k} !== true`, () => w.assign(k, O === !0 ? !0 : (0, t._)`${k} > ${O} ? ${k} : ${O}`)),
      mergeValues: (w, O) => w === !0 ? !0 : Math.max(w, O),
      resultToName: (w, O) => w.var("items", O)
    })
  };
  function b(w, O) {
    if (O === !0)
      return w.var("props", !0);
    const k = w.var("props", (0, t._)`{}`);
    return O !== void 0 && g(w, k, O), k;
  }
  qe.evaluatedPropsToName = b;
  function g(w, O, k) {
    Object.keys(k).forEach(($) => w.assign((0, t._)`${O}${(0, t.getProperty)($)}`, !0));
  }
  qe.setEvaluated = g;
  const h = {};
  function y(w, O) {
    return w.scopeValue("func", {
      ref: O,
      code: h[O.code] || (h[O.code] = new e._Code(O.code))
    });
  }
  qe.useFunc = y;
  var S;
  (function(w) {
    w[w.Num = 0] = "Num", w[w.Str = 1] = "Str";
  })(S || (qe.Type = S = {}));
  function x(w, O, k) {
    if (w instanceof t.Name) {
      const $ = O === S.Num;
      return k ? $ ? (0, t._)`"[" + ${w} + "]"` : (0, t._)`"['" + ${w} + "']"` : $ ? (0, t._)`"/" + ${w}` : (0, t._)`"/" + ${w}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return k ? (0, t.getProperty)(w).toString() : "/" + c(w);
  }
  qe.getErrorPath = x;
  function P(w, O, k = w.opts.strictSchema) {
    if (k) {
      if (O = `strict mode: ${O}`, k === !0)
        throw new Error(O);
      w.self.logger.warn(O);
    }
  }
  return qe.checkStrictMode = P, qe;
}
var Gi = {}, Wg;
function as() {
  if (Wg) return Gi;
  Wg = 1, Object.defineProperty(Gi, "__esModule", { value: !0 });
  const t = We(), e = {
    // validation function arguments
    data: new t.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new t.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new t.Name("instancePath"),
    parentData: new t.Name("parentData"),
    parentDataProperty: new t.Name("parentDataProperty"),
    rootData: new t.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new t.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new t.Name("vErrors"),
    // null or array of validation errors
    errors: new t.Name("errors"),
    // counter of validation errors
    this: new t.Name("this"),
    // "globals"
    self: new t.Name("self"),
    scope: new t.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new t.Name("json"),
    jsonPos: new t.Name("jsonPos"),
    jsonLen: new t.Name("jsonLen"),
    jsonPart: new t.Name("jsonPart")
  };
  return Gi.default = e, Gi;
}
var Gg;
function Jl() {
  return Gg || (Gg = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
    const e = We(), r = Qe(), n = as();
    t.keywordError = {
      message: ({ keyword: h }) => (0, e.str)`must pass "${h}" keyword validation`
    }, t.keyword$DataError = {
      message: ({ keyword: h, schemaType: y }) => y ? (0, e.str)`"${h}" keyword must be ${y} ($data)` : (0, e.str)`"${h}" keyword is invalid ($data)`
    };
    function s(h, y = t.keywordError, S, x) {
      const { it: P } = h, { gen: w, compositeRule: O, allErrors: k } = P, $ = f(h, y, S);
      x ?? (O || k) ? l(w, $) : u(P, (0, e._)`[${$}]`);
    }
    t.reportError = s;
    function o(h, y = t.keywordError, S) {
      const { it: x } = h, { gen: P, compositeRule: w, allErrors: O } = x, k = f(h, y, S);
      l(P, k), w || O || u(x, n.default.vErrors);
    }
    t.reportExtraError = o;
    function i(h, y) {
      h.assign(n.default.errors, y), h.if((0, e._)`${n.default.vErrors} !== null`, () => h.if(y, () => h.assign((0, e._)`${n.default.vErrors}.length`, y), () => h.assign(n.default.vErrors, null)));
    }
    t.resetErrorsCount = i;
    function a({ gen: h, keyword: y, schemaValue: S, data: x, errsCount: P, it: w }) {
      if (P === void 0)
        throw new Error("ajv implementation error");
      const O = h.name("err");
      h.forRange("i", P, n.default.errors, (k) => {
        h.const(O, (0, e._)`${n.default.vErrors}[${k}]`), h.if((0, e._)`${O}.instancePath === undefined`, () => h.assign((0, e._)`${O}.instancePath`, (0, e.strConcat)(n.default.instancePath, w.errorPath))), h.assign((0, e._)`${O}.schemaPath`, (0, e.str)`${w.errSchemaPath}/${y}`), w.opts.verbose && (h.assign((0, e._)`${O}.schema`, S), h.assign((0, e._)`${O}.data`, x));
      });
    }
    t.extendErrors = a;
    function l(h, y) {
      const S = h.const("err", y);
      h.if((0, e._)`${n.default.vErrors} === null`, () => h.assign(n.default.vErrors, (0, e._)`[${S}]`), (0, e._)`${n.default.vErrors}.push(${S})`), h.code((0, e._)`${n.default.errors}++`);
    }
    function u(h, y) {
      const { gen: S, validateName: x, schemaEnv: P } = h;
      P.$async ? S.throw((0, e._)`new ${h.ValidationError}(${y})`) : (S.assign((0, e._)`${x}.errors`, y), S.return(!1));
    }
    const c = {
      keyword: new e.Name("keyword"),
      schemaPath: new e.Name("schemaPath"),
      // also used in JTD errors
      params: new e.Name("params"),
      propertyName: new e.Name("propertyName"),
      message: new e.Name("message"),
      schema: new e.Name("schema"),
      parentSchema: new e.Name("parentSchema")
    };
    function f(h, y, S) {
      const { createErrors: x } = h.it;
      return x === !1 ? (0, e._)`{}` : p(h, y, S);
    }
    function p(h, y, S = {}) {
      const { gen: x, it: P } = h, w = [
        _(P, S),
        b(h, S)
      ];
      return g(h, y, w), x.object(...w);
    }
    function _({ errorPath: h }, { instancePath: y }) {
      const S = y ? (0, e.str)`${h}${(0, r.getErrorPath)(y, r.Type.Str)}` : h;
      return [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, S)];
    }
    function b({ keyword: h, it: { errSchemaPath: y } }, { schemaPath: S, parentSchema: x }) {
      let P = x ? y : (0, e.str)`${y}/${h}`;
      return S && (P = (0, e.str)`${P}${(0, r.getErrorPath)(S, r.Type.Str)}`), [c.schemaPath, P];
    }
    function g(h, { params: y, message: S }, x) {
      const { keyword: P, data: w, schemaValue: O, it: k } = h, { opts: $, propertyName: T, topSchemaRef: E, schemaPath: M } = k;
      x.push([c.keyword, P], [c.params, typeof y == "function" ? y(h) : y || (0, e._)`{}`]), $.messages && x.push([c.message, typeof S == "function" ? S(h) : S]), $.verbose && x.push([c.schema, O], [c.parentSchema, (0, e._)`${E}${M}`], [n.default.data, w]), T && x.push([c.propertyName, T]);
    }
  })(Nu)), Nu;
}
var Yg;
function wk() {
  if (Yg) return ps;
  Yg = 1, Object.defineProperty(ps, "__esModule", { value: !0 }), ps.boolOrEmptySchema = ps.topBoolOrEmptySchema = void 0;
  const t = Jl(), e = We(), r = as(), n = {
    message: "boolean schema is false"
  };
  function s(a) {
    const { gen: l, schema: u, validateName: c } = a;
    u === !1 ? i(a, !1) : typeof u == "object" && u.$async === !0 ? l.return(r.default.data) : (l.assign((0, e._)`${c}.errors`, null), l.return(!0));
  }
  ps.topBoolOrEmptySchema = s;
  function o(a, l) {
    const { gen: u, schema: c } = a;
    c === !1 ? (u.var(l, !1), i(a)) : u.var(l, !0);
  }
  ps.boolOrEmptySchema = o;
  function i(a, l) {
    const { gen: u, data: c } = a, f = {
      gen: u,
      keyword: "false schema",
      data: c,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: a
    };
    (0, t.reportError)(f, n, void 0, l);
  }
  return ps;
}
var $t = {}, ms = {}, Xg;
function db() {
  if (Xg) return ms;
  Xg = 1, Object.defineProperty(ms, "__esModule", { value: !0 }), ms.getRules = ms.isJSONType = void 0;
  const t = ["string", "number", "integer", "boolean", "null", "object", "array"], e = new Set(t);
  function r(s) {
    return typeof s == "string" && e.has(s);
  }
  ms.isJSONType = r;
  function n() {
    const s = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...s, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, s.number, s.string, s.array, s.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return ms.getRules = n, ms;
}
var dn = {}, Jg;
function fb() {
  if (Jg) return dn;
  Jg = 1, Object.defineProperty(dn, "__esModule", { value: !0 }), dn.shouldUseRule = dn.shouldUseGroup = dn.schemaHasRulesForType = void 0;
  function t({ schema: n, self: s }, o) {
    const i = s.RULES.types[o];
    return i && i !== !0 && e(n, i);
  }
  dn.schemaHasRulesForType = t;
  function e(n, s) {
    return s.rules.some((o) => r(n, o));
  }
  dn.shouldUseGroup = e;
  function r(n, s) {
    var o;
    return n[s.keyword] !== void 0 || ((o = s.definition.implements) === null || o === void 0 ? void 0 : o.some((i) => n[i] !== void 0));
  }
  return dn.shouldUseRule = r, dn;
}
var Zg;
function il() {
  if (Zg) return $t;
  Zg = 1, Object.defineProperty($t, "__esModule", { value: !0 }), $t.reportTypeError = $t.checkDataTypes = $t.checkDataType = $t.coerceAndCheckDataType = $t.getJSONTypes = $t.getSchemaTypes = $t.DataType = void 0;
  const t = db(), e = fb(), r = Jl(), n = We(), s = Qe();
  var o;
  (function(S) {
    S[S.Correct = 0] = "Correct", S[S.Wrong = 1] = "Wrong";
  })(o || ($t.DataType = o = {}));
  function i(S) {
    const x = a(S.type);
    if (x.includes("null")) {
      if (S.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!x.length && S.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      S.nullable === !0 && x.push("null");
    }
    return x;
  }
  $t.getSchemaTypes = i;
  function a(S) {
    const x = Array.isArray(S) ? S : S ? [S] : [];
    if (x.every(t.isJSONType))
      return x;
    throw new Error("type must be JSONType or JSONType[]: " + x.join(","));
  }
  $t.getJSONTypes = a;
  function l(S, x) {
    const { gen: P, data: w, opts: O } = S, k = c(x, O.coerceTypes), $ = x.length > 0 && !(k.length === 0 && x.length === 1 && (0, e.schemaHasRulesForType)(S, x[0]));
    if ($) {
      const T = b(x, w, O.strictNumbers, o.Wrong);
      P.if(T, () => {
        k.length ? f(S, x, k) : h(S);
      });
    }
    return $;
  }
  $t.coerceAndCheckDataType = l;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function c(S, x) {
    return x ? S.filter((P) => u.has(P) || x === "array" && P === "array") : [];
  }
  function f(S, x, P) {
    const { gen: w, data: O, opts: k } = S, $ = w.let("dataType", (0, n._)`typeof ${O}`), T = w.let("coerced", (0, n._)`undefined`);
    k.coerceTypes === "array" && w.if((0, n._)`${$} == 'object' && Array.isArray(${O}) && ${O}.length == 1`, () => w.assign(O, (0, n._)`${O}[0]`).assign($, (0, n._)`typeof ${O}`).if(b(x, O, k.strictNumbers), () => w.assign(T, O))), w.if((0, n._)`${T} !== undefined`);
    for (const M of P)
      (u.has(M) || M === "array" && k.coerceTypes === "array") && E(M);
    w.else(), h(S), w.endIf(), w.if((0, n._)`${T} !== undefined`, () => {
      w.assign(O, T), p(S, T);
    });
    function E(M) {
      switch (M) {
        case "string":
          w.elseIf((0, n._)`${$} == "number" || ${$} == "boolean"`).assign(T, (0, n._)`"" + ${O}`).elseIf((0, n._)`${O} === null`).assign(T, (0, n._)`""`);
          return;
        case "number":
          w.elseIf((0, n._)`${$} == "boolean" || ${O} === null
              || (${$} == "string" && ${O} && ${O} == +${O})`).assign(T, (0, n._)`+${O}`);
          return;
        case "integer":
          w.elseIf((0, n._)`${$} === "boolean" || ${O} === null
              || (${$} === "string" && ${O} && ${O} == +${O} && !(${O} % 1))`).assign(T, (0, n._)`+${O}`);
          return;
        case "boolean":
          w.elseIf((0, n._)`${O} === "false" || ${O} === 0 || ${O} === null`).assign(T, !1).elseIf((0, n._)`${O} === "true" || ${O} === 1`).assign(T, !0);
          return;
        case "null":
          w.elseIf((0, n._)`${O} === "" || ${O} === 0 || ${O} === false`), w.assign(T, null);
          return;
        case "array":
          w.elseIf((0, n._)`${$} === "string" || ${$} === "number"
              || ${$} === "boolean" || ${O} === null`).assign(T, (0, n._)`[${O}]`);
      }
    }
  }
  function p({ gen: S, parentData: x, parentDataProperty: P }, w) {
    S.if((0, n._)`${x} !== undefined`, () => S.assign((0, n._)`${x}[${P}]`, w));
  }
  function _(S, x, P, w = o.Correct) {
    const O = w === o.Correct ? n.operators.EQ : n.operators.NEQ;
    let k;
    switch (S) {
      case "null":
        return (0, n._)`${x} ${O} null`;
      case "array":
        k = (0, n._)`Array.isArray(${x})`;
        break;
      case "object":
        k = (0, n._)`${x} && typeof ${x} == "object" && !Array.isArray(${x})`;
        break;
      case "integer":
        k = $((0, n._)`!(${x} % 1) && !isNaN(${x})`);
        break;
      case "number":
        k = $();
        break;
      default:
        return (0, n._)`typeof ${x} ${O} ${S}`;
    }
    return w === o.Correct ? k : (0, n.not)(k);
    function $(T = n.nil) {
      return (0, n.and)((0, n._)`typeof ${x} == "number"`, T, P ? (0, n._)`isFinite(${x})` : n.nil);
    }
  }
  $t.checkDataType = _;
  function b(S, x, P, w) {
    if (S.length === 1)
      return _(S[0], x, P, w);
    let O;
    const k = (0, s.toHash)(S);
    if (k.array && k.object) {
      const $ = (0, n._)`typeof ${x} != "object"`;
      O = k.null ? $ : (0, n._)`!${x} || ${$}`, delete k.null, delete k.array, delete k.object;
    } else
      O = n.nil;
    k.number && delete k.integer;
    for (const $ in k)
      O = (0, n.and)(O, _($, x, P, w));
    return O;
  }
  $t.checkDataTypes = b;
  const g = {
    message: ({ schema: S }) => `must be ${S}`,
    params: ({ schema: S, schemaValue: x }) => typeof S == "string" ? (0, n._)`{type: ${S}}` : (0, n._)`{type: ${x}}`
  };
  function h(S) {
    const x = y(S);
    (0, r.reportError)(x, g);
  }
  $t.reportTypeError = h;
  function y(S) {
    const { gen: x, data: P, schema: w } = S, O = (0, s.schemaRefOrVal)(S, w, "type");
    return {
      gen: x,
      keyword: "type",
      data: P,
      schema: w.type,
      schemaCode: O,
      schemaValue: O,
      parentSchema: w,
      params: {},
      it: S
    };
  }
  return $t;
}
var Jo = {}, Qg;
function Sk() {
  if (Qg) return Jo;
  Qg = 1, Object.defineProperty(Jo, "__esModule", { value: !0 }), Jo.assignDefaults = void 0;
  const t = We(), e = Qe();
  function r(s, o) {
    const { properties: i, items: a } = s.schema;
    if (o === "object" && i)
      for (const l in i)
        n(s, l, i[l].default);
    else o === "array" && Array.isArray(a) && a.forEach((l, u) => n(s, u, l.default));
  }
  Jo.assignDefaults = r;
  function n(s, o, i) {
    const { gen: a, compositeRule: l, data: u, opts: c } = s;
    if (i === void 0)
      return;
    const f = (0, t._)`${u}${(0, t.getProperty)(o)}`;
    if (l) {
      (0, e.checkStrictMode)(s, `default is ignored for: ${f}`);
      return;
    }
    let p = (0, t._)`${f} === undefined`;
    c.useDefaults === "empty" && (p = (0, t._)`${p} || ${f} === null || ${f} === ""`), a.if(p, (0, t._)`${f} = ${(0, t.stringify)(i)}`);
  }
  return Jo;
}
var Cr = {}, rt = {}, ep;
function zr() {
  if (ep) return rt;
  ep = 1, Object.defineProperty(rt, "__esModule", { value: !0 }), rt.validateUnion = rt.validateArray = rt.usePattern = rt.callValidateCode = rt.schemaProperties = rt.allSchemaProperties = rt.noPropertyInData = rt.propertyInData = rt.isOwnProperty = rt.hasPropFunc = rt.reportMissingProp = rt.checkMissingProp = rt.checkReportMissingProp = void 0;
  const t = We(), e = Qe(), r = as(), n = Qe();
  function s(S, x) {
    const { gen: P, data: w, it: O } = S;
    P.if(c(P, w, x, O.opts.ownProperties), () => {
      S.setParams({ missingProperty: (0, t._)`${x}` }, !0), S.error();
    });
  }
  rt.checkReportMissingProp = s;
  function o({ gen: S, data: x, it: { opts: P } }, w, O) {
    return (0, t.or)(...w.map((k) => (0, t.and)(c(S, x, k, P.ownProperties), (0, t._)`${O} = ${k}`)));
  }
  rt.checkMissingProp = o;
  function i(S, x) {
    S.setParams({ missingProperty: x }, !0), S.error();
  }
  rt.reportMissingProp = i;
  function a(S) {
    return S.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, t._)`Object.prototype.hasOwnProperty`
    });
  }
  rt.hasPropFunc = a;
  function l(S, x, P) {
    return (0, t._)`${a(S)}.call(${x}, ${P})`;
  }
  rt.isOwnProperty = l;
  function u(S, x, P, w) {
    const O = (0, t._)`${x}${(0, t.getProperty)(P)} !== undefined`;
    return w ? (0, t._)`${O} && ${l(S, x, P)}` : O;
  }
  rt.propertyInData = u;
  function c(S, x, P, w) {
    const O = (0, t._)`${x}${(0, t.getProperty)(P)} === undefined`;
    return w ? (0, t.or)(O, (0, t.not)(l(S, x, P))) : O;
  }
  rt.noPropertyInData = c;
  function f(S) {
    return S ? Object.keys(S).filter((x) => x !== "__proto__") : [];
  }
  rt.allSchemaProperties = f;
  function p(S, x) {
    return f(x).filter((P) => !(0, e.alwaysValidSchema)(S, x[P]));
  }
  rt.schemaProperties = p;
  function _({ schemaCode: S, data: x, it: { gen: P, topSchemaRef: w, schemaPath: O, errorPath: k }, it: $ }, T, E, M) {
    const R = M ? (0, t._)`${S}, ${x}, ${w}${O}` : x, U = [
      [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, k)],
      [r.default.parentData, $.parentData],
      [r.default.parentDataProperty, $.parentDataProperty],
      [r.default.rootData, r.default.rootData]
    ];
    $.opts.dynamicRef && U.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const B = (0, t._)`${R}, ${P.object(...U)}`;
    return E !== t.nil ? (0, t._)`${T}.call(${E}, ${B})` : (0, t._)`${T}(${B})`;
  }
  rt.callValidateCode = _;
  const b = (0, t._)`new RegExp`;
  function g({ gen: S, it: { opts: x } }, P) {
    const w = x.unicodeRegExp ? "u" : "", { regExp: O } = x.code, k = O(P, w);
    return S.scopeValue("pattern", {
      key: k.toString(),
      ref: k,
      code: (0, t._)`${O.code === "new RegExp" ? b : (0, n.useFunc)(S, O)}(${P}, ${w})`
    });
  }
  rt.usePattern = g;
  function h(S) {
    const { gen: x, data: P, keyword: w, it: O } = S, k = x.name("valid");
    if (O.allErrors) {
      const T = x.let("valid", !0);
      return $(() => x.assign(T, !1)), T;
    }
    return x.var(k, !0), $(() => x.break()), k;
    function $(T) {
      const E = x.const("len", (0, t._)`${P}.length`);
      x.forRange("i", 0, E, (M) => {
        S.subschema({
          keyword: w,
          dataProp: M,
          dataPropType: e.Type.Num
        }, k), x.if((0, t.not)(k), T);
      });
    }
  }
  rt.validateArray = h;
  function y(S) {
    const { gen: x, schema: P, keyword: w, it: O } = S;
    if (!Array.isArray(P))
      throw new Error("ajv implementation error");
    if (P.some((E) => (0, e.alwaysValidSchema)(O, E)) && !O.opts.unevaluated)
      return;
    const $ = x.let("valid", !1), T = x.name("_valid");
    x.block(() => P.forEach((E, M) => {
      const R = S.subschema({
        keyword: w,
        schemaProp: M,
        compositeRule: !0
      }, T);
      x.assign($, (0, t._)`${$} || ${T}`), S.mergeValidEvaluated(R, T) || x.if((0, t.not)($));
    })), S.result($, () => S.reset(), () => S.error(!0));
  }
  return rt.validateUnion = y, rt;
}
var tp;
function xk() {
  if (tp) return Cr;
  tp = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.validateKeywordUsage = Cr.validSchemaType = Cr.funcKeywordCode = Cr.macroKeywordCode = void 0;
  const t = We(), e = as(), r = zr(), n = Jl();
  function s(p, _) {
    const { gen: b, keyword: g, schema: h, parentSchema: y, it: S } = p, x = _.macro.call(S.self, h, y, S), P = u(b, g, x);
    S.opts.validateSchema !== !1 && S.self.validateSchema(x, !0);
    const w = b.name("valid");
    p.subschema({
      schema: x,
      schemaPath: t.nil,
      errSchemaPath: `${S.errSchemaPath}/${g}`,
      topSchemaRef: P,
      compositeRule: !0
    }, w), p.pass(w, () => p.error(!0));
  }
  Cr.macroKeywordCode = s;
  function o(p, _) {
    var b;
    const { gen: g, keyword: h, schema: y, parentSchema: S, $data: x, it: P } = p;
    l(P, _);
    const w = !x && _.compile ? _.compile.call(P.self, y, S, P) : _.validate, O = u(g, h, w), k = g.let("valid");
    p.block$data(k, $), p.ok((b = _.valid) !== null && b !== void 0 ? b : k);
    function $() {
      if (_.errors === !1)
        M(), _.modifying && i(p), R(() => p.error());
      else {
        const U = _.async ? T() : E();
        _.modifying && i(p), R(() => a(p, U));
      }
    }
    function T() {
      const U = g.let("ruleErrs", null);
      return g.try(() => M((0, t._)`await `), (B) => g.assign(k, !1).if((0, t._)`${B} instanceof ${P.ValidationError}`, () => g.assign(U, (0, t._)`${B}.errors`), () => g.throw(B))), U;
    }
    function E() {
      const U = (0, t._)`${O}.errors`;
      return g.assign(U, null), M(t.nil), U;
    }
    function M(U = _.async ? (0, t._)`await ` : t.nil) {
      const B = P.opts.passContext ? e.default.this : e.default.self, F = !("compile" in _ && !x || _.schema === !1);
      g.assign(k, (0, t._)`${U}${(0, r.callValidateCode)(p, O, B, F)}`, _.modifying);
    }
    function R(U) {
      var B;
      g.if((0, t.not)((B = _.valid) !== null && B !== void 0 ? B : k), U);
    }
  }
  Cr.funcKeywordCode = o;
  function i(p) {
    const { gen: _, data: b, it: g } = p;
    _.if(g.parentData, () => _.assign(b, (0, t._)`${g.parentData}[${g.parentDataProperty}]`));
  }
  function a(p, _) {
    const { gen: b } = p;
    b.if((0, t._)`Array.isArray(${_})`, () => {
      b.assign(e.default.vErrors, (0, t._)`${e.default.vErrors} === null ? ${_} : ${e.default.vErrors}.concat(${_})`).assign(e.default.errors, (0, t._)`${e.default.vErrors}.length`), (0, n.extendErrors)(p);
    }, () => p.error());
  }
  function l({ schemaEnv: p }, _) {
    if (_.async && !p.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(p, _, b) {
    if (b === void 0)
      throw new Error(`keyword "${_}" failed to compile`);
    return p.scopeValue("keyword", typeof b == "function" ? { ref: b } : { ref: b, code: (0, t.stringify)(b) });
  }
  function c(p, _, b = !1) {
    return !_.length || _.some((g) => g === "array" ? Array.isArray(p) : g === "object" ? p && typeof p == "object" && !Array.isArray(p) : typeof p == g || b && typeof p > "u");
  }
  Cr.validSchemaType = c;
  function f({ schema: p, opts: _, self: b, errSchemaPath: g }, h, y) {
    if (Array.isArray(h.keyword) ? !h.keyword.includes(y) : h.keyword !== y)
      throw new Error("ajv implementation error");
    const S = h.dependencies;
    if (S?.some((x) => !Object.prototype.hasOwnProperty.call(p, x)))
      throw new Error(`parent schema must have dependencies of ${y}: ${S.join(",")}`);
    if (h.validateSchema && !h.validateSchema(p[y])) {
      const P = `keyword "${y}" value is invalid at path "${g}": ` + b.errorsText(h.validateSchema.errors);
      if (_.validateSchema === "log")
        b.logger.error(P);
      else
        throw new Error(P);
    }
  }
  return Cr.validateKeywordUsage = f, Cr;
}
var fn = {}, rp;
function Pk() {
  if (rp) return fn;
  rp = 1, Object.defineProperty(fn, "__esModule", { value: !0 }), fn.extendSubschemaMode = fn.extendSubschemaData = fn.getSubschema = void 0;
  const t = We(), e = Qe();
  function r(o, { keyword: i, schemaProp: a, schema: l, schemaPath: u, errSchemaPath: c, topSchemaRef: f }) {
    if (i !== void 0 && l !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (i !== void 0) {
      const p = o.schema[i];
      return a === void 0 ? {
        schema: p,
        schemaPath: (0, t._)`${o.schemaPath}${(0, t.getProperty)(i)}`,
        errSchemaPath: `${o.errSchemaPath}/${i}`
      } : {
        schema: p[a],
        schemaPath: (0, t._)`${o.schemaPath}${(0, t.getProperty)(i)}${(0, t.getProperty)(a)}`,
        errSchemaPath: `${o.errSchemaPath}/${i}/${(0, e.escapeFragment)(a)}`
      };
    }
    if (l !== void 0) {
      if (u === void 0 || c === void 0 || f === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: l,
        schemaPath: u,
        topSchemaRef: f,
        errSchemaPath: c
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  fn.getSubschema = r;
  function n(o, i, { dataProp: a, dataPropType: l, data: u, dataTypes: c, propertyName: f }) {
    if (u !== void 0 && a !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: p } = i;
    if (a !== void 0) {
      const { errorPath: b, dataPathArr: g, opts: h } = i, y = p.let("data", (0, t._)`${i.data}${(0, t.getProperty)(a)}`, !0);
      _(y), o.errorPath = (0, t.str)`${b}${(0, e.getErrorPath)(a, l, h.jsPropertySyntax)}`, o.parentDataProperty = (0, t._)`${a}`, o.dataPathArr = [...g, o.parentDataProperty];
    }
    if (u !== void 0) {
      const b = u instanceof t.Name ? u : p.let("data", u, !0);
      _(b), f !== void 0 && (o.propertyName = f);
    }
    c && (o.dataTypes = c);
    function _(b) {
      o.data = b, o.dataLevel = i.dataLevel + 1, o.dataTypes = [], i.definedProperties = /* @__PURE__ */ new Set(), o.parentData = i.data, o.dataNames = [...i.dataNames, b];
    }
  }
  fn.extendSubschemaData = n;
  function s(o, { jtdDiscriminator: i, jtdMetadata: a, compositeRule: l, createErrors: u, allErrors: c }) {
    l !== void 0 && (o.compositeRule = l), u !== void 0 && (o.createErrors = u), c !== void 0 && (o.allErrors = c), o.jtdDiscriminator = i, o.jtdMetadata = a;
  }
  return fn.extendSubschemaMode = s, fn;
}
var Vt = {}, Lu, np;
function hb() {
  return np || (np = 1, Lu = function t(e, r) {
    if (e === r) return !0;
    if (e && r && typeof e == "object" && typeof r == "object") {
      if (e.constructor !== r.constructor) return !1;
      var n, s, o;
      if (Array.isArray(e)) {
        if (n = e.length, n != r.length) return !1;
        for (s = n; s-- !== 0; )
          if (!t(e[s], r[s])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === r.source && e.flags === r.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === r.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === r.toString();
      if (o = Object.keys(e), n = o.length, n !== Object.keys(r).length) return !1;
      for (s = n; s-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, o[s])) return !1;
      for (s = n; s-- !== 0; ) {
        var i = o[s];
        if (!t(e[i], r[i])) return !1;
      }
      return !0;
    }
    return e !== e && r !== r;
  }), Lu;
}
var ju = { exports: {} }, sp;
function Ok() {
  if (sp) return ju.exports;
  sp = 1;
  var t = ju.exports = function(n, s, o) {
    typeof s == "function" && (o = s, s = {}), o = s.cb || o;
    var i = typeof o == "function" ? o : o.pre || function() {
    }, a = o.post || function() {
    };
    e(s, i, a, n, "", n);
  };
  t.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, t.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, t.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, t.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function e(n, s, o, i, a, l, u, c, f, p) {
    if (i && typeof i == "object" && !Array.isArray(i)) {
      s(i, a, l, u, c, f, p);
      for (var _ in i) {
        var b = i[_];
        if (Array.isArray(b)) {
          if (_ in t.arrayKeywords)
            for (var g = 0; g < b.length; g++)
              e(n, s, o, b[g], a + "/" + _ + "/" + g, l, a, _, i, g);
        } else if (_ in t.propsKeywords) {
          if (b && typeof b == "object")
            for (var h in b)
              e(n, s, o, b[h], a + "/" + _ + "/" + r(h), l, a, _, i, h);
        } else (_ in t.keywords || n.allKeys && !(_ in t.skipKeywords)) && e(n, s, o, b, a + "/" + _, l, a, _, i);
      }
      o(i, a, l, u, c, f, p);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return ju.exports;
}
var op;
function Zl() {
  if (op) return Vt;
  op = 1, Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.getSchemaRefs = Vt.resolveUrl = Vt.normalizeId = Vt._getFullPath = Vt.getFullPath = Vt.inlineRef = void 0;
  const t = Qe(), e = hb(), r = Ok(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function s(g, h = !0) {
    return typeof g == "boolean" ? !0 : h === !0 ? !i(g) : h ? a(g) <= h : !1;
  }
  Vt.inlineRef = s;
  const o = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function i(g) {
    for (const h in g) {
      if (o.has(h))
        return !0;
      const y = g[h];
      if (Array.isArray(y) && y.some(i) || typeof y == "object" && i(y))
        return !0;
    }
    return !1;
  }
  function a(g) {
    let h = 0;
    for (const y in g) {
      if (y === "$ref")
        return 1 / 0;
      if (h++, !n.has(y) && (typeof g[y] == "object" && (0, t.eachItem)(g[y], (S) => h += a(S)), h === 1 / 0))
        return 1 / 0;
    }
    return h;
  }
  function l(g, h = "", y) {
    y !== !1 && (h = f(h));
    const S = g.parse(h);
    return u(g, S);
  }
  Vt.getFullPath = l;
  function u(g, h) {
    return g.serialize(h).split("#")[0] + "#";
  }
  Vt._getFullPath = u;
  const c = /#\/?$/;
  function f(g) {
    return g ? g.replace(c, "") : "";
  }
  Vt.normalizeId = f;
  function p(g, h, y) {
    return y = f(y), g.resolve(h, y);
  }
  Vt.resolveUrl = p;
  const _ = /^[a-z_][-a-z0-9._]*$/i;
  function b(g, h) {
    if (typeof g == "boolean")
      return {};
    const { schemaId: y, uriResolver: S } = this.opts, x = f(g[y] || h), P = { "": x }, w = l(S, x, !1), O = {}, k = /* @__PURE__ */ new Set();
    return r(g, { allKeys: !0 }, (E, M, R, U) => {
      if (U === void 0)
        return;
      const B = w + M;
      let F = P[U];
      typeof E[y] == "string" && (F = Z.call(this, E[y])), Y.call(this, E.$anchor), Y.call(this, E.$dynamicAnchor), P[M] = F;
      function Z(X) {
        const ae = this.opts.uriResolver.resolve;
        if (X = f(F ? ae(F, X) : X), k.has(X))
          throw T(X);
        k.add(X);
        let J = this.refs[X];
        return typeof J == "string" && (J = this.refs[J]), typeof J == "object" ? $(E, J.schema, X) : X !== f(B) && (X[0] === "#" ? ($(E, O[X], X), O[X] = E) : this.refs[X] = B), X;
      }
      function Y(X) {
        if (typeof X == "string") {
          if (!_.test(X))
            throw new Error(`invalid anchor "${X}"`);
          Z.call(this, `#${X}`);
        }
      }
    }), O;
    function $(E, M, R) {
      if (M !== void 0 && !e(E, M))
        throw T(R);
    }
    function T(E) {
      return new Error(`reference "${E}" resolves to more than one schema`);
    }
  }
  return Vt.getSchemaRefs = b, Vt;
}
var ip;
function Ql() {
  if (ip) return cn;
  ip = 1, Object.defineProperty(cn, "__esModule", { value: !0 }), cn.getData = cn.KeywordCxt = cn.validateFunctionCode = void 0;
  const t = wk(), e = il(), r = fb(), n = il(), s = Sk(), o = xk(), i = Pk(), a = We(), l = as(), u = Zl(), c = Qe(), f = Jl();
  function p(re) {
    if (w(re) && (k(re), P(re))) {
      h(re);
      return;
    }
    _(re, () => (0, t.topBoolOrEmptySchema)(re));
  }
  cn.validateFunctionCode = p;
  function _({ gen: re, validateName: oe, schema: pe, schemaEnv: ye, opts: Pe }, Oe) {
    Pe.code.es5 ? re.func(oe, (0, a._)`${l.default.data}, ${l.default.valCxt}`, ye.$async, () => {
      re.code((0, a._)`"use strict"; ${S(pe, Pe)}`), g(re, Pe), re.code(Oe);
    }) : re.func(oe, (0, a._)`${l.default.data}, ${b(Pe)}`, ye.$async, () => re.code(S(pe, Pe)).code(Oe));
  }
  function b(re) {
    return (0, a._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${re.dynamicRef ? (0, a._)`, ${l.default.dynamicAnchors}={}` : a.nil}}={}`;
  }
  function g(re, oe) {
    re.if(l.default.valCxt, () => {
      re.var(l.default.instancePath, (0, a._)`${l.default.valCxt}.${l.default.instancePath}`), re.var(l.default.parentData, (0, a._)`${l.default.valCxt}.${l.default.parentData}`), re.var(l.default.parentDataProperty, (0, a._)`${l.default.valCxt}.${l.default.parentDataProperty}`), re.var(l.default.rootData, (0, a._)`${l.default.valCxt}.${l.default.rootData}`), oe.dynamicRef && re.var(l.default.dynamicAnchors, (0, a._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
    }, () => {
      re.var(l.default.instancePath, (0, a._)`""`), re.var(l.default.parentData, (0, a._)`undefined`), re.var(l.default.parentDataProperty, (0, a._)`undefined`), re.var(l.default.rootData, l.default.data), oe.dynamicRef && re.var(l.default.dynamicAnchors, (0, a._)`{}`);
    });
  }
  function h(re) {
    const { schema: oe, opts: pe, gen: ye } = re;
    _(re, () => {
      pe.$comment && oe.$comment && U(re), E(re), ye.let(l.default.vErrors, null), ye.let(l.default.errors, 0), pe.unevaluated && y(re), $(re), B(re);
    });
  }
  function y(re) {
    const { gen: oe, validateName: pe } = re;
    re.evaluated = oe.const("evaluated", (0, a._)`${pe}.evaluated`), oe.if((0, a._)`${re.evaluated}.dynamicProps`, () => oe.assign((0, a._)`${re.evaluated}.props`, (0, a._)`undefined`)), oe.if((0, a._)`${re.evaluated}.dynamicItems`, () => oe.assign((0, a._)`${re.evaluated}.items`, (0, a._)`undefined`));
  }
  function S(re, oe) {
    const pe = typeof re == "object" && re[oe.schemaId];
    return pe && (oe.code.source || oe.code.process) ? (0, a._)`/*# sourceURL=${pe} */` : a.nil;
  }
  function x(re, oe) {
    if (w(re) && (k(re), P(re))) {
      O(re, oe);
      return;
    }
    (0, t.boolOrEmptySchema)(re, oe);
  }
  function P({ schema: re, self: oe }) {
    if (typeof re == "boolean")
      return !re;
    for (const pe in re)
      if (oe.RULES.all[pe])
        return !0;
    return !1;
  }
  function w(re) {
    return typeof re.schema != "boolean";
  }
  function O(re, oe) {
    const { schema: pe, gen: ye, opts: Pe } = re;
    Pe.$comment && pe.$comment && U(re), M(re), R(re);
    const Oe = ye.const("_errs", l.default.errors);
    $(re, Oe), ye.var(oe, (0, a._)`${Oe} === ${l.default.errors}`);
  }
  function k(re) {
    (0, c.checkUnknownRules)(re), T(re);
  }
  function $(re, oe) {
    if (re.opts.jtd)
      return Z(re, [], !1, oe);
    const pe = (0, e.getSchemaTypes)(re.schema), ye = (0, e.coerceAndCheckDataType)(re, pe);
    Z(re, pe, !ye, oe);
  }
  function T(re) {
    const { schema: oe, errSchemaPath: pe, opts: ye, self: Pe } = re;
    oe.$ref && ye.ignoreKeywordsWithRef && (0, c.schemaHasRulesButRef)(oe, Pe.RULES) && Pe.logger.warn(`$ref: keywords ignored in schema at path "${pe}"`);
  }
  function E(re) {
    const { schema: oe, opts: pe } = re;
    oe.default !== void 0 && pe.useDefaults && pe.strictSchema && (0, c.checkStrictMode)(re, "default is ignored in the schema root");
  }
  function M(re) {
    const oe = re.schema[re.opts.schemaId];
    oe && (re.baseId = (0, u.resolveUrl)(re.opts.uriResolver, re.baseId, oe));
  }
  function R(re) {
    if (re.schema.$async && !re.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function U({ gen: re, schemaEnv: oe, schema: pe, errSchemaPath: ye, opts: Pe }) {
    const Oe = pe.$comment;
    if (Pe.$comment === !0)
      re.code((0, a._)`${l.default.self}.logger.log(${Oe})`);
    else if (typeof Pe.$comment == "function") {
      const Re = (0, a.str)`${ye}/$comment`, Ke = re.scopeValue("root", { ref: oe.root });
      re.code((0, a._)`${l.default.self}.opts.$comment(${Oe}, ${Re}, ${Ke}.schema)`);
    }
  }
  function B(re) {
    const { gen: oe, schemaEnv: pe, validateName: ye, ValidationError: Pe, opts: Oe } = re;
    pe.$async ? oe.if((0, a._)`${l.default.errors} === 0`, () => oe.return(l.default.data), () => oe.throw((0, a._)`new ${Pe}(${l.default.vErrors})`)) : (oe.assign((0, a._)`${ye}.errors`, l.default.vErrors), Oe.unevaluated && F(re), oe.return((0, a._)`${l.default.errors} === 0`));
  }
  function F({ gen: re, evaluated: oe, props: pe, items: ye }) {
    pe instanceof a.Name && re.assign((0, a._)`${oe}.props`, pe), ye instanceof a.Name && re.assign((0, a._)`${oe}.items`, ye);
  }
  function Z(re, oe, pe, ye) {
    const { gen: Pe, schema: Oe, data: Re, allErrors: Ke, opts: Ve, self: je } = re, { RULES: He } = je;
    if (Oe.$ref && (Ve.ignoreKeywordsWithRef || !(0, c.schemaHasRulesButRef)(Oe, He))) {
      Pe.block(() => fe(re, "$ref", He.all.$ref.definition));
      return;
    }
    Ve.jtd || X(re, oe), Pe.block(() => {
      for (const Je of He.rules)
        gt(Je);
      gt(He.post);
    });
    function gt(Je) {
      (0, r.shouldUseGroup)(Oe, Je) && (Je.type ? (Pe.if((0, n.checkDataType)(Je.type, Re, Ve.strictNumbers)), Y(re, Je), oe.length === 1 && oe[0] === Je.type && pe && (Pe.else(), (0, n.reportTypeError)(re)), Pe.endIf()) : Y(re, Je), Ke || Pe.if((0, a._)`${l.default.errors} === ${ye || 0}`));
    }
  }
  function Y(re, oe) {
    const { gen: pe, schema: ye, opts: { useDefaults: Pe } } = re;
    Pe && (0, s.assignDefaults)(re, oe.type), pe.block(() => {
      for (const Oe of oe.rules)
        (0, r.shouldUseRule)(ye, Oe) && fe(re, Oe.keyword, Oe.definition, oe.type);
    });
  }
  function X(re, oe) {
    re.schemaEnv.meta || !re.opts.strictTypes || (ae(re, oe), re.opts.allowUnionTypes || J(re, oe), j(re, re.dataTypes));
  }
  function ae(re, oe) {
    if (oe.length) {
      if (!re.dataTypes.length) {
        re.dataTypes = oe;
        return;
      }
      oe.forEach((pe) => {
        L(re.dataTypes, pe) || V(re, `type "${pe}" not allowed by context "${re.dataTypes.join(",")}"`);
      }), N(re, oe);
    }
  }
  function J(re, oe) {
    oe.length > 1 && !(oe.length === 2 && oe.includes("null")) && V(re, "use allowUnionTypes to allow union type keyword");
  }
  function j(re, oe) {
    const pe = re.self.RULES.all;
    for (const ye in pe) {
      const Pe = pe[ye];
      if (typeof Pe == "object" && (0, r.shouldUseRule)(re.schema, Pe)) {
        const { type: Oe } = Pe.definition;
        Oe.length && !Oe.some((Re) => ee(oe, Re)) && V(re, `missing type "${Oe.join(",")}" for keyword "${ye}"`);
      }
    }
  }
  function ee(re, oe) {
    return re.includes(oe) || oe === "number" && re.includes("integer");
  }
  function L(re, oe) {
    return re.includes(oe) || oe === "integer" && re.includes("number");
  }
  function N(re, oe) {
    const pe = [];
    for (const ye of re.dataTypes)
      L(oe, ye) ? pe.push(ye) : oe.includes("integer") && ye === "number" && pe.push("integer");
    re.dataTypes = pe;
  }
  function V(re, oe) {
    const pe = re.schemaEnv.baseId + re.errSchemaPath;
    oe += ` at "${pe}" (strictTypes)`, (0, c.checkStrictMode)(re, oe, re.opts.strictTypes);
  }
  class G {
    constructor(oe, pe, ye) {
      if ((0, o.validateKeywordUsage)(oe, pe, ye), this.gen = oe.gen, this.allErrors = oe.allErrors, this.keyword = ye, this.data = oe.data, this.schema = oe.schema[ye], this.$data = pe.$data && oe.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, c.schemaRefOrVal)(oe, this.schema, ye, this.$data), this.schemaType = pe.schemaType, this.parentSchema = oe.schema, this.params = {}, this.it = oe, this.def = pe, this.$data)
        this.schemaCode = oe.gen.const("vSchema", le(this.$data, oe));
      else if (this.schemaCode = this.schemaValue, !(0, o.validSchemaType)(this.schema, pe.schemaType, pe.allowUndefined))
        throw new Error(`${ye} value must be ${JSON.stringify(pe.schemaType)}`);
      ("code" in pe ? pe.trackErrors : pe.errors !== !1) && (this.errsCount = oe.gen.const("_errs", l.default.errors));
    }
    result(oe, pe, ye) {
      this.failResult((0, a.not)(oe), pe, ye);
    }
    failResult(oe, pe, ye) {
      this.gen.if(oe), ye ? ye() : this.error(), pe ? (this.gen.else(), pe(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(oe, pe) {
      this.failResult((0, a.not)(oe), void 0, pe);
    }
    fail(oe) {
      if (oe === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(oe), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(oe) {
      if (!this.$data)
        return this.fail(oe);
      const { schemaCode: pe } = this;
      this.fail((0, a._)`${pe} !== undefined && (${(0, a.or)(this.invalid$data(), oe)})`);
    }
    error(oe, pe, ye) {
      if (pe) {
        this.setParams(pe), this._error(oe, ye), this.setParams({});
        return;
      }
      this._error(oe, ye);
    }
    _error(oe, pe) {
      (oe ? f.reportExtraError : f.reportError)(this, this.def.error, pe);
    }
    $dataError() {
      (0, f.reportError)(this, this.def.$dataError || f.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, f.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(oe) {
      this.allErrors || this.gen.if(oe);
    }
    setParams(oe, pe) {
      pe ? Object.assign(this.params, oe) : this.params = oe;
    }
    block$data(oe, pe, ye = a.nil) {
      this.gen.block(() => {
        this.check$data(oe, ye), pe();
      });
    }
    check$data(oe = a.nil, pe = a.nil) {
      if (!this.$data)
        return;
      const { gen: ye, schemaCode: Pe, schemaType: Oe, def: Re } = this;
      ye.if((0, a.or)((0, a._)`${Pe} === undefined`, pe)), oe !== a.nil && ye.assign(oe, !0), (Oe.length || Re.validateSchema) && (ye.elseIf(this.invalid$data()), this.$dataError(), oe !== a.nil && ye.assign(oe, !1)), ye.else();
    }
    invalid$data() {
      const { gen: oe, schemaCode: pe, schemaType: ye, def: Pe, it: Oe } = this;
      return (0, a.or)(Re(), Ke());
      function Re() {
        if (ye.length) {
          if (!(pe instanceof a.Name))
            throw new Error("ajv implementation error");
          const Ve = Array.isArray(ye) ? ye : [ye];
          return (0, a._)`${(0, n.checkDataTypes)(Ve, pe, Oe.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return a.nil;
      }
      function Ke() {
        if (Pe.validateSchema) {
          const Ve = oe.scopeValue("validate$data", { ref: Pe.validateSchema });
          return (0, a._)`!${Ve}(${pe})`;
        }
        return a.nil;
      }
    }
    subschema(oe, pe) {
      const ye = (0, i.getSubschema)(this.it, oe);
      (0, i.extendSubschemaData)(ye, this.it, oe), (0, i.extendSubschemaMode)(ye, oe);
      const Pe = { ...this.it, ...ye, items: void 0, props: void 0 };
      return x(Pe, pe), Pe;
    }
    mergeEvaluated(oe, pe) {
      const { it: ye, gen: Pe } = this;
      ye.opts.unevaluated && (ye.props !== !0 && oe.props !== void 0 && (ye.props = c.mergeEvaluated.props(Pe, oe.props, ye.props, pe)), ye.items !== !0 && oe.items !== void 0 && (ye.items = c.mergeEvaluated.items(Pe, oe.items, ye.items, pe)));
    }
    mergeValidEvaluated(oe, pe) {
      const { it: ye, gen: Pe } = this;
      if (ye.opts.unevaluated && (ye.props !== !0 || ye.items !== !0))
        return Pe.if(pe, () => this.mergeEvaluated(oe, a.Name)), !0;
    }
  }
  cn.KeywordCxt = G;
  function fe(re, oe, pe, ye) {
    const Pe = new G(re, pe, oe);
    "code" in pe ? pe.code(Pe, ye) : Pe.$data && pe.validate ? (0, o.funcKeywordCode)(Pe, pe) : "macro" in pe ? (0, o.macroKeywordCode)(Pe, pe) : (pe.compile || pe.validate) && (0, o.funcKeywordCode)(Pe, pe);
  }
  const se = /^\/(?:[^~]|~0|~1)*$/, we = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function le(re, { dataLevel: oe, dataNames: pe, dataPathArr: ye }) {
    let Pe, Oe;
    if (re === "")
      return l.default.rootData;
    if (re[0] === "/") {
      if (!se.test(re))
        throw new Error(`Invalid JSON-pointer: ${re}`);
      Pe = re, Oe = l.default.rootData;
    } else {
      const je = we.exec(re);
      if (!je)
        throw new Error(`Invalid JSON-pointer: ${re}`);
      const He = +je[1];
      if (Pe = je[2], Pe === "#") {
        if (He >= oe)
          throw new Error(Ve("property/index", He));
        return ye[oe - He];
      }
      if (He > oe)
        throw new Error(Ve("data", He));
      if (Oe = pe[oe - He], !Pe)
        return Oe;
    }
    let Re = Oe;
    const Ke = Pe.split("/");
    for (const je of Ke)
      je && (Oe = (0, a._)`${Oe}${(0, a.getProperty)((0, c.unescapeJsonPointer)(je))}`, Re = (0, a._)`${Re} && ${Oe}`);
    return Re;
    function Ve(je, He) {
      return `Cannot access ${je} ${He} levels up, current level is ${oe}`;
    }
  }
  return cn.getData = le, cn;
}
var Yi = {}, ap;
function Vd() {
  if (ap) return Yi;
  ap = 1, Object.defineProperty(Yi, "__esModule", { value: !0 });
  class t extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return Yi.default = t, Yi;
}
var Xi = {}, lp;
function eu() {
  if (lp) return Xi;
  lp = 1, Object.defineProperty(Xi, "__esModule", { value: !0 });
  const t = Zl();
  class e extends Error {
    constructor(n, s, o, i) {
      super(i || `can't resolve reference ${o} from id ${s}`), this.missingRef = (0, t.resolveUrl)(n, s, o), this.missingSchema = (0, t.normalizeId)((0, t.getFullPath)(n, this.missingRef));
    }
  }
  return Xi.default = e, Xi;
}
var ir = {}, up;
function Ld() {
  if (up) return ir;
  up = 1, Object.defineProperty(ir, "__esModule", { value: !0 }), ir.resolveSchema = ir.getCompilingSchema = ir.resolveRef = ir.compileSchema = ir.SchemaEnv = void 0;
  const t = We(), e = Vd(), r = as(), n = Zl(), s = Qe(), o = Ql();
  class i {
    constructor(y) {
      var S;
      this.refs = {}, this.dynamicAnchors = {};
      let x;
      typeof y.schema == "object" && (x = y.schema), this.schema = y.schema, this.schemaId = y.schemaId, this.root = y.root || this, this.baseId = (S = y.baseId) !== null && S !== void 0 ? S : (0, n.normalizeId)(x?.[y.schemaId || "$id"]), this.schemaPath = y.schemaPath, this.localRefs = y.localRefs, this.meta = y.meta, this.$async = x?.$async, this.refs = {};
    }
  }
  ir.SchemaEnv = i;
  function a(h) {
    const y = c.call(this, h);
    if (y)
      return y;
    const S = (0, n.getFullPath)(this.opts.uriResolver, h.root.baseId), { es5: x, lines: P } = this.opts.code, { ownProperties: w } = this.opts, O = new t.CodeGen(this.scope, { es5: x, lines: P, ownProperties: w });
    let k;
    h.$async && (k = O.scopeValue("Error", {
      ref: e.default,
      code: (0, t._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const $ = O.scopeName("validate");
    h.validateName = $;
    const T = {
      gen: O,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [t.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: O.scopeValue("schema", this.opts.code.source === !0 ? { ref: h.schema, code: (0, t.stringify)(h.schema) } : { ref: h.schema }),
      validateName: $,
      ValidationError: k,
      schema: h.schema,
      schemaEnv: h,
      rootId: S,
      baseId: h.baseId || S,
      schemaPath: t.nil,
      errSchemaPath: h.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, t._)`""`,
      opts: this.opts,
      self: this
    };
    let E;
    try {
      this._compilations.add(h), (0, o.validateFunctionCode)(T), O.optimize(this.opts.code.optimize);
      const M = O.toString();
      E = `${O.scopeRefs(r.default.scope)}return ${M}`, this.opts.code.process && (E = this.opts.code.process(E, h));
      const U = new Function(`${r.default.self}`, `${r.default.scope}`, E)(this, this.scope.get());
      if (this.scope.value($, { ref: U }), U.errors = null, U.schema = h.schema, U.schemaEnv = h, h.$async && (U.$async = !0), this.opts.code.source === !0 && (U.source = { validateName: $, validateCode: M, scopeValues: O._values }), this.opts.unevaluated) {
        const { props: B, items: F } = T;
        U.evaluated = {
          props: B instanceof t.Name ? void 0 : B,
          items: F instanceof t.Name ? void 0 : F,
          dynamicProps: B instanceof t.Name,
          dynamicItems: F instanceof t.Name
        }, U.source && (U.source.evaluated = (0, t.stringify)(U.evaluated));
      }
      return h.validate = U, h;
    } catch (M) {
      throw delete h.validate, delete h.validateName, E && this.logger.error("Error compiling schema, function code:", E), M;
    } finally {
      this._compilations.delete(h);
    }
  }
  ir.compileSchema = a;
  function l(h, y, S) {
    var x;
    S = (0, n.resolveUrl)(this.opts.uriResolver, y, S);
    const P = h.refs[S];
    if (P)
      return P;
    let w = p.call(this, h, S);
    if (w === void 0) {
      const O = (x = h.localRefs) === null || x === void 0 ? void 0 : x[S], { schemaId: k } = this.opts;
      O && (w = new i({ schema: O, schemaId: k, root: h, baseId: y }));
    }
    if (w !== void 0)
      return h.refs[S] = u.call(this, w);
  }
  ir.resolveRef = l;
  function u(h) {
    return (0, n.inlineRef)(h.schema, this.opts.inlineRefs) ? h.schema : h.validate ? h : a.call(this, h);
  }
  function c(h) {
    for (const y of this._compilations)
      if (f(y, h))
        return y;
  }
  ir.getCompilingSchema = c;
  function f(h, y) {
    return h.schema === y.schema && h.root === y.root && h.baseId === y.baseId;
  }
  function p(h, y) {
    let S;
    for (; typeof (S = this.refs[y]) == "string"; )
      y = S;
    return S || this.schemas[y] || _.call(this, h, y);
  }
  function _(h, y) {
    const S = this.opts.uriResolver.parse(y), x = (0, n._getFullPath)(this.opts.uriResolver, S);
    let P = (0, n.getFullPath)(this.opts.uriResolver, h.baseId, void 0);
    if (Object.keys(h.schema).length > 0 && x === P)
      return g.call(this, S, h);
    const w = (0, n.normalizeId)(x), O = this.refs[w] || this.schemas[w];
    if (typeof O == "string") {
      const k = _.call(this, h, O);
      return typeof k?.schema != "object" ? void 0 : g.call(this, S, k);
    }
    if (typeof O?.schema == "object") {
      if (O.validate || a.call(this, O), w === (0, n.normalizeId)(y)) {
        const { schema: k } = O, { schemaId: $ } = this.opts, T = k[$];
        return T && (P = (0, n.resolveUrl)(this.opts.uriResolver, P, T)), new i({ schema: k, schemaId: $, root: h, baseId: P });
      }
      return g.call(this, S, O);
    }
  }
  ir.resolveSchema = _;
  const b = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function g(h, { baseId: y, schema: S, root: x }) {
    var P;
    if (((P = h.fragment) === null || P === void 0 ? void 0 : P[0]) !== "/")
      return;
    for (const k of h.fragment.slice(1).split("/")) {
      if (typeof S == "boolean")
        return;
      const $ = S[(0, s.unescapeFragment)(k)];
      if ($ === void 0)
        return;
      S = $;
      const T = typeof S == "object" && S[this.opts.schemaId];
      !b.has(k) && T && (y = (0, n.resolveUrl)(this.opts.uriResolver, y, T));
    }
    let w;
    if (typeof S != "boolean" && S.$ref && !(0, s.schemaHasRulesButRef)(S, this.RULES)) {
      const k = (0, n.resolveUrl)(this.opts.uriResolver, y, S.$ref);
      w = _.call(this, x, k);
    }
    const { schemaId: O } = this.opts;
    if (w = w || new i({ schema: S, schemaId: O, root: x, baseId: y }), w.schema !== w.root.schema)
      return w;
  }
  return ir;
}
const Ck = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", kk = "Meta-schema for $data reference (JSON AnySchema extension proposal)", $k = "object", Ak = ["$data"], Ek = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, Tk = !1, Dk = {
  $id: Ck,
  description: kk,
  type: $k,
  required: Ak,
  properties: Ek,
  additionalProperties: Tk
};
var Ji = {}, Zo = { exports: {} }, Bu, cp;
function gb() {
  if (cp) return Bu;
  cp = 1;
  const t = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), e = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function r(p) {
    let _ = "", b = 0, g = 0;
    for (g = 0; g < p.length; g++)
      if (b = p[g].charCodeAt(0), b !== 48) {
        if (!(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
          return "";
        _ += p[g];
        break;
      }
    for (g += 1; g < p.length; g++) {
      if (b = p[g].charCodeAt(0), !(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
        return "";
      _ += p[g];
    }
    return _;
  }
  const n = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function s(p) {
    return p.length = 0, !0;
  }
  function o(p, _, b) {
    if (p.length) {
      const g = r(p);
      if (g !== "")
        _.push(g);
      else
        return b.error = !0, !1;
      p.length = 0;
    }
    return !0;
  }
  function i(p) {
    let _ = 0;
    const b = { error: !1, address: "", zone: "" }, g = [], h = [];
    let y = !1, S = !1, x = o;
    for (let P = 0; P < p.length; P++) {
      const w = p[P];
      if (!(w === "[" || w === "]"))
        if (w === ":") {
          if (y === !0 && (S = !0), !x(h, g, b))
            break;
          if (++_ > 7) {
            b.error = !0;
            break;
          }
          P > 0 && p[P - 1] === ":" && (y = !0), g.push(":");
          continue;
        } else if (w === "%") {
          if (!x(h, g, b))
            break;
          x = s;
        } else {
          h.push(w);
          continue;
        }
    }
    return h.length && (x === s ? b.zone = h.join("") : S ? g.push(h.join("")) : g.push(r(h))), b.address = g.join(""), b;
  }
  function a(p) {
    if (l(p, ":") < 2)
      return { host: p, isIPV6: !1 };
    const _ = i(p);
    if (_.error)
      return { host: p, isIPV6: !1 };
    {
      let b = _.address, g = _.address;
      return _.zone && (b += "%" + _.zone, g += "%25" + _.zone), { host: b, isIPV6: !0, escapedHost: g };
    }
  }
  function l(p, _) {
    let b = 0;
    for (let g = 0; g < p.length; g++)
      p[g] === _ && b++;
    return b;
  }
  function u(p) {
    let _ = p;
    const b = [];
    let g = -1, h = 0;
    for (; h = _.length; ) {
      if (h === 1) {
        if (_ === ".")
          break;
        if (_ === "/") {
          b.push("/");
          break;
        } else {
          b.push(_);
          break;
        }
      } else if (h === 2) {
        if (_[0] === ".") {
          if (_[1] === ".")
            break;
          if (_[1] === "/") {
            _ = _.slice(2);
            continue;
          }
        } else if (_[0] === "/" && (_[1] === "." || _[1] === "/")) {
          b.push("/");
          break;
        }
      } else if (h === 3 && _ === "/..") {
        b.length !== 0 && b.pop(), b.push("/");
        break;
      }
      if (_[0] === ".") {
        if (_[1] === ".") {
          if (_[2] === "/") {
            _ = _.slice(3);
            continue;
          }
        } else if (_[1] === "/") {
          _ = _.slice(2);
          continue;
        }
      } else if (_[0] === "/" && _[1] === ".") {
        if (_[2] === "/") {
          _ = _.slice(2);
          continue;
        } else if (_[2] === "." && _[3] === "/") {
          _ = _.slice(3), b.length !== 0 && b.pop();
          continue;
        }
      }
      if ((g = _.indexOf("/", 1)) === -1) {
        b.push(_);
        break;
      } else
        b.push(_.slice(0, g)), _ = _.slice(g);
    }
    return b.join("");
  }
  function c(p, _) {
    const b = _ !== !0 ? escape : unescape;
    return p.scheme !== void 0 && (p.scheme = b(p.scheme)), p.userinfo !== void 0 && (p.userinfo = b(p.userinfo)), p.host !== void 0 && (p.host = b(p.host)), p.path !== void 0 && (p.path = b(p.path)), p.query !== void 0 && (p.query = b(p.query)), p.fragment !== void 0 && (p.fragment = b(p.fragment)), p;
  }
  function f(p) {
    const _ = [];
    if (p.userinfo !== void 0 && (_.push(p.userinfo), _.push("@")), p.host !== void 0) {
      let b = unescape(p.host);
      if (!e(b)) {
        const g = a(b);
        g.isIPV6 === !0 ? b = `[${g.escapedHost}]` : b = p.host;
      }
      _.push(b);
    }
    return (typeof p.port == "number" || typeof p.port == "string") && (_.push(":"), _.push(String(p.port))), _.length ? _.join("") : void 0;
  }
  return Bu = {
    nonSimpleDomain: n,
    recomposeAuthority: f,
    normalizeComponentEncoding: c,
    removeDotSegments: u,
    isIPv4: e,
    isUUID: t,
    normalizeIPv6: a,
    stringArrayToHexStripped: r
  }, Bu;
}
var zu, dp;
function Mk() {
  if (dp) return zu;
  dp = 1;
  const { isUUID: t } = gb(), e = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, r = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function n(w) {
    return r.indexOf(
      /** @type {*} */
      w
    ) !== -1;
  }
  function s(w) {
    return w.secure === !0 ? !0 : w.secure === !1 ? !1 : w.scheme ? w.scheme.length === 3 && (w.scheme[0] === "w" || w.scheme[0] === "W") && (w.scheme[1] === "s" || w.scheme[1] === "S") && (w.scheme[2] === "s" || w.scheme[2] === "S") : !1;
  }
  function o(w) {
    return w.host || (w.error = w.error || "HTTP URIs must have a host."), w;
  }
  function i(w) {
    const O = String(w.scheme).toLowerCase() === "https";
    return (w.port === (O ? 443 : 80) || w.port === "") && (w.port = void 0), w.path || (w.path = "/"), w;
  }
  function a(w) {
    return w.secure = s(w), w.resourceName = (w.path || "/") + (w.query ? "?" + w.query : ""), w.path = void 0, w.query = void 0, w;
  }
  function l(w) {
    if ((w.port === (s(w) ? 443 : 80) || w.port === "") && (w.port = void 0), typeof w.secure == "boolean" && (w.scheme = w.secure ? "wss" : "ws", w.secure = void 0), w.resourceName) {
      const [O, k] = w.resourceName.split("?");
      w.path = O && O !== "/" ? O : void 0, w.query = k, w.resourceName = void 0;
    }
    return w.fragment = void 0, w;
  }
  function u(w, O) {
    if (!w.path)
      return w.error = "URN can not be parsed", w;
    const k = w.path.match(e);
    if (k) {
      const $ = O.scheme || w.scheme || "urn";
      w.nid = k[1].toLowerCase(), w.nss = k[2];
      const T = `${$}:${O.nid || w.nid}`, E = P(T);
      w.path = void 0, E && (w = E.parse(w, O));
    } else
      w.error = w.error || "URN can not be parsed.";
    return w;
  }
  function c(w, O) {
    if (w.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const k = O.scheme || w.scheme || "urn", $ = w.nid.toLowerCase(), T = `${k}:${O.nid || $}`, E = P(T);
    E && (w = E.serialize(w, O));
    const M = w, R = w.nss;
    return M.path = `${$ || O.nid}:${R}`, O.skipEscape = !0, M;
  }
  function f(w, O) {
    const k = w;
    return k.uuid = k.nss, k.nss = void 0, !O.tolerant && (!k.uuid || !t(k.uuid)) && (k.error = k.error || "UUID is not valid."), k;
  }
  function p(w) {
    const O = w;
    return O.nss = (w.uuid || "").toLowerCase(), O;
  }
  const _ = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: o,
      serialize: i
    }
  ), b = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: _.domainHost,
      parse: o,
      serialize: i
    }
  ), g = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: a,
      serialize: l
    }
  ), h = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: g.domainHost,
      parse: g.parse,
      serialize: g.serialize
    }
  ), x = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: _,
      https: b,
      ws: g,
      wss: h,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: u,
          serialize: c,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: f,
          serialize: p,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(x, null);
  function P(w) {
    return w && (x[
      /** @type {SchemeName} */
      w
    ] || x[
      /** @type {SchemeName} */
      w.toLowerCase()
    ]) || void 0;
  }
  return zu = {
    wsIsSecure: s,
    SCHEMES: x,
    isValidSchemeName: n,
    getSchemeHandler: P
  }, zu;
}
var fp;
function Ik() {
  if (fp) return Zo.exports;
  fp = 1;
  const { normalizeIPv6: t, removeDotSegments: e, recomposeAuthority: r, normalizeComponentEncoding: n, isIPv4: s, nonSimpleDomain: o } = gb(), { SCHEMES: i, getSchemeHandler: a } = Mk();
  function l(h, y) {
    return typeof h == "string" ? h = /** @type {T} */
    p(b(h, y), y) : typeof h == "object" && (h = /** @type {T} */
    b(p(h, y), y)), h;
  }
  function u(h, y, S) {
    const x = S ? Object.assign({ scheme: "null" }, S) : { scheme: "null" }, P = c(b(h, x), b(y, x), x, !0);
    return x.skipEscape = !0, p(P, x);
  }
  function c(h, y, S, x) {
    const P = {};
    return x || (h = b(p(h, S), S), y = b(p(y, S), S)), S = S || {}, !S.tolerant && y.scheme ? (P.scheme = y.scheme, P.userinfo = y.userinfo, P.host = y.host, P.port = y.port, P.path = e(y.path || ""), P.query = y.query) : (y.userinfo !== void 0 || y.host !== void 0 || y.port !== void 0 ? (P.userinfo = y.userinfo, P.host = y.host, P.port = y.port, P.path = e(y.path || ""), P.query = y.query) : (y.path ? (y.path[0] === "/" ? P.path = e(y.path) : ((h.userinfo !== void 0 || h.host !== void 0 || h.port !== void 0) && !h.path ? P.path = "/" + y.path : h.path ? P.path = h.path.slice(0, h.path.lastIndexOf("/") + 1) + y.path : P.path = y.path, P.path = e(P.path)), P.query = y.query) : (P.path = h.path, y.query !== void 0 ? P.query = y.query : P.query = h.query), P.userinfo = h.userinfo, P.host = h.host, P.port = h.port), P.scheme = h.scheme), P.fragment = y.fragment, P;
  }
  function f(h, y, S) {
    return typeof h == "string" ? (h = unescape(h), h = p(n(b(h, S), !0), { ...S, skipEscape: !0 })) : typeof h == "object" && (h = p(n(h, !0), { ...S, skipEscape: !0 })), typeof y == "string" ? (y = unescape(y), y = p(n(b(y, S), !0), { ...S, skipEscape: !0 })) : typeof y == "object" && (y = p(n(y, !0), { ...S, skipEscape: !0 })), h.toLowerCase() === y.toLowerCase();
  }
  function p(h, y) {
    const S = {
      host: h.host,
      scheme: h.scheme,
      userinfo: h.userinfo,
      port: h.port,
      path: h.path,
      query: h.query,
      nid: h.nid,
      nss: h.nss,
      uuid: h.uuid,
      fragment: h.fragment,
      reference: h.reference,
      resourceName: h.resourceName,
      secure: h.secure,
      error: ""
    }, x = Object.assign({}, y), P = [], w = a(x.scheme || S.scheme);
    w && w.serialize && w.serialize(S, x), S.path !== void 0 && (x.skipEscape ? S.path = unescape(S.path) : (S.path = escape(S.path), S.scheme !== void 0 && (S.path = S.path.split("%3A").join(":")))), x.reference !== "suffix" && S.scheme && P.push(S.scheme, ":");
    const O = r(S);
    if (O !== void 0 && (x.reference !== "suffix" && P.push("//"), P.push(O), S.path && S.path[0] !== "/" && P.push("/")), S.path !== void 0) {
      let k = S.path;
      !x.absolutePath && (!w || !w.absolutePath) && (k = e(k)), O === void 0 && k[0] === "/" && k[1] === "/" && (k = "/%2F" + k.slice(2)), P.push(k);
    }
    return S.query !== void 0 && P.push("?", S.query), S.fragment !== void 0 && P.push("#", S.fragment), P.join("");
  }
  const _ = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function b(h, y) {
    const S = Object.assign({}, y), x = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let P = !1;
    S.reference === "suffix" && (S.scheme ? h = S.scheme + ":" + h : h = "//" + h);
    const w = h.match(_);
    if (w) {
      if (x.scheme = w[1], x.userinfo = w[3], x.host = w[4], x.port = parseInt(w[5], 10), x.path = w[6] || "", x.query = w[7], x.fragment = w[8], isNaN(x.port) && (x.port = w[5]), x.host)
        if (s(x.host) === !1) {
          const $ = t(x.host);
          x.host = $.host.toLowerCase(), P = $.isIPV6;
        } else
          P = !0;
      x.scheme === void 0 && x.userinfo === void 0 && x.host === void 0 && x.port === void 0 && x.query === void 0 && !x.path ? x.reference = "same-document" : x.scheme === void 0 ? x.reference = "relative" : x.fragment === void 0 ? x.reference = "absolute" : x.reference = "uri", S.reference && S.reference !== "suffix" && S.reference !== x.reference && (x.error = x.error || "URI is not a " + S.reference + " reference.");
      const O = a(S.scheme || x.scheme);
      if (!S.unicodeSupport && (!O || !O.unicodeSupport) && x.host && (S.domainHost || O && O.domainHost) && P === !1 && o(x.host))
        try {
          x.host = URL.domainToASCII(x.host.toLowerCase());
        } catch (k) {
          x.error = x.error || "Host's domain name can not be converted to ASCII: " + k;
        }
      (!O || O && !O.skipNormalize) && (h.indexOf("%") !== -1 && (x.scheme !== void 0 && (x.scheme = unescape(x.scheme)), x.host !== void 0 && (x.host = unescape(x.host))), x.path && (x.path = escape(unescape(x.path))), x.fragment && (x.fragment = encodeURI(decodeURIComponent(x.fragment)))), O && O.parse && O.parse(x, S);
    } else
      x.error = x.error || "URI can not be parsed.";
    return x;
  }
  const g = {
    SCHEMES: i,
    normalize: l,
    resolve: u,
    resolveComponent: c,
    equal: f,
    serialize: p,
    parse: b
  };
  return Zo.exports = g, Zo.exports.default = g, Zo.exports.fastUri = g, Zo.exports;
}
var hp;
function Nk() {
  if (hp) return Ji;
  hp = 1, Object.defineProperty(Ji, "__esModule", { value: !0 });
  const t = Ik();
  return t.code = 'require("ajv/dist/runtime/uri").default', Ji.default = t, Ji;
}
var gp;
function Fk() {
  return gp || (gp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    var e = Ql();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return e.KeywordCxt;
    } });
    var r = We();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = Vd(), s = eu(), o = db(), i = Ld(), a = We(), l = Zl(), u = il(), c = Qe(), f = Dk, p = Nk(), _ = (J, j) => new RegExp(J, j);
    _.code = "new RegExp";
    const b = ["removeAdditional", "useDefaults", "coerceTypes"], g = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), h = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, y = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, S = 200;
    function x(J) {
      var j, ee, L, N, V, G, fe, se, we, le, re, oe, pe, ye, Pe, Oe, Re, Ke, Ve, je, He, gt, Je, kt, lt;
      const ct = J.strict, pt = (j = J.code) === null || j === void 0 ? void 0 : j.optimize, Kt = pt === !0 || pt === void 0 ? 1 : pt || 0, yt = (L = (ee = J.code) === null || ee === void 0 ? void 0 : ee.regExp) !== null && L !== void 0 ? L : _, Rt = (N = J.uriResolver) !== null && N !== void 0 ? N : p.default;
      return {
        strictSchema: (G = (V = J.strictSchema) !== null && V !== void 0 ? V : ct) !== null && G !== void 0 ? G : !0,
        strictNumbers: (se = (fe = J.strictNumbers) !== null && fe !== void 0 ? fe : ct) !== null && se !== void 0 ? se : !0,
        strictTypes: (le = (we = J.strictTypes) !== null && we !== void 0 ? we : ct) !== null && le !== void 0 ? le : "log",
        strictTuples: (oe = (re = J.strictTuples) !== null && re !== void 0 ? re : ct) !== null && oe !== void 0 ? oe : "log",
        strictRequired: (ye = (pe = J.strictRequired) !== null && pe !== void 0 ? pe : ct) !== null && ye !== void 0 ? ye : !1,
        code: J.code ? { ...J.code, optimize: Kt, regExp: yt } : { optimize: Kt, regExp: yt },
        loopRequired: (Pe = J.loopRequired) !== null && Pe !== void 0 ? Pe : S,
        loopEnum: (Oe = J.loopEnum) !== null && Oe !== void 0 ? Oe : S,
        meta: (Re = J.meta) !== null && Re !== void 0 ? Re : !0,
        messages: (Ke = J.messages) !== null && Ke !== void 0 ? Ke : !0,
        inlineRefs: (Ve = J.inlineRefs) !== null && Ve !== void 0 ? Ve : !0,
        schemaId: (je = J.schemaId) !== null && je !== void 0 ? je : "$id",
        addUsedSchema: (He = J.addUsedSchema) !== null && He !== void 0 ? He : !0,
        validateSchema: (gt = J.validateSchema) !== null && gt !== void 0 ? gt : !0,
        validateFormats: (Je = J.validateFormats) !== null && Je !== void 0 ? Je : !0,
        unicodeRegExp: (kt = J.unicodeRegExp) !== null && kt !== void 0 ? kt : !0,
        int32range: (lt = J.int32range) !== null && lt !== void 0 ? lt : !0,
        uriResolver: Rt
      };
    }
    class P {
      constructor(j = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), j = this.opts = { ...j, ...x(j) };
        const { es5: ee, lines: L } = this.opts.code;
        this.scope = new a.ValueScope({ scope: {}, prefixes: g, es5: ee, lines: L }), this.logger = R(j.logger);
        const N = j.validateFormats;
        j.validateFormats = !1, this.RULES = (0, o.getRules)(), w.call(this, h, j, "NOT SUPPORTED"), w.call(this, y, j, "DEPRECATED", "warn"), this._metaOpts = E.call(this), j.formats && $.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), j.keywords && T.call(this, j.keywords), typeof j.meta == "object" && this.addMetaSchema(j.meta), k.call(this), j.validateFormats = N;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: j, meta: ee, schemaId: L } = this.opts;
        let N = f;
        L === "id" && (N = { ...f }, N.id = N.$id, delete N.$id), ee && j && this.addMetaSchema(N, N[L], !1);
      }
      defaultMeta() {
        const { meta: j, schemaId: ee } = this.opts;
        return this.opts.defaultMeta = typeof j == "object" ? j[ee] || j : void 0;
      }
      validate(j, ee) {
        let L;
        if (typeof j == "string") {
          if (L = this.getSchema(j), !L)
            throw new Error(`no schema with key or ref "${j}"`);
        } else
          L = this.compile(j);
        const N = L(ee);
        return "$async" in L || (this.errors = L.errors), N;
      }
      compile(j, ee) {
        const L = this._addSchema(j, ee);
        return L.validate || this._compileSchemaEnv(L);
      }
      compileAsync(j, ee) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: L } = this.opts;
        return N.call(this, j, ee);
        async function N(le, re) {
          await V.call(this, le.$schema);
          const oe = this._addSchema(le, re);
          return oe.validate || G.call(this, oe);
        }
        async function V(le) {
          le && !this.getSchema(le) && await N.call(this, { $ref: le }, !0);
        }
        async function G(le) {
          try {
            return this._compileSchemaEnv(le);
          } catch (re) {
            if (!(re instanceof s.default))
              throw re;
            return fe.call(this, re), await se.call(this, re.missingSchema), G.call(this, le);
          }
        }
        function fe({ missingSchema: le, missingRef: re }) {
          if (this.refs[le])
            throw new Error(`AnySchema ${le} is loaded but ${re} cannot be resolved`);
        }
        async function se(le) {
          const re = await we.call(this, le);
          this.refs[le] || await V.call(this, re.$schema), this.refs[le] || this.addSchema(re, le, ee);
        }
        async function we(le) {
          const re = this._loading[le];
          if (re)
            return re;
          try {
            return await (this._loading[le] = L(le));
          } finally {
            delete this._loading[le];
          }
        }
      }
      // Adds schema to the instance
      addSchema(j, ee, L, N = this.opts.validateSchema) {
        if (Array.isArray(j)) {
          for (const G of j)
            this.addSchema(G, void 0, L, N);
          return this;
        }
        let V;
        if (typeof j == "object") {
          const { schemaId: G } = this.opts;
          if (V = j[G], V !== void 0 && typeof V != "string")
            throw new Error(`schema ${G} must be string`);
        }
        return ee = (0, l.normalizeId)(ee || V), this._checkUnique(ee), this.schemas[ee] = this._addSchema(j, L, ee, N, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(j, ee, L = this.opts.validateSchema) {
        return this.addSchema(j, ee, !0, L), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(j, ee) {
        if (typeof j == "boolean")
          return !0;
        let L;
        if (L = j.$schema, L !== void 0 && typeof L != "string")
          throw new Error("$schema must be a string");
        if (L = L || this.opts.defaultMeta || this.defaultMeta(), !L)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const N = this.validate(L, j);
        if (!N && ee) {
          const V = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(V);
          else
            throw new Error(V);
        }
        return N;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(j) {
        let ee;
        for (; typeof (ee = O.call(this, j)) == "string"; )
          j = ee;
        if (ee === void 0) {
          const { schemaId: L } = this.opts, N = new i.SchemaEnv({ schema: {}, schemaId: L });
          if (ee = i.resolveSchema.call(this, N, j), !ee)
            return;
          this.refs[j] = ee;
        }
        return ee.validate || this._compileSchemaEnv(ee);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(j) {
        if (j instanceof RegExp)
          return this._removeAllSchemas(this.schemas, j), this._removeAllSchemas(this.refs, j), this;
        switch (typeof j) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const ee = O.call(this, j);
            return typeof ee == "object" && this._cache.delete(ee.schema), delete this.schemas[j], delete this.refs[j], this;
          }
          case "object": {
            const ee = j;
            this._cache.delete(ee);
            let L = j[this.opts.schemaId];
            return L && (L = (0, l.normalizeId)(L), delete this.schemas[L], delete this.refs[L]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(j) {
        for (const ee of j)
          this.addKeyword(ee);
        return this;
      }
      addKeyword(j, ee) {
        let L;
        if (typeof j == "string")
          L = j, typeof ee == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), ee.keyword = L);
        else if (typeof j == "object" && ee === void 0) {
          if (ee = j, L = ee.keyword, Array.isArray(L) && !L.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (B.call(this, L, ee), !ee)
          return (0, c.eachItem)(L, (V) => F.call(this, V)), this;
        Y.call(this, ee);
        const N = {
          ...ee,
          type: (0, u.getJSONTypes)(ee.type),
          schemaType: (0, u.getJSONTypes)(ee.schemaType)
        };
        return (0, c.eachItem)(L, N.type.length === 0 ? (V) => F.call(this, V, N) : (V) => N.type.forEach((G) => F.call(this, V, N, G))), this;
      }
      getKeyword(j) {
        const ee = this.RULES.all[j];
        return typeof ee == "object" ? ee.definition : !!ee;
      }
      // Remove keyword
      removeKeyword(j) {
        const { RULES: ee } = this;
        delete ee.keywords[j], delete ee.all[j];
        for (const L of ee.rules) {
          const N = L.rules.findIndex((V) => V.keyword === j);
          N >= 0 && L.rules.splice(N, 1);
        }
        return this;
      }
      // Add format
      addFormat(j, ee) {
        return typeof ee == "string" && (ee = new RegExp(ee)), this.formats[j] = ee, this;
      }
      errorsText(j = this.errors, { separator: ee = ", ", dataVar: L = "data" } = {}) {
        return !j || j.length === 0 ? "No errors" : j.map((N) => `${L}${N.instancePath} ${N.message}`).reduce((N, V) => N + ee + V);
      }
      $dataMetaSchema(j, ee) {
        const L = this.RULES.all;
        j = JSON.parse(JSON.stringify(j));
        for (const N of ee) {
          const V = N.split("/").slice(1);
          let G = j;
          for (const fe of V)
            G = G[fe];
          for (const fe in L) {
            const se = L[fe];
            if (typeof se != "object")
              continue;
            const { $data: we } = se.definition, le = G[fe];
            we && le && (G[fe] = ae(le));
          }
        }
        return j;
      }
      _removeAllSchemas(j, ee) {
        for (const L in j) {
          const N = j[L];
          (!ee || ee.test(L)) && (typeof N == "string" ? delete j[L] : N && !N.meta && (this._cache.delete(N.schema), delete j[L]));
        }
      }
      _addSchema(j, ee, L, N = this.opts.validateSchema, V = this.opts.addUsedSchema) {
        let G;
        const { schemaId: fe } = this.opts;
        if (typeof j == "object")
          G = j[fe];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof j != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let se = this._cache.get(j);
        if (se !== void 0)
          return se;
        L = (0, l.normalizeId)(G || L);
        const we = l.getSchemaRefs.call(this, j, L);
        return se = new i.SchemaEnv({ schema: j, schemaId: fe, meta: ee, baseId: L, localRefs: we }), this._cache.set(se.schema, se), V && !L.startsWith("#") && (L && this._checkUnique(L), this.refs[L] = se), N && this.validateSchema(j, !0), se;
      }
      _checkUnique(j) {
        if (this.schemas[j] || this.refs[j])
          throw new Error(`schema with key or id "${j}" already exists`);
      }
      _compileSchemaEnv(j) {
        if (j.meta ? this._compileMetaSchema(j) : i.compileSchema.call(this, j), !j.validate)
          throw new Error("ajv implementation error");
        return j.validate;
      }
      _compileMetaSchema(j) {
        const ee = this.opts;
        this.opts = this._metaOpts;
        try {
          i.compileSchema.call(this, j);
        } finally {
          this.opts = ee;
        }
      }
    }
    P.ValidationError = n.default, P.MissingRefError = s.default, t.default = P;
    function w(J, j, ee, L = "error") {
      for (const N in J) {
        const V = N;
        V in j && this.logger[L](`${ee}: option ${N}. ${J[V]}`);
      }
    }
    function O(J) {
      return J = (0, l.normalizeId)(J), this.schemas[J] || this.refs[J];
    }
    function k() {
      const J = this.opts.schemas;
      if (J)
        if (Array.isArray(J))
          this.addSchema(J);
        else
          for (const j in J)
            this.addSchema(J[j], j);
    }
    function $() {
      for (const J in this.opts.formats) {
        const j = this.opts.formats[J];
        j && this.addFormat(J, j);
      }
    }
    function T(J) {
      if (Array.isArray(J)) {
        this.addVocabulary(J);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const j in J) {
        const ee = J[j];
        ee.keyword || (ee.keyword = j), this.addKeyword(ee);
      }
    }
    function E() {
      const J = { ...this.opts };
      for (const j of b)
        delete J[j];
      return J;
    }
    const M = { log() {
    }, warn() {
    }, error() {
    } };
    function R(J) {
      if (J === !1)
        return M;
      if (J === void 0)
        return console;
      if (J.log && J.warn && J.error)
        return J;
      throw new Error("logger must implement log, warn and error methods");
    }
    const U = /^[a-z_$][a-z0-9_$:-]*$/i;
    function B(J, j) {
      const { RULES: ee } = this;
      if ((0, c.eachItem)(J, (L) => {
        if (ee.keywords[L])
          throw new Error(`Keyword ${L} is already defined`);
        if (!U.test(L))
          throw new Error(`Keyword ${L} has invalid name`);
      }), !!j && j.$data && !("code" in j || "validate" in j))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function F(J, j, ee) {
      var L;
      const N = j?.post;
      if (ee && N)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: V } = this;
      let G = N ? V.post : V.rules.find(({ type: se }) => se === ee);
      if (G || (G = { type: ee, rules: [] }, V.rules.push(G)), V.keywords[J] = !0, !j)
        return;
      const fe = {
        keyword: J,
        definition: {
          ...j,
          type: (0, u.getJSONTypes)(j.type),
          schemaType: (0, u.getJSONTypes)(j.schemaType)
        }
      };
      j.before ? Z.call(this, G, fe, j.before) : G.rules.push(fe), V.all[J] = fe, (L = j.implements) === null || L === void 0 || L.forEach((se) => this.addKeyword(se));
    }
    function Z(J, j, ee) {
      const L = J.rules.findIndex((N) => N.keyword === ee);
      L >= 0 ? J.rules.splice(L, 0, j) : (J.rules.push(j), this.logger.warn(`rule ${ee} is not defined`));
    }
    function Y(J) {
      let { metaSchema: j } = J;
      j !== void 0 && (J.$data && this.opts.$data && (j = ae(j)), J.validateSchema = this.compile(j, !0));
    }
    const X = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function ae(J) {
      return { anyOf: [J, X] };
    }
  })(Iu)), Iu;
}
var Zi = {}, Qi = {}, ea = {}, pp;
function Rk() {
  if (pp) return ea;
  pp = 1, Object.defineProperty(ea, "__esModule", { value: !0 });
  const t = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return ea.default = t, ea;
}
var Rn = {}, mp;
function Vk() {
  if (mp) return Rn;
  mp = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.callRef = Rn.getValidate = void 0;
  const t = eu(), e = zr(), r = We(), n = as(), s = Ld(), o = Qe(), i = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: c, schema: f, it: p } = u, { baseId: _, schemaEnv: b, validateName: g, opts: h, self: y } = p, { root: S } = b;
      if ((f === "#" || f === "#/") && _ === S.baseId)
        return P();
      const x = s.resolveRef.call(y, S, _, f);
      if (x === void 0)
        throw new t.default(p.opts.uriResolver, _, f);
      if (x instanceof s.SchemaEnv)
        return w(x);
      return O(x);
      function P() {
        if (b === S)
          return l(u, g, b, b.$async);
        const k = c.scopeValue("root", { ref: S });
        return l(u, (0, r._)`${k}.validate`, S, S.$async);
      }
      function w(k) {
        const $ = a(u, k);
        l(u, $, k, k.$async);
      }
      function O(k) {
        const $ = c.scopeValue("schema", h.code.source === !0 ? { ref: k, code: (0, r.stringify)(k) } : { ref: k }), T = c.name("valid"), E = u.subschema({
          schema: k,
          dataTypes: [],
          schemaPath: r.nil,
          topSchemaRef: $,
          errSchemaPath: f
        }, T);
        u.mergeEvaluated(E), u.ok(T);
      }
    }
  };
  function a(u, c) {
    const { gen: f } = u;
    return c.validate ? f.scopeValue("validate", { ref: c.validate }) : (0, r._)`${f.scopeValue("wrapper", { ref: c })}.validate`;
  }
  Rn.getValidate = a;
  function l(u, c, f, p) {
    const { gen: _, it: b } = u, { allErrors: g, schemaEnv: h, opts: y } = b, S = y.passContext ? n.default.this : r.nil;
    p ? x() : P();
    function x() {
      if (!h.$async)
        throw new Error("async schema referenced by sync schema");
      const k = _.let("valid");
      _.try(() => {
        _.code((0, r._)`await ${(0, e.callValidateCode)(u, c, S)}`), O(c), g || _.assign(k, !0);
      }, ($) => {
        _.if((0, r._)`!(${$} instanceof ${b.ValidationError})`, () => _.throw($)), w($), g || _.assign(k, !1);
      }), u.ok(k);
    }
    function P() {
      u.result((0, e.callValidateCode)(u, c, S), () => O(c), () => w(c));
    }
    function w(k) {
      const $ = (0, r._)`${k}.errors`;
      _.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${$} : ${n.default.vErrors}.concat(${$})`), _.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function O(k) {
      var $;
      if (!b.opts.unevaluated)
        return;
      const T = ($ = f?.validate) === null || $ === void 0 ? void 0 : $.evaluated;
      if (b.props !== !0)
        if (T && !T.dynamicProps)
          T.props !== void 0 && (b.props = o.mergeEvaluated.props(_, T.props, b.props));
        else {
          const E = _.var("props", (0, r._)`${k}.evaluated.props`);
          b.props = o.mergeEvaluated.props(_, E, b.props, r.Name);
        }
      if (b.items !== !0)
        if (T && !T.dynamicItems)
          T.items !== void 0 && (b.items = o.mergeEvaluated.items(_, T.items, b.items));
        else {
          const E = _.var("items", (0, r._)`${k}.evaluated.items`);
          b.items = o.mergeEvaluated.items(_, E, b.items, r.Name);
        }
    }
  }
  return Rn.callRef = l, Rn.default = i, Rn;
}
var vp;
function Lk() {
  if (vp) return Qi;
  vp = 1, Object.defineProperty(Qi, "__esModule", { value: !0 });
  const t = Rk(), e = Vk(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    t.default,
    e.default
  ];
  return Qi.default = r, Qi;
}
var ta = {}, ra = {}, yp;
function jk() {
  if (yp) return ra;
  yp = 1, Object.defineProperty(ra, "__esModule", { value: !0 });
  const t = We(), e = t.operators, r = {
    maximum: { okStr: "<=", ok: e.LTE, fail: e.GT },
    minimum: { okStr: ">=", ok: e.GTE, fail: e.LT },
    exclusiveMaximum: { okStr: "<", ok: e.LT, fail: e.GTE },
    exclusiveMinimum: { okStr: ">", ok: e.GT, fail: e.LTE }
  }, n = {
    message: ({ keyword: o, schemaCode: i }) => (0, t.str)`must be ${r[o].okStr} ${i}`,
    params: ({ keyword: o, schemaCode: i }) => (0, t._)`{comparison: ${r[o].okStr}, limit: ${i}}`
  }, s = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(o) {
      const { keyword: i, data: a, schemaCode: l } = o;
      o.fail$data((0, t._)`${a} ${r[i].fail} ${l} || isNaN(${a})`);
    }
  };
  return ra.default = s, ra;
}
var na = {}, bp;
function Bk() {
  if (bp) return na;
  bp = 1, Object.defineProperty(na, "__esModule", { value: !0 });
  const t = We(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, t.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, t._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: s, data: o, schemaCode: i, it: a } = n, l = a.opts.multipleOfPrecision, u = s.let("res"), c = l ? (0, t._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}` : (0, t._)`${u} !== parseInt(${u})`;
      n.fail$data((0, t._)`(${i} === 0 || (${u} = ${o}/${i}, ${c}))`);
    }
  };
  return na.default = r, na;
}
var sa = {}, oa = {}, _p;
function zk() {
  if (_p) return oa;
  _p = 1, Object.defineProperty(oa, "__esModule", { value: !0 });
  function t(e) {
    const r = e.length;
    let n = 0, s = 0, o;
    for (; s < r; )
      n++, o = e.charCodeAt(s++), o >= 55296 && o <= 56319 && s < r && (o = e.charCodeAt(s), (o & 64512) === 56320 && s++);
    return n;
  }
  return oa.default = t, t.code = 'require("ajv/dist/runtime/ucs2length").default', oa;
}
var wp;
function qk() {
  if (wp) return sa;
  wp = 1, Object.defineProperty(sa, "__esModule", { value: !0 });
  const t = We(), e = Qe(), r = zk(), s = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: o, schemaCode: i }) {
        const a = o === "maxLength" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${a} than ${i} characters`;
      },
      params: ({ schemaCode: o }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { keyword: i, data: a, schemaCode: l, it: u } = o, c = i === "maxLength" ? t.operators.GT : t.operators.LT, f = u.opts.unicode === !1 ? (0, t._)`${a}.length` : (0, t._)`${(0, e.useFunc)(o.gen, r.default)}(${a})`;
      o.fail$data((0, t._)`${f} ${c} ${l}`);
    }
  };
  return sa.default = s, sa;
}
var ia = {}, Sp;
function Uk() {
  if (Sp) return ia;
  Sp = 1, Object.defineProperty(ia, "__esModule", { value: !0 });
  const t = zr(), e = We(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: s }) => (0, e.str)`must match pattern "${s}"`,
      params: ({ schemaCode: s }) => (0, e._)`{pattern: ${s}}`
    },
    code(s) {
      const { data: o, $data: i, schema: a, schemaCode: l, it: u } = s, c = u.opts.unicodeRegExp ? "u" : "", f = i ? (0, e._)`(new RegExp(${l}, ${c}))` : (0, t.usePattern)(s, a);
      s.fail$data((0, e._)`!${f}.test(${o})`);
    }
  };
  return ia.default = n, ia;
}
var aa = {}, xp;
function Kk() {
  if (xp) return aa;
  xp = 1, Object.defineProperty(aa, "__esModule", { value: !0 });
  const t = We(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: s }) {
        const o = n === "maxProperties" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${o} than ${s} properties`;
      },
      params: ({ schemaCode: n }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: s, data: o, schemaCode: i } = n, a = s === "maxProperties" ? t.operators.GT : t.operators.LT;
      n.fail$data((0, t._)`Object.keys(${o}).length ${a} ${i}`);
    }
  };
  return aa.default = r, aa;
}
var la = {}, Pp;
function Hk() {
  if (Pp) return la;
  Pp = 1, Object.defineProperty(la, "__esModule", { value: !0 });
  const t = zr(), e = We(), r = Qe(), s = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: o } }) => (0, e.str)`must have required property '${o}'`,
      params: ({ params: { missingProperty: o } }) => (0, e._)`{missingProperty: ${o}}`
    },
    code(o) {
      const { gen: i, schema: a, schemaCode: l, data: u, $data: c, it: f } = o, { opts: p } = f;
      if (!c && a.length === 0)
        return;
      const _ = a.length >= p.loopRequired;
      if (f.allErrors ? b() : g(), p.strictRequired) {
        const S = o.parentSchema.properties, { definedProperties: x } = o.it;
        for (const P of a)
          if (S?.[P] === void 0 && !x.has(P)) {
            const w = f.schemaEnv.baseId + f.errSchemaPath, O = `required property "${P}" is not defined at "${w}" (strictRequired)`;
            (0, r.checkStrictMode)(f, O, f.opts.strictRequired);
          }
      }
      function b() {
        if (_ || c)
          o.block$data(e.nil, h);
        else
          for (const S of a)
            (0, t.checkReportMissingProp)(o, S);
      }
      function g() {
        const S = i.let("missing");
        if (_ || c) {
          const x = i.let("valid", !0);
          o.block$data(x, () => y(S, x)), o.ok(x);
        } else
          i.if((0, t.checkMissingProp)(o, a, S)), (0, t.reportMissingProp)(o, S), i.else();
      }
      function h() {
        i.forOf("prop", l, (S) => {
          o.setParams({ missingProperty: S }), i.if((0, t.noPropertyInData)(i, u, S, p.ownProperties), () => o.error());
        });
      }
      function y(S, x) {
        o.setParams({ missingProperty: S }), i.forOf(S, l, () => {
          i.assign(x, (0, t.propertyInData)(i, u, S, p.ownProperties)), i.if((0, e.not)(x), () => {
            o.error(), i.break();
          });
        }, e.nil);
      }
    }
  };
  return la.default = s, la;
}
var ua = {}, Op;
function Wk() {
  if (Op) return ua;
  Op = 1, Object.defineProperty(ua, "__esModule", { value: !0 });
  const t = We(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: s }) {
        const o = n === "maxItems" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${o} than ${s} items`;
      },
      params: ({ schemaCode: n }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: s, data: o, schemaCode: i } = n, a = s === "maxItems" ? t.operators.GT : t.operators.LT;
      n.fail$data((0, t._)`${o}.length ${a} ${i}`);
    }
  };
  return ua.default = r, ua;
}
var ca = {}, da = {}, Cp;
function jd() {
  if (Cp) return da;
  Cp = 1, Object.defineProperty(da, "__esModule", { value: !0 });
  const t = hb();
  return t.code = 'require("ajv/dist/runtime/equal").default', da.default = t, da;
}
var kp;
function Gk() {
  if (kp) return ca;
  kp = 1, Object.defineProperty(ca, "__esModule", { value: !0 });
  const t = il(), e = We(), r = Qe(), n = jd(), o = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i, j: a } }) => (0, e.str)`must NOT have duplicate items (items ## ${a} and ${i} are identical)`,
      params: ({ params: { i, j: a } }) => (0, e._)`{i: ${i}, j: ${a}}`
    },
    code(i) {
      const { gen: a, data: l, $data: u, schema: c, parentSchema: f, schemaCode: p, it: _ } = i;
      if (!u && !c)
        return;
      const b = a.let("valid"), g = f.items ? (0, t.getSchemaTypes)(f.items) : [];
      i.block$data(b, h, (0, e._)`${p} === false`), i.ok(b);
      function h() {
        const P = a.let("i", (0, e._)`${l}.length`), w = a.let("j");
        i.setParams({ i: P, j: w }), a.assign(b, !0), a.if((0, e._)`${P} > 1`, () => (y() ? S : x)(P, w));
      }
      function y() {
        return g.length > 0 && !g.some((P) => P === "object" || P === "array");
      }
      function S(P, w) {
        const O = a.name("item"), k = (0, t.checkDataTypes)(g, O, _.opts.strictNumbers, t.DataType.Wrong), $ = a.const("indices", (0, e._)`{}`);
        a.for((0, e._)`;${P}--;`, () => {
          a.let(O, (0, e._)`${l}[${P}]`), a.if(k, (0, e._)`continue`), g.length > 1 && a.if((0, e._)`typeof ${O} == "string"`, (0, e._)`${O} += "_"`), a.if((0, e._)`typeof ${$}[${O}] == "number"`, () => {
            a.assign(w, (0, e._)`${$}[${O}]`), i.error(), a.assign(b, !1).break();
          }).code((0, e._)`${$}[${O}] = ${P}`);
        });
      }
      function x(P, w) {
        const O = (0, r.useFunc)(a, n.default), k = a.name("outer");
        a.label(k).for((0, e._)`;${P}--;`, () => a.for((0, e._)`${w} = ${P}; ${w}--;`, () => a.if((0, e._)`${O}(${l}[${P}], ${l}[${w}])`, () => {
          i.error(), a.assign(b, !1).break(k);
        })));
      }
    }
  };
  return ca.default = o, ca;
}
var fa = {}, $p;
function Yk() {
  if ($p) return fa;
  $p = 1, Object.defineProperty(fa, "__esModule", { value: !0 });
  const t = We(), e = Qe(), r = jd(), s = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: o }) => (0, t._)`{allowedValue: ${o}}`
    },
    code(o) {
      const { gen: i, data: a, $data: l, schemaCode: u, schema: c } = o;
      l || c && typeof c == "object" ? o.fail$data((0, t._)`!${(0, e.useFunc)(i, r.default)}(${a}, ${u})`) : o.fail((0, t._)`${c} !== ${a}`);
    }
  };
  return fa.default = s, fa;
}
var ha = {}, Ap;
function Xk() {
  if (Ap) return ha;
  Ap = 1, Object.defineProperty(ha, "__esModule", { value: !0 });
  const t = We(), e = Qe(), r = jd(), s = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: o }) => (0, t._)`{allowedValues: ${o}}`
    },
    code(o) {
      const { gen: i, data: a, $data: l, schema: u, schemaCode: c, it: f } = o;
      if (!l && u.length === 0)
        throw new Error("enum must have non-empty array");
      const p = u.length >= f.opts.loopEnum;
      let _;
      const b = () => _ ?? (_ = (0, e.useFunc)(i, r.default));
      let g;
      if (p || l)
        g = i.let("valid"), o.block$data(g, h);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const S = i.const("vSchema", c);
        g = (0, t.or)(...u.map((x, P) => y(S, P)));
      }
      o.pass(g);
      function h() {
        i.assign(g, !1), i.forOf("v", c, (S) => i.if((0, t._)`${b()}(${a}, ${S})`, () => i.assign(g, !0).break()));
      }
      function y(S, x) {
        const P = u[x];
        return typeof P == "object" && P !== null ? (0, t._)`${b()}(${a}, ${S}[${x}])` : (0, t._)`${a} === ${P}`;
      }
    }
  };
  return ha.default = s, ha;
}
var Ep;
function Jk() {
  if (Ep) return ta;
  Ep = 1, Object.defineProperty(ta, "__esModule", { value: !0 });
  const t = jk(), e = Bk(), r = qk(), n = Uk(), s = Kk(), o = Hk(), i = Wk(), a = Gk(), l = Yk(), u = Xk(), c = [
    // number
    t.default,
    e.default,
    // string
    r.default,
    n.default,
    // object
    s.default,
    o.default,
    // array
    i.default,
    a.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    l.default,
    u.default
  ];
  return ta.default = c, ta;
}
var ga = {}, Xs = {}, Tp;
function pb() {
  if (Tp) return Xs;
  Tp = 1, Object.defineProperty(Xs, "__esModule", { value: !0 }), Xs.validateAdditionalItems = void 0;
  const t = We(), e = Qe(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: o } }) => (0, t.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { parentSchema: i, it: a } = o, { items: l } = i;
      if (!Array.isArray(l)) {
        (0, e.checkStrictMode)(a, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      s(o, l);
    }
  };
  function s(o, i) {
    const { gen: a, schema: l, data: u, keyword: c, it: f } = o;
    f.items = !0;
    const p = a.const("len", (0, t._)`${u}.length`);
    if (l === !1)
      o.setParams({ len: i.length }), o.pass((0, t._)`${p} <= ${i.length}`);
    else if (typeof l == "object" && !(0, e.alwaysValidSchema)(f, l)) {
      const b = a.var("valid", (0, t._)`${p} <= ${i.length}`);
      a.if((0, t.not)(b), () => _(b)), o.ok(b);
    }
    function _(b) {
      a.forRange("i", i.length, p, (g) => {
        o.subschema({ keyword: c, dataProp: g, dataPropType: e.Type.Num }, b), f.allErrors || a.if((0, t.not)(b), () => a.break());
      });
    }
  }
  return Xs.validateAdditionalItems = s, Xs.default = n, Xs;
}
var pa = {}, Js = {}, Dp;
function mb() {
  if (Dp) return Js;
  Dp = 1, Object.defineProperty(Js, "__esModule", { value: !0 }), Js.validateTuple = void 0;
  const t = We(), e = Qe(), r = zr(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(o) {
      const { schema: i, it: a } = o;
      if (Array.isArray(i))
        return s(o, "additionalItems", i);
      a.items = !0, !(0, e.alwaysValidSchema)(a, i) && o.ok((0, r.validateArray)(o));
    }
  };
  function s(o, i, a = o.schema) {
    const { gen: l, parentSchema: u, data: c, keyword: f, it: p } = o;
    g(u), p.opts.unevaluated && a.length && p.items !== !0 && (p.items = e.mergeEvaluated.items(l, a.length, p.items));
    const _ = l.name("valid"), b = l.const("len", (0, t._)`${c}.length`);
    a.forEach((h, y) => {
      (0, e.alwaysValidSchema)(p, h) || (l.if((0, t._)`${b} > ${y}`, () => o.subschema({
        keyword: f,
        schemaProp: y,
        dataProp: y
      }, _)), o.ok(_));
    });
    function g(h) {
      const { opts: y, errSchemaPath: S } = p, x = a.length, P = x === h.minItems && (x === h.maxItems || h[i] === !1);
      if (y.strictTuples && !P) {
        const w = `"${f}" is ${x}-tuple, but minItems or maxItems/${i} are not specified or different at path "${S}"`;
        (0, e.checkStrictMode)(p, w, y.strictTuples);
      }
    }
  }
  return Js.validateTuple = s, Js.default = n, Js;
}
var Mp;
function Zk() {
  if (Mp) return pa;
  Mp = 1, Object.defineProperty(pa, "__esModule", { value: !0 });
  const t = mb(), e = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, t.validateTuple)(r, "items")
  };
  return pa.default = e, pa;
}
var ma = {}, Ip;
function Qk() {
  if (Ip) return ma;
  Ip = 1, Object.defineProperty(ma, "__esModule", { value: !0 });
  const t = We(), e = Qe(), r = zr(), n = pb(), o = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: i } }) => (0, t.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, t._)`{limit: ${i}}`
    },
    code(i) {
      const { schema: a, parentSchema: l, it: u } = i, { prefixItems: c } = l;
      u.items = !0, !(0, e.alwaysValidSchema)(u, a) && (c ? (0, n.validateAdditionalItems)(i, c) : i.ok((0, r.validateArray)(i)));
    }
  };
  return ma.default = o, ma;
}
var va = {}, Np;
function e$() {
  if (Np) return va;
  Np = 1, Object.defineProperty(va, "__esModule", { value: !0 });
  const t = We(), e = Qe(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: s, max: o } }) => o === void 0 ? (0, t.str)`must contain at least ${s} valid item(s)` : (0, t.str)`must contain at least ${s} and no more than ${o} valid item(s)`,
      params: ({ params: { min: s, max: o } }) => o === void 0 ? (0, t._)`{minContains: ${s}}` : (0, t._)`{minContains: ${s}, maxContains: ${o}}`
    },
    code(s) {
      const { gen: o, schema: i, parentSchema: a, data: l, it: u } = s;
      let c, f;
      const { minContains: p, maxContains: _ } = a;
      u.opts.next ? (c = p === void 0 ? 1 : p, f = _) : c = 1;
      const b = o.const("len", (0, t._)`${l}.length`);
      if (s.setParams({ min: c, max: f }), f === void 0 && c === 0) {
        (0, e.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (f !== void 0 && c > f) {
        (0, e.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), s.fail();
        return;
      }
      if ((0, e.alwaysValidSchema)(u, i)) {
        let x = (0, t._)`${b} >= ${c}`;
        f !== void 0 && (x = (0, t._)`${x} && ${b} <= ${f}`), s.pass(x);
        return;
      }
      u.items = !0;
      const g = o.name("valid");
      f === void 0 && c === 1 ? y(g, () => o.if(g, () => o.break())) : c === 0 ? (o.let(g, !0), f !== void 0 && o.if((0, t._)`${l}.length > 0`, h)) : (o.let(g, !1), h()), s.result(g, () => s.reset());
      function h() {
        const x = o.name("_valid"), P = o.let("count", 0);
        y(x, () => o.if(x, () => S(P)));
      }
      function y(x, P) {
        o.forRange("i", 0, b, (w) => {
          s.subschema({
            keyword: "contains",
            dataProp: w,
            dataPropType: e.Type.Num,
            compositeRule: !0
          }, x), P();
        });
      }
      function S(x) {
        o.code((0, t._)`${x}++`), f === void 0 ? o.if((0, t._)`${x} >= ${c}`, () => o.assign(g, !0).break()) : (o.if((0, t._)`${x} > ${f}`, () => o.assign(g, !1).break()), c === 1 ? o.assign(g, !0) : o.if((0, t._)`${x} >= ${c}`, () => o.assign(g, !0)));
      }
    }
  };
  return va.default = n, va;
}
var qu = {}, Fp;
function t$() {
  return Fp || (Fp = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
    const e = We(), r = Qe(), n = zr();
    t.error = {
      message: ({ params: { property: l, depsCount: u, deps: c } }) => {
        const f = u === 1 ? "property" : "properties";
        return (0, e.str)`must have ${f} ${c} when property ${l} is present`;
      },
      params: ({ params: { property: l, depsCount: u, deps: c, missingProperty: f } }) => (0, e._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${u},
    deps: ${c}}`
      // TODO change to reference
    };
    const s = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: t.error,
      code(l) {
        const [u, c] = o(l);
        i(l, u), a(l, c);
      }
    };
    function o({ schema: l }) {
      const u = {}, c = {};
      for (const f in l) {
        if (f === "__proto__")
          continue;
        const p = Array.isArray(l[f]) ? u : c;
        p[f] = l[f];
      }
      return [u, c];
    }
    function i(l, u = l.schema) {
      const { gen: c, data: f, it: p } = l;
      if (Object.keys(u).length === 0)
        return;
      const _ = c.let("missing");
      for (const b in u) {
        const g = u[b];
        if (g.length === 0)
          continue;
        const h = (0, n.propertyInData)(c, f, b, p.opts.ownProperties);
        l.setParams({
          property: b,
          depsCount: g.length,
          deps: g.join(", ")
        }), p.allErrors ? c.if(h, () => {
          for (const y of g)
            (0, n.checkReportMissingProp)(l, y);
        }) : (c.if((0, e._)`${h} && (${(0, n.checkMissingProp)(l, g, _)})`), (0, n.reportMissingProp)(l, _), c.else());
      }
    }
    t.validatePropertyDeps = i;
    function a(l, u = l.schema) {
      const { gen: c, data: f, keyword: p, it: _ } = l, b = c.name("valid");
      for (const g in u)
        (0, r.alwaysValidSchema)(_, u[g]) || (c.if(
          (0, n.propertyInData)(c, f, g, _.opts.ownProperties),
          () => {
            const h = l.subschema({ keyword: p, schemaProp: g }, b);
            l.mergeValidEvaluated(h, b);
          },
          () => c.var(b, !0)
          // TODO var
        ), l.ok(b));
    }
    t.validateSchemaDeps = a, t.default = s;
  })(qu)), qu;
}
var ya = {}, Rp;
function r$() {
  if (Rp) return ya;
  Rp = 1, Object.defineProperty(ya, "__esModule", { value: !0 });
  const t = We(), e = Qe(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: s }) => (0, t._)`{propertyName: ${s.propertyName}}`
    },
    code(s) {
      const { gen: o, schema: i, data: a, it: l } = s;
      if ((0, e.alwaysValidSchema)(l, i))
        return;
      const u = o.name("valid");
      o.forIn("key", a, (c) => {
        s.setParams({ propertyName: c }), s.subschema({
          keyword: "propertyNames",
          data: c,
          dataTypes: ["string"],
          propertyName: c,
          compositeRule: !0
        }, u), o.if((0, t.not)(u), () => {
          s.error(!0), l.allErrors || o.break();
        });
      }), s.ok(u);
    }
  };
  return ya.default = n, ya;
}
var ba = {}, Vp;
function vb() {
  if (Vp) return ba;
  Vp = 1, Object.defineProperty(ba, "__esModule", { value: !0 });
  const t = zr(), e = We(), r = as(), n = Qe(), o = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: i }) => (0, e._)`{additionalProperty: ${i.additionalProperty}}`
    },
    code(i) {
      const { gen: a, schema: l, parentSchema: u, data: c, errsCount: f, it: p } = i;
      if (!f)
        throw new Error("ajv implementation error");
      const { allErrors: _, opts: b } = p;
      if (p.props = !0, b.removeAdditional !== "all" && (0, n.alwaysValidSchema)(p, l))
        return;
      const g = (0, t.allSchemaProperties)(u.properties), h = (0, t.allSchemaProperties)(u.patternProperties);
      y(), i.ok((0, e._)`${f} === ${r.default.errors}`);
      function y() {
        a.forIn("key", c, (O) => {
          !g.length && !h.length ? P(O) : a.if(S(O), () => P(O));
        });
      }
      function S(O) {
        let k;
        if (g.length > 8) {
          const $ = (0, n.schemaRefOrVal)(p, u.properties, "properties");
          k = (0, t.isOwnProperty)(a, $, O);
        } else g.length ? k = (0, e.or)(...g.map(($) => (0, e._)`${O} === ${$}`)) : k = e.nil;
        return h.length && (k = (0, e.or)(k, ...h.map(($) => (0, e._)`${(0, t.usePattern)(i, $)}.test(${O})`))), (0, e.not)(k);
      }
      function x(O) {
        a.code((0, e._)`delete ${c}[${O}]`);
      }
      function P(O) {
        if (b.removeAdditional === "all" || b.removeAdditional && l === !1) {
          x(O);
          return;
        }
        if (l === !1) {
          i.setParams({ additionalProperty: O }), i.error(), _ || a.break();
          return;
        }
        if (typeof l == "object" && !(0, n.alwaysValidSchema)(p, l)) {
          const k = a.name("valid");
          b.removeAdditional === "failing" ? (w(O, k, !1), a.if((0, e.not)(k), () => {
            i.reset(), x(O);
          })) : (w(O, k), _ || a.if((0, e.not)(k), () => a.break()));
        }
      }
      function w(O, k, $) {
        const T = {
          keyword: "additionalProperties",
          dataProp: O,
          dataPropType: n.Type.Str
        };
        $ === !1 && Object.assign(T, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), i.subschema(T, k);
      }
    }
  };
  return ba.default = o, ba;
}
var _a = {}, Lp;
function n$() {
  if (Lp) return _a;
  Lp = 1, Object.defineProperty(_a, "__esModule", { value: !0 });
  const t = Ql(), e = zr(), r = Qe(), n = vb(), s = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(o) {
      const { gen: i, schema: a, parentSchema: l, data: u, it: c } = o;
      c.opts.removeAdditional === "all" && l.additionalProperties === void 0 && n.default.code(new t.KeywordCxt(c, n.default, "additionalProperties"));
      const f = (0, e.allSchemaProperties)(a);
      for (const h of f)
        c.definedProperties.add(h);
      c.opts.unevaluated && f.length && c.props !== !0 && (c.props = r.mergeEvaluated.props(i, (0, r.toHash)(f), c.props));
      const p = f.filter((h) => !(0, r.alwaysValidSchema)(c, a[h]));
      if (p.length === 0)
        return;
      const _ = i.name("valid");
      for (const h of p)
        b(h) ? g(h) : (i.if((0, e.propertyInData)(i, u, h, c.opts.ownProperties)), g(h), c.allErrors || i.else().var(_, !0), i.endIf()), o.it.definedProperties.add(h), o.ok(_);
      function b(h) {
        return c.opts.useDefaults && !c.compositeRule && a[h].default !== void 0;
      }
      function g(h) {
        o.subschema({
          keyword: "properties",
          schemaProp: h,
          dataProp: h
        }, _);
      }
    }
  };
  return _a.default = s, _a;
}
var wa = {}, jp;
function s$() {
  if (jp) return wa;
  jp = 1, Object.defineProperty(wa, "__esModule", { value: !0 });
  const t = zr(), e = We(), r = Qe(), n = Qe(), s = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(o) {
      const { gen: i, schema: a, data: l, parentSchema: u, it: c } = o, { opts: f } = c, p = (0, t.allSchemaProperties)(a), _ = p.filter((P) => (0, r.alwaysValidSchema)(c, a[P]));
      if (p.length === 0 || _.length === p.length && (!c.opts.unevaluated || c.props === !0))
        return;
      const b = f.strictSchema && !f.allowMatchingProperties && u.properties, g = i.name("valid");
      c.props !== !0 && !(c.props instanceof e.Name) && (c.props = (0, n.evaluatedPropsToName)(i, c.props));
      const { props: h } = c;
      y();
      function y() {
        for (const P of p)
          b && S(P), c.allErrors ? x(P) : (i.var(g, !0), x(P), i.if(g));
      }
      function S(P) {
        for (const w in b)
          new RegExp(P).test(w) && (0, r.checkStrictMode)(c, `property ${w} matches pattern ${P} (use allowMatchingProperties)`);
      }
      function x(P) {
        i.forIn("key", l, (w) => {
          i.if((0, e._)`${(0, t.usePattern)(o, P)}.test(${w})`, () => {
            const O = _.includes(P);
            O || o.subschema({
              keyword: "patternProperties",
              schemaProp: P,
              dataProp: w,
              dataPropType: n.Type.Str
            }, g), c.opts.unevaluated && h !== !0 ? i.assign((0, e._)`${h}[${w}]`, !0) : !O && !c.allErrors && i.if((0, e.not)(g), () => i.break());
          });
        });
      }
    }
  };
  return wa.default = s, wa;
}
var Sa = {}, Bp;
function o$() {
  if (Bp) return Sa;
  Bp = 1, Object.defineProperty(Sa, "__esModule", { value: !0 });
  const t = Qe(), e = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: s, it: o } = r;
      if ((0, t.alwaysValidSchema)(o, s)) {
        r.fail();
        return;
      }
      const i = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, i), r.failResult(i, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Sa.default = e, Sa;
}
var xa = {}, zp;
function i$() {
  if (zp) return xa;
  zp = 1, Object.defineProperty(xa, "__esModule", { value: !0 });
  const e = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: zr().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return xa.default = e, xa;
}
var Pa = {}, qp;
function a$() {
  if (qp) return Pa;
  qp = 1, Object.defineProperty(Pa, "__esModule", { value: !0 });
  const t = We(), e = Qe(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: s }) => (0, t._)`{passingSchemas: ${s.passing}}`
    },
    code(s) {
      const { gen: o, schema: i, parentSchema: a, it: l } = s;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      if (l.opts.discriminator && a.discriminator)
        return;
      const u = i, c = o.let("valid", !1), f = o.let("passing", null), p = o.name("_valid");
      s.setParams({ passing: f }), o.block(_), s.result(c, () => s.reset(), () => s.error(!0));
      function _() {
        u.forEach((b, g) => {
          let h;
          (0, e.alwaysValidSchema)(l, b) ? o.var(p, !0) : h = s.subschema({
            keyword: "oneOf",
            schemaProp: g,
            compositeRule: !0
          }, p), g > 0 && o.if((0, t._)`${p} && ${c}`).assign(c, !1).assign(f, (0, t._)`[${f}, ${g}]`).else(), o.if(p, () => {
            o.assign(c, !0), o.assign(f, g), h && s.mergeEvaluated(h, t.Name);
          });
        });
      }
    }
  };
  return Pa.default = n, Pa;
}
var Oa = {}, Up;
function l$() {
  if (Up) return Oa;
  Up = 1, Object.defineProperty(Oa, "__esModule", { value: !0 });
  const t = Qe(), e = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: s, it: o } = r;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const i = n.name("valid");
      s.forEach((a, l) => {
        if ((0, t.alwaysValidSchema)(o, a))
          return;
        const u = r.subschema({ keyword: "allOf", schemaProp: l }, i);
        r.ok(i), r.mergeEvaluated(u);
      });
    }
  };
  return Oa.default = e, Oa;
}
var Ca = {}, Kp;
function u$() {
  if (Kp) return Ca;
  Kp = 1, Object.defineProperty(Ca, "__esModule", { value: !0 });
  const t = We(), e = Qe(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: o }) => (0, t.str)`must match "${o.ifClause}" schema`,
      params: ({ params: o }) => (0, t._)`{failingKeyword: ${o.ifClause}}`
    },
    code(o) {
      const { gen: i, parentSchema: a, it: l } = o;
      a.then === void 0 && a.else === void 0 && (0, e.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
      const u = s(l, "then"), c = s(l, "else");
      if (!u && !c)
        return;
      const f = i.let("valid", !0), p = i.name("_valid");
      if (_(), o.reset(), u && c) {
        const g = i.let("ifClause");
        o.setParams({ ifClause: g }), i.if(p, b("then", g), b("else", g));
      } else u ? i.if(p, b("then")) : i.if((0, t.not)(p), b("else"));
      o.pass(f, () => o.error(!0));
      function _() {
        const g = o.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, p);
        o.mergeEvaluated(g);
      }
      function b(g, h) {
        return () => {
          const y = o.subschema({ keyword: g }, p);
          i.assign(f, p), o.mergeValidEvaluated(y, f), h ? i.assign(h, (0, t._)`${g}`) : o.setParams({ ifClause: g });
        };
      }
    }
  };
  function s(o, i) {
    const a = o.schema[i];
    return a !== void 0 && !(0, e.alwaysValidSchema)(o, a);
  }
  return Ca.default = n, Ca;
}
var ka = {}, Hp;
function c$() {
  if (Hp) return ka;
  Hp = 1, Object.defineProperty(ka, "__esModule", { value: !0 });
  const t = Qe(), e = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: s }) {
      n.if === void 0 && (0, t.checkStrictMode)(s, `"${r}" without "if" is ignored`);
    }
  };
  return ka.default = e, ka;
}
var Wp;
function d$() {
  if (Wp) return ga;
  Wp = 1, Object.defineProperty(ga, "__esModule", { value: !0 });
  const t = pb(), e = Zk(), r = mb(), n = Qk(), s = e$(), o = t$(), i = r$(), a = vb(), l = n$(), u = s$(), c = o$(), f = i$(), p = a$(), _ = l$(), b = u$(), g = c$();
  function h(y = !1) {
    const S = [
      // any
      c.default,
      f.default,
      p.default,
      _.default,
      b.default,
      g.default,
      // object
      i.default,
      a.default,
      o.default,
      l.default,
      u.default
    ];
    return y ? S.push(e.default, n.default) : S.push(t.default, r.default), S.push(s.default), S;
  }
  return ga.default = h, ga;
}
var $a = {}, Aa = {}, Gp;
function f$() {
  if (Gp) return Aa;
  Gp = 1, Object.defineProperty(Aa, "__esModule", { value: !0 });
  const t = We(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, t.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, t._)`{format: ${n}}`
    },
    code(n, s) {
      const { gen: o, data: i, $data: a, schema: l, schemaCode: u, it: c } = n, { opts: f, errSchemaPath: p, schemaEnv: _, self: b } = c;
      if (!f.validateFormats)
        return;
      a ? g() : h();
      function g() {
        const y = o.scopeValue("formats", {
          ref: b.formats,
          code: f.code.formats
        }), S = o.const("fDef", (0, t._)`${y}[${u}]`), x = o.let("fType"), P = o.let("format");
        o.if((0, t._)`typeof ${S} == "object" && !(${S} instanceof RegExp)`, () => o.assign(x, (0, t._)`${S}.type || "string"`).assign(P, (0, t._)`${S}.validate`), () => o.assign(x, (0, t._)`"string"`).assign(P, S)), n.fail$data((0, t.or)(w(), O()));
        function w() {
          return f.strictSchema === !1 ? t.nil : (0, t._)`${u} && !${P}`;
        }
        function O() {
          const k = _.$async ? (0, t._)`(${S}.async ? await ${P}(${i}) : ${P}(${i}))` : (0, t._)`${P}(${i})`, $ = (0, t._)`(typeof ${P} == "function" ? ${k} : ${P}.test(${i}))`;
          return (0, t._)`${P} && ${P} !== true && ${x} === ${s} && !${$}`;
        }
      }
      function h() {
        const y = b.formats[l];
        if (!y) {
          w();
          return;
        }
        if (y === !0)
          return;
        const [S, x, P] = O(y);
        S === s && n.pass(k());
        function w() {
          if (f.strictSchema === !1) {
            b.logger.warn($());
            return;
          }
          throw new Error($());
          function $() {
            return `unknown format "${l}" ignored in schema at path "${p}"`;
          }
        }
        function O($) {
          const T = $ instanceof RegExp ? (0, t.regexpCode)($) : f.code.formats ? (0, t._)`${f.code.formats}${(0, t.getProperty)(l)}` : void 0, E = o.scopeValue("formats", { key: l, ref: $, code: T });
          return typeof $ == "object" && !($ instanceof RegExp) ? [$.type || "string", $.validate, (0, t._)`${E}.validate`] : ["string", $, E];
        }
        function k() {
          if (typeof y == "object" && !(y instanceof RegExp) && y.async) {
            if (!_.$async)
              throw new Error("async format in sync schema");
            return (0, t._)`await ${P}(${i})`;
          }
          return typeof x == "function" ? (0, t._)`${P}(${i})` : (0, t._)`${P}.test(${i})`;
        }
      }
    }
  };
  return Aa.default = r, Aa;
}
var Yp;
function h$() {
  if (Yp) return $a;
  Yp = 1, Object.defineProperty($a, "__esModule", { value: !0 });
  const e = [f$().default];
  return $a.default = e, $a;
}
var vs = {}, Xp;
function g$() {
  return Xp || (Xp = 1, Object.defineProperty(vs, "__esModule", { value: !0 }), vs.contentVocabulary = vs.metadataVocabulary = void 0, vs.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], vs.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), vs;
}
var Jp;
function p$() {
  if (Jp) return Zi;
  Jp = 1, Object.defineProperty(Zi, "__esModule", { value: !0 });
  const t = Lk(), e = Jk(), r = d$(), n = h$(), s = g$(), o = [
    t.default,
    e.default,
    (0, r.default)(),
    n.default,
    s.metadataVocabulary,
    s.contentVocabulary
  ];
  return Zi.default = o, Zi;
}
var Ea = {}, Qo = {}, Zp;
function m$() {
  if (Zp) return Qo;
  Zp = 1, Object.defineProperty(Qo, "__esModule", { value: !0 }), Qo.DiscrError = void 0;
  var t;
  return (function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  })(t || (Qo.DiscrError = t = {})), Qo;
}
var Qp;
function v$() {
  if (Qp) return Ea;
  Qp = 1, Object.defineProperty(Ea, "__esModule", { value: !0 });
  const t = We(), e = m$(), r = Ld(), n = eu(), s = Qe(), i = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: a, tagName: l } }) => a === e.DiscrError.Tag ? `tag "${l}" must be string` : `value of tag "${l}" must be in oneOf`,
      params: ({ params: { discrError: a, tag: l, tagName: u } }) => (0, t._)`{error: ${a}, tag: ${u}, tagValue: ${l}}`
    },
    code(a) {
      const { gen: l, data: u, schema: c, parentSchema: f, it: p } = a, { oneOf: _ } = f;
      if (!p.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const b = c.propertyName;
      if (typeof b != "string")
        throw new Error("discriminator: requires propertyName");
      if (c.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!_)
        throw new Error("discriminator: requires oneOf keyword");
      const g = l.let("valid", !1), h = l.const("tag", (0, t._)`${u}${(0, t.getProperty)(b)}`);
      l.if((0, t._)`typeof ${h} == "string"`, () => y(), () => a.error(!1, { discrError: e.DiscrError.Tag, tag: h, tagName: b })), a.ok(g);
      function y() {
        const P = x();
        l.if(!1);
        for (const w in P)
          l.elseIf((0, t._)`${h} === ${w}`), l.assign(g, S(P[w]));
        l.else(), a.error(!1, { discrError: e.DiscrError.Mapping, tag: h, tagName: b }), l.endIf();
      }
      function S(P) {
        const w = l.name("valid"), O = a.subschema({ keyword: "oneOf", schemaProp: P }, w);
        return a.mergeEvaluated(O, t.Name), w;
      }
      function x() {
        var P;
        const w = {}, O = $(f);
        let k = !0;
        for (let M = 0; M < _.length; M++) {
          let R = _[M];
          if (R?.$ref && !(0, s.schemaHasRulesButRef)(R, p.self.RULES)) {
            const B = R.$ref;
            if (R = r.resolveRef.call(p.self, p.schemaEnv.root, p.baseId, B), R instanceof r.SchemaEnv && (R = R.schema), R === void 0)
              throw new n.default(p.opts.uriResolver, p.baseId, B);
          }
          const U = (P = R?.properties) === null || P === void 0 ? void 0 : P[b];
          if (typeof U != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${b}"`);
          k = k && (O || $(R)), T(U, M);
        }
        if (!k)
          throw new Error(`discriminator: "${b}" must be required`);
        return w;
        function $({ required: M }) {
          return Array.isArray(M) && M.includes(b);
        }
        function T(M, R) {
          if (M.const)
            E(M.const, R);
          else if (M.enum)
            for (const U of M.enum)
              E(U, R);
          else
            throw new Error(`discriminator: "properties/${b}" must have "const" or "enum"`);
        }
        function E(M, R) {
          if (typeof M != "string" || M in w)
            throw new Error(`discriminator: "${b}" values must be unique strings`);
          w[M] = R;
        }
      }
    }
  };
  return Ea.default = i, Ea;
}
const y$ = "http://json-schema.org/draft-07/schema#", b$ = "http://json-schema.org/draft-07/schema#", _$ = "Core schema meta-schema", w$ = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, S$ = ["object", "boolean"], x$ = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, P$ = {
  $schema: y$,
  $id: b$,
  title: _$,
  definitions: w$,
  type: S$,
  properties: x$,
  default: !0
};
var em;
function O$() {
  return em || (em = 1, (function(t, e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = e.Ajv = void 0;
    const r = Fk(), n = p$(), s = v$(), o = P$, i = ["/properties"], a = "http://json-schema.org/draft-07/schema";
    class l extends r.default {
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((b) => this.addVocabulary(b)), this.opts.discriminator && this.addKeyword(s.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const b = this.opts.$data ? this.$dataMetaSchema(o, i) : o;
        this.addMetaSchema(b, a, !1), this.refs["http://json-schema.org/schema"] = a;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
      }
    }
    e.Ajv = l, t.exports = e = l, t.exports.Ajv = l, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l;
    var u = Ql();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return u.KeywordCxt;
    } });
    var c = We();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return c._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return c.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return c.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return c.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return c.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return c.CodeGen;
    } });
    var f = Vd();
    Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
      return f.default;
    } });
    var p = eu();
    Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
      return p.default;
    } });
  })(Wi, Wi.exports)), Wi.exports;
}
var C$ = O$();
function k$({ params: { missingProperty: t, propertyName: e }, propertyName: r = e }, n) {
  let s = n;
  return s = t !== void 0 ? n.concat(t) : s, s = r !== void 0 ? n.concat(r, Ad("key-input")) : s, s;
}
function yb({ params: { missingProperty: t }, parentSchema: e, message: r }, n) {
  if (!r)
    return "";
  if (t === void 0)
    return r;
  const s = n(t, e);
  return s === void 0 ? r : r.replace(t, s);
}
function $$({ uiSchema: t = {} }) {
  return (e, r) => ({
    value: r,
    errors: e.map((n) => {
      const s = JO(n.instancePath, r);
      return {
        path: k$(n, s),
        message: yb(n, (o, i) => {
          const a = eC(t, s.concat(o));
          if (a !== void 0)
            return a;
          const l = i?.properties?.[o];
          if (typeof l == "object")
            return l.title;
        })
      };
    })
  });
}
function bb(t) {
  return t.instancePath === "";
}
function A$(t) {
  return bb(t) && t.keyword !== "type";
}
function E$(t) {
  return (e) => e.filter(t.required ? bb : A$).map((r) => yb(r, () => t.title));
}
function _b(t, e, r, n) {
  t(e);
  const s = t.errors;
  return t.errors = null, s ? n(s, e) : r(e);
}
const T$ = (t) => ({ value: t }), D$ = () => [];
function M$({ compileSchema: t }) {
  return {
    isValid(e, r, n) {
      if (typeof e == "boolean")
        return e;
      const s = t(e, r);
      try {
        return s(n);
      } catch (o) {
        return console.warn("Failed to validate", o), !1;
      }
    }
  };
}
function I$(t) {
  const e = $$(t);
  return {
    validateFormValue(r, n) {
      return _b(t.compileSchema(r, r), n, T$, e);
    }
  };
}
function N$({ compileFieldSchema: t }) {
  return {
    validateFieldValue(e, r) {
      return _b(t(e), r, D$, E$(e));
    }
  };
}
function F$({ ajvOptions: t = hk, ajvPlugins: e = yk, ajv: r = e(new C$.Ajv(t)), validatorsCache: n, compileSchema: s = bk(r, !1, n), compileFieldSchema: o = _k(r, !1), ...i } = {}) {
  const a = {
    ...i,
    compileSchema: s,
    compileFieldSchema: o
  };
  return Object.assign(M$(a), I$(a), N$(a));
}
function R$(t, e, { checkVisibility: r = !1 } = {}) {
  const n = t.querySelector(`[id="${e}"]`);
  return (n instanceof HTMLElement || n instanceof SVGElement) && n.tabIndex >= 0 && "disabled" in n && n.disabled !== !0 && (!r || window.getComputedStyle(n).visibility !== "hidden") ? n : null;
}
function V$(t, e) {
  return t.querySelector(`#${e}`);
}
function L$(t, e) {
  if (t !== null)
    return () => t.focus();
  const r = e();
  return r !== null ? () => r.scrollIntoView({ behavior: "auto", block: "center" }) : null;
}
function j$(t = {}) {
  return ({ errors: e }, r, n) => {
    if (e.length === 0)
      return !1;
    const s = r.target;
    if (!(s instanceof HTMLElement))
      return console.warn("Expected form to be an HTMLElement, got", s), !1;
    const { path: o } = e[0], i = L$(R$(s, Vg(n, o), t), () => V$(s, Vg(n, o.concat(Ad("errors")))));
    return i === null ? !1 : Rl().then(i);
  };
}
const B$ = "_";
function z$({ idPrefix: t = Ty, separator: e = B$ } = {}) {
  return {
    fromPath: (r) => {
      let n = "";
      for (let s = 0; s < r.length; s++) {
        const o = r[s], i = gC(o);
        n += i !== void 0 ? `${e}${e}${i}` : `${e}${o}`;
      }
      return `${t}${n}`;
    }
  };
}
function q$({ jsonSchemaMerger: { mergeSchemaDefinitions: t, mergeArrayOfSchemaDefinitions: e } = gO(), jsonSchemaAllOfMerge: r = mO(e) } = {}) {
  return {
    mergeSchemas(n, s) {
      return t(n, s);
    },
    mergeAllOf(n) {
      return r(n);
    }
  };
}
function U$(t) {
  const e = q$(t);
  return {
    ...e,
    mergeFormDataAndSchemaDefaults({ formData: r, schema: n, initialDefaultsGenerated: s = !1, includeUndefinedValues: o = !1 }) {
      return LO(t.validator, e, n, r, t.schema, o, t, s);
    }
  };
}
const K$ = {
  submit: "Submit",
  "array-schema-missing-items": "Missing items definition",
  yes: "Yes",
  no: "No",
  "multi-schema-option-label-with-title": ({ title: t, index: e }) => `${t} option ${e + 1}`,
  "multi-schema-option-label": ({ index: t }) => `Option ${t + 1}`,
  "add-array-item": "Add item",
  "copy-array-item": "Copy",
  "add-object-property": "Add property",
  "move-array-item-down": "Down",
  "move-array-item-up": "Up",
  "remove-array-item": "Del",
  "remove-object-property": "Del",
  edit: "Edit",
  clear: "Clear",
  "validation-process-error": ({ error: t }) => H$[t.reason],
  "component-not-found": ({ type: t }) => `"${t}" component not found`,
  "key-input-title": ({ name: t }) => `${t} Key`,
  "additional-property": "Additional property",
  "unknown-field-error": ({ schema: t }) => `You're seeing this error because your JSON Schema doesnâ€™t contain enough information
to determine its type. You can:
- specify the schema type (for example, using the 'type' keyword)
- specify which component to use via UiSchema
  ('{ "ui:components": { "unknownField": "myField" } }')
- specify which component to use by providing a custom 'resolver'
  (https://x0k.dev/svelte-jsonschema-form/guides/fields-resolution/)

JSON Schema:
${JSON.stringify(t, null, 2)}`
}, H$ = {
  aborted: "Validation aborted",
  timeout: "Validation terminated by timeout",
  error: "Something went wrong during validation"
}, W$ = Ii(K$);
var Uu, tm;
function G$() {
  if (tm) return Uu;
  tm = 1;
  function t(c) {
    return c === void 0;
  }
  function e(c) {
    return c === null;
  }
  function r(c) {
    return typeof c == "boolean";
  }
  function n(c) {
    return c === Object(c);
  }
  function s(c) {
    return Array.isArray(c);
  }
  function o(c) {
    return c instanceof Date;
  }
  function i(c, f) {
    return f ? n(c) && !t(c.uri) : n(c) && typeof c.size == "number" && typeof c.type == "string" && typeof c.slice == "function";
  }
  function a(c, f) {
    return i(c, f) && typeof c.name == "string" && (n(c.lastModifiedDate) || typeof c.lastModified == "number");
  }
  function l(c) {
    return t(c) ? !1 : c;
  }
  function u(c, f, p, _) {
    f = f || {}, p = p || new FormData(), f.indices = l(f.indices), f.nullsAsUndefineds = l(f.nullsAsUndefineds), f.booleansAsIntegers = l(f.booleansAsIntegers), f.allowEmptyArrays = l(f.allowEmptyArrays), f.noAttributesWithArrayNotation = l(
      f.noAttributesWithArrayNotation
    ), f.noFilesWithArrayNotation = l(f.noFilesWithArrayNotation), f.dotsForObjectNotation = l(f.dotsForObjectNotation);
    const b = typeof p.getParts == "function";
    return t(c) || (e(c) ? f.nullsAsUndefineds || p.append(_, "") : r(c) ? f.booleansAsIntegers ? p.append(_, c ? 1 : 0) : p.append(_, c) : s(c) ? c.length ? c.forEach((g, h) => {
      let y = _ + "[" + (f.indices ? h : "") + "]";
      (f.noAttributesWithArrayNotation || f.noFilesWithArrayNotation && a(g, b)) && (y = _), u(g, f, p, y);
    }) : f.allowEmptyArrays && p.append(f.noAttributesWithArrayNotation ? _ : _ + "[]", "") : o(c) ? p.append(_, c.toISOString()) : n(c) && !i(c, b) ? Object.keys(c).forEach((g) => {
      const h = c[g];
      if (s(h))
        for (; g.length > 2 && g.lastIndexOf("[]") === g.length - 2; )
          g = g.substring(0, g.length - 2);
      const y = _ ? f.dotsForObjectNotation ? _ + "." + g : _ + "[" + g + "]" : g;
      u(h, f, p, y);
    }) : p.append(_, c)), p;
  }
  return Uu = {
    serialize: u
  }, Uu;
}
var Y$ = G$(), X$ = /* @__PURE__ */ ne("<!> <!>", 1);
function Bd(t, e) {
  H(e, !0);
  const r = (B) => {
    var F = I(), Z = D(F);
    te(
      Z,
      () => d($) ?? ge,
      () => l,
      s,
      () => ({
        get current() {
          return n();
        },
        set current(Y) {
          n(Y);
        }
      }),
      () => d(w)
    ), A(B, F);
  };
  let n = v(e, "value", 15), s = v(e, "config", 7), o = v(e, "combinationKey", 7), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = De(), u = /* @__PURE__ */ C(() => Le(l, "multiFieldTemplate", s())), c = /* @__PURE__ */ C(() => Le(l, "selectWidget", s())), f = /* @__PURE__ */ C(() => {
    const { [o()]: B, ...F } = s().schema;
    if (ho(s().schema) !== "object")
      return null;
    const Y = ho(F);
    return {
      ...s(),
      schema: Y === "unknown" ? { type: "object" } : F
    };
  }), p = /* @__PURE__ */ C(() => d(f) && vo(l, d(f))), _ = /* @__PURE__ */ C(() => (s().schema[o()] ?? []).map((B) => typeof B != "boolean" ? $r(l, B, n()) : {}));
  let b = /* @__PURE__ */ xe(void 0), g = /* @__PURE__ */ C(() => SC(l, n(), d(_), d(b) ?? 0, Ds(s().schema)));
  Ze(() => {
    const B = d(g);
    d(b) !== B && (n(ot(() => {
      const F = d(_)[B];
      if (F === void 0)
        return;
      const Z = d(b) !== void 0 ? d(_)[d(b)] : void 0;
      return Dd(l, {
        schema: F,
        formData: Z !== void 0 ? wC(l, F, Z, n()) : n(),
        includeUndefinedValues: "excludeObjectChildren"
      });
    })), q(b, B));
  });
  const h = /* @__PURE__ */ C(() => {
    const B = s().uiSchema[o()];
    return Array.isArray(B) ? B.map((F) => Gn(l, F)) : [];
  }), y = /* @__PURE__ */ C(() => {
    const B = Wr(l, s().uiSchema) ?? s().schema.title;
    return B ? (F) => a()("multi-schema-option-label-with-title", { index: F, title: B }) : (F) => a()("multi-schema-option-label", { index: F });
  }), S = /* @__PURE__ */ C(() => {
    const B = Ds(s().schema);
    return d(_).map((F, Z) => {
      if (B !== void 0) {
        const X = d(h)[Z]?.[B];
        if (typeof X == "object" && !Array.isArray(X)) {
          const J = Wr(l, Gn(l, X));
          if (J !== void 0)
            return J;
        }
        const ae = F.properties?.[B];
        if (ae !== void 0 && typeof ae != "boolean") {
          const { title: J } = $r(l, ae, void 0);
          if (J !== void 0)
            return J;
        }
      }
      const Y = d(h)[Z];
      return (Y && Wr(l, Y)) ?? F.title ?? d(y)(Z);
    });
  }), x = /* @__PURE__ */ C(() => d(S).map((B, F) => ({
    id: mo(l, s().path, F),
    label: B,
    value: F,
    disabled: !1
  }))), P = /* @__PURE__ */ C(() => {
    const B = o().toLowerCase(), F = Gn(l, s().uiSchema.combinationFieldOptionSelector);
    return {
      path: Mi(l, s().path, B),
      title: Wr(l, F) ?? s().title,
      schema: { type: "integer", default: 0 },
      uiSchema: F,
      required: !0
    };
  }), w = /* @__PURE__ */ C(() => qt(l, s().path)), O = /* @__PURE__ */ C(() => {
    const B = d(b) ?? d(g);
    if (B < 0)
      return null;
    const F = d(_)[B], { required: Z } = s().schema, Y = Z ? {
      ...F,
      required: F.required ? Z.concat(F.required) : Z
    } : F, X = B < d(h).length ? d(h)[B] : s().uiSchema;
    return {
      path: s().path,
      title: "",
      schema: Y,
      uiSchema: X,
      required: s().required
    };
  }), k = /* @__PURE__ */ C(() => d(O) && vo(l, d(O))), $ = /* @__PURE__ */ C(() => on(l, s(), `${o()}Field`));
  var T = {
    get value() {
      return n();
    },
    set value(B) {
      n(B), m();
    },
    get config() {
      return s();
    },
    set config(B) {
      s(B), m();
    },
    get combinationKey() {
      return o();
    },
    set combinationKey(B) {
      o(B), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(B) {
      i(B), m();
    },
    get translate() {
      return a();
    },
    set translate(B) {
      a(B), m();
    }
  }, E = X$(), M = D(E);
  {
    var R = (B) => {
      var F = I(), Z = D(F);
      {
        let Y = /* @__PURE__ */ C(() => Ms(l, d(f)));
        Q(Z, () => d(p), (X, ae) => {
          ae(X, {
            type: "field",
            get config() {
              return d(f);
            },
            uiOption: (J) => It(l, d(f), J),
            get translate() {
              return d(Y);
            },
            get value() {
              return n();
            },
            set value(J) {
              n(J);
            }
          });
        });
      }
      A(B, F);
    };
    ue(M, (B) => {
      d(f) && B(R);
    });
  }
  var U = be(M, 2);
  {
    const B = (Z) => {
      var Y = I(), X = D(Y), ae = () => d(b) ?? d(g), J = (j) => q(g, j);
      Q(X, () => d(c), (j, ee) => {
        ee(j, {
          type: "widget",
          get errors() {
            return d(w);
          },
          handlers: {},
          get config() {
            return d(P);
          },
          uiOption: (L) => It(l, d(P), L),
          get options() {
            return d(x);
          },
          get value() {
            return ae();
          },
          set value(L) {
            J(L);
          }
        });
      }), A(Z, Y);
    };
    let F = /* @__PURE__ */ C(() => d($) && r);
    Q(U, () => d(u), (Z, Y) => {
      Y(Z, {
        type: "template",
        get config() {
          return s();
        },
        get value() {
          return n();
        },
        get errors() {
          return d(w);
        },
        get uiOption() {
          return i();
        },
        get action() {
          return d(F);
        },
        optionSelector: B,
        children: (X, ae) => {
          var J = I(), j = D(J);
          {
            var ee = (L) => {
              var N = I(), V = D(N);
              {
                let G = /* @__PURE__ */ C(() => Ms(l, d(O)));
                Q(V, () => d(k), (fe, se) => {
                  se(fe, {
                    type: "field",
                    get config() {
                      return d(O);
                    },
                    uiOption: (we) => It(l, d(O), we),
                    get translate() {
                      return d(G);
                    },
                    get value() {
                      return n();
                    },
                    set value(we) {
                      n(we);
                    }
                  });
                });
              }
              A(L, N);
            };
            ue(j, (L) => {
              d(O) && L(ee);
            });
          }
          A(X, J);
        },
        $$slots: { optionSelector: !0, default: !0 }
      });
    });
  }
  return A(t, E), W(T);
}
K(
  Bd,
  {
    value: {},
    config: {},
    combinationKey: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
class J$ {
  array;
  nextKey;
  #e = /* @__PURE__ */ xe(0);
  get changesPropagator() {
    return d(this.#e);
  }
  set changesPropagator(e) {
    q(this.#e, e);
  }
  keys;
  constructor(e, r) {
    this.array = e, this.nextKey = r;
    const n = new Array(e.length);
    for (let s = 0; s < e.length; s++)
      n[s] = r();
    this.keys = n;
  }
  key(e) {
    return this.changesPropagator, this.keys[e];
  }
  push(e) {
    return this.keys.push(this.nextKey()), this.array.push(e);
  }
  swap(e, r) {
    const n = this.keys[e];
    if (this.keys[e] = this.keys[r], this.keys[r] = n, this.array[e] !== this.array[r]) {
      const s = this.array[e];
      this.array[e] = this.array[r], this.array[r] = s;
    }
    this.changesPropagator++;
  }
  insert(e, r) {
    this.keys.splice(e, 0, this.nextKey()), this.array.splice(e, 0, r);
  }
  remove(e) {
    return this.keys.splice(e, 1), this.array.splice(e, 1)[0];
  }
  splice(e, r, ...n) {
    const s = n.length;
    let o;
    if (s > 0) {
      const i = new Array(n.length);
      for (let a = 0; a < s; a++)
        i[a] = this.nextKey();
      this.keys.splice(e, r, ...i), o = this.array.splice(e, r, ...n);
    } else
      this.keys.splice(e, r), o = this.array.splice(e, r);
    return this.changesPropagator++, o;
  }
}
function Z$(t, e, r) {
  return e >= r ? `${t}-${e - r + 1}` : t;
}
const wb = /* @__PURE__ */ Symbol("array-context");
function Q$() {
  return Es(wb);
}
function eA(t) {
  Po(wb, t);
}
function Sb({ ctx: t, config: e, itemSchema: r, keyedArray: n, value: s }) {
  const o = (b) => It(t, e(), b);
  function i() {
    Os(t, e().path, sl);
    const b = Yy(t);
    !(b & sC) || b & kd && !t.isSubmitted || Mn(t, e(), s());
  }
  const a = /* @__PURE__ */ C(n), l = /* @__PURE__ */ C(() => qt(t, e().path)), u = /* @__PURE__ */ C(() => o("addable") ?? !0), c = /* @__PURE__ */ C(() => o("orderable") ?? !0), f = /* @__PURE__ */ C(() => o("removable") ?? !0), p = /* @__PURE__ */ C(() => o("copyable") ?? !1), _ = /* @__PURE__ */ C(() => o("itemTitle") ?? Z$);
  return {
    config: e,
    uiOption: o,
    itemTitle(b, g, h, y) {
      return d(_)(b, g, h, y);
    },
    addable: () => d(u),
    orderable: () => d(c),
    removable: () => d(f),
    copyable: () => d(p),
    errors: () => d(l),
    key: (b) => d(a).key(b),
    pushItem: () => {
      const b = r();
      b !== void 0 && (d(a).push(Dd(t, { schema: b, formData: void 0 }) ?? ky(ho(b))), i());
    },
    moveItemUp(b) {
      d(a).swap(b, b - 1), i();
    },
    moveItemDown(b) {
      d(a).swap(b, b + 1), i();
    },
    copyItem(b) {
      d(a).insert(b, xo(s()[b])), i();
    },
    removeItem(b) {
      d(a).remove(b), i();
    }
  };
}
function xb(t, e, r) {
  let n;
  return () => r() && (n = t().schema.maxItems, n === void 0 || e() < n);
}
function tA({ ctx: t, config: e, value: r, keyedArray: n }) {
  const s = /* @__PURE__ */ C(r), o = /* @__PURE__ */ C(() => {
    const { schema: { items: f } } = e();
    return Be(f) ? f : {};
  }), i = Sb({
    ctx: t,
    config: e,
    value: r,
    keyedArray: n,
    itemSchema: () => d(o)
  }), a = /* @__PURE__ */ C(() => {
    const { uiSchema: { items: f } } = e();
    return Gn(t, Array.isArray(f) ? void 0 : f);
  }), l = /* @__PURE__ */ C(() => Wr(t, d(a))), u = () => d(s)?.length ?? 0, c = /* @__PURE__ */ C(xb(e, u, i.addable));
  return {
    ...i,
    length: u,
    set(f, p) {
      d(s)[f] = p;
    },
    canAdd() {
      return d(c);
    },
    canCopy() {
      return i.copyable() && d(c);
    },
    canRemove: i.removable,
    canMoveUp(f) {
      return i.orderable() && f > 0;
    },
    canMoveDown(f) {
      return i.orderable() && f < d(s).length - 1;
    },
    itemConfig(f, p, _) {
      const b = $r(t, d(o), p);
      return {
        path: Gl(t, f.path, _),
        title: i.itemTitle(d(l) ?? b.title ?? f.title, _, 0, p),
        schema: b,
        uiSchema: d(a),
        required: !hy(b)
      };
    }
  };
}
function rA({ ctx: t, config: e, value: r, keyedArray: n }) {
  const s = /* @__PURE__ */ C(r), o = /* @__PURE__ */ C(() => {
    const { items: b } = e().schema;
    return Array.isArray(b) ? b.map((g, h) => {
      if (typeof g == "boolean")
        throw new Error("Invalid schema: items must be an array of schemas");
      return $r(t, g, d(s)?.[h]);
    }) : [];
  }), i = (b) => b >= d(o).length, a = /* @__PURE__ */ C(() => {
    const { additionalItems: b } = e().schema;
    return Be(b) ? b : void 0;
  }), l = /* @__PURE__ */ C(n), u = Sb({
    ctx: t,
    config: e,
    value: r,
    keyedArray: () => d(l),
    itemSchema: () => d(a)
  }), c = /* @__PURE__ */ C(() => Math.max(d(s)?.length ?? 0, d(o).length)), f = () => d(c), p = /* @__PURE__ */ C(xb(e, f, () => u.addable() && d(a) !== void 0));
  function _(b = dy) {
    const g = new Array(d(c));
    b(g), d(l).splice(0, 0, ...g);
  }
  return {
    ...u,
    length: f,
    pushItem() {
      d(s) || _(), u.pushItem();
    },
    set(b, g) {
      d(s) ? d(s)[b] = g : _((h) => {
        h[b] = g;
      });
    },
    canAdd() {
      return d(p);
    },
    canCopy(b) {
      return u.copyable() && d(p) && i(b);
    },
    canRemove(b) {
      return u.removable() && i(b);
    },
    canMoveUp(b) {
      return u.orderable() && b > d(o).length;
    },
    canMoveDown(b) {
      return u.orderable() && b < d(c) - 1 && i(b);
    },
    itemConfig(b, g, h) {
      const y = i(h), S = $r(
        t,
        y ? d(a) : d(o)[h],
        g
      ), x = Gn(t, y ? b.uiSchema.additionalItems : Array.isArray(b.uiSchema.items) ? b.uiSchema.items[h] : b.uiSchema.items);
      return {
        path: Gl(t, b.path, h),
        title: u.itemTitle(Wr(t, x) ?? S.title ?? b.title, h, d(o).length, g),
        schema: S,
        uiSchema: x,
        required: !hy(S)
      };
    }
  };
}
class nA {
  setValue;
  constructor(e) {
    this.setValue = e;
  }
  key(e) {
    return e;
  }
  push(e) {
    return this.setValue([e]), 1;
  }
  swap() {
    throw new Error('Method "swap" cannot be called on "VirtualKeyedArray" instance');
  }
  insert(e, r) {
    if (e !== 0)
      throw new Error(`Method "insert" cannot be called on "VirtualKeyedArray" instance with those args (index=${e}), expected (0)`);
    this.setValue([r]);
  }
  remove(e) {
    throw new Error('Method "remove" cannot be called on "VirtualKeyedArray" instance');
  }
  splice(e, r, ...n) {
    if (e !== 0 || r !== 0)
      throw new Error(`Method "splice" cannot be called on "VirtualKeyedArray" instance with those args(start=${e}, count=${r}) expected (0, 0)`);
    return this.setValue(n), [];
  }
}
function zd(t, e) {
  H(e, !0);
  const r = (x) => {
    var P = I(), w = D(P);
    {
      let O = /* @__PURE__ */ C(() => f.errors());
      Q(w, () => d(b), (k, $) => {
        $(k, {
          get errors() {
            return d(O);
          },
          get config() {
            return o();
          },
          disabled: !1,
          type: "array-item-add",
          get onclick() {
            return f.pushItem;
          },
          children: (T, E) => {
            vn(T, {
              get config() {
                return o();
              },
              id: "add-array-item",
              get translate() {
                return l();
              }
            });
          },
          $$slots: { default: !0 }
        });
      });
    }
    A(x, P);
  }, n = (x) => {
    var P = I(), w = D(P);
    {
      let O = /* @__PURE__ */ C(() => f.errors());
      te(
        w,
        () => d(g) ?? ge,
        () => c,
        o,
        () => ({
          get current() {
            return s();
          },
          set current(k) {
            s(k);
          }
        }),
        () => d(O)
      );
    }
    A(x, P);
  };
  let s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "createContext", 7), a = v(e, "uiOption", 7), l = v(e, "translate", 7), u = v(e, "field", 7);
  const c = De(), f = i()({
    ctx: c,
    config: () => o(),
    value: () => s(),
    keyedArray: HC(c, () => s(), () => new nA((x) => s(x)), (x, P) => new J$(x, P))
  });
  eA(f);
  const p = /* @__PURE__ */ C(() => Le(c, "arrayItemField", o())), _ = /* @__PURE__ */ C(() => Le(c, "arrayTemplate", o())), b = /* @__PURE__ */ C(() => Le(c, "button", o())), g = /* @__PURE__ */ C(() => on(c, o(), u()));
  var h = {
    get value() {
      return s();
    },
    set value(x) {
      s(x), m();
    },
    get config() {
      return o();
    },
    set config(x) {
      o(x), m();
    },
    get createContext() {
      return i();
    },
    set createContext(x) {
      i(x), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(x) {
      a(x), m();
    },
    get translate() {
      return l();
    },
    set translate(x) {
      l(x), m();
    },
    get field() {
      return u();
    },
    set field(x) {
      u(x), m();
    }
  }, y = I(), S = D(y);
  {
    let x = /* @__PURE__ */ C(() => f.errors()), P = /* @__PURE__ */ C(() => f.canAdd() ? r : void 0), w = /* @__PURE__ */ C(() => d(g) && n);
    Q(S, () => d(_), (O, k) => {
      k(O, {
        type: "template",
        get errors() {
          return d(x);
        },
        get config() {
          return o();
        },
        get value() {
          return s();
        },
        get uiOption() {
          return a();
        },
        get addButton() {
          return d(P);
        },
        get action() {
          return d(w);
        },
        children: ($, T) => {
          var E = I(), M = D(E);
          st(M, 19, () => ({ length: f.length() }), (R, U) => f.key(U), (R, U, B) => {
            const F = /* @__PURE__ */ C(() => f.itemConfig(o(), s()?.[d(B)], d(B)));
            var Z = I(), Y = D(Z), X = () => s()?.[d(B)], ae = (J) => f.set(d(B), J);
            {
              let J = /* @__PURE__ */ C(() => Ms(c, d(F)));
              Q(Y, () => d(p), (j, ee) => {
                ee(j, {
                  type: "field",
                  get index() {
                    return d(B);
                  },
                  get config() {
                    return d(F);
                  },
                  get value() {
                    return X();
                  },
                  set value(L) {
                    ae(L);
                  },
                  uiOption: (L) => It(c, d(F), L),
                  get translate() {
                    return d(J);
                  }
                });
              });
            }
            A(R, Z);
          }), A($, E);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, y), W(h);
}
K(
  zd,
  {
    value: {},
    config: {},
    createContext: {},
    uiOption: {},
    translate: {},
    field: {}
  },
  [],
  [],
  { mode: "open" }
);
function Pb(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return zd(t, {
    type: "field",
    field: "arrayField",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get createContext() {
      return tA;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), W(i);
}
K(Pb, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Ob(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return zd(t, {
    type: "field",
    field: "tupleField",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get createContext() {
      return rA;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), W(i);
}
K(Ob, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
var sA = /* @__PURE__ */ ne("<!> <!>", 1), oA = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function Cb(t, e) {
  H(e, !0);
  const r = (O) => {
    var k = oA(), $ = D(k);
    {
      var T = (B) => {
        var F = sA(), Z = D(F);
        {
          let X = /* @__PURE__ */ C(() => !d(g));
          Q(Z, () => d(p), (ae, J) => {
            J(ae, {
              get errors() {
                return d(S);
              },
              get config() {
                return o();
              },
              type: "array-item-move-up",
              get disabled() {
                return d(X);
              },
              onclick: () => {
                u.moveItemUp(n());
              },
              children: (j, ee) => {
                vn(j, {
                  get config() {
                    return o();
                  },
                  id: "move-array-item-up",
                  get translate() {
                    return a();
                  }
                });
              },
              $$slots: { default: !0 }
            });
          });
        }
        var Y = be(Z, 2);
        {
          let X = /* @__PURE__ */ C(() => !d(h));
          Q(Y, () => d(p), (ae, J) => {
            J(ae, {
              get errors() {
                return d(S);
              },
              get config() {
                return o();
              },
              get disabled() {
                return d(X);
              },
              type: "array-item-move-down",
              onclick: () => {
                u.moveItemDown(n());
              },
              children: (j, ee) => {
                vn(j, {
                  get config() {
                    return o();
                  },
                  id: "move-array-item-down",
                  get translate() {
                    return a();
                  }
                });
              },
              $$slots: { default: !0 }
            });
          });
        }
        A(B, F);
      };
      ue($, (B) => {
        u.orderable() && B(T);
      });
    }
    var E = be($, 2);
    {
      var M = (B) => {
        var F = I(), Z = D(F);
        Q(Z, () => d(p), (Y, X) => {
          X(Y, {
            get errors() {
              return d(S);
            },
            get config() {
              return o();
            },
            type: "array-item-copy",
            onclick: () => {
              u.copyItem(n());
            },
            disabled: !1,
            children: (ae, J) => {
              vn(ae, {
                get config() {
                  return o();
                },
                id: "copy-array-item",
                get translate() {
                  return a();
                }
              });
            },
            $$slots: { default: !0 }
          });
        }), A(B, F);
      };
      ue(E, (B) => {
        d(_) && B(M);
      });
    }
    var R = be(E, 2);
    {
      var U = (B) => {
        var F = I(), Z = D(F);
        Q(Z, () => d(p), (Y, X) => {
          X(Y, {
            get errors() {
              return d(S);
            },
            get config() {
              return o();
            },
            disabled: !1,
            type: "array-item-remove",
            onclick: () => {
              u.removeItem(n());
            },
            children: (ae, J) => {
              vn(ae, {
                get config() {
                  return o();
                },
                id: "remove-array-item",
                get translate() {
                  return a();
                }
              });
            },
            $$slots: { default: !0 }
          });
        }), A(B, F);
      };
      ue(R, (B) => {
        d(b) && B(U);
      });
    }
    A(O, k);
  };
  let n = v(e, "index", 7), s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "uiOption", 7), a = v(e, "translate", 7);
  const l = De(), u = Q$(), c = /* @__PURE__ */ C(() => Le(l, "arrayItemTemplate", o())), f = /* @__PURE__ */ C(() => vo(l, o())), p = /* @__PURE__ */ C(() => Le(l, "button", o())), _ = /* @__PURE__ */ C(() => u.canCopy(n())), b = /* @__PURE__ */ C(() => u.canRemove(n())), g = /* @__PURE__ */ C(() => u.canMoveUp(n())), h = /* @__PURE__ */ C(() => u.canMoveDown(n())), y = /* @__PURE__ */ C(() => d(_) || d(b) || d(g) || d(h)), S = /* @__PURE__ */ C(() => qt(l, o().path));
  var x = {
    get index() {
      return n();
    },
    set index(O) {
      n(O), m();
    },
    get value() {
      return s();
    },
    set value(O) {
      s(O), m();
    },
    get config() {
      return o();
    },
    set config(O) {
      o(O), m();
    },
    get uiOption() {
      return i();
    },
    set uiOption(O) {
      i(O), m();
    },
    get translate() {
      return a();
    },
    set translate(O) {
      a(O), m();
    }
  }, P = I(), w = D(P);
  {
    let O = /* @__PURE__ */ C(() => d(y) ? r : void 0);
    Q(w, () => d(c), (k, $) => {
      $(k, {
        type: "template",
        get index() {
          return n();
        },
        get value() {
          return s();
        },
        get config() {
          return o();
        },
        get errors() {
          return d(S);
        },
        get buttons() {
          return d(O);
        },
        get uiOption() {
          return i();
        },
        children: (T, E) => {
          var M = I(), R = D(M);
          Q(R, () => d(f), (U, B) => {
            B(U, {
              type: "field",
              get config() {
                return o();
              },
              get uiOption() {
                return i();
              },
              get translate() {
                return a();
              },
              get value() {
                return s();
              },
              set value(F) {
                s(F);
              }
            });
          }), A(T, M);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, P), W(x);
}
K(
  Cb,
  {
    index: {},
    value: {},
    config: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
function rm(t, e, r) {
  let n = 0, s;
  do
    s = r(e, n++);
  while (s in t);
  return s;
}
function iA(t, e) {
  return e === 0 ? t : `${t}-${e}`;
}
function aA(t) {
  const e = [], r = Object.keys(t);
  for (const n of r) {
    const s = t[n];
    !er(s) || jl in s || e.push(n);
  }
  return e.length < r.length && e.push("*"), e;
}
const kb = /* @__PURE__ */ Symbol("object-context");
function $b() {
  return Es(kb);
}
function lA(t) {
  Po(kb, t);
}
function uA({ ctx: t, config: e, value: r, setValue: n, translate: s }) {
  const o = /* @__PURE__ */ C(() => $r(t, e().schema, r(), !0));
  let i;
  const a = /* @__PURE__ */ C(() => {
    const y = xo(d(o).properties);
    return TO(i, y) || (i = y), i;
  });
  Ze(() => {
    d(a), xC(t);
  });
  const l = (y) => It(t, e(), y), u = /* @__PURE__ */ C(() => Be(d(a)) ? UO(d(a), l("order") ?? aA(d(a))) : []), c = /* @__PURE__ */ C(() => new Set(d(o).required)), f = /* @__PURE__ */ C(() => {
    const { additionalProperties: y, patternProperties: S } = d(o);
    let x;
    if (S !== void 0 && (x = Object.keys(S), x.length > 0)) {
      const P = x.map((O) => {
        const k = S[O];
        return [
          new RegExp(O),
          typeof k == "boolean" ? {} : k
        ];
      }), w = Be(y) ? (O) => $r(t, y, O) : () => P[0][1];
      return (O, k) => $r(t, P.find(([$]) => $.test(k))?.[1] ?? w(O), O);
    }
    return Be(y) ? (P) => $r(t, y, P) : () => ({});
  }), p = /* @__PURE__ */ C(() => l("expandable") !== !1 && WO(d(o), r())), _ = /* @__PURE__ */ C(() => qt(t, e().path)), b = /* @__PURE__ */ C(() => s("additional-property", {}));
  function g(y) {
    Os(t, e().path, sl);
    const S = Yy(t);
    !(S & oC) || S & kd && !t.isSubmitted || Mn(t, e(), y);
  }
  const h = /* @__PURE__ */ C(() => l("additionalPropertyKey") ?? iA);
  return {
    errors() {
      return d(_);
    },
    canExpand() {
      return d(p);
    },
    propertiesOrder() {
      return d(u);
    },
    isAdditionalProperty(y) {
      return KO(d(a), y);
    },
    propertyConfig(y, S, x) {
      const P = d(a)[S] ?? !1, w = typeof P == "boolean" ? {} : $r(t, P, r()?.[S]), O = Gn(t, x ? y.uiSchema.additionalProperties : y.uiSchema[S]);
      return {
        path: Gl(t, y.path, S),
        title: Wr(t, O) ?? w.title ?? S,
        schema: w,
        uiSchema: O,
        required: d(c).has(S)
      };
    },
    addProperty() {
      let y = r();
      const S = y ? rm(y, d(b), d(h)) : d(h)(d(b), 0), x = d(f)(y, S), P = Dd(t, { schema: x, formData: void 0 }) ?? ky(ho(x));
      y ? y[S] = P : (y = { [S]: P }, n(y)), g(y);
    },
    removeProperty(y) {
      const S = r();
      S && (delete S[y], g(S));
    },
    renameProperty(y, S, x) {
      const P = r();
      if (!P)
        return;
      const w = rm(P, S, d(h));
      kC(t, e(), w, x) && (P[w] = P[y], delete P[y], g(P));
    }
  };
}
const cA = "objectField";
function Ab(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    {
      let P = /* @__PURE__ */ C(() => u.errors());
      Q(x, () => d(p), (w, O) => {
        O(w, {
          type: "object-property-add",
          get config() {
            return o();
          },
          get errors() {
            return d(P);
          },
          disabled: !1,
          get onclick() {
            return u.addProperty;
          },
          children: (k, $) => {
            vn(k, {
              get config() {
                return o();
              },
              id: "add-object-property",
              get translate() {
                return l();
              }
            });
          },
          $$slots: { default: !0 }
        });
      });
    }
    A(y, S);
  }, n = (y) => {
    var S = I(), x = D(S);
    {
      let P = /* @__PURE__ */ C(() => u.errors());
      te(
        x,
        () => d(_) ?? ge,
        () => s,
        o,
        () => ({
          get current() {
            return i();
          },
          set current(w) {
            i(w);
          }
        }),
        () => d(P)
      );
    }
    A(y, S);
  }, s = De();
  let o = v(e, "config", 7), i = v(e, "value", 15), a = v(e, "uiOption", 7), l = v(e, "translate", 7);
  const u = uA({
    ctx: s,
    config: () => o(),
    value: () => i(),
    setValue: (y) => i(y),
    translate: l()
  });
  lA(u);
  const c = /* @__PURE__ */ C(() => Le(s, "objectPropertyField", o())), f = /* @__PURE__ */ C(() => Le(s, "objectTemplate", o())), p = /* @__PURE__ */ C(() => Le(s, "button", o())), _ = /* @__PURE__ */ C(() => on(s, o(), cA));
  var b = {
    get config() {
      return o();
    },
    set config(y) {
      o(y), m();
    },
    get value() {
      return i();
    },
    set value(y) {
      i(y), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(y) {
      a(y), m();
    },
    get translate() {
      return l();
    },
    set translate(y) {
      l(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => u.errors()), S = /* @__PURE__ */ C(() => u.canExpand() ? r : void 0), x = /* @__PURE__ */ C(() => d(_) && n);
    Q(h, () => d(f), (P, w) => {
      w(P, {
        type: "template",
        get value() {
          return i();
        },
        get config() {
          return o();
        },
        get uiOption() {
          return a();
        },
        get errors() {
          return d(y);
        },
        get addButton() {
          return d(S);
        },
        get action() {
          return d(x);
        },
        children: (O, k) => {
          var $ = I(), T = D($);
          st(T, 16, () => u.propertiesOrder(), (E) => E, (E, M) => {
            const R = /* @__PURE__ */ C(() => u.isAdditionalProperty(M)), U = /* @__PURE__ */ C(() => u.propertyConfig(o(), M, d(R)));
            var B = I(), F = D(B), Z = () => i()?.[M], Y = (X) => {
              const ae = i();
              ae ? ae[M] = X : i({ [M]: X });
            };
            {
              let X = /* @__PURE__ */ C(() => Ms(s, d(U)));
              Q(F, () => d(c), (ae, J) => {
                J(ae, {
                  type: "field",
                  get property() {
                    return M;
                  },
                  get isAdditional() {
                    return d(R);
                  },
                  get value() {
                    return Z();
                  },
                  set value(j) {
                    Y(j);
                  },
                  get config() {
                    return d(U);
                  },
                  uiOption: (j) => It(s, d(U), j),
                  get translate() {
                    return d(X);
                  }
                });
              });
            }
            A(E, B);
          }), A(O, $);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Ab, { config: {}, value: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Eb(t, e) {
  H(e, !0);
  const r = v(e, "parent", 7), n = v(e, "property", 7), s = v(e, "uiSchema", 7), o = v(e, "translate", 7), i = De(), a = $b(), l = /* @__PURE__ */ C(() => ({
    path: Mi(i, r().path, "key-input"),
    title: Wr(i, s()) ?? o()("key-input-title", { name: n() }),
    schema: { type: "string" },
    uiSchema: s(),
    required: !0
  })), u = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", d(l))), c = "textWidget", f = /* @__PURE__ */ C(() => Le(i, c, d(l)));
  let p = /* @__PURE__ */ C(n);
  const _ = {
    onblur: () => {
      d(p) === void 0 || d(p) === n() || a.renameProperty(n(), d(p), d(l));
    }
  }, b = /* @__PURE__ */ C(() => qt(i, d(l).path)), g = (x) => It(i, d(l), x);
  var h = {
    get parent() {
      return r();
    },
    set parent(x) {
      r(x), m();
    },
    get property() {
      return n();
    },
    set property(x) {
      n(x), m();
    },
    get uiSchema() {
      return s();
    },
    set uiSchema(x) {
      s(x), m();
    },
    get translate() {
      return o();
    },
    set translate(x) {
      o(x), m();
    }
  }, y = I(), S = D(y);
  return Q(S, () => d(u), (x, P) => {
    P(x, {
      type: "template",
      showTitle: !0,
      useLabel: !0,
      widgetType: c,
      get value() {
        return n();
      },
      get config() {
        return d(l);
      },
      get errors() {
        return d(b);
      },
      uiOption: g,
      children: (w, O) => {
        var k = I(), $ = D(k);
        Q($, () => d(f), (T, E) => {
          E(T, {
            type: "widget",
            get errors() {
              return d(b);
            },
            get handlers() {
              return _;
            },
            get config() {
              return d(l);
            },
            uiOption: g,
            get value() {
              return d(p);
            },
            set value(M) {
              q(p, M);
            }
          });
        }), A(w, k);
      },
      $$slots: { default: !0 }
    });
  }), A(t, y), W(h);
}
K(Eb, { parent: {}, property: {}, uiSchema: {}, translate: {} }, [], [], { mode: "open" });
function Tb(t, e) {
  H(e, !0);
  const r = (x) => {
    {
      let P = /* @__PURE__ */ C(() => Gn(c, s().uiSchema.additionalPropertyKeyInput));
      Eb(x, {
        get translate() {
          return u();
        },
        get property() {
          return o();
        },
        get parent() {
          return s();
        },
        get uiSchema() {
          return d(P);
        }
      });
    }
  }, n = (x) => {
    var P = I(), w = D(P);
    Q(w, () => d(b), (O, k) => {
      k(O, {
        get errors() {
          return d(g);
        },
        get config() {
          return s();
        },
        type: "object-property-remove",
        disabled: !1,
        onclick: () => {
          f.removeProperty(o());
        },
        children: ($, T) => {
          vn($, {
            get config() {
              return s();
            },
            id: "remove-object-property",
            get translate() {
              return u();
            }
          });
        },
        $$slots: { default: !0 }
      });
    }), A(x, P);
  };
  let s = v(e, "config", 7), o = v(e, "property", 7), i = v(e, "isAdditional", 7), a = v(e, "value", 15), l = v(e, "uiOption", 7), u = v(e, "translate", 7);
  const c = De(), f = $b(), p = /* @__PURE__ */ C(() => Le(c, "objectPropertyTemplate", s())), _ = /* @__PURE__ */ C(() => vo(c, s())), b = /* @__PURE__ */ C(() => Le(c, "button", s())), g = /* @__PURE__ */ C(() => qt(c, s().path));
  var h = {
    get config() {
      return s();
    },
    set config(x) {
      s(x), m();
    },
    get property() {
      return o();
    },
    set property(x) {
      o(x), m();
    },
    get isAdditional() {
      return i();
    },
    set isAdditional(x) {
      i(x), m();
    },
    get value() {
      return a();
    },
    set value(x) {
      a(x), m();
    },
    get uiOption() {
      return l();
    },
    set uiOption(x) {
      l(x), m();
    },
    get translate() {
      return u();
    },
    set translate(x) {
      u(x), m();
    }
  }, y = I(), S = D(y);
  {
    let x = /* @__PURE__ */ C(() => i() ? r : void 0), P = /* @__PURE__ */ C(() => i() ? n : void 0);
    Q(S, () => d(p), (w, O) => {
      O(w, {
        type: "template",
        get property() {
          return o();
        },
        get value() {
          return a();
        },
        get config() {
          return s();
        },
        get errors() {
          return d(g);
        },
        get keyInput() {
          return d(x);
        },
        get removeButton() {
          return d(P);
        },
        get uiOption() {
          return l();
        },
        children: (k, $) => {
          var T = I(), E = D(T);
          Q(E, () => d(_), (M, R) => {
            R(M, {
              type: "field",
              get config() {
                return s();
              },
              get uiOption() {
                return l();
              },
              get translate() {
                return u();
              },
              get value() {
                return a();
              },
              set value(U) {
                a(U);
              }
            });
          }), A(k, T);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, y), W(h);
}
K(
  Tb,
  {
    config: {},
    property: {},
    isAdditional: {},
    value: {},
    uiOption: {},
    translate: {}
  },
  [],
  [],
  { mode: "open" }
);
function Fi(t, e) {
  H(e, !0);
  const r = (w) => {
    var O = I(), k = D(O);
    te(
      k,
      () => d(y) ?? ge,
      () => n,
      a,
      () => ({
        get current() {
          return i();
        },
        set current($) {
          i($);
        }
      }),
      () => d(h)
    ), A(w, O);
  }, n = De();
  let s = v(e, "field", 7), o = v(e, "widgetType", 7), i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "uiOption", 7), u = v(e, "fromValue", 7), c = v(e, "toValue", 7), f = v(e, "showTitle", 7), p = v(e, "useLabel", 7);
  const _ = /* @__PURE__ */ C(() => Le(n, "fieldTemplate", a())), b = /* @__PURE__ */ C(() => Le(n, o(), a())), g = qs(n, () => a(), () => Mn(n, a(), i())), h = /* @__PURE__ */ C(() => qt(n, a().path)), y = /* @__PURE__ */ C(() => on(n, a(), s()));
  var S = {
    get field() {
      return s();
    },
    set field(w) {
      s(w), m();
    },
    get widgetType() {
      return o();
    },
    set widgetType(w) {
      o(w), m();
    },
    get value() {
      return i();
    },
    set value(w) {
      i(w), m();
    },
    get config() {
      return a();
    },
    set config(w) {
      a(w), m();
    },
    get uiOption() {
      return l();
    },
    set uiOption(w) {
      l(w), m();
    },
    get fromValue() {
      return u();
    },
    set fromValue(w) {
      u(w), m();
    },
    get toValue() {
      return c();
    },
    set toValue(w) {
      c(w), m();
    },
    get showTitle() {
      return f();
    },
    set showTitle(w) {
      f(w), m();
    },
    get useLabel() {
      return p();
    },
    set useLabel(w) {
      p(w), m();
    }
  }, x = I(), P = D(x);
  {
    let w = /* @__PURE__ */ C(() => d(y) && r);
    Q(P, () => d(_), (O, k) => {
      k(O, {
        type: "template",
        get showTitle() {
          return f();
        },
        get useLabel() {
          return p();
        },
        get widgetType() {
          return o();
        },
        get uiOption() {
          return l();
        },
        get value() {
          return i();
        },
        get config() {
          return a();
        },
        get errors() {
          return d(h);
        },
        get action() {
          return d(w);
        },
        children: ($, T) => {
          var E = I(), M = D(E), R = () => u()(i()), U = (B) => i(c()(B));
          Q(M, () => d(b), (B, F) => {
            F(B, {
              type: "widget",
              get config() {
                return a();
              },
              get errors() {
                return d(h);
              },
              get uiOption() {
                return l();
              },
              get value() {
                return R();
              },
              set value(Z) {
                U(Z);
              },
              get handlers() {
                return g;
              }
            });
          }), A($, E);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, x), W(S);
}
K(
  Fi,
  {
    field: {},
    widgetType: {},
    value: {},
    config: {},
    uiOption: {},
    fromValue: {},
    toValue: {},
    showTitle: {},
    useLabel: {}
  },
  [],
  [],
  { mode: "open" }
);
const dA = "booleanField";
function Db(t, e) {
  H(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "uiOption", 7);
  var o = {
    get config() {
      return r();
    },
    set config(i) {
      r(i), m();
    },
    get value() {
      return n();
    },
    set value(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  {
    let i = /* @__PURE__ */ C(() => s()("hideTitle") === !1);
    Fi(t, {
      field: dA,
      get config() {
        return r();
      },
      get uiOption() {
        return s();
      },
      widgetType: "checkboxWidget",
      get showTitle() {
        return d(i);
      },
      useLabel: !0,
      fromValue: (a) => a ?? void 0,
      get toValue() {
        return rl;
      },
      get value() {
        return n();
      },
      set value(a) {
        n(a);
      }
    });
  }
  return W(o);
}
K(Db, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
const fA = "integerField";
function Mb(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  var o = {
    get value() {
      return r();
    },
    set value(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(l) {
      s(l), m();
    }
  }, i = () => r(), a = (l) => {
    Number.isInteger(l) ? r(l) : l === void 0 && r(s()("numberEmptyValue"));
  };
  return Fi(t, {
    field: fA,
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "numberWidget",
    get value() {
      return i();
    },
    set value(l) {
      a(l);
    },
    fromValue: (l) => l ?? void 0,
    get toValue() {
      return rl;
    }
  }), W(o);
}
K(Mb, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
function Ib(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  Ze(() => {
    r() === void 0 && r(null);
  });
  const o = De(), i = /* @__PURE__ */ C(() => Le(o, "fieldTemplate", n())), a = /* @__PURE__ */ C(() => qt(o, n().path));
  var l = {
    get value() {
      return r();
    },
    set value(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(f) {
      s(f), m();
    }
  }, u = I(), c = D(u);
  return Q(c, () => d(i), (f, p) => {
    p(f, {
      type: "template",
      showTitle: !0,
      useLabel: !1,
      widgetType: "nullField",
      get uiOption() {
        return s();
      },
      get errors() {
        return d(a);
      },
      get value() {
        return r();
      },
      get config() {
        return n();
      },
      children: (_, b) => {
        vt();
        var g = tt();
        g.nodeValue = "", A(_, g);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), W(l);
}
K(Ib, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
const hA = "numberField";
function Nb(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7);
  var o = {
    get value() {
      return r();
    },
    set value(i) {
      r(i), m();
    },
    get config() {
      return n();
    },
    set config(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  return Fi(t, {
    field: hA,
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "numberWidget",
    fromValue: (i) => i ?? void 0,
    toValue: (i) => i ?? s()("numberEmptyValue"),
    get value() {
      return r();
    },
    set value(i) {
      r(i);
    }
  }), W(o);
}
K(Nb, { value: {}, config: {}, uiOption: {} }, [], [], { mode: "open" });
const gA = "stringField";
function Fb(t, e) {
  H(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "uiOption", 7);
  var o = {
    get config() {
      return r();
    },
    set config(i) {
      r(i), m();
    },
    get value() {
      return n();
    },
    set value(i) {
      n(i), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(i) {
      s(i), m();
    }
  };
  return Fi(t, {
    field: gA,
    get config() {
      return r();
    },
    get uiOption() {
      return s();
    },
    showTitle: !0,
    useLabel: !0,
    widgetType: "textWidget",
    fromValue: (i) => i ?? void 0,
    toValue: (i) => i || s()("stringEmptyValue"),
    get value() {
      return n();
    },
    set value(i) {
      n(i);
    }
  }), W(o);
}
K(Fb, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function Rb(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7);
  var i = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return Bd(t, {
    type: "field",
    get config() {
      return n();
    },
    get uiOption() {
      return s();
    },
    get translate() {
      return o();
    },
    get combinationKey() {
      return ro;
    },
    get value() {
      return r();
    },
    set value(a) {
      r(a);
    }
  }), W(i);
}
K(Rb, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
function Vb(t, e) {
  H(e, !0);
  let r = v(e, "config", 7), n = v(e, "uiOption", 7), s = v(e, "value", 15), o = v(e, "translate", 7);
  var i = {
    get config() {
      return r();
    },
    set config(a) {
      r(a), m();
    },
    get uiOption() {
      return n();
    },
    set uiOption(a) {
      n(a), m();
    },
    get value() {
      return s();
    },
    set value(a) {
      s(a), m();
    },
    get translate() {
      return o();
    },
    set translate(a) {
      o(a), m();
    }
  };
  return Bd(t, {
    type: "field",
    get config() {
      return r();
    },
    get uiOption() {
      return n();
    },
    get translate() {
      return o();
    },
    get combinationKey() {
      return no;
    },
    get value() {
      return s();
    },
    set value(a) {
      s(a);
    }
  }), W(i);
}
K(Vb, { config: {}, uiOption: {}, value: {}, translate: {} }, [], [], { mode: "open" });
function Lb(t, e) {
  H(e, !0);
  const r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "translate", 7), i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = /* @__PURE__ */ C(() => qt(i, n().path));
  var u = {
    get value() {
      return r();
    },
    set value(p) {
      r(p), m();
    },
    get config() {
      return n();
    },
    set config(p) {
      n(p), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(p) {
      s(p), m();
    },
    get translate() {
      return o();
    },
    set translate(p) {
      o(p), m();
    }
  }, c = I(), f = D(c);
  return Q(f, () => d(a), (p, _) => {
    _(p, {
      type: "template",
      showTitle: !0,
      useLabel: !1,
      widgetType: "unknownField",
      get uiOption() {
        return s();
      },
      get errors() {
        return d(l);
      },
      get config() {
        return n();
      },
      value: void 0,
      children: (b, g) => {
        {
          let h = /* @__PURE__ */ C(() => o()("unknown-field-error", { schema: n().schema }));
          Id(b, {
            get message() {
              return d(h);
            }
          });
        }
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), W(u);
}
K(Lb, { value: {}, config: {}, uiOption: {}, translate: {} }, [], [], { mode: "open" });
const pA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anyOfField: Rb,
  arrayField: Pb,
  arrayItemField: Cb,
  booleanField: Db,
  integerField: Mb,
  nullField: Ib,
  numberField: Nb,
  objectField: Ab,
  objectPropertyField: Tb,
  oneOfField: Vb,
  stringField: Fb,
  tupleField: Ob,
  unknownField: Lb
}, Symbol.toStringTag, { value: "Module" }));
function qd(t, e) {
  return {
    title: e.title,
    showMeta: t("hideTitle") !== !0,
    description: t("description") ?? e.schema.description
  };
}
var mA = /* @__PURE__ */ ne("<!> <!>", 1), vA = /* @__PURE__ */ ne("<!> <!>", 1), yA = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function jb(t, e) {
  H(e, !0);
  const r = "fieldTemplate", n = v(e, "children", 7), s = v(e, "config", 7), o = v(e, "uiOption", 7), i = v(e, "showTitle", 7), a = v(e, "useLabel", 7), l = v(e, "errors", 7), u = v(e, "action", 7), c = De(), f = /* @__PURE__ */ C(() => Le(c, "layout", s())), p = /* @__PURE__ */ C(() => Le(c, o()("useLabel") ?? a() ? "label" : "title", s())), _ = /* @__PURE__ */ C(() => Le(c, "description", s())), b = /* @__PURE__ */ C(() => Le(c, "errorsList", s())), g = /* @__PURE__ */ C(() => Le(c, "help", s())), h = /* @__PURE__ */ C(() => qd(o(), s())), y = /* @__PURE__ */ C(() => d(h).title), S = /* @__PURE__ */ C(() => d(h).description), x = /* @__PURE__ */ C(() => d(h).showMeta), P = /* @__PURE__ */ C(() => o()("help"));
  var w = {
    get children() {
      return n();
    },
    set children($) {
      n($), m();
    },
    get config() {
      return s();
    },
    set config($) {
      s($), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption($) {
      o($), m();
    },
    get showTitle() {
      return i();
    },
    set showTitle($) {
      i($), m();
    },
    get useLabel() {
      return a();
    },
    set useLabel($) {
      a($), m();
    },
    get errors() {
      return l();
    },
    set errors($) {
      l($), m();
    },
    get action() {
      return u();
    },
    set action($) {
      u($), m();
    }
  }, O = I(), k = D(O);
  return Q(k, () => d(f), ($, T) => {
    T($, {
      type: "field",
      get config() {
        return s();
      },
      get errors() {
        return l();
      },
      children: (E, M) => {
        var R = yA(), U = D(R);
        {
          var B = (J) => {
            var j = I(), ee = D(j);
            Q(ee, () => d(f), (L, N) => {
              N(L, {
                type: "field-meta",
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                },
                children: (V, G) => {
                  var fe = vA(), se = D(fe);
                  {
                    var we = (oe) => {
                      var pe = I(), ye = D(pe);
                      Q(ye, () => d(f), (Pe, Oe) => {
                        Oe(Pe, {
                          type: "field-title-row",
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          },
                          children: (Re, Ke) => {
                            var Ve = mA(), je = D(Ve);
                            Q(je, () => d(p), (gt, Je) => {
                              Je(gt, {
                                templateType: r,
                                get title() {
                                  return d(y);
                                },
                                get config() {
                                  return s();
                                },
                                get errors() {
                                  return l();
                                }
                              });
                            });
                            var He = be(je, 2);
                            te(He, () => u() ?? ge), A(Re, Ve);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(oe, pe);
                    };
                    ue(se, (oe) => {
                      i() && d(y) && oe(we);
                    });
                  }
                  var le = be(se, 2);
                  {
                    var re = (oe) => {
                      var pe = I(), ye = D(pe);
                      Q(ye, () => d(_), (Pe, Oe) => {
                        Oe(Pe, {
                          templateType: r,
                          get description() {
                            return d(S);
                          },
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          }
                        });
                      }), A(oe, pe);
                    };
                    ue(le, (oe) => {
                      d(S) && oe(re);
                    });
                  }
                  A(V, fe);
                },
                $$slots: { default: !0 }
              });
            }), A(J, j);
          };
          ue(U, (J) => {
            d(x) && (i() && d(y) || d(S)) && J(B);
          });
        }
        var F = be(U, 2);
        Q(F, () => d(f), (J, j) => {
          j(J, {
            type: "field-content",
            get config() {
              return s();
            },
            get errors() {
              return l();
            },
            children: (ee, L) => {
              var N = I(), V = D(N);
              te(V, n), A(ee, N);
            },
            $$slots: { default: !0 }
          });
        });
        var Z = be(F, 2);
        {
          var Y = (J) => {
            var j = I(), ee = D(j);
            Q(ee, () => d(b), (L, N) => {
              N(L, {
                get errors() {
                  return l();
                },
                get config() {
                  return s();
                }
              });
            }), A(J, j);
          };
          ue(Z, (J) => {
            l().length > 0 && J(Y);
          });
        }
        var X = be(Z, 2);
        {
          var ae = (J) => {
            var j = I(), ee = D(j);
            Q(ee, () => d(g), (L, N) => {
              N(L, {
                get help() {
                  return d(P);
                },
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                }
              });
            }), A(J, j);
          };
          ue(X, (J) => {
            d(P) !== void 0 && J(ae);
          });
        }
        A(E, R);
      },
      $$slots: { default: !0 }
    });
  }), A(t, O), W(w);
}
K(
  jb,
  {
    children: {},
    config: {},
    uiOption: {},
    showTitle: {},
    useLabel: {},
    errors: {},
    action: {}
  },
  [],
  [],
  { mode: "open" }
);
var bA = /* @__PURE__ */ ne("<!> <!>", 1), _A = /* @__PURE__ */ ne("<!> <!>", 1), wA = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function Bb(t, e) {
  H(e, !0);
  const r = De(), n = "objectTemplate", s = v(e, "config", 7), o = v(e, "children", 7), i = v(e, "addButton", 7), a = v(e, "action", 7), l = v(e, "errors", 7), u = v(e, "uiOption", 7), c = /* @__PURE__ */ C(() => Le(r, "layout", s())), f = /* @__PURE__ */ C(() => Le(r, "title", s())), p = /* @__PURE__ */ C(() => Le(r, "description", s())), _ = /* @__PURE__ */ C(() => Le(r, "errorsList", s())), b = /* @__PURE__ */ C(() => qd(u(), s())), g = /* @__PURE__ */ C(() => d(b).title), h = /* @__PURE__ */ C(() => d(b).description), y = /* @__PURE__ */ C(() => d(b).showMeta);
  var S = {
    get config() {
      return s();
    },
    set config(w) {
      s(w), m();
    },
    get children() {
      return o();
    },
    set children(w) {
      o(w), m();
    },
    get addButton() {
      return i();
    },
    set addButton(w) {
      i(w), m();
    },
    get action() {
      return a();
    },
    set action(w) {
      a(w), m();
    },
    get errors() {
      return l();
    },
    set errors(w) {
      l(w), m();
    },
    get uiOption() {
      return u();
    },
    set uiOption(w) {
      u(w), m();
    }
  }, x = I(), P = D(x);
  return Q(P, () => d(c), (w, O) => {
    O(w, {
      type: "object-field",
      get config() {
        return s();
      },
      get errors() {
        return l();
      },
      children: (k, $) => {
        var T = wA(), E = D(T);
        {
          var M = (Z) => {
            var Y = I(), X = D(Y);
            Q(X, () => d(c), (ae, J) => {
              J(ae, {
                type: "object-field-meta",
                get config() {
                  return s();
                },
                get errors() {
                  return l();
                },
                children: (j, ee) => {
                  var L = _A(), N = D(L);
                  {
                    var V = (se) => {
                      var we = I(), le = D(we);
                      Q(le, () => d(c), (re, oe) => {
                        oe(re, {
                          type: "object-field-title-row",
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          },
                          children: (pe, ye) => {
                            var Pe = bA(), Oe = D(Pe);
                            Q(Oe, () => d(f), (Ke, Ve) => {
                              Ve(Ke, {
                                templateType: n,
                                get title() {
                                  return d(g);
                                },
                                get config() {
                                  return s();
                                },
                                get errors() {
                                  return l();
                                }
                              });
                            });
                            var Re = be(Oe, 2);
                            te(Re, () => a() ?? ge), A(pe, Pe);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(se, we);
                    };
                    ue(N, (se) => {
                      d(g) && se(V);
                    });
                  }
                  var G = be(N, 2);
                  {
                    var fe = (se) => {
                      var we = I(), le = D(we);
                      Q(le, () => d(p), (re, oe) => {
                        oe(re, {
                          templateType: n,
                          get description() {
                            return d(h);
                          },
                          get config() {
                            return s();
                          },
                          get errors() {
                            return l();
                          }
                        });
                      }), A(se, we);
                    };
                    ue(G, (se) => {
                      d(h) && se(fe);
                    });
                  }
                  A(j, L);
                },
                $$slots: { default: !0 }
              });
            }), A(Z, Y);
          };
          ue(E, (Z) => {
            d(y) && (d(g) || d(h)) && Z(M);
          });
        }
        var R = be(E, 2);
        Q(R, () => d(c), (Z, Y) => {
          Y(Z, {
            type: "object-properties",
            get config() {
              return s();
            },
            get errors() {
              return l();
            },
            children: (X, ae) => {
              var J = I(), j = D(J);
              te(j, o), A(X, J);
            },
            $$slots: { default: !0 }
          });
        });
        var U = be(R, 2);
        te(U, () => i() ?? ge);
        var B = be(U, 2);
        {
          var F = (Z) => {
            var Y = I(), X = D(Y);
            Q(X, () => d(_), (ae, J) => {
              J(ae, {
                get errors() {
                  return l();
                },
                get config() {
                  return s();
                }
              });
            }), A(Z, Y);
          };
          ue(B, (Z) => {
            l().length > 0 && Z(F);
          });
        }
        A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), W(S);
}
K(
  Bb,
  {
    config: {},
    children: {},
    addButton: {},
    action: {},
    errors: {},
    uiOption: {}
  },
  [],
  [],
  { mode: "open" }
);
var SA = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function zb(t, e) {
  H(e, !0);
  const r = v(e, "children", 7), n = v(e, "keyInput", 7), s = v(e, "removeButton", 7), o = v(e, "config", 7), i = v(e, "errors", 7), a = De(), l = /* @__PURE__ */ C(() => Le(a, "layout", o()));
  var u = {
    get children() {
      return r();
    },
    set children(p) {
      r(p), m();
    },
    get keyInput() {
      return n();
    },
    set keyInput(p) {
      n(p), m();
    },
    get removeButton() {
      return s();
    },
    set removeButton(p) {
      s(p), m();
    },
    get config() {
      return o();
    },
    set config(p) {
      o(p), m();
    },
    get errors() {
      return i();
    },
    set errors(p) {
      i(p), m();
    }
  }, c = I(), f = D(c);
  return Q(f, () => d(l), (p, _) => {
    _(p, {
      type: "object-property",
      get config() {
        return o();
      },
      get errors() {
        return i();
      },
      children: (b, g) => {
        var h = SA(), y = D(h);
        {
          var S = (O) => {
            var k = I(), $ = D(k);
            Q($, () => d(l), (T, E) => {
              E(T, {
                type: "object-property-key-input",
                get config() {
                  return o();
                },
                get errors() {
                  return i();
                },
                children: (M, R) => {
                  var U = I(), B = D(U);
                  te(B, n), A(M, U);
                },
                $$slots: { default: !0 }
              });
            }), A(O, k);
          };
          ue(y, (O) => {
            n() && O(S);
          });
        }
        var x = be(y, 2);
        Q(x, () => d(l), (O, k) => {
          k(O, {
            type: "object-property-content",
            get config() {
              return o();
            },
            get errors() {
              return i();
            },
            children: ($, T) => {
              var E = I(), M = D(E);
              te(M, r), A($, E);
            },
            $$slots: { default: !0 }
          });
        });
        var P = be(x, 2);
        {
          var w = (O) => {
            var k = I(), $ = D(k);
            Q($, () => d(l), (T, E) => {
              E(T, {
                type: "object-property-controls",
                get config() {
                  return o();
                },
                get errors() {
                  return i();
                },
                children: (M, R) => {
                  var U = I(), B = D(U);
                  te(B, s), A(M, U);
                },
                $$slots: { default: !0 }
              });
            }), A(O, k);
          };
          ue(P, (O) => {
            s() && O(w);
          });
        }
        A(b, h);
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), W(u);
}
K(
  zb,
  {
    children: {},
    keyInput: {},
    removeButton: {},
    config: {},
    errors: {}
  },
  [],
  [],
  { mode: "open" }
);
var xA = /* @__PURE__ */ ne("<!> <!>", 1), PA = /* @__PURE__ */ ne("<!> <!>", 1), OA = /* @__PURE__ */ ne("<!> <!> <!> <!>", 1);
function qb(t, e) {
  H(e, !0);
  const r = De(), n = "arrayTemplate", s = v(e, "children", 7), o = v(e, "addButton", 7), i = v(e, "action", 7), a = v(e, "uiOption", 7), l = v(e, "config", 7), u = v(e, "errors", 7), c = /* @__PURE__ */ C(() => Le(r, "layout", l())), f = /* @__PURE__ */ C(() => Le(r, "title", l())), p = /* @__PURE__ */ C(() => Le(r, "description", l())), _ = /* @__PURE__ */ C(() => Le(r, "errorsList", l())), b = /* @__PURE__ */ C(() => qd(a(), l())), g = /* @__PURE__ */ C(() => d(b).title), h = /* @__PURE__ */ C(() => d(b).description), y = /* @__PURE__ */ C(() => d(b).showMeta);
  var S = {
    get children() {
      return s();
    },
    set children(w) {
      s(w), m();
    },
    get addButton() {
      return o();
    },
    set addButton(w) {
      o(w), m();
    },
    get action() {
      return i();
    },
    set action(w) {
      i(w), m();
    },
    get uiOption() {
      return a();
    },
    set uiOption(w) {
      a(w), m();
    },
    get config() {
      return l();
    },
    set config(w) {
      l(w), m();
    },
    get errors() {
      return u();
    },
    set errors(w) {
      u(w), m();
    }
  }, x = I(), P = D(x);
  return Q(P, () => d(c), (w, O) => {
    O(w, {
      type: "array-field",
      get config() {
        return l();
      },
      get errors() {
        return u();
      },
      children: (k, $) => {
        var T = OA(), E = D(T);
        {
          var M = (Z) => {
            var Y = I(), X = D(Y);
            Q(X, () => d(c), (ae, J) => {
              J(ae, {
                type: "array-field-meta",
                get config() {
                  return l();
                },
                get errors() {
                  return u();
                },
                children: (j, ee) => {
                  var L = PA(), N = D(L);
                  {
                    var V = (se) => {
                      var we = I(), le = D(we);
                      Q(le, () => d(c), (re, oe) => {
                        oe(re, {
                          type: "array-field-title-row",
                          get config() {
                            return l();
                          },
                          get errors() {
                            return u();
                          },
                          children: (pe, ye) => {
                            var Pe = xA(), Oe = D(Pe);
                            Q(Oe, () => d(f), (Ke, Ve) => {
                              Ve(Ke, {
                                templateType: n,
                                get title() {
                                  return d(g);
                                },
                                get config() {
                                  return l();
                                },
                                get errors() {
                                  return u();
                                }
                              });
                            });
                            var Re = be(Oe, 2);
                            te(Re, () => i() ?? ge), A(pe, Pe);
                          },
                          $$slots: { default: !0 }
                        });
                      }), A(se, we);
                    };
                    ue(N, (se) => {
                      d(g) && se(V);
                    });
                  }
                  var G = be(N, 2);
                  {
                    var fe = (se) => {
                      var we = I(), le = D(we);
                      Q(le, () => d(p), (re, oe) => {
                        oe(re, {
                          templateType: n,
                          get description() {
                            return d(h);
                          },
                          get config() {
                            return l();
                          },
                          get errors() {
                            return u();
                          }
                        });
                      }), A(se, we);
                    };
                    ue(G, (se) => {
                      d(h) && se(fe);
                    });
                  }
                  A(j, L);
                },
                $$slots: { default: !0 }
              });
            }), A(Z, Y);
          };
          ue(E, (Z) => {
            d(y) && (d(g) || d(h)) && Z(M);
          });
        }
        var R = be(E, 2);
        Q(R, () => d(c), (Z, Y) => {
          Y(Z, {
            type: "array-items",
            get config() {
              return l();
            },
            get errors() {
              return u();
            },
            children: (X, ae) => {
              var J = I(), j = D(J);
              te(j, s), A(X, J);
            },
            $$slots: { default: !0 }
          });
        });
        var U = be(R, 2);
        te(U, () => o() ?? ge);
        var B = be(U, 2);
        {
          var F = (Z) => {
            var Y = I(), X = D(Y);
            Q(X, () => d(_), (ae, J) => {
              J(ae, {
                get errors() {
                  return u();
                },
                get config() {
                  return l();
                }
              });
            }), A(Z, Y);
          };
          ue(B, (Z) => {
            u().length > 0 && Z(F);
          });
        }
        A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), W(S);
}
K(
  qb,
  {
    children: {},
    addButton: {},
    action: {},
    uiOption: {},
    config: {},
    errors: {}
  },
  [],
  [],
  { mode: "open" }
);
var CA = /* @__PURE__ */ ne("<!> <!>", 1);
function Ub(t, e) {
  H(e, !0);
  const r = v(e, "children", 7), n = v(e, "buttons", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = De(), a = /* @__PURE__ */ C(() => Le(i, "layout", s()));
  var l = {
    get children() {
      return r();
    },
    set children(f) {
      r(f), m();
    },
    get buttons() {
      return n();
    },
    set buttons(f) {
      n(f), m();
    },
    get config() {
      return s();
    },
    set config(f) {
      s(f), m();
    },
    get errors() {
      return o();
    },
    set errors(f) {
      o(f), m();
    }
  }, u = I(), c = D(u);
  return Q(c, () => d(a), (f, p) => {
    p(f, {
      type: "array-item",
      get config() {
        return s();
      },
      get errors() {
        return o();
      },
      children: (_, b) => {
        var g = CA(), h = D(g);
        Q(h, () => d(a), (x, P) => {
          P(x, {
            type: "array-item-content",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, O) => {
              var k = I(), $ = D(k);
              te($, r), A(w, k);
            },
            $$slots: { default: !0 }
          });
        });
        var y = be(h, 2);
        {
          var S = (x) => {
            var P = I(), w = D(P);
            Q(w, () => d(a), (O, k) => {
              k(O, {
                type: "array-item-controls",
                get config() {
                  return s();
                },
                get errors() {
                  return o();
                },
                children: ($, T) => {
                  var E = I(), M = D(E);
                  te(M, n), A($, E);
                },
                $$slots: { default: !0 }
              });
            }), A(x, P);
          };
          ue(y, (x) => {
            n() && x(S);
          });
        }
        A(_, g);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), W(l);
}
K(Ub, { children: {}, buttons: {}, config: {}, errors: {} }, [], [], { mode: "open" });
var kA = /* @__PURE__ */ ne("<!> <!>", 1), $A = /* @__PURE__ */ ne("<!> <!>", 1);
function Kb(t, e) {
  H(e, !0);
  const r = v(e, "children", 7), n = v(e, "optionSelector", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = v(e, "action", 7), a = De(), l = /* @__PURE__ */ C(() => Le(a, "layout", s()));
  var u = {
    get children() {
      return r();
    },
    set children(p) {
      r(p), m();
    },
    get optionSelector() {
      return n();
    },
    set optionSelector(p) {
      n(p), m();
    },
    get config() {
      return s();
    },
    set config(p) {
      s(p), m();
    },
    get errors() {
      return o();
    },
    set errors(p) {
      o(p), m();
    },
    get action() {
      return i();
    },
    set action(p) {
      i(p), m();
    }
  }, c = I(), f = D(c);
  return Q(f, () => d(l), (p, _) => {
    _(p, {
      type: "multi-field",
      get config() {
        return s();
      },
      get errors() {
        return o();
      },
      children: (b, g) => {
        var h = $A(), y = D(h);
        Q(y, () => d(l), (x, P) => {
          P(x, {
            type: "multi-field-controls",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, O) => {
              var k = kA(), $ = D(k);
              te($, n);
              var T = be($, 2);
              te(T, () => i() ?? ge), A(w, k);
            },
            $$slots: { default: !0 }
          });
        });
        var S = be(y, 2);
        Q(S, () => d(l), (x, P) => {
          P(x, {
            type: "multi-field-content",
            get config() {
              return s();
            },
            get errors() {
              return o();
            },
            children: (w, O) => {
              var k = I(), $ = D(k);
              te($, r), A(w, k);
            },
            $$slots: { default: !0 }
          });
        }), A(b, h);
      },
      $$slots: { default: !0 }
    });
  }), A(t, c), W(u);
}
K(
  Kb,
  {
    children: {},
    optionSelector: {},
    config: {},
    errors: {},
    action: {}
  },
  [],
  [],
  { mode: "open" }
);
const AA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayItemTemplate: Ub,
  arrayTemplate: qb,
  fieldTemplate: jb,
  multiFieldTemplate: Kb,
  objectPropertyTemplate: zb,
  objectTemplate: Bb
}, Symbol.toStringTag, { value: "Module" })), In = Object.assign({}, pA, AA);
function EA(t, e) {
  return (r) => {
    const n = r?.findIndex((s) => s === void 0 || !e(s)) ?? -1;
    if (n >= 0) {
      const s = r[n];
      throw new TypeError(`Expected array of "${t}" or "undefined", but got (${typeof s}: ${JSON.stringify(s)})`);
    }
  };
}
const TA = EA("File", (t) => t instanceof File);
function DA(t) {
  if (t !== void 0 && !(t instanceof File))
    throw new Error(`expected "File" or "undefined", but got (${typeof t}: ${JSON.stringify(t)})`);
}
const MA = "nativeFilesField";
function Ud(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    te(
      x,
      () => d(_) ?? ge,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(f)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ C(() => Le(i, l, n())), c = qs(i, () => n(), () => Mn(i, n(), s())), f = /* @__PURE__ */ C(() => qt(i, n().path)), p = yo({
    combinator: yi,
    async execute(y, S) {
      if (S === void 0)
        return;
      const x = Array.from(S);
      if (!await Yl(y, i, n(), S))
        throw new Ul();
      return x;
    },
    onSuccess(y) {
      s(y);
    }
  }), _ = /* @__PURE__ */ C(() => on(i, n(), MA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(f);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var O = I(), k = D(O), $ = () => {
            const E = s(), M = new DataTransfer();
            if (E)
              for (const R of E)
                M.items.add(R);
            return M.files;
          }, T = p.run;
          Q(k, () => d(u), (E, M) => {
            M(E, {
              type: "widget",
              get value() {
                return $();
              },
              set value(R) {
                T(R);
              },
              get processing() {
                return p.isProcessed;
              },
              loading: !1,
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(f);
              },
              get config() {
                return n();
              },
              multiple: !0
            });
          }), A(P, O);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Ud, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
function Hb(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (TA(r()), r()), i = (a) => {
    r(a);
  };
  return Ud(t, ce(() => n, {
    get value() {
      return o();
    },
    set value(a) {
      i(a);
    }
  })), W(s);
}
K(Hb, { value: {} }, [], [], { mode: "open" });
In.arrayNativeFilesField = Hb;
function IA(t, e) {
  return t.anyOf ? [t.anyOf, e.anyOf] : [t.oneOf, e.oneOf];
}
function Wb(t, e, r, n) {
  const s = n.enum, o = new Set(r("disabledEnumValues"));
  if (s) {
    const l = r("enumNames");
    return s.map((u, c) => {
      const f = l?.[c] ?? Tg(u);
      return {
        id: mo(t, e.path, c),
        label: f,
        value: u,
        disabled: o.has(u)
      };
    });
  }
  const [i, a] = IA(n, e.uiSchema);
  return i && i.map((l, u) => {
    if (typeof l == "boolean")
      throw new Error(`Invalid enum definition in anyOf ${u}`);
    const c = xy(l), f = Gn(t, a?.[u])["ui:options"]?.title ?? l.title ?? Tg(c);
    return {
      id: mo(t, e.path, u),
      schema: l,
      label: f,
      value: c,
      disabled: o.has(c)
    };
  });
}
const NA = "enumField";
function Gb(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    te(
      x,
      () => d(_) ?? ge,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(p)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = "selectWidget", u = /* @__PURE__ */ C(() => Le(i, l, n())), c = qs(i, () => n(), () => Mn(i, n(), s())), f = /* @__PURE__ */ C(() => Wb(i, n(), o(), n().schema) ?? []), p = /* @__PURE__ */ C(() => qt(i, n().path)), _ = /* @__PURE__ */ C(() => on(i, n(), NA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(p);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var O = I(), k = D(O);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get handlers() {
                return c;
              },
              get config() {
                return n();
              },
              get errors() {
                return d(p);
              },
              get uiOption() {
                return o();
              },
              get options() {
                return d(f);
              },
              get value() {
                return s();
              },
              set value(E) {
                s(E);
              }
            });
          }), A(P, O);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Gb, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
In.enumField = Gb;
const FA = "fileField";
function Yb(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    te(
      x,
      () => d(_) ?? ge,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(p)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ C(() => Le(i, l, n())), c = qs(i, () => n(), () => Mn(i, n(), s())), f = sb({
    initialOutput: void 0,
    getInput: () => s(),
    setInput: (y) => s(y),
    async toOutput(y, S) {
      const x = new DataTransfer();
      return S && await nb(i, y, x, S), x.files;
    },
    async toInput(y, S) {
      if (S === void 0 || S.length === 0)
        return;
      const x = S[0];
      if (!await Yl(y, i, n(), S))
        throw new Ul();
      return ob(y, x);
    }
  }), p = /* @__PURE__ */ C(() => qt(i, n().path)), _ = /* @__PURE__ */ C(() => on(i, n(), FA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(p);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var O = I(), k = D(O);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get processing() {
                return f.inputProcessing;
              },
              get loading() {
                return f.outputProcessing;
              },
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(p);
              },
              get config() {
                return n();
              },
              multiple: !1,
              get value() {
                return f.current;
              },
              set value(E) {
                f.current = E;
              }
            });
          }), A(P, O);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Yb, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
In.fileField = Yb;
const RA = "filesField";
function Xb(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    te(
      x,
      () => d(_) ?? ge,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(p)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ C(() => Le(i, l, n())), c = qs(i, () => n(), () => Mn(i, n(), s())), f = sb({
    initialOutput: void 0,
    getInput: () => s(),
    setInput: (y) => s(y),
    isEqual: (y, S) => y === void 0 && S === void 0 || Array.isArray(y) && Array.isArray(S) && y.length === S.length && y.every((x, P) => x === S[P]),
    async toOutput(y, S) {
      const x = new DataTransfer();
      return S && await qC(i, y, x, S), x.files;
    },
    async toInput(y, S) {
      if (S === void 0)
        return;
      const x = Array.from(S);
      if (!await Yl(y, i, n(), S))
        throw new Ul();
      return Promise.all(x.map((P) => ob(y, P)));
    }
  }), p = /* @__PURE__ */ C(() => qt(i, n().path)), _ = /* @__PURE__ */ C(() => on(i, n(), RA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(p);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var O = I(), k = D(O);
          Q(k, () => d(u), ($, T) => {
            T($, {
              type: "widget",
              get processing() {
                return f.inputProcessing;
              },
              get loading() {
                return f.outputProcessing;
              },
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(p);
              },
              get config() {
                return n();
              },
              multiple: !0,
              get value() {
                return f.current;
              },
              set value(E) {
                f.current = E;
              }
            });
          }), A(P, O);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Xb, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
In.filesField = Xb;
const VA = "multiEnumField";
function Jb(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    te(
      x,
      () => d(_) ?? ge,
      () => i,
      n,
      () => ({
        get current() {
          return o();
        },
        set current(P) {
          o(P);
        }
      }),
      () => d(p)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "uiOption", 7), o = v(e, "value", 15);
  const i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = "checkboxesWidget", u = /* @__PURE__ */ C(() => Le(i, l, n())), c = qs(i, () => n(), () => Mn(i, n(), o())), f = /* @__PURE__ */ C(() => {
    const { items: y } = n().schema, S = Be(y) ? y : {};
    return Wb(i, n(), s(), S) ?? [];
  }), p = /* @__PURE__ */ C(() => qt(i, n().path)), _ = /* @__PURE__ */ C(() => on(i, n(), VA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get uiOption() {
      return s();
    },
    set uiOption(y) {
      s(y), m();
    },
    get value() {
      return o();
    },
    set value(y) {
      o(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !1,
        get uiOption() {
          return s();
        },
        widgetType: l,
        get value() {
          return o();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(p);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var O = I(), k = D(O), $ = () => o() ?? void 0, T = (E) => o(E);
          Q(k, () => d(u), (E, M) => {
            M(E, {
              type: "widget",
              get handlers() {
                return c;
              },
              get config() {
                return n();
              },
              get errors() {
                return d(p);
              },
              get value() {
                return $();
              },
              set value(R) {
                T(R);
              },
              get options() {
                return d(f);
              },
              get uiOption() {
                return s();
              }
            });
          }), A(P, O);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Jb, { config: {}, uiOption: {}, value: {} }, [], [], { mode: "open" });
In.multiEnumField = Jb;
const LA = "nativeFileField";
function Kd(t, e) {
  H(e, !0);
  const r = (y) => {
    var S = I(), x = D(S);
    te(
      x,
      () => d(_) ?? ge,
      () => i,
      n,
      () => ({
        get current() {
          return s();
        },
        set current(P) {
          s(P);
        }
      }),
      () => d(f)
    ), A(y, S);
  };
  let n = v(e, "config", 7), s = v(e, "value", 15), o = v(e, "uiOption", 7);
  const i = De(), a = /* @__PURE__ */ C(() => Le(i, "fieldTemplate", n())), l = "fileWidget", u = /* @__PURE__ */ C(() => Le(i, l, n())), c = qs(i, () => n(), () => Mn(i, n(), s())), f = /* @__PURE__ */ C(() => qt(i, n().path)), p = yo({
    combinator: yi,
    async execute(y, S) {
      if (S === void 0 || S.length === 0)
        return;
      const x = S[0];
      if (!await Yl(y, i, n(), S))
        throw new Ul();
      return x;
    },
    onSuccess(y) {
      s(y);
    }
  }), _ = /* @__PURE__ */ C(() => on(i, n(), LA));
  var b = {
    get config() {
      return n();
    },
    set config(y) {
      n(y), m();
    },
    get value() {
      return s();
    },
    set value(y) {
      s(y), m();
    },
    get uiOption() {
      return o();
    },
    set uiOption(y) {
      o(y), m();
    }
  }, g = I(), h = D(g);
  {
    let y = /* @__PURE__ */ C(() => d(_) && r);
    Q(h, () => d(a), (S, x) => {
      x(S, {
        type: "template",
        showTitle: !0,
        useLabel: !0,
        get uiOption() {
          return o();
        },
        widgetType: l,
        get value() {
          return s();
        },
        get config() {
          return n();
        },
        get errors() {
          return d(f);
        },
        get action() {
          return d(y);
        },
        children: (P, w) => {
          var O = I(), k = D(O), $ = () => {
            const E = s(), M = new DataTransfer();
            return E && M.items.add(E), M.files;
          }, T = p.run;
          Q(k, () => d(u), (E, M) => {
            M(E, {
              type: "widget",
              get value() {
                return $();
              },
              set value(R) {
                T(R);
              },
              get processing() {
                return p.isProcessed;
              },
              loading: !1,
              get uiOption() {
                return o();
              },
              get handlers() {
                return c;
              },
              get errors() {
                return d(f);
              },
              get config() {
                return n();
              },
              multiple: !1
            });
          }), A(P, O);
        },
        $$slots: { default: !0 }
      });
    });
  }
  return A(t, g), W(b);
}
K(Kd, { config: {}, value: {}, uiOption: {} }, [], [], { mode: "open" });
In.nativeFileField = Kd;
In.nativeFilesField = Ud;
function Zb(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  var s = {
    get value() {
      return r();
    },
    set value(a) {
      r(a), m();
    }
  }, o = () => (DA(r()), r()), i = (a) => {
    r(a);
  };
  return Kd(t, ce(
    {
      get value() {
        return o();
      },
      set value(a) {
        i(a);
      }
    },
    () => n
  )), W(s);
}
K(Zb, { value: {} }, [], [], { mode: "open" });
In.unknownNativeFileField = Zb;
function jA(t) {
  return (e) => {
    const { schema: r } = e;
    if (yC(t, r))
      return "enumField";
    if (r.oneOf !== void 0)
      return "oneOfField";
    if (r.anyOf !== void 0)
      return "anyOfField";
    const n = ho(r);
    return n === "array" ? bC(t, r) ? "multiEnumField" : Oy(r) ? "tupleField" : _C(t, r) && It(t, e, "orderable") !== !0 ? "filesField" : "arrayField" : Ey(r) ? "fileField" : `${n}Field`;
  };
}
const BA = Ii(In);
var zA = /* @__PURE__ */ ne("<form><!></form>");
function qA(t, e) {
  H(e, !0);
  let r = v(e, "children", 7), n = v(e, "ref", 15), s = v(e, "config", 7), o = v(e, "attributes", 7);
  const i = De();
  var a = {
    get children() {
      return r();
    },
    set children(c) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    },
    get attributes() {
      return o();
    },
    set attributes(c) {
      o(c), m();
    }
  }, l = zA();
  ve(l, (c) => ({ onsubmit: i.submit, onreset: i.reset, ...c }), [
    () => Qy(i, s(), "form", o(), { class: "sjsf-form" })
  ]);
  var u = he(l);
  return te(u, r), de(l), et(l, (c) => n(c), () => n()), A(t, l), W(a);
}
K(qA, { children: {}, ref: {}, config: {}, attributes: {} }, [], [], { mode: "open" });
var UA = /* @__PURE__ */ ne("<form><!></form>");
function Qb(t, e) {
  H(e, !0);
  let r = v(e, "children", 7), n = v(e, "ref", 15), s = v(e, "config", 7), o = v(e, "attributes", 7);
  const i = De();
  var a = {
    get children() {
      return r();
    },
    set children(c) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    },
    get attributes() {
      return o();
    },
    set attributes(c) {
      o(c), m();
    }
  }, l = UA();
  ve(
    l,
    (c) => ({
      onsubmit: i.submit,
      onreset: i.reset,
      class: "flex flex-col gap-4",
      ...c
    }),
    [
      () => Qy(i, s(), "form", o(), {})
    ]
  );
  var u = he(l);
  return te(u, () => r() ?? ge), de(l), et(l, (c) => n(c), () => n()), A(t, l), W(a);
}
K(Qb, { children: {}, ref: {}, config: {}, attributes: {} }, [], [], { mode: "open" });
const e_ = /* @__PURE__ */ Symbol("theme-context");
function ut() {
  return Es(e_);
}
function KA(t) {
  Po(e_, t);
}
function t_(t, e) {
  H(e, !0);
  const r = v(e, "children", 7), n = v(e, "disabled", 7), s = v(e, "onclick", 7), o = v(e, "config", 7), i = v(e, "type", 7), a = De(), l = ut(), u = /* @__PURE__ */ C(() => l.components), c = /* @__PURE__ */ C(() => d(u).Button);
  var f = {
    get children() {
      return r();
    },
    set children(b) {
      r(b), m();
    },
    get disabled() {
      return n();
    },
    set disabled(b) {
      n(b), m();
    },
    get onclick() {
      return s();
    },
    set onclick(b) {
      s(b), m();
    },
    get config() {
      return o();
    },
    set config(b) {
      o(b), m();
    },
    get type() {
      return i();
    },
    set type(b) {
      i(b), m();
    }
  }, p = I(), _ = D(p);
  {
    let b = /* @__PURE__ */ C(() => Nt(
      a,
      o(),
      {
        type: "button",
        disabled: n(),
        onclick: s(),
        variant: "outline"
      },
      St("shadcn4Button"),
      Gy("shadcn4Buttons", (g) => g[i()]),
      Do
    ));
    Q(_, () => d(c), (g, h) => {
      h(g, ce(() => d(b), {
        children: (y, S) => {
          var x = I(), P = D(x);
          te(P, r), A(y, x);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, p), W(f);
}
K(
  t_,
  {
    children: {},
    disabled: {},
    onclick: {},
    config: {},
    type: {}
  },
  [],
  [],
  { mode: "open" }
);
function r_(t, e) {
  H(e, !0);
  const r = v(e, "children", 7), n = v(e, "config", 7), s = De(), o = ut(), i = /* @__PURE__ */ C(() => o.components), a = /* @__PURE__ */ C(() => d(i).Button);
  var l = {
    get children() {
      return r();
    },
    set children(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = I(), c = D(u);
  {
    let f = /* @__PURE__ */ C(() => zC(s, n(), "shadcn4SubmitButton", "submit", {}));
    Q(c, () => d(a), (p, _) => {
      _(p, ce(() => d(f), {
        children: (b, g) => {
          var h = I(), y = D(h);
          te(y, r), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), W(l);
}
K(r_, { children: {}, config: {} }, [], [], { mode: "open" });
var HA = /* @__PURE__ */ ne("<div><!></div>");
function WA(t, e) {
  H(e, !0);
  const r = v(e, "type", 7), n = v(e, "children", 7), s = v(e, "config", 7), o = De(), i = /* @__PURE__ */ C(() => tb(o, s(), "layout", "layouts", r(), { class: "sjsf-layout" }));
  var a = {
    get type() {
      return r();
    },
    set type(c) {
      r(c), m();
    },
    get children() {
      return n();
    },
    set children(c) {
      n(c), m();
    },
    get config() {
      return s();
    },
    set config(c) {
      s(c), m();
    }
  }, l = HA();
  ve(l, () => ({ ...d(i) }));
  var u = he(l);
  return te(u, n), de(l), A(t, l), W(a);
}
K(WA, { type: {}, children: {}, config: {} }, [], [], { mode: "open" });
var GA = /* @__PURE__ */ ne("<div><!></div>"), YA = /* @__PURE__ */ ne("<div><!></div>");
function n_(t, e) {
  H(e, !0);
  const r = v(e, "type", 7), n = v(e, "children", 7), s = v(e, "config", 7), o = v(e, "errors", 7), i = /* @__PURE__ */ C(() => r() === "array-item"), a = /* @__PURE__ */ C(() => r() === "array-item-content" || r() === "object-property-key-input" || r() === "object-property-content"), l = /* @__PURE__ */ C(() => r() === "object-property"), u = /* @__PURE__ */ C(() => r() === "field-meta" || r() === "array-field-meta" || r() === "object-field-meta"), c = /* @__PURE__ */ C(() => r() === "multi-field-controls"), f = De(), p = ut(), _ = /* @__PURE__ */ C(() => p.components), b = /* @__PURE__ */ C(() => d(_).ButtonGroup), g = /* @__PURE__ */ C(() => d(_).FieldSet), h = /* @__PURE__ */ C(() => d(_).FieldLegend), y = /* @__PURE__ */ C(() => d(_).Field), S = /* @__PURE__ */ C(() => d(_).FieldGroup), x = /* @__PURE__ */ C(() => tb(f, s(), "layout", "layouts", r(), {}));
  var P = {
    get type() {
      return r();
    },
    set type(T) {
      r(T), m();
    },
    get children() {
      return n();
    },
    set children(T) {
      n(T), m();
    },
    get config() {
      return s();
    },
    set config(T) {
      s(T), m();
    },
    get errors() {
      return o();
    },
    set errors(T) {
      o(T), m();
    }
  }, w = I(), O = D(w);
  {
    var k = (T) => {
      var E = I(), M = D(E);
      te(M, n), A(T, E);
    }, $ = (T) => {
      var E = I(), M = D(E);
      {
        var R = (B) => {
          var F = I(), Z = D(F);
          {
            let Y = /* @__PURE__ */ C(() => St("shadcn4ButtonGroup")(d(x), s(), f));
            Q(Z, () => d(b), (X, ae) => {
              ae(X, ce(() => d(Y), {
                children: (J, j) => {
                  var ee = I(), L = D(ee);
                  te(L, n), A(J, ee);
                },
                $$slots: { default: !0 }
              }));
            });
          }
          A(B, F);
        }, U = (B) => {
          var F = I(), Z = D(F);
          {
            var Y = (ae) => {
              var J = I(), j = D(J);
              {
                let ee = /* @__PURE__ */ C(() => St("shadcn4FieldSet")(d(x), s(), f));
                Q(j, () => d(g), (L, N) => {
                  N(L, ce(() => d(ee), {
                    children: (V, G) => {
                      var fe = I(), se = D(fe);
                      te(se, n), A(V, fe);
                    },
                    $$slots: { default: !0 }
                  }));
                });
              }
              A(ae, J);
            }, X = (ae) => {
              var J = I(), j = D(J);
              {
                var ee = (N) => {
                  var V = I(), G = D(V);
                  {
                    let fe = /* @__PURE__ */ C(() => o().length > 0), se = /* @__PURE__ */ C(() => St("shadcn4Field")(d(x), s(), f));
                    Q(G, () => d(y), (we, le) => {
                      le(we, ce(
                        {
                          get "data-invalid"() {
                            return d(fe);
                          }
                        },
                        () => d(se),
                        {
                          children: (re, oe) => {
                            var pe = I(), ye = D(pe);
                            te(ye, n), A(re, pe);
                          },
                          $$slots: { default: !0 }
                        }
                      ));
                    });
                  }
                  A(N, V);
                }, L = (N) => {
                  var V = I(), G = D(V);
                  {
                    var fe = (we) => {
                      var le = GA();
                      ve(le, () => ({
                        class: "flex w-full items-center justify-between",
                        ...d(x)
                      }));
                      var re = he(le);
                      te(re, n), de(le), A(we, le);
                    }, se = (we) => {
                      var le = I(), re = D(le);
                      {
                        var oe = (ye) => {
                          var Pe = I(), Oe = D(Pe);
                          Q(Oe, () => d(h), (Re, Ke) => {
                            Ke(Re, ce({ class: "flex w-full items-center justify-between" }, () => d(x), {
                              children: (Ve, je) => {
                                var He = I(), gt = D(He);
                                te(gt, n), A(Ve, He);
                              },
                              $$slots: { default: !0 }
                            }));
                          }), A(ye, Pe);
                        }, pe = (ye) => {
                          var Pe = I(), Oe = D(Pe);
                          {
                            var Re = (Ve) => {
                              var je = I(), He = D(je);
                              Q(He, () => d(S), (gt, Je) => {
                                Je(gt, ce(() => d(x), {
                                  children: (kt, lt) => {
                                    var ct = I(), pt = D(ct);
                                    te(pt, n), A(kt, ct);
                                  },
                                  $$slots: { default: !0 }
                                }));
                              }), A(Ve, je);
                            }, Ke = (Ve) => {
                              var je = YA();
                              ve(je, () => ({
                                class: {
                                  grow: d(a),
                                  "flex items-center gap-2": d(c),
                                  "flex items-start gap-1.5": d(i),
                                  "grid grid-cols-1 grid-rows-[1fr] items-start gap-x-1.5 [&:has(>:nth-child(2))]:grid-cols-[1fr_1fr_auto]": d(l)
                                },
                                ...d(x)
                              }));
                              var He = he(je);
                              te(He, n), de(je), A(Ve, je);
                            };
                            ue(
                              Oe,
                              (Ve) => {
                                r() === "array-items" || r() === "object-properties" || r() === "multi-field" || r() === "multi-field-content" ? Ve(Re) : Ve(Ke, !1);
                              },
                              !0
                            );
                          }
                          A(ye, Pe);
                        };
                        ue(
                          re,
                          (ye) => {
                            r() === "array-field-title-row" || r() === "object-field-title-row" ? ye(oe) : ye(pe, !1);
                          },
                          !0
                        );
                      }
                      A(we, le);
                    };
                    ue(
                      G,
                      (we) => {
                        r() === "field-title-row" ? we(fe) : we(se, !1);
                      },
                      !0
                    );
                  }
                  A(N, V);
                };
                ue(
                  j,
                  (N) => {
                    r() == "field" ? N(ee) : N(L, !1);
                  },
                  !0
                );
              }
              A(ae, J);
            };
            ue(
              Z,
              (ae) => {
                r() === "array-field" || r() === "object-field" ? ae(Y) : ae(X, !1);
              },
              !0
            );
          }
          A(B, F);
        };
        ue(
          M,
          (B) => {
            r() === "array-item-controls" ? B(R) : B(U, !1);
          },
          !0
        );
      }
      A(T, E);
    };
    ue(O, (T) => {
      (r() === "field-content" || d(u)) && Object.keys(d(x)).length < 2 ? T(k) : T($, !1);
    });
  }
  return A(t, w), W(P);
}
K(n_, { type: {}, children: {}, config: {}, errors: {} }, [], [], { mode: "open" });
var XA = /* @__PURE__ */ ne("<legend> <!></legend>");
function JA(t, e) {
  H(e, !0);
  const r = v(e, "title", 7), n = v(e, "config", 7), s = v(e, "templateType", 7), o = De();
  var i = {
    get title() {
      return r();
    },
    set title(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    },
    get templateType() {
      return s();
    },
    set templateType(f) {
      s(f), m();
    }
  }, a = XA();
  ve(a, (f) => ({ ...f }), [
    () => Ec(o, n(), "titleAttributes", { class: "sjsf-title", "data-template": s() })
  ]);
  var l = he(a), u = be(l);
  {
    var c = (f) => {
      var p = tt("*");
      A(f, p);
    };
    ue(u, (f) => {
      n().required && s() === "fieldTemplate" && f(c);
    });
  }
  return de(a), ke(() => Me(l, `${r() ?? ""} `)), A(t, a), W(i);
}
K(JA, { title: {}, config: {}, templateType: {} }, [], [], { mode: "open" });
var ZA = /* @__PURE__ */ ne(" <!>", 1), QA = /* @__PURE__ */ ne("<div> </div>");
function s_(t, e) {
  H(e, !0);
  const r = v(e, "title", 7), n = v(e, "templateType", 7), s = v(e, "config", 7), o = De(), i = ut(), a = /* @__PURE__ */ C(() => i.components), l = /* @__PURE__ */ C(() => d(a).FieldTitle);
  var u = {
    get title() {
      return r();
    },
    set title(b) {
      r(b), m();
    },
    get templateType() {
      return n();
    },
    set templateType(b) {
      n(b), m();
    },
    get config() {
      return s();
    },
    set config(b) {
      s(b), m();
    }
  }, c = I(), f = D(c);
  {
    var p = (b) => {
      var g = I(), h = D(g);
      {
        let y = /* @__PURE__ */ C(() => Ec(o, s(), "titleAttributes", {}));
        Q(h, () => d(l), (S, x) => {
          x(S, ce(() => d(y), {
            children: (P, w) => {
              vt();
              var O = ZA(), k = D(O), $ = be(k);
              {
                var T = (E) => {
                  var M = tt("*");
                  A(E, M);
                };
                ue($, (E) => {
                  s().required && E(T);
                });
              }
              ke(() => Me(k, `${r() ?? ""} `)), A(P, O);
            },
            $$slots: { default: !0 }
          }));
        });
      }
      A(b, g);
    }, _ = (b) => {
      var g = QA();
      ve(g, (y) => ({ ...y }), [() => Ec(o, s(), "titleAttributes", {})]);
      var h = he(g, !0);
      de(g), ke(() => Me(h, r())), A(b, g);
    };
    ue(f, (b) => {
      n() === "fieldTemplate" ? b(p) : b(_, !1);
    });
  }
  return A(t, c), W(u);
}
K(s_, { title: {}, templateType: {}, config: {} }, [], [], { mode: "open" });
var eE = /* @__PURE__ */ ne("<span>*</span>"), tE = /* @__PURE__ */ ne(" <!>", 1);
function o_(t, e) {
  H(e, !0);
  const r = v(e, "title", 7), n = v(e, "config", 7), s = De(), o = ut(), i = /* @__PURE__ */ C(() => o.components), a = /* @__PURE__ */ C(() => d(i).FieldLabel);
  var l = {
    get title() {
      return r();
    },
    set title(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = I(), c = D(u);
  {
    let f = /* @__PURE__ */ C(() => BC(s, n(), "shadcn4Label", {}));
    Q(c, () => d(a), (p, _) => {
      _(p, ce(() => d(f), {
        children: (b, g) => {
          vt();
          var h = tE(), y = D(h), S = be(y);
          {
            var x = (P) => {
              var w = eE();
              A(P, w);
            };
            ue(S, (P) => {
              n().required && P(x);
            });
          }
          ke(() => Me(y, `${r() ?? ""} `)), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), W(l);
}
K(o_, { title: {}, config: {} }, [], [], { mode: "open" });
var rE = /* @__PURE__ */ ne("<div> </div>");
function nE(t, e) {
  H(e, !0);
  const r = v(e, "description", 7), n = v(e, "config", 7), s = De();
  var o = {
    get description() {
      return r();
    },
    set description(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    }
  }, i = rE();
  ve(i, (l) => ({ ...l }), [
    () => Jy(s, n(), "descriptionAttributes", { class: "sjsf-description" })
  ]);
  var a = he(i, !0);
  return de(i), ke(() => Me(a, r())), A(t, i), W(o);
}
K(nE, { description: {}, config: {} }, [], [], { mode: "open" });
function i_(t, e) {
  H(e, !0);
  const r = v(e, "description", 7), n = v(e, "config", 7), s = De(), o = ut(), i = /* @__PURE__ */ C(() => o.components), a = /* @__PURE__ */ C(() => d(i).FieldDescription);
  var l = {
    get description() {
      return r();
    },
    set description(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = I(), c = D(u);
  {
    let f = /* @__PURE__ */ C(() => Jy(s, n(), "descriptionAttributes", {}));
    Q(c, () => d(a), (p, _) => {
      _(p, ce(() => d(f), {
        children: (b, g) => {
          vt();
          var h = tt();
          ke(() => Me(h, r())), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), W(l);
}
K(i_, { description: {}, config: {} }, [], [], { mode: "open" });
var sE = /* @__PURE__ */ ne("<div> </div>");
function oE(t, e) {
  H(e, !0);
  const r = v(e, "help", 7), n = v(e, "config", 7), s = De();
  var o = {
    get help() {
      return r();
    },
    set help(l) {
      r(l), m();
    },
    get config() {
      return n();
    },
    set config(l) {
      n(l), m();
    }
  }, i = sE();
  ve(i, (l) => ({ ...l }), [
    () => eb(s, n(), "helpAttributes", { class: "sjsf-help" })
  ]);
  var a = he(i, !0);
  return de(i), ke(() => Me(a, r())), A(t, i), W(o);
}
K(oE, { help: {}, config: {} }, [], [], { mode: "open" });
function a_(t, e) {
  H(e, !0);
  const r = v(e, "help", 7), n = v(e, "config", 7), s = De(), o = ut(), i = /* @__PURE__ */ C(() => o.components), a = /* @__PURE__ */ C(() => d(i).FieldDescription);
  var l = {
    get help() {
      return r();
    },
    set help(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = I(), c = D(u);
  {
    let f = /* @__PURE__ */ C(() => eb(s, n(), "helpAttributes", {}));
    Q(c, () => d(a), (p, _) => {
      _(p, ce(() => d(f), {
        children: (b, g) => {
          vt();
          var h = tt();
          ke(() => Me(h, r())), A(b, h);
        },
        $$slots: { default: !0 }
      }));
    });
  }
  return A(t, u), W(l);
}
K(a_, { help: {}, config: {} }, [], [], { mode: "open" });
var iE = /* @__PURE__ */ ne("<li> </li>"), aE = /* @__PURE__ */ ne("<ul></ul>");
function lE(t, e) {
  H(e, !0);
  const r = v(e, "errors", 7), n = v(e, "config", 7), s = De();
  var o = {
    get errors() {
      return r();
    },
    set errors(a) {
      r(a), m();
    },
    get config() {
      return n();
    },
    set config(a) {
      n(a), m();
    }
  }, i = aE();
  return ve(i, (a) => ({ ...a }), [
    () => Zy(s, n(), "errorsList", { class: "sjsf-errors-list" })
  ]), st(i, 21, r, Ll, (a, l) => {
    var u = iE(), c = he(u, !0);
    de(u), ke(() => Me(c, d(l))), A(a, u);
  }), de(i), A(t, i), W(o);
}
K(lE, { errors: {}, config: {} }, [], [], { mode: "open" });
var uE = /* @__PURE__ */ ne("<li> </li>"), cE = /* @__PURE__ */ ne("<ul></ul>");
function l_(t, e) {
  H(e, !0);
  const r = v(e, "errors", 7), n = v(e, "config", 7), s = De(), o = ut(), i = /* @__PURE__ */ C(() => o.components), a = /* @__PURE__ */ C(() => d(i).FieldError);
  var l = {
    get errors() {
      return r();
    },
    set errors(f) {
      r(f), m();
    },
    get config() {
      return n();
    },
    set config(f) {
      n(f), m();
    }
  }, u = I(), c = D(u);
  return Q(c, () => d(a), (f, p) => {
    p(f, {
      children: (_, b) => {
        var g = cE();
        ve(g, (h) => ({ class: "ml-4 flex list-disc flex-col gap-1", ...h }), [() => Zy(s, n(), "errorsList", {})]), st(g, 21, r, Ll, (h, y) => {
          var S = uE(), x = he(S, !0);
          de(S), ke(() => Me(x, d(y))), A(h, S);
        }), de(g), A(_, g);
      },
      $$slots: { default: !0 }
    });
  }), A(t, u), W(l);
}
K(l_, { errors: {}, config: {} }, [], [], { mode: "open" });
const dE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  button: t_,
  description: i_,
  errorsList: l_,
  form: Qb,
  help: a_,
  label: o_,
  layout: n_,
  submitButton: r_,
  title: s_
}, Symbol.toStringTag, { value: "Module" }));
var fE = /* @__PURE__ */ ne("<!> <!>", 1);
function Hd(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Input);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ C(() => Ni(r, a(), "shadcn4Text", l(), {}));
  var c = {
    get value() {
      return i();
    },
    set value(b) {
      i(b), m();
    },
    get config() {
      return a();
    },
    set config(b) {
      a(b), m();
    },
    get handlers() {
      return l();
    },
    set handlers(b) {
      l(b), m();
    }
  }, f = fE(), p = D(f);
  Q(p, () => d(o), (b, g) => {
    g(b, ce(() => d(u), {
      get value() {
        return i();
      },
      set value(h) {
        i(h);
      }
    }));
  });
  var _ = be(p, 2);
  return Rd(_, {
    get id() {
      return d(u).list;
    },
    get config() {
      return a();
    }
  }), A(t, f), W(c);
}
K(Hd, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
var hE = /* @__PURE__ */ ne("<!> <!>", 1);
function u_(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Input);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ C(() => Ni(r, a(), "shadcn4Number", l(), { type: "number" }));
  var c = {
    get value() {
      return i();
    },
    set value(h) {
      i(h), m();
    },
    get config() {
      return a();
    },
    set config(h) {
      a(h), m();
    },
    get handlers() {
      return l();
    },
    set handlers(h) {
      l(h), m();
    }
  }, f = hE(), p = D(f), _ = () => i() ?? null, b = (h) => i(h ?? void 0);
  Q(p, () => d(o), (h, y) => {
    y(h, ce(
      {
        get value() {
          return _();
        },
        set value(S) {
          b(S);
        }
      },
      () => d(u)
    ));
  });
  var g = be(p, 2);
  return Rd(g, {
    get id() {
      return d(u).list;
    },
    get config() {
      return a();
    }
  }), A(t, f), W(c);
}
K(u_, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
const Ha = "-1";
function Mo(t) {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  for (const n of t)
    e.set(n.id, n.value), r.set(n.value, n.id);
  return {
    fromValue(n) {
      if (n === void 0)
        return Ha;
      const s = r.get(n);
      return s !== void 0 ? s : Ts(n) ? t.find((o) => ql(o.value, n))?.id ?? Ha : t.find((o) => o.value === n)?.id ?? Ha;
    },
    toValue(n) {
      return e.get(n);
    }
  };
}
function tu({ mapper: t, value: e, update: r }) {
  const n = /* @__PURE__ */ C(t), s = /* @__PURE__ */ C(() => d(n).fromValue), o = /* @__PURE__ */ C(() => d(n).toValue), i = /* @__PURE__ */ C(() => d(s)(e()));
  return {
    get value() {
      return d(i);
    },
    set value(a) {
      r(d(o)(a));
    },
    get current() {
      return d(i);
    },
    set current(a) {
      r(d(o)(a));
    }
  };
}
function c_({ mapper: t, value: e, update: r }) {
  const n = /* @__PURE__ */ C(t), s = /* @__PURE__ */ C(() => d(n).fromValue), o = /* @__PURE__ */ C(() => d(n).toValue), i = /* @__PURE__ */ C(() => e()?.map(d(s)) ?? []);
  return {
    get value() {
      return d(i);
    },
    set value(a) {
      r(a.map(d(o)));
    },
    get current() {
      return d(i);
    },
    set current(a) {
      r(a.map(d(o)));
    }
  };
}
var gE = /* @__PURE__ */ ne("<span> </span>"), pE = /* @__PURE__ */ ne('<span class="min-h-5"> </span>'), mE = /* @__PURE__ */ ne("<!> <!>", 1), vE = /* @__PURE__ */ ne("<!> <!>", 1);
function d_(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Select), i = /* @__PURE__ */ C(() => d(s).SelectTrigger), a = /* @__PURE__ */ C(() => d(s).SelectContent), l = /* @__PURE__ */ C(() => d(s).SelectItem);
  let u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7), p = v(e, "config", 7);
  const _ = /* @__PURE__ */ C(() => new Map(f().map(($) => [$.id, $.label]))), b = tu({
    mapper: () => Mo(f()),
    value: () => c(),
    update: ($) => c($)
  }), g = /* @__PURE__ */ C(() => u().oninput), h = /* @__PURE__ */ C(() => u().onchange), y = /* @__PURE__ */ C(() => Dn(u(), ["oninput", "onchange"])), S = /* @__PURE__ */ C(() => gr(r, p(), "shadcn4Select", {
    required: p().required,
    onValueChange: () => {
      d(g)?.(), d(h)?.();
    }
  })), x = /* @__PURE__ */ C(() => d(_).get(b.current) ?? d(S).placeholder), P = /* @__PURE__ */ C(() => pr(r, p().path));
  var w = {
    get handlers() {
      return u();
    },
    set handlers($) {
      u($), m();
    },
    get value() {
      return c();
    },
    set value($) {
      c($), m();
    },
    get options() {
      return f();
    },
    set options($) {
      f($), m();
    },
    get config() {
      return p();
    },
    set config($) {
      p($), m();
    }
  }, O = I(), k = D(O);
  return Q(k, () => d(o), ($, T) => {
    T($, ce(() => d(S), {
      type: "single",
      get value() {
        return b.current;
      },
      set value(E) {
        b.current = E;
      },
      children: (E, M) => {
        var R = vE(), U = D(R);
        {
          let F = /* @__PURE__ */ C(() => gr(r, p(), "shadcn4SelectTrigger", an(d(y))({ id: d(P), name: d(P) })));
          Q(U, () => d(i), (Z, Y) => {
            Y(Z, ce({ class: "w-full" }, () => d(F), {
              children: (X, ae) => {
                var J = gE(), j = he(J, !0);
                de(J), ke(() => Me(j, d(x))), A(X, J);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var B = be(U, 2);
        Q(B, () => d(a), (F, Z) => {
          Z(F, {
            children: (Y, X) => {
              var ae = mE(), J = D(ae);
              {
                var j = (L) => {
                  var N = I(), V = D(N);
                  Q(V, () => d(l), (G, fe) => {
                    fe(G, {
                      get value() {
                        return Ha;
                      },
                      children: (se, we) => {
                        var le = pE(), re = he(le, !0);
                        de(le), ke(() => Me(re, d(S).placeholder)), A(se, le);
                      },
                      $$slots: { default: !0 }
                    });
                  }), A(L, N);
                };
                ue(J, (L) => {
                  p().schema.default === void 0 && L(j);
                });
              }
              var ee = be(J, 2);
              st(ee, 17, f, (L) => L.id, (L, N) => {
                var V = I(), G = D(V);
                Q(G, () => d(l), (fe, se) => {
                  se(fe, {
                    get value() {
                      return d(N).id;
                    },
                    get label() {
                      return d(N).label;
                    },
                    get disabled() {
                      return d(N).disabled;
                    }
                  });
                }), A(L, V);
              }), A(Y, ae);
            },
            $$slots: { default: !0 }
          });
        }), A(E, R);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, O), W(w);
}
K(d_, { handlers: {}, value: {}, options: {}, config: {} }, [], [], { mode: "open" });
var yE = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function f_(t, e) {
  H(e, !0);
  let r = v(e, "config", 7), n = v(e, "value", 15), s = v(e, "handlers", 7);
  const o = De(), i = ut(), a = /* @__PURE__ */ C(() => i.components), l = /* @__PURE__ */ C(() => d(a).Checkbox), u = /* @__PURE__ */ C(() => d(a).FieldLabel), c = /* @__PURE__ */ C(() => s().oninput), f = /* @__PURE__ */ C(() => s().onchange), p = /* @__PURE__ */ C(() => Dn(s(), ["oninput", "onchange"])), _ = /* @__PURE__ */ C(() => pr(o, r().path)), b = /* @__PURE__ */ C(() => gr(o, r(), "shadcn4Checkbox", an(d(p))({
    id: d(_),
    name: d(_),
    required: r().required,
    onCheckedChange: () => {
      d(c)?.(), d(f)?.();
    }
  })));
  var g = {
    get config() {
      return r();
    },
    set config(w) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get handlers() {
      return s();
    },
    set handlers(w) {
      s(w), m();
    }
  }, h = yE(), y = he(h), S = () => n() ?? !1, x = (w) => {
    n(w);
  };
  Q(y, () => d(l), (w, O) => {
    O(w, ce(
      {
        get checked() {
          return S();
        },
        set checked(k) {
          x(k);
        }
      },
      () => d(b)
    ));
  });
  var P = be(y, 2);
  return Q(P, () => d(u), (w, O) => {
    O(w, {
      get for() {
        return d(b).id;
      },
      children: (k, $) => {
        vt();
        var T = tt();
        ke(() => Me(T, r().title)), A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), de(h), A(t, h), W(g);
}
K(f_, { config: {}, value: {}, handlers: {} }, [], [], { mode: "open" });
const bE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkboxWidget: f_,
  numberWidget: u_,
  selectWidget: d_,
  textWidget: Hd
}, Symbol.toStringTag, { value: "Module" })), tr = {
  ...dE,
  ...bE
}, _E = Wy(BA, tr);
const wE = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var SE = /* @__PURE__ */ yP("<svg><!><!></svg>");
function Tt(t, e) {
  H(e, !0);
  const r = v(e, "name", 7), n = v(e, "color", 7, "currentColor"), s = v(e, "size", 7, 24), o = v(e, "strokeWidth", 7, 2), i = v(e, "absoluteStrokeWidth", 7, !1), a = v(e, "iconNode", 23, () => []), l = v(e, "children", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode",
    "children"
  ]);
  var c = {
    get name() {
      return r();
    },
    set name(b) {
      r(b), m();
    },
    get color() {
      return n();
    },
    set color(b = "currentColor") {
      n(b), m();
    },
    get size() {
      return s();
    },
    set size(b = 24) {
      s(b), m();
    },
    get strokeWidth() {
      return o();
    },
    set strokeWidth(b = 2) {
      o(b), m();
    },
    get absoluteStrokeWidth() {
      return i();
    },
    set absoluteStrokeWidth(b = !1) {
      i(b), m();
    },
    get iconNode() {
      return a();
    },
    set iconNode(b = []) {
      a(b), m();
    },
    get children() {
      return l();
    },
    set children(b) {
      l(b), m();
    }
  }, f = SE();
  ve(
    f,
    (b) => ({
      ...wE,
      ...u,
      width: s(),
      height: s(),
      stroke: n(),
      "stroke-width": b,
      class: [
        "lucide-icon lucide",
        r() && `lucide-${r()}`,
        e.class
      ]
    }),
    [
      () => i() ? Number(o()) * 24 / Number(s()) : o()
    ]
  );
  var p = he(f);
  st(p, 17, a, Ll, (b, g) => {
    var h = /* @__PURE__ */ C(() => Cx(d(g), 2));
    let y = () => d(h)[0], S = () => d(h)[1];
    var x = I(), P = D(x);
    IP(P, y, !0, (w, O) => {
      ve(w, () => ({ ...S() }));
    }), A(b, x);
  });
  var _ = be(p);
  return te(_, () => l() ?? ge), de(f), A(t, f), W(c);
}
K(
  Tt,
  {
    name: {},
    color: {},
    size: {},
    strokeWidth: {},
    absoluteStrokeWidth: {},
    iconNode: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
function h_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M12 5v14" }],
    ["path", { d: "m19 12-7 7-7-7" }]
  ];
  Tt(t, ce({ name: "arrow-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(h_, {}, [], [], { mode: "open" });
function g_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m5 12 7-7 7 7" }],
    ["path", { d: "M12 19V5" }]
  ];
  Tt(t, ce({ name: "arrow-up" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(g_, {}, [], [], { mode: "open" });
function p_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    [
      "rect",
      { width: "18", height: "18", x: "3", y: "4", rx: "2" }
    ],
    ["path", { d: "M3 10h18" }]
  ];
  Tt(t, ce({ name: "calendar" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(p_, {}, [], [], { mode: "open" });
function ru(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "M20 6 9 17l-5-5" }]];
  Tt(t, ce({ name: "check" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(ru, {}, [], [], { mode: "open" });
function Ks(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m6 9 6 6 6-6" }]];
  Tt(t, ce({ name: "chevron-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(Ks, {}, [], [], { mode: "open" });
function Wd(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m15 18-6-6 6-6" }]];
  Tt(t, ce({ name: "chevron-left" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(Wd, {}, [], [], { mode: "open" });
function Gd(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m9 18 6-6-6-6" }]];
  Tt(t, ce({ name: "chevron-right" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(Gd, {}, [], [], { mode: "open" });
function m_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "m18 15-6-6-6 6" }]];
  Tt(t, ce({ name: "chevron-up" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(m_, {}, [], [], { mode: "open" });
function v_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m7 15 5 5 5-5" }],
    ["path", { d: "m7 9 5-5 5 5" }]
  ];
  Tt(t, ce({ name: "chevrons-up-down" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(v_, {}, [], [], { mode: "open" });
function y_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["circle", { cx: "12", cy: "12", r: "10" }]];
  Tt(t, ce({ name: "circle" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(y_, {}, [], [], { mode: "open" });
function b_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    [
      "rect",
      {
        width: "14",
        height: "14",
        x: "8",
        y: "8",
        rx: "2",
        ry: "2"
      }
    ],
    [
      "path",
      {
        d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
      }
    ]
  ];
  Tt(t, ce({ name: "copy" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(b_, {}, [], [], { mode: "open" });
function __(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [["path", { d: "M5 12h14" }]];
  Tt(t, ce({ name: "minus" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(__, {}, [], [], { mode: "open" });
function w_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "m21 21-4.34-4.34" }],
    ["circle", { cx: "11", cy: "11", r: "8" }]
  ];
  Tt(t, ce({ name: "search" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(w_, {}, [], [], { mode: "open" });
function S_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }]
  ];
  Tt(t, ce({ name: "trash" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(S_, {}, [], [], { mode: "open" });
function x_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    [
      "path",
      {
        d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"
      }
    ],
    ["path", { d: "M12 9v4" }],
    ["path", { d: "M12 17h.01" }]
  ];
  Tt(t, ce({ name: "triangle-alert" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(x_, {}, [], [], { mode: "open" });
function P_(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  const n = [
    ["path", { d: "M18 6 6 18" }],
    ["path", { d: "m6 6 12 12" }]
  ];
  Tt(t, ce({ name: "x" }, () => r, {
    get iconNode() {
      return n;
    },
    children: (s, o) => {
      var i = I(), a = D(i);
      te(a, () => e.children ?? ge), A(s, i);
    },
    $$slots: { default: !0 }
  })), W();
}
K(P_, {}, [], [], { mode: "open" });
function xE(t) {
  return t instanceof Error ? t.message : String(t);
}
const Io = function(t, e) {
  let s = t;
  const o = ii[e];
  let i = null, a = 0, l = null;
  const u = [], c = {}, f = function(k, $) {
    a = s * 4 + 17, i = (function(T) {
      const E = new Array(T);
      for (let M = 0; M < T; M += 1) {
        E[M] = new Array(T);
        for (let R = 0; R < T; R += 1)
          E[M][R] = null;
      }
      return E;
    })(a), p(0, 0), p(a - 7, 0), p(0, a - 7), g(), b(), y(k, $), s >= 7 && h(k), l == null && (l = P(s, o, u)), S(l, $);
  }, p = function(k, $) {
    for (let T = -1; T <= 7; T += 1)
      if (!(k + T <= -1 || a <= k + T))
        for (let E = -1; E <= 7; E += 1)
          $ + E <= -1 || a <= $ + E || (0 <= T && T <= 6 && (E == 0 || E == 6) || 0 <= E && E <= 6 && (T == 0 || T == 6) || 2 <= T && T <= 4 && 2 <= E && E <= 4 ? i[k + T][$ + E] = !0 : i[k + T][$ + E] = !1);
  }, _ = function() {
    let k = 0, $ = 0;
    for (let T = 0; T < 8; T += 1) {
      f(!0, T);
      const E = Ln.getLostPoint(c);
      (T == 0 || k > E) && (k = E, $ = T);
    }
    return $;
  }, b = function() {
    for (let k = 8; k < a - 8; k += 1)
      i[k][6] == null && (i[k][6] = k % 2 == 0);
    for (let k = 8; k < a - 8; k += 1)
      i[6][k] == null && (i[6][k] = k % 2 == 0);
  }, g = function() {
    const k = Ln.getPatternPosition(s);
    for (let $ = 0; $ < k.length; $ += 1)
      for (let T = 0; T < k.length; T += 1) {
        const E = k[$], M = k[T];
        if (i[E][M] == null)
          for (let R = -2; R <= 2; R += 1)
            for (let U = -2; U <= 2; U += 1)
              R == -2 || R == 2 || U == -2 || U == 2 || R == 0 && U == 0 ? i[E + R][M + U] = !0 : i[E + R][M + U] = !1;
      }
  }, h = function(k) {
    const $ = Ln.getBCHTypeNumber(s);
    for (let T = 0; T < 18; T += 1) {
      const E = !k && ($ >> T & 1) == 1;
      i[Math.floor(T / 3)][T % 3 + a - 8 - 3] = E;
    }
    for (let T = 0; T < 18; T += 1) {
      const E = !k && ($ >> T & 1) == 1;
      i[T % 3 + a - 8 - 3][Math.floor(T / 3)] = E;
    }
  }, y = function(k, $) {
    const T = o << 3 | $, E = Ln.getBCHTypeInfo(T);
    for (let M = 0; M < 15; M += 1) {
      const R = !k && (E >> M & 1) == 1;
      M < 6 ? i[M][8] = R : M < 8 ? i[M + 1][8] = R : i[a - 15 + M][8] = R;
    }
    for (let M = 0; M < 15; M += 1) {
      const R = !k && (E >> M & 1) == 1;
      M < 8 ? i[8][a - M - 1] = R : M < 9 ? i[8][15 - M - 1 + 1] = R : i[8][15 - M - 1] = R;
    }
    i[a - 8][8] = !k;
  }, S = function(k, $) {
    let T = -1, E = a - 1, M = 7, R = 0;
    const U = Ln.getMaskFunction($);
    for (let B = a - 1; B > 0; B -= 2)
      for (B == 6 && (B -= 1); ; ) {
        for (let F = 0; F < 2; F += 1)
          if (i[E][B - F] == null) {
            let Z = !1;
            R < k.length && (Z = (k[R] >>> M & 1) == 1), U(E, B - F) && (Z = !Z), i[E][B - F] = Z, M -= 1, M == -1 && (R += 1, M = 7);
          }
        if (E += T, E < 0 || a <= E) {
          E -= T, T = -T;
          break;
        }
      }
  }, x = function(k, $) {
    let T = 0, E = 0, M = 0;
    const R = new Array($.length), U = new Array($.length);
    for (let Y = 0; Y < $.length; Y += 1) {
      const X = $[Y].dataCount, ae = $[Y].totalCount - X;
      E = Math.max(E, X), M = Math.max(M, ae), R[Y] = new Array(X);
      for (let L = 0; L < R[Y].length; L += 1)
        R[Y][L] = 255 & k.getBuffer()[L + T];
      T += X;
      const J = Ln.getErrorCorrectPolynomial(ae), ee = bi(R[Y], J.getLength() - 1).mod(J);
      U[Y] = new Array(J.getLength() - 1);
      for (let L = 0; L < U[Y].length; L += 1) {
        const N = L + ee.getLength() - U[Y].length;
        U[Y][L] = N >= 0 ? ee.getAt(N) : 0;
      }
    }
    let B = 0;
    for (let Y = 0; Y < $.length; Y += 1)
      B += $[Y].totalCount;
    const F = new Array(B);
    let Z = 0;
    for (let Y = 0; Y < E; Y += 1)
      for (let X = 0; X < $.length; X += 1)
        Y < R[X].length && (F[Z] = R[X][Y], Z += 1);
    for (let Y = 0; Y < M; Y += 1)
      for (let X = 0; X < $.length; X += 1)
        Y < U[X].length && (F[Z] = U[X][Y], Z += 1);
    return F;
  }, P = function(k, $, T) {
    const E = nm.getRSBlocks(k, $), M = sm();
    for (let U = 0; U < T.length; U += 1) {
      const B = T[U];
      M.put(B.getMode(), 4), M.put(B.getLength(), Ln.getLengthInBits(B.getMode(), k)), B.write(M);
    }
    let R = 0;
    for (let U = 0; U < E.length; U += 1)
      R += E[U].dataCount;
    if (M.getLengthInBits() > R * 8)
      throw "code length overflow. (" + M.getLengthInBits() + ">" + R * 8 + ")";
    for (M.getLengthInBits() + 4 <= R * 8 && M.put(0, 4); M.getLengthInBits() % 8 != 0; )
      M.putBit(!1);
    for (; !(M.getLengthInBits() >= R * 8 || (M.put(236, 8), M.getLengthInBits() >= R * 8)); )
      M.put(17, 8);
    return x(M, E);
  };
  c.addData = function(k, $) {
    $ = $ || "Byte";
    let T = null;
    switch ($) {
      case "Numeric":
        T = PE(k);
        break;
      case "Alphanumeric":
        T = OE(k);
        break;
      case "Byte":
        T = CE(k);
        break;
      case "Kanji":
        T = kE(k);
        break;
      default:
        throw "mode:" + $;
    }
    u.push(T), l = null;
  }, c.isDark = function(k, $) {
    if (k < 0 || a <= k || $ < 0 || a <= $)
      throw k + "," + $;
    return i[k][$];
  }, c.getModuleCount = function() {
    return a;
  }, c.make = function() {
    if (s < 1) {
      let k = 1;
      for (; k < 40; k++) {
        const $ = nm.getRSBlocks(k, o), T = sm();
        for (let M = 0; M < u.length; M++) {
          const R = u[M];
          T.put(R.getMode(), 4), T.put(R.getLength(), Ln.getLengthInBits(R.getMode(), k)), R.write(T);
        }
        let E = 0;
        for (let M = 0; M < $.length; M++)
          E += $[M].dataCount;
        if (T.getLengthInBits() <= E * 8)
          break;
      }
      s = k;
    }
    f(!1, _());
  }, c.createTableTag = function(k, $) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    let T = "";
    T += '<table style="', T += " border-width: 0px; border-style: none;", T += " border-collapse: collapse;", T += " padding: 0px; margin: " + $ + "px;", T += '">', T += "<tbody>";
    for (let E = 0; E < c.getModuleCount(); E += 1) {
      T += "<tr>";
      for (let M = 0; M < c.getModuleCount(); M += 1)
        T += '<td style="', T += " border-width: 0px; border-style: none;", T += " border-collapse: collapse;", T += " padding: 0px; margin: 0px;", T += " width: " + k + "px;", T += " height: " + k + "px;", T += " background-color: ", T += c.isDark(E, M) ? "#000000" : "#ffffff", T += ";", T += '"/>';
      T += "</tr>";
    }
    return T += "</tbody>", T += "</table>", T;
  }, c.createSvgTag = function(k, $, T, E) {
    let M = {};
    typeof arguments[0] == "object" && (M = arguments[0], k = M.cellSize, $ = M.margin, T = M.alt, E = M.title), k = k || 2, $ = typeof $ > "u" ? k * 4 : $, T = typeof T == "string" ? { text: T } : T || {}, T.text = T.text || null, T.id = T.text ? T.id || "qrcode-description" : null, E = typeof E == "string" ? { text: E } : E || {}, E.text = E.text || null, E.id = E.text ? E.id || "qrcode-title" : null;
    const R = c.getModuleCount() * k + $ * 2;
    let U, B, F, Z, Y = "", X;
    for (X = "l" + k + ",0 0," + k + " -" + k + ",0 0,-" + k + "z ", Y += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Y += M.scalable ? "" : ' width="' + R + 'px" height="' + R + 'px"', Y += ' viewBox="0 0 ' + R + " " + R + '" ', Y += ' preserveAspectRatio="xMinYMin meet"', Y += E.text || T.text ? ' role="img" aria-labelledby="' + w([E.id, T.id].join(" ").trim()) + '"' : "", Y += ">", Y += E.text ? '<title id="' + w(E.id) + '">' + w(E.text) + "</title>" : "", Y += T.text ? '<description id="' + w(T.id) + '">' + w(T.text) + "</description>" : "", Y += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Y += '<path d="', F = 0; F < c.getModuleCount(); F += 1)
      for (Z = F * k + $, U = 0; U < c.getModuleCount(); U += 1)
        c.isDark(F, U) && (B = U * k + $, Y += "M" + B + "," + Z + X);
    return Y += '" stroke="transparent" fill="black"/>', Y += "</svg>", Y;
  }, c.createDataURL = function(k, $) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    const T = c.getModuleCount() * k + $ * 2, E = $, M = T - $;
    return TE(T, T, function(R, U) {
      if (E <= R && R < M && E <= U && U < M) {
        const B = Math.floor((R - E) / k), F = Math.floor((U - E) / k);
        return c.isDark(F, B) ? 0 : 1;
      } else
        return 1;
    });
  }, c.createImgTag = function(k, $, T) {
    k = k || 2, $ = typeof $ > "u" ? k * 4 : $;
    const E = c.getModuleCount() * k + $ * 2;
    let M = "";
    return M += "<img", M += ' src="', M += c.createDataURL(k, $), M += '"', M += ' width="', M += E, M += '"', M += ' height="', M += E, M += '"', T && (M += ' alt="', M += w(T), M += '"'), M += "/>", M;
  };
  const w = function(k) {
    let $ = "";
    for (let T = 0; T < k.length; T += 1) {
      const E = k.charAt(T);
      switch (E) {
        case "<":
          $ += "&lt;";
          break;
        case ">":
          $ += "&gt;";
          break;
        case "&":
          $ += "&amp;";
          break;
        case '"':
          $ += "&quot;";
          break;
        default:
          $ += E;
          break;
      }
    }
    return $;
  }, O = function(k) {
    k = typeof k > "u" ? 2 : k;
    const T = c.getModuleCount() * 1 + k * 2, E = k, M = T - k;
    let R, U, B, F, Z;
    const Y = {
      "â–ˆâ–ˆ": "â–ˆ",
      "â–ˆ ": "â–€",
      " â–ˆ": "â–„",
      "  ": " "
    }, X = {
      "â–ˆâ–ˆ": "â–€",
      "â–ˆ ": "â–€",
      " â–ˆ": " ",
      "  ": " "
    };
    let ae = "";
    for (R = 0; R < T; R += 2) {
      for (B = Math.floor((R - E) / 1), F = Math.floor((R + 1 - E) / 1), U = 0; U < T; U += 1)
        Z = "â–ˆ", E <= U && U < M && E <= R && R < M && c.isDark(B, Math.floor((U - E) / 1)) && (Z = " "), E <= U && U < M && E <= R + 1 && R + 1 < M && c.isDark(F, Math.floor((U - E) / 1)) ? Z += " " : Z += "â–ˆ", ae += k < 1 && R + 1 >= M ? X[Z] : Y[Z];
      ae += `
`;
    }
    return T % 2 && k > 0 ? ae.substring(0, ae.length - T - 1) + Array(T + 1).join("â–€") : ae.substring(0, ae.length - 1);
  };
  return c.createASCII = function(k, $) {
    if (k = k || 1, k < 2)
      return O($);
    k -= 1, $ = typeof $ > "u" ? k * 2 : $;
    const T = c.getModuleCount() * k + $ * 2, E = $, M = T - $;
    let R, U, B, F;
    const Z = Array(k + 1).join("â–ˆâ–ˆ"), Y = Array(k + 1).join("  ");
    let X = "", ae = "";
    for (R = 0; R < T; R += 1) {
      for (B = Math.floor((R - E) / k), ae = "", U = 0; U < T; U += 1)
        F = 1, E <= U && U < M && E <= R && R < M && c.isDark(B, Math.floor((U - E) / k)) && (F = 0), ae += F ? Z : Y;
      for (B = 0; B < k; B += 1)
        X += ae + `
`;
    }
    return X.substring(0, X.length - 1);
  }, c.renderTo2dContext = function(k, $) {
    $ = $ || 2;
    const T = c.getModuleCount();
    for (let E = 0; E < T; E++)
      for (let M = 0; M < T; M++)
        k.fillStyle = c.isDark(E, M) ? "black" : "white", k.fillRect(M * $, E * $, $, $);
  }, c;
};
Io.stringToBytes = function(t) {
  const e = [];
  for (let r = 0; r < t.length; r += 1) {
    const n = t.charCodeAt(r);
    e.push(n & 255);
  }
  return e;
};
Io.createStringToBytes = function(t, e) {
  const r = (function() {
    const s = AE(t), o = function() {
      const l = s.read();
      if (l == -1) throw "eof";
      return l;
    };
    let i = 0;
    const a = {};
    for (; ; ) {
      const l = s.read();
      if (l == -1) break;
      const u = o(), c = o(), f = o(), p = String.fromCharCode(l << 8 | u), _ = c << 8 | f;
      a[p] = _, i += 1;
    }
    if (i != e)
      throw i + " != " + e;
    return a;
  })(), n = 63;
  return function(s) {
    const o = [];
    for (let i = 0; i < s.length; i += 1) {
      const a = s.charCodeAt(i);
      if (a < 128)
        o.push(a);
      else {
        const l = r[s.charAt(i)];
        typeof l == "number" ? (l & 255) == l ? o.push(l) : (o.push(l >>> 8), o.push(l & 255)) : o.push(n);
      }
    }
    return o;
  };
};
const Mt = {
  MODE_NUMBER: 1,
  MODE_ALPHA_NUM: 2,
  MODE_8BIT_BYTE: 4,
  MODE_KANJI: 8
}, ii = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
}, Vn = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
}, Ln = (function() {
  const t = [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
  ], e = 1335, r = 7973, n = 21522, s = {}, o = function(i) {
    let a = 0;
    for (; i != 0; )
      a += 1, i >>>= 1;
    return a;
  };
  return s.getBCHTypeInfo = function(i) {
    let a = i << 10;
    for (; o(a) - o(e) >= 0; )
      a ^= e << o(a) - o(e);
    return (i << 10 | a) ^ n;
  }, s.getBCHTypeNumber = function(i) {
    let a = i << 12;
    for (; o(a) - o(r) >= 0; )
      a ^= r << o(a) - o(r);
    return i << 12 | a;
  }, s.getPatternPosition = function(i) {
    return t[i - 1];
  }, s.getMaskFunction = function(i) {
    switch (i) {
      case Vn.PATTERN000:
        return function(a, l) {
          return (a + l) % 2 == 0;
        };
      case Vn.PATTERN001:
        return function(a, l) {
          return a % 2 == 0;
        };
      case Vn.PATTERN010:
        return function(a, l) {
          return l % 3 == 0;
        };
      case Vn.PATTERN011:
        return function(a, l) {
          return (a + l) % 3 == 0;
        };
      case Vn.PATTERN100:
        return function(a, l) {
          return (Math.floor(a / 2) + Math.floor(l / 3)) % 2 == 0;
        };
      case Vn.PATTERN101:
        return function(a, l) {
          return a * l % 2 + a * l % 3 == 0;
        };
      case Vn.PATTERN110:
        return function(a, l) {
          return (a * l % 2 + a * l % 3) % 2 == 0;
        };
      case Vn.PATTERN111:
        return function(a, l) {
          return (a * l % 3 + (a + l) % 2) % 2 == 0;
        };
      default:
        throw "bad maskPattern:" + i;
    }
  }, s.getErrorCorrectPolynomial = function(i) {
    let a = bi([1], 0);
    for (let l = 0; l < i; l += 1)
      a = a.multiply(bi([1, qn.gexp(l)], 0));
    return a;
  }, s.getLengthInBits = function(i, a) {
    if (1 <= a && a < 10)
      switch (i) {
        case Mt.MODE_NUMBER:
          return 10;
        case Mt.MODE_ALPHA_NUM:
          return 9;
        case Mt.MODE_8BIT_BYTE:
          return 8;
        case Mt.MODE_KANJI:
          return 8;
        default:
          throw "mode:" + i;
      }
    else if (a < 27)
      switch (i) {
        case Mt.MODE_NUMBER:
          return 12;
        case Mt.MODE_ALPHA_NUM:
          return 11;
        case Mt.MODE_8BIT_BYTE:
          return 16;
        case Mt.MODE_KANJI:
          return 10;
        default:
          throw "mode:" + i;
      }
    else if (a < 41)
      switch (i) {
        case Mt.MODE_NUMBER:
          return 14;
        case Mt.MODE_ALPHA_NUM:
          return 13;
        case Mt.MODE_8BIT_BYTE:
          return 16;
        case Mt.MODE_KANJI:
          return 12;
        default:
          throw "mode:" + i;
      }
    else
      throw "type:" + a;
  }, s.getLostPoint = function(i) {
    const a = i.getModuleCount();
    let l = 0;
    for (let f = 0; f < a; f += 1)
      for (let p = 0; p < a; p += 1) {
        let _ = 0;
        const b = i.isDark(f, p);
        for (let g = -1; g <= 1; g += 1)
          if (!(f + g < 0 || a <= f + g))
            for (let h = -1; h <= 1; h += 1)
              p + h < 0 || a <= p + h || g == 0 && h == 0 || b == i.isDark(f + g, p + h) && (_ += 1);
        _ > 5 && (l += 3 + _ - 5);
      }
    for (let f = 0; f < a - 1; f += 1)
      for (let p = 0; p < a - 1; p += 1) {
        let _ = 0;
        i.isDark(f, p) && (_ += 1), i.isDark(f + 1, p) && (_ += 1), i.isDark(f, p + 1) && (_ += 1), i.isDark(f + 1, p + 1) && (_ += 1), (_ == 0 || _ == 4) && (l += 3);
      }
    for (let f = 0; f < a; f += 1)
      for (let p = 0; p < a - 6; p += 1)
        i.isDark(f, p) && !i.isDark(f, p + 1) && i.isDark(f, p + 2) && i.isDark(f, p + 3) && i.isDark(f, p + 4) && !i.isDark(f, p + 5) && i.isDark(f, p + 6) && (l += 40);
    for (let f = 0; f < a; f += 1)
      for (let p = 0; p < a - 6; p += 1)
        i.isDark(p, f) && !i.isDark(p + 1, f) && i.isDark(p + 2, f) && i.isDark(p + 3, f) && i.isDark(p + 4, f) && !i.isDark(p + 5, f) && i.isDark(p + 6, f) && (l += 40);
    let u = 0;
    for (let f = 0; f < a; f += 1)
      for (let p = 0; p < a; p += 1)
        i.isDark(p, f) && (u += 1);
    const c = Math.abs(100 * u / a / a - 50) / 5;
    return l += c * 10, l;
  }, s;
})(), qn = (function() {
  const t = new Array(256), e = new Array(256);
  for (let n = 0; n < 8; n += 1)
    t[n] = 1 << n;
  for (let n = 8; n < 256; n += 1)
    t[n] = t[n - 4] ^ t[n - 5] ^ t[n - 6] ^ t[n - 8];
  for (let n = 0; n < 255; n += 1)
    e[t[n]] = n;
  const r = {};
  return r.glog = function(n) {
    if (n < 1)
      throw "glog(" + n + ")";
    return e[n];
  }, r.gexp = function(n) {
    for (; n < 0; )
      n += 255;
    for (; n >= 256; )
      n -= 255;
    return t[n];
  }, r;
})(), bi = function(t, e) {
  if (typeof t.length > "u")
    throw t.length + "/" + e;
  const r = (function() {
    let s = 0;
    for (; s < t.length && t[s] == 0; )
      s += 1;
    const o = new Array(t.length - s + e);
    for (let i = 0; i < t.length - s; i += 1)
      o[i] = t[i + s];
    return o;
  })(), n = {};
  return n.getAt = function(s) {
    return r[s];
  }, n.getLength = function() {
    return r.length;
  }, n.multiply = function(s) {
    const o = new Array(n.getLength() + s.getLength() - 1);
    for (let i = 0; i < n.getLength(); i += 1)
      for (let a = 0; a < s.getLength(); a += 1)
        o[i + a] ^= qn.gexp(qn.glog(n.getAt(i)) + qn.glog(s.getAt(a)));
    return bi(o, 0);
  }, n.mod = function(s) {
    if (n.getLength() - s.getLength() < 0)
      return n;
    const o = qn.glog(n.getAt(0)) - qn.glog(s.getAt(0)), i = new Array(n.getLength());
    for (let a = 0; a < n.getLength(); a += 1)
      i[a] = n.getAt(a);
    for (let a = 0; a < s.getLength(); a += 1)
      i[a] ^= qn.gexp(qn.glog(s.getAt(a)) + o);
    return bi(i, 0).mod(s);
  }, n;
}, nm = (function() {
  const t = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12, 7, 37, 13],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ], e = function(s, o) {
    const i = {};
    return i.totalCount = s, i.dataCount = o, i;
  }, r = {}, n = function(s, o) {
    switch (o) {
      case ii.L:
        return t[(s - 1) * 4 + 0];
      case ii.M:
        return t[(s - 1) * 4 + 1];
      case ii.Q:
        return t[(s - 1) * 4 + 2];
      case ii.H:
        return t[(s - 1) * 4 + 3];
      default:
        return;
    }
  };
  return r.getRSBlocks = function(s, o) {
    const i = n(s, o);
    if (typeof i > "u")
      throw "bad rs block @ typeNumber:" + s + "/errorCorrectionLevel:" + o;
    const a = i.length / 3, l = [];
    for (let u = 0; u < a; u += 1) {
      const c = i[u * 3 + 0], f = i[u * 3 + 1], p = i[u * 3 + 2];
      for (let _ = 0; _ < c; _ += 1)
        l.push(e(f, p));
    }
    return l;
  }, r;
})(), sm = function() {
  const t = [];
  let e = 0;
  const r = {};
  return r.getBuffer = function() {
    return t;
  }, r.getAt = function(n) {
    const s = Math.floor(n / 8);
    return (t[s] >>> 7 - n % 8 & 1) == 1;
  }, r.put = function(n, s) {
    for (let o = 0; o < s; o += 1)
      r.putBit((n >>> s - o - 1 & 1) == 1);
  }, r.getLengthInBits = function() {
    return e;
  }, r.putBit = function(n) {
    const s = Math.floor(e / 8);
    t.length <= s && t.push(0), n && (t[s] |= 128 >>> e % 8), e += 1;
  }, r;
}, PE = function(t) {
  const e = Mt.MODE_NUMBER, r = t, n = {};
  n.getMode = function() {
    return e;
  }, n.getLength = function(i) {
    return r.length;
  }, n.write = function(i) {
    const a = r;
    let l = 0;
    for (; l + 2 < a.length; )
      i.put(s(a.substring(l, l + 3)), 10), l += 3;
    l < a.length && (a.length - l == 1 ? i.put(s(a.substring(l, l + 1)), 4) : a.length - l == 2 && i.put(s(a.substring(l, l + 2)), 7));
  };
  const s = function(i) {
    let a = 0;
    for (let l = 0; l < i.length; l += 1)
      a = a * 10 + o(i.charAt(l));
    return a;
  }, o = function(i) {
    if ("0" <= i && i <= "9")
      return i.charCodeAt(0) - 48;
    throw "illegal char :" + i;
  };
  return n;
}, OE = function(t) {
  const e = Mt.MODE_ALPHA_NUM, r = t, n = {};
  n.getMode = function() {
    return e;
  }, n.getLength = function(o) {
    return r.length;
  }, n.write = function(o) {
    const i = r;
    let a = 0;
    for (; a + 1 < i.length; )
      o.put(
        s(i.charAt(a)) * 45 + s(i.charAt(a + 1)),
        11
      ), a += 2;
    a < i.length && o.put(s(i.charAt(a)), 6);
  };
  const s = function(o) {
    if ("0" <= o && o <= "9")
      return o.charCodeAt(0) - 48;
    if ("A" <= o && o <= "Z")
      return o.charCodeAt(0) - 65 + 10;
    switch (o) {
      case " ":
        return 36;
      case "$":
        return 37;
      case "%":
        return 38;
      case "*":
        return 39;
      case "+":
        return 40;
      case "-":
        return 41;
      case ".":
        return 42;
      case "/":
        return 43;
      case ":":
        return 44;
      default:
        throw "illegal char :" + o;
    }
  };
  return n;
}, CE = function(t) {
  const e = Mt.MODE_8BIT_BYTE, r = Io.stringToBytes(t), n = {};
  return n.getMode = function() {
    return e;
  }, n.getLength = function(s) {
    return r.length;
  }, n.write = function(s) {
    for (let o = 0; o < r.length; o += 1)
      s.put(r[o], 8);
  }, n;
}, kE = function(t) {
  const e = Mt.MODE_KANJI, r = Io.stringToBytes;
  (function(o, i) {
    const a = r(o);
    if (a.length != 2 || (a[0] << 8 | a[1]) != i)
      throw "sjis not supported.";
  })("å‹", 38726);
  const n = r(t), s = {};
  return s.getMode = function() {
    return e;
  }, s.getLength = function(o) {
    return ~~(n.length / 2);
  }, s.write = function(o) {
    const i = n;
    let a = 0;
    for (; a + 1 < i.length; ) {
      let l = (255 & i[a]) << 8 | 255 & i[a + 1];
      if (33088 <= l && l <= 40956)
        l -= 33088;
      else if (57408 <= l && l <= 60351)
        l -= 49472;
      else
        throw "illegal char at " + (a + 1) + "/" + l;
      l = (l >>> 8 & 255) * 192 + (l & 255), o.put(l, 13), a += 2;
    }
    if (a < i.length)
      throw "illegal char at " + (a + 1);
  }, s;
}, O_ = function() {
  const t = [], e = {};
  return e.writeByte = function(r) {
    t.push(r & 255);
  }, e.writeShort = function(r) {
    e.writeByte(r), e.writeByte(r >>> 8);
  }, e.writeBytes = function(r, n, s) {
    n = n || 0, s = s || r.length;
    for (let o = 0; o < s; o += 1)
      e.writeByte(r[o + n]);
  }, e.writeString = function(r) {
    for (let n = 0; n < r.length; n += 1)
      e.writeByte(r.charCodeAt(n));
  }, e.toByteArray = function() {
    return t;
  }, e.toString = function() {
    let r = "";
    r += "[";
    for (let n = 0; n < t.length; n += 1)
      n > 0 && (r += ","), r += t[n];
    return r += "]", r;
  }, e;
}, $E = function() {
  let t = 0, e = 0, r = 0, n = "";
  const s = {}, o = function(a) {
    n += String.fromCharCode(i(a & 63));
  }, i = function(a) {
    if (a < 0)
      throw "n:" + a;
    if (a < 26)
      return 65 + a;
    if (a < 52)
      return 97 + (a - 26);
    if (a < 62)
      return 48 + (a - 52);
    if (a == 62)
      return 43;
    if (a == 63)
      return 47;
    throw "n:" + a;
  };
  return s.writeByte = function(a) {
    for (t = t << 8 | a & 255, e += 8, r += 1; e >= 6; )
      o(t >>> e - 6), e -= 6;
  }, s.flush = function() {
    if (e > 0 && (o(t << 6 - e), t = 0, e = 0), r % 3 != 0) {
      const a = 3 - r % 3;
      for (let l = 0; l < a; l += 1)
        n += "=";
    }
  }, s.toString = function() {
    return n;
  }, s;
}, AE = function(t) {
  const e = t;
  let r = 0, n = 0, s = 0;
  const o = {};
  o.read = function() {
    for (; s < 8; ) {
      if (r >= e.length) {
        if (s == 0)
          return -1;
        throw "unexpected end of file./" + s;
      }
      const l = e.charAt(r);
      if (r += 1, l == "=")
        return s = 0, -1;
      if (l.match(/^\s$/))
        continue;
      n = n << 6 | i(l.charCodeAt(0)), s += 6;
    }
    const a = n >>> s - 8 & 255;
    return s -= 8, a;
  };
  const i = function(a) {
    if (65 <= a && a <= 90)
      return a - 65;
    if (97 <= a && a <= 122)
      return a - 97 + 26;
    if (48 <= a && a <= 57)
      return a - 48 + 52;
    if (a == 43)
      return 62;
    if (a == 47)
      return 63;
    throw "c:" + a;
  };
  return o;
}, EE = function(t, e) {
  const r = t, n = e, s = new Array(t * e), o = {};
  o.setPixel = function(u, c, f) {
    s[c * r + u] = f;
  }, o.write = function(u) {
    u.writeString("GIF87a"), u.writeShort(r), u.writeShort(n), u.writeByte(128), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(0), u.writeByte(255), u.writeByte(255), u.writeByte(255), u.writeString(","), u.writeShort(0), u.writeShort(0), u.writeShort(r), u.writeShort(n), u.writeByte(0);
    const c = 2, f = a(c);
    u.writeByte(c);
    let p = 0;
    for (; f.length - p > 255; )
      u.writeByte(255), u.writeBytes(f, p, 255), p += 255;
    u.writeByte(f.length - p), u.writeBytes(f, p, f.length - p), u.writeByte(0), u.writeString(";");
  };
  const i = function(u) {
    const c = u;
    let f = 0, p = 0;
    const _ = {};
    return _.write = function(b, g) {
      if (b >>> g)
        throw "length over";
      for (; f + g >= 8; )
        c.writeByte(255 & (b << f | p)), g -= 8 - f, b >>>= 8 - f, p = 0, f = 0;
      p = b << f | p, f = f + g;
    }, _.flush = function() {
      f > 0 && c.writeByte(p);
    }, _;
  }, a = function(u) {
    const c = 1 << u, f = (1 << u) + 1;
    let p = u + 1;
    const _ = l();
    for (let S = 0; S < c; S += 1)
      _.add(String.fromCharCode(S));
    _.add(String.fromCharCode(c)), _.add(String.fromCharCode(f));
    const b = O_(), g = i(b);
    g.write(c, p);
    let h = 0, y = String.fromCharCode(s[h]);
    for (h += 1; h < s.length; ) {
      const S = String.fromCharCode(s[h]);
      h += 1, _.contains(y + S) ? y = y + S : (g.write(_.indexOf(y), p), _.size() < 4095 && (_.size() == 1 << p && (p += 1), _.add(y + S)), y = S);
    }
    return g.write(_.indexOf(y), p), g.write(f, p), g.flush(), b.toByteArray();
  }, l = function() {
    const u = {};
    let c = 0;
    const f = {};
    return f.add = function(p) {
      if (f.contains(p))
        throw "dup key:" + p;
      u[p] = c, c += 1;
    }, f.size = function() {
      return c;
    }, f.indexOf = function(p) {
      return u[p];
    }, f.contains = function(p) {
      return typeof u[p] < "u";
    }, f;
  };
  return o;
}, TE = function(t, e, r) {
  const n = EE(t, e);
  for (let a = 0; a < e; a += 1)
    for (let l = 0; l < t; l += 1)
      n.setPixel(l, a, r(l, a));
  const s = O_();
  n.write(s);
  const o = $E(), i = s.toByteArray();
  for (let a = 0; a < i.length; a += 1)
    o.writeByte(i[a]);
  return o.flush(), "data:image/gif;base64," + o;
};
Io.stringToBytes;
var DE = /* @__PURE__ */ ne("<!> <p> </p>", 1), ME = /* @__PURE__ */ ne('<img class="aspect-square h-full w-full object-contain" alt="QR Code"/>'), IE = /* @__PURE__ */ ne("<p>Type something to generate a QR Code</p>"), NE = /* @__PURE__ */ ne('<div class="flex gap-4"><!> <div><!></div></div>');
function C_(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  function s(_, b = 20) {
    const g = Io(0, "L");
    return g.addData(_), g.make(), g.createDataURL(b);
  }
  const o = /* @__PURE__ */ C(() => {
    if (r())
      try {
        return s(r());
      } catch (_) {
        return new Error(xE(_));
      }
  });
  var i = {
    get value() {
      return r();
    },
    set value(_) {
      r(_), m();
    }
  }, a = NE(), l = he(a);
  Hd(l, ce(() => n, {
    get value() {
      return r();
    },
    set value(_) {
      r(_);
    }
  }));
  var u = be(l, 2), c = he(u);
  {
    var f = (_) => {
      var b = DE(), g = D(b);
      x_(g, { size: 20 });
      var h = be(g, 2), y = he(h, !0);
      de(h), ke(() => Me(y, d(o).message)), A(_, b);
    }, p = (_) => {
      var b = I(), g = D(b);
      {
        var h = (S) => {
          var x = ME();
          ke(() => Cn(x, "src", d(o))), A(S, x);
        }, y = (S) => {
          var x = IE();
          A(S, x);
        };
        ue(
          g,
          (S) => {
            d(o) ? S(h) : S(y, !1);
          },
          !0
        );
      }
      A(_, b);
    };
    ue(c, (_) => {
      d(o) instanceof Error ? _(f) : _(p, !1);
    });
  }
  return de(u), de(a), ke(() => Bs(u, 1, js([
    "aspect-square size-48 shrink-0 overflow-hidden rounded-md border bg-slate-50",
    "flex flex-col items-center justify-center gap-1",
    "text-center text-xs text-muted-foreground",
    (!d(o) || d(o) instanceof Error) && "p-3"
  ]))), A(t, a), W(i);
}
K(C_, { value: {} }, [], [], { mode: "open" });
Ux();
const FE = (t) => {
  g_(t, { size: 20 });
}, RE = (t) => {
  h_(t, { size: 20 });
}, om = (t) => {
  S_(t, { size: 20 });
}, VE = (t) => {
  b_(t, { size: 20 });
};
function LE(t) {
}
K(LE, {}, [], [], { mode: "open" });
const jE = {
  "move-array-item-up": FE,
  "move-array-item-down": RE,
  "remove-array-item": om,
  "copy-array-item": VE,
  "remove-object-property": om
}, BE = jE, zE = Ii(BE);
var qE = /\s+/g, UE = (t) => typeof t != "string" || !t ? t : t.replace(qE, " ").trim(), al = (...t) => {
  const e = [], r = (n) => {
    if (!n && n !== 0 && n !== 0n) return;
    if (Array.isArray(n)) {
      for (let o = 0, i = n.length; o < i; o++) r(n[o]);
      return;
    }
    const s = typeof n;
    if (s === "string" || s === "number" || s === "bigint") {
      if (s === "number" && n !== n) return;
      e.push(String(n));
    } else if (s === "object") {
      const o = Object.keys(n);
      for (let i = 0, a = o.length; i < a; i++) {
        const l = o[i];
        n[l] && e.push(l);
      }
    }
  };
  for (let n = 0, s = t.length; n < s; n++) {
    const o = t[n];
    o != null && r(o);
  }
  return e.length > 0 ? UE(e.join(" ")) : void 0;
}, im = (t) => t === !1 ? "false" : t === !0 ? "true" : t === 0 ? "0" : t, Gt = (t) => {
  if (!t || typeof t != "object") return !0;
  for (const e in t) return !1;
  return !0;
}, KE = (t, e) => {
  if (t === e) return !0;
  if (!t || !e) return !1;
  const r = Object.keys(t), n = Object.keys(e);
  if (r.length !== n.length) return !1;
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    if (!n.includes(o) || t[o] !== e[o]) return !1;
  }
  return !0;
}, HE = (t, e) => {
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const n = e[r];
      r in t ? t[r] = al(t[r], n) : t[r] = n;
    }
  return t;
}, k_ = (t, e) => {
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    Array.isArray(n) ? k_(n, e) : n && e.push(n);
  }
}, $_ = (...t) => {
  const e = [];
  k_(t, e);
  const r = [];
  for (let n = 0; n < e.length; n++)
    e[n] && r.push(e[n]);
  return r;
}, Dc = (t, e) => {
  const r = {};
  for (const n in t) {
    const s = t[n];
    if (n in e) {
      const o = e[n];
      Array.isArray(s) || Array.isArray(o) ? r[n] = $_(o, s) : typeof s == "object" && typeof o == "object" && s && o ? r[n] = Dc(s, o) : r[n] = o + " " + s;
    } else
      r[n] = s;
  }
  for (const n in e)
    n in t || (r[n] = e[n]);
  return r;
}, WE = {
  twMerge: !0,
  twMergeConfig: {}
};
function GE() {
  let t = null, e = {}, r = !1;
  return {
    get cachedTwMerge() {
      return t;
    },
    set cachedTwMerge(n) {
      t = n;
    },
    get cachedTwMergeConfig() {
      return e;
    },
    set cachedTwMergeConfig(n) {
      e = n;
    },
    get didTwMergeConfigChange() {
      return r;
    },
    set didTwMergeConfigChange(n) {
      r = n;
    },
    reset() {
      t = null, e = {}, r = !1;
    }
  };
}
var pn = GE(), YE = (t) => {
  const e = (n, s) => {
    const {
      extend: o = null,
      slots: i = {},
      variants: a = {},
      compoundVariants: l = [],
      compoundSlots: u = [],
      defaultVariants: c = {}
    } = n, f = { ...WE, ...s }, p = o?.base ? al(o.base, n?.base) : n?.base, _ = o?.variants && !Gt(o.variants) ? Dc(a, o.variants) : a, b = o?.defaultVariants && !Gt(o.defaultVariants) ? { ...o.defaultVariants, ...c } : c;
    !Gt(f.twMergeConfig) && !KE(f.twMergeConfig, pn.cachedTwMergeConfig) && (pn.didTwMergeConfigChange = !0, pn.cachedTwMergeConfig = f.twMergeConfig);
    const g = Gt(o?.slots), h = Gt(i) ? {} : {
      // add "base" to the slots object
      base: al(n?.base, g && o?.base),
      ...i
    }, y = g ? h : HE(
      { ...o?.slots },
      Gt(h) ? { base: n?.base } : h
    ), S = Gt(o?.compoundVariants) ? l : $_(o?.compoundVariants, l), x = (w) => {
      if (Gt(_) && Gt(i) && g)
        return t(p, w?.class, w?.className)(f);
      if (S && !Array.isArray(S))
        throw new TypeError(
          `The "compoundVariants" prop must be an array. Received: ${typeof S}`
        );
      if (u && !Array.isArray(u))
        throw new TypeError(
          `The "compoundSlots" prop must be an array. Received: ${typeof u}`
        );
      const O = (B, F = _, Z = null, Y = null) => {
        const X = F[B];
        if (!X || Gt(X))
          return null;
        const ae = Y?.[B] ?? w?.[B];
        if (ae === null) return null;
        const J = im(ae);
        if (typeof J == "object")
          return null;
        const j = b?.[B], ee = J ?? im(j);
        return X[ee || "false"];
      }, k = () => {
        if (!_) return null;
        const B = Object.keys(_), F = [];
        for (let Z = 0; Z < B.length; Z++) {
          const Y = O(B[Z], _);
          Y && F.push(Y);
        }
        return F;
      }, $ = (B, F) => {
        if (!_ || typeof _ != "object") return null;
        const Z = [];
        for (const Y in _) {
          const X = O(Y, _, B, F), ae = B === "base" && typeof X == "string" ? X : X && X[B];
          ae && Z.push(ae);
        }
        return Z;
      }, T = {};
      for (const B in w) {
        const F = w[B];
        F !== void 0 && (T[B] = F);
      }
      const E = (B, F) => {
        const Z = typeof w?.[B] == "object" ? {
          [B]: w[B]?.initial
        } : {};
        return {
          ...b,
          ...T,
          ...Z,
          ...F
        };
      }, M = (B = [], F) => {
        const Z = [], Y = B.length;
        for (let X = 0; X < Y; X++) {
          const { class: ae, className: J, ...j } = B[X];
          let ee = !0;
          const L = E(null, F);
          for (const N in j) {
            const V = j[N], G = L[N];
            if (Array.isArray(V)) {
              if (!V.includes(G)) {
                ee = !1;
                break;
              }
            } else {
              if ((V == null || V === !1) && (G == null || G === !1))
                continue;
              if (G !== V) {
                ee = !1;
                break;
              }
            }
          }
          ee && (ae && Z.push(ae), J && Z.push(J));
        }
        return Z;
      }, R = (B) => {
        const F = M(S, B);
        if (!Array.isArray(F)) return F;
        const Z = {}, Y = t;
        for (let X = 0; X < F.length; X++) {
          const ae = F[X];
          if (typeof ae == "string")
            Z.base = Y(Z.base, ae)(f);
          else if (typeof ae == "object")
            for (const J in ae)
              Z[J] = Y(Z[J], ae[J])(f);
        }
        return Z;
      }, U = (B) => {
        if (u.length < 1) return null;
        const F = {}, Z = E(null, B);
        for (let Y = 0; Y < u.length; Y++) {
          const {
            slots: X = [],
            class: ae,
            className: J,
            ...j
          } = u[Y];
          if (!Gt(j)) {
            let ee = !0;
            for (const L in j) {
              const N = Z[L], V = j[L];
              if (N === void 0 || (Array.isArray(V) ? !V.includes(N) : V !== N)) {
                ee = !1;
                break;
              }
            }
            if (!ee) continue;
          }
          for (let ee = 0; ee < X.length; ee++) {
            const L = X[ee];
            F[L] || (F[L] = []), F[L].push([ae, J]);
          }
        }
        return F;
      };
      if (!Gt(i) || !g) {
        const B = {};
        if (typeof y == "object" && !Gt(y)) {
          const F = t;
          for (const Z in y)
            B[Z] = (Y) => {
              const X = R(Y), ae = U(Y);
              return F(
                y[Z],
                $(Z, Y),
                X ? X[Z] : void 0,
                ae ? ae[Z] : void 0,
                Y?.class,
                Y?.className
              )(f);
            };
        }
        return B;
      }
      return t(
        p,
        k(),
        M(S),
        w?.class,
        w?.className
      )(f);
    }, P = () => {
      if (!(!_ || typeof _ != "object"))
        return Object.keys(_);
    };
    return x.variantKeys = P(), x.extend = o, x.base = p, x.slots = y, x.variants = _, x.defaultVariants = b, x.compoundSlots = u, x.compoundVariants = S, x;
  };
  return {
    tv: e,
    createTV: (n) => (s, o) => e(s, o ? Dc(n, o) : n)
  };
};
const XE = (t, e) => {
  const r = new Array(t.length + e.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t[n];
  for (let n = 0; n < e.length; n++)
    r[t.length + n] = e[n];
  return r;
}, JE = (t, e) => ({
  classGroupId: t,
  validator: e
}), A_ = (t = /* @__PURE__ */ new Map(), e = null, r) => ({
  nextPart: t,
  validators: e,
  classGroupId: r
}), ll = "-", am = [], ZE = "arbitrary..", QE = (t) => {
  const e = t7(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (i) => {
      if (i.startsWith("[") && i.endsWith("]"))
        return e7(i);
      const a = i.split(ll), l = a[0] === "" && a.length > 1 ? 1 : 0;
      return E_(a, l, e);
    },
    getConflictingClassGroupIds: (i, a) => {
      if (a) {
        const l = n[i], u = r[i];
        return l ? u ? XE(u, l) : l : u || am;
      }
      return r[i] || am;
    }
  };
}, E_ = (t, e, r) => {
  if (t.length - e === 0)
    return r.classGroupId;
  const s = t[e], o = r.nextPart.get(s);
  if (o) {
    const u = E_(t, e + 1, o);
    if (u) return u;
  }
  const i = r.validators;
  if (i === null)
    return;
  const a = e === 0 ? t.join(ll) : t.slice(e).join(ll), l = i.length;
  for (let u = 0; u < l; u++) {
    const c = i[u];
    if (c.validator(a))
      return c.classGroupId;
  }
}, e7 = (t) => t.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const e = t.slice(1, -1), r = e.indexOf(":"), n = e.slice(0, r);
  return n ? ZE + n : void 0;
})(), t7 = (t) => {
  const {
    theme: e,
    classGroups: r
  } = t;
  return r7(r, e);
}, r7 = (t, e) => {
  const r = A_();
  for (const n in t) {
    const s = t[n];
    Yd(s, r, n, e);
  }
  return r;
}, Yd = (t, e, r, n) => {
  const s = t.length;
  for (let o = 0; o < s; o++) {
    const i = t[o];
    n7(i, e, r, n);
  }
}, n7 = (t, e, r, n) => {
  if (typeof t == "string") {
    s7(t, e, r);
    return;
  }
  if (typeof t == "function") {
    o7(t, e, r, n);
    return;
  }
  i7(t, e, r, n);
}, s7 = (t, e, r) => {
  const n = t === "" ? e : T_(e, t);
  n.classGroupId = r;
}, o7 = (t, e, r, n) => {
  if (a7(t)) {
    Yd(t(n), e, r, n);
    return;
  }
  e.validators === null && (e.validators = []), e.validators.push(JE(r, t));
}, i7 = (t, e, r, n) => {
  const s = Object.entries(t), o = s.length;
  for (let i = 0; i < o; i++) {
    const [a, l] = s[i];
    Yd(l, T_(e, a), r, n);
  }
}, T_ = (t, e) => {
  let r = t;
  const n = e.split(ll), s = n.length;
  for (let o = 0; o < s; o++) {
    const i = n[o];
    let a = r.nextPart.get(i);
    a || (a = A_(), r.nextPart.set(i, a)), r = a;
  }
  return r;
}, a7 = (t) => "isThemeGetter" in t && t.isThemeGetter === !0, l7 = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  const s = (o, i) => {
    r[o] = i, e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let i = r[o];
      if (i !== void 0)
        return i;
      if ((i = n[o]) !== void 0)
        return s(o, i), i;
    },
    set(o, i) {
      o in r ? r[o] = i : s(o, i);
    }
  };
}, Mc = "!", lm = ":", u7 = [], um = (t, e, r, n, s) => ({
  modifiers: t,
  hasImportantModifier: e,
  baseClassName: r,
  maybePostfixModifierPosition: n,
  isExternal: s
}), c7 = (t) => {
  const {
    prefix: e,
    experimentalParseClassName: r
  } = t;
  let n = (s) => {
    const o = [];
    let i = 0, a = 0, l = 0, u;
    const c = s.length;
    for (let g = 0; g < c; g++) {
      const h = s[g];
      if (i === 0 && a === 0) {
        if (h === lm) {
          o.push(s.slice(l, g)), l = g + 1;
          continue;
        }
        if (h === "/") {
          u = g;
          continue;
        }
      }
      h === "[" ? i++ : h === "]" ? i-- : h === "(" ? a++ : h === ")" && a--;
    }
    const f = o.length === 0 ? s : s.slice(l);
    let p = f, _ = !1;
    f.endsWith(Mc) ? (p = f.slice(0, -1), _ = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(Mc) && (p = f.slice(1), _ = !0)
    );
    const b = u && u > l ? u - l : void 0;
    return um(o, _, p, b);
  };
  if (e) {
    const s = e + lm, o = n;
    n = (i) => i.startsWith(s) ? o(i.slice(s.length)) : um(u7, !1, i, void 0, !0);
  }
  if (r) {
    const s = n;
    n = (o) => r({
      className: o,
      parseClassName: s
    });
  }
  return n;
}, d7 = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.orderSensitiveModifiers.forEach((r, n) => {
    e.set(r, 1e6 + n);
  }), (r) => {
    const n = [];
    let s = [];
    for (let o = 0; o < r.length; o++) {
      const i = r[o], a = i[0] === "[", l = e.has(i);
      a || l ? (s.length > 0 && (s.sort(), n.push(...s), s = []), n.push(i)) : s.push(i);
    }
    return s.length > 0 && (s.sort(), n.push(...s)), n;
  };
}, f7 = (t) => ({
  cache: l7(t.cacheSize),
  parseClassName: c7(t),
  sortModifiers: d7(t),
  ...QE(t)
}), h7 = /\s+/, g7 = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: s,
    sortModifiers: o
  } = e, i = [], a = t.trim().split(h7);
  let l = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const c = a[u], {
      isExternal: f,
      modifiers: p,
      hasImportantModifier: _,
      baseClassName: b,
      maybePostfixModifierPosition: g
    } = r(c);
    if (f) {
      l = c + (l.length > 0 ? " " + l : l);
      continue;
    }
    let h = !!g, y = n(h ? b.substring(0, g) : b);
    if (!y) {
      if (!h) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      if (y = n(b), !y) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      h = !1;
    }
    const S = p.length === 0 ? "" : p.length === 1 ? p[0] : o(p).join(":"), x = _ ? S + Mc : S, P = x + y;
    if (i.indexOf(P) > -1)
      continue;
    i.push(P);
    const w = s(y, h);
    for (let O = 0; O < w.length; ++O) {
      const k = w[O];
      i.push(x + k);
    }
    l = c + (l.length > 0 ? " " + l : l);
  }
  return l;
}, p7 = (...t) => {
  let e = 0, r, n, s = "";
  for (; e < t.length; )
    (r = t[e++]) && (n = D_(r)) && (s && (s += " "), s += n);
  return s;
}, D_ = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = D_(t[n])) && (r && (r += " "), r += e);
  return r;
}, Ic = (t, ...e) => {
  let r, n, s, o;
  const i = (l) => {
    const u = e.reduce((c, f) => f(c), t());
    return r = f7(u), n = r.cache.get, s = r.cache.set, o = a, a(l);
  }, a = (l) => {
    const u = n(l);
    if (u)
      return u;
    const c = g7(l, r);
    return s(l, c), c;
  };
  return o = i, (...l) => o(p7(...l));
}, m7 = [], bt = (t) => {
  const e = (r) => r[t] || m7;
  return e.isThemeGetter = !0, e;
}, M_ = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, I_ = /^\((?:(\w[\w-]*):)?(.+)\)$/i, v7 = /^\d+\/\d+$/, y7 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, b7 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, _7 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, w7 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, S7 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Zs = (t) => v7.test(t), Ue = (t) => !!t && !Number.isNaN(Number(t)), jn = (t) => !!t && Number.isInteger(Number(t)), Ku = (t) => t.endsWith("%") && Ue(t.slice(0, -1)), hn = (t) => y7.test(t), x7 = () => !0, P7 = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  b7.test(t) && !_7.test(t)
), N_ = () => !1, O7 = (t) => w7.test(t), C7 = (t) => S7.test(t), k7 = (t) => !$e(t) && !Ae(t), $7 = (t) => No(t, V_, N_), $e = (t) => M_.test(t), ys = (t) => No(t, L_, P7), Hu = (t) => No(t, M7, Ue), cm = (t) => No(t, F_, N_), A7 = (t) => No(t, R_, C7), Ta = (t) => No(t, j_, O7), Ae = (t) => I_.test(t), ei = (t) => Fo(t, L_), E7 = (t) => Fo(t, I7), dm = (t) => Fo(t, F_), T7 = (t) => Fo(t, V_), D7 = (t) => Fo(t, R_), Da = (t) => Fo(t, j_, !0), No = (t, e, r) => {
  const n = M_.exec(t);
  return n ? n[1] ? e(n[1]) : r(n[2]) : !1;
}, Fo = (t, e, r = !1) => {
  const n = I_.exec(t);
  return n ? n[1] ? e(n[1]) : r : !1;
}, F_ = (t) => t === "position" || t === "percentage", R_ = (t) => t === "image" || t === "url", V_ = (t) => t === "length" || t === "size" || t === "bg-size", L_ = (t) => t === "length", M7 = (t) => t === "number", I7 = (t) => t === "family-name", j_ = (t) => t === "shadow", Nc = () => {
  const t = bt("color"), e = bt("font"), r = bt("text"), n = bt("font-weight"), s = bt("tracking"), o = bt("leading"), i = bt("breakpoint"), a = bt("container"), l = bt("spacing"), u = bt("radius"), c = bt("shadow"), f = bt("inset-shadow"), p = bt("text-shadow"), _ = bt("drop-shadow"), b = bt("blur"), g = bt("perspective"), h = bt("aspect"), y = bt("ease"), S = bt("animate"), x = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], P = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], w = () => [...P(), Ae, $e], O = () => ["auto", "hidden", "clip", "visible", "scroll"], k = () => ["auto", "contain", "none"], $ = () => [Ae, $e, l], T = () => [Zs, "full", "auto", ...$()], E = () => [jn, "none", "subgrid", Ae, $e], M = () => ["auto", {
    span: ["full", jn, Ae, $e]
  }, jn, Ae, $e], R = () => [jn, "auto", Ae, $e], U = () => ["auto", "min", "max", "fr", Ae, $e], B = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], F = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], Z = () => ["auto", ...$()], Y = () => [Zs, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...$()], X = () => [t, Ae, $e], ae = () => [...P(), dm, cm, {
    position: [Ae, $e]
  }], J = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], j = () => ["auto", "cover", "contain", T7, $7, {
    size: [Ae, $e]
  }], ee = () => [Ku, ei, ys], L = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    u,
    Ae,
    $e
  ], N = () => ["", Ue, ei, ys], V = () => ["solid", "dashed", "dotted", "double"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], fe = () => [Ue, Ku, dm, cm], se = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    b,
    Ae,
    $e
  ], we = () => ["none", Ue, Ae, $e], le = () => ["none", Ue, Ae, $e], re = () => [Ue, Ae, $e], oe = () => [Zs, "full", ...$()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [hn],
      breakpoint: [hn],
      color: [x7],
      container: [hn],
      "drop-shadow": [hn],
      ease: ["in", "out", "in-out"],
      font: [k7],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [hn],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [hn],
      shadow: [hn],
      spacing: ["px", Ue],
      text: [hn],
      "text-shadow": [hn],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", Zs, $e, Ae, h]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ue, $e, Ae, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": x()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": x()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: w()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: O()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": O()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": O()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: k()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": k()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": k()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: T()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": T()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": T()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: T()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: T()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: T()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: T()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: T()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: T()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [jn, "auto", Ae, $e]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [Zs, "full", "auto", a, ...$()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Ue, Zs, "auto", "initial", "none", $e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Ue, Ae, $e]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Ue, Ae, $e]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [jn, "first", "last", "none", Ae, $e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": E()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: M()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": R()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": R()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": E()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: M()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": R()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": R()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": U()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": U()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: $()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": $()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": $()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...B(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...F(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...F()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...B()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...F(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...F(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": B()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...F(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...F()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: $()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: $()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: $()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: $()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: $()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: $()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: $()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: $()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: $()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: Z()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: Z()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: Z()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: Z()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: Z()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: Z()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: Z()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: Z()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: Z()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": $()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": $()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Y()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...Y()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Y()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [i]
          },
          ...Y()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Y()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Y()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Y()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", r, ei, ys]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [n, Ae, Hu]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Ku, $e]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [E7, $e, e]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [s, Ae, $e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Ue, "none", Ae, Hu]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...$()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ae, $e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", Ae, $e]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: X()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: X()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...V(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Ue, "from-font", "auto", Ae, ys]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: X()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Ue, "auto", Ae, $e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: $()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ae, $e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ae, $e]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: ae()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: J()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: j()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, jn, Ae, $e],
          radial: ["", Ae, $e],
          conic: [jn, Ae, $e]
        }, D7, A7]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: X()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: ee()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: ee()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: ee()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: X()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: L()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": L()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": L()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": L()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": L()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": L()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": L()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": L()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": L()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": L()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": L()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": L()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": L()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": L()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": L()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: N()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": N()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": N()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": N()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": N()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": N()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": N()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": N()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": N()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": N()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": N()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...V(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...V(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: X()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": X()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": X()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": X()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": X()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": X()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": X()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": X()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": X()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: X()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...V(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ue, Ae, $e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Ue, ei, ys]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: X()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          Da,
          Ta
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: X()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, Da, Ta]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": X()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: N()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: X()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Ue, ys]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": X()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": N()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": X()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", p, Da, Ta]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": X()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Ue, Ae, $e]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...G(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": G()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Ue]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": fe()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": fe()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": X()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": X()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": fe()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": fe()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": X()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": X()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": fe()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": fe()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": X()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": X()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": fe()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": fe()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": X()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": X()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": fe()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": fe()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": X()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": X()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": fe()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": fe()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": X()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": X()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": fe()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": fe()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": X()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": X()
      }],
      "mask-image-radial": [{
        "mask-radial": [Ae, $e]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": fe()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": fe()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": X()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": X()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": P()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Ue]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": fe()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": fe()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": X()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": X()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: ae()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: J()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: j()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", Ae, $e]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Ae,
          $e
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: se()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ue, Ae, $e]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Ue, Ae, $e]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          _,
          Da,
          Ta
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": X()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Ue, Ae, $e]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Ue, Ae, $e]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Ue, Ae, $e]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ue, Ae, $e]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Ae,
          $e
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": se()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Ue, Ae, $e]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ue, Ae, $e]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Ue, Ae, $e]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": $()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": $()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": $()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Ae, $e]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Ue, "initial", Ae, $e]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", y, Ae, $e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Ue, Ae, $e]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, Ae, $e]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [g, Ae, $e]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": w()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: we()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": we()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": we()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": we()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: le()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": le()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": le()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": le()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: re()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": re()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": re()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [Ae, $e, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: w()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: oe()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": oe()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": oe()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": oe()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: X()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: X()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ae, $e]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": $()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": $()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": $()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": $()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": $()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": $()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": $()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": $()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": $()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": $()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": $()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": $()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": $()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": $()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": $()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": $()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": $()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": $()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ae, $e]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...X()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ue, ei, ys, Hu]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...X()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, N7 = (t, {
  cacheSize: e,
  prefix: r,
  experimentalParseClassName: n,
  extend: s = {},
  override: o = {}
}) => (ai(t, "cacheSize", e), ai(t, "prefix", r), ai(t, "experimentalParseClassName", n), Ma(t.theme, o.theme), Ma(t.classGroups, o.classGroups), Ma(t.conflictingClassGroups, o.conflictingClassGroups), Ma(t.conflictingClassGroupModifiers, o.conflictingClassGroupModifiers), ai(t, "orderSensitiveModifiers", o.orderSensitiveModifiers), Ia(t.theme, s.theme), Ia(t.classGroups, s.classGroups), Ia(t.conflictingClassGroups, s.conflictingClassGroups), Ia(t.conflictingClassGroupModifiers, s.conflictingClassGroupModifiers), B_(t, s, "orderSensitiveModifiers"), t), ai = (t, e, r) => {
  r !== void 0 && (t[e] = r);
}, Ma = (t, e) => {
  if (e)
    for (const r in e)
      ai(t, r, e[r]);
}, Ia = (t, e) => {
  if (e)
    for (const r in e)
      B_(t, e, r);
}, B_ = (t, e, r) => {
  const n = e[r];
  n !== void 0 && (t[r] = t[r] ? t[r].concat(n) : n);
}, F7 = (t, ...e) => typeof t == "function" ? Ic(Nc, t, ...e) : Ic(() => N7(Nc(), t), ...e), Xd = /* @__PURE__ */ Ic(Nc);
var R7 = (t) => Gt(t) ? Xd : F7({
  ...t,
  extend: {
    theme: t.theme,
    classGroups: t.classGroups,
    conflictingClassGroupModifiers: t.conflictingClassGroupModifiers,
    conflictingClassGroups: t.conflictingClassGroups,
    ...t.extend
  }
}), V7 = (t, e) => {
  const r = al(t);
  return !r || !(e?.twMerge ?? !0) ? r : ((!pn.cachedTwMerge || pn.didTwMergeConfigChange) && (pn.didTwMergeConfigChange = !1, pn.cachedTwMerge = R7(pn.cachedTwMergeConfig)), pn.cachedTwMerge(r) || void 0);
}, L7 = (...t) => (e) => V7(t, e), { tv: Ri } = YE(L7);
function Se(...t) {
  return Xd(so(t));
}
const j7 = Ri({
  base: "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*]:focus-visible:relative [&>*]:focus-visible:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-e-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  variants: {
    orientation: {
      horizontal: "[&>*:not(:first-child)]:rounded-s-none [&>*:not(:first-child)]:border-s-0 [&>*:not(:last-child)]:rounded-e-none",
      vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
    }
  },
  defaultVariants: { orientation: "horizontal" }
});
var B7 = /* @__PURE__ */ ne("<div><!></div>");
function z_(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "orientation", 7, "horizontal"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "orientation"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get orientation() {
      return o();
    },
    set orientation(c = "horizontal") {
      o(c), m();
    }
  }, l = B7();
  ve(
    l,
    (c) => ({
      role: "group",
      "data-slot": "button-group",
      "data-orientation": o(),
      class: c,
      ...i
    }),
    [
      () => Se(j7({ orientation: o() }), n())
    ]
  );
  var u = he(l);
  return te(u, () => s() ?? ge), de(l), et(l, (c) => r(c), () => r()), A(t, l), W(a);
}
K(z_, { ref: {}, class: {}, children: {}, orientation: {} }, [], [], { mode: "open" });
var z7 = /* @__PURE__ */ ne("<div><!></div>");
function q7(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "child", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "child"
  ]);
  const i = /* @__PURE__ */ C(() => ({
    ...o,
    class: Se("bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4", n())
  }));
  var a = {
    get ref() {
      return r();
    },
    set ref(p = null) {
      r(p), m();
    },
    get class() {
      return n();
    },
    set class(p) {
      n(p), m();
    },
    get child() {
      return s();
    },
    set child(p) {
      s(p), m();
    }
  }, l = I(), u = D(l);
  {
    var c = (p) => {
      var _ = I(), b = D(_);
      te(b, s, () => ({ props: d(i) })), A(p, _);
    }, f = (p) => {
      var _ = z7();
      ve(_, () => ({ ...d(i) }));
      var b = he(_);
      te(b, () => d(i).children ?? ge), de(_), et(_, (g) => r(g), () => r()), A(p, _);
    };
    ue(u, (p) => {
      s() ? p(c) : p(f, !1);
    });
  }
  return A(t, l), W(a);
}
K(q7, { ref: {}, class: {}, child: {} }, [], [], { mode: "open" });
function U7(t) {
  return typeof t == "function";
}
function Vi(t) {
  return t !== null && typeof t == "object";
}
const K7 = ["string", "number", "bigint", "boolean"];
function Fc(t) {
  return t == null || K7.includes(typeof t) ? !0 : Array.isArray(t) ? t.every((e) => Fc(e)) : typeof t == "object" ? Object.getPrototypeOf(t) === Object.prototype : !1;
}
const bo = /* @__PURE__ */ Symbol("box"), nu = /* @__PURE__ */ Symbol("is-writable");
function z(t, e) {
  const r = /* @__PURE__ */ C(t);
  return e ? {
    [bo]: !0,
    [nu]: !0,
    get current() {
      return d(r);
    },
    set current(n) {
      e(n);
    }
  } : {
    [bo]: !0,
    get current() {
      return t();
    }
  };
}
function Li(t) {
  return Vi(t) && bo in t;
}
function Jd(t) {
  return Li(t) && nu in t;
}
function q_(t) {
  return Li(t) ? t : U7(t) ? z(t) : Gr(t);
}
function H7(t) {
  return Object.entries(t).reduce(
    (e, [r, n]) => Li(n) ? (Jd(n) ? Object.defineProperty(e, r, {
      get() {
        return n.current;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(s) {
        n.current = s;
      }
    }) : Object.defineProperty(e, r, {
      get() {
        return n.current;
      }
    }), e) : Object.assign(e, { [r]: n }),
    {}
  );
}
function W7(t) {
  return Jd(t) ? {
    [bo]: !0,
    get current() {
      return t.current;
    }
  } : t;
}
function Gr(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    [bo]: !0,
    [nu]: !0,
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
function Hs(t) {
  let e = /* @__PURE__ */ xe(Pt(t));
  return {
    [bo]: !0,
    [nu]: !0,
    get current() {
      return d(e);
    },
    set current(r) {
      q(e, r, !0);
    }
  };
}
Hs.from = q_;
Hs.with = z;
Hs.flatten = H7;
Hs.readonly = W7;
Hs.isBox = Li;
Hs.isWritableBox = Jd;
function U_(...t) {
  return function(e) {
    for (const r of t)
      if (r) {
        if (e.defaultPrevented)
          return;
        typeof r == "function" ? r.call(this, e) : r.current?.call(this, e);
      }
  };
}
var fm = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, G7 = /\n/g, Y7 = /^\s*/, X7 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, J7 = /^:\s*/, Z7 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Q7 = /^[;\s]*/, e2 = /^\s+|\s+$/g, t2 = `
`, hm = "/", gm = "*", _s = "", r2 = "comment", n2 = "declaration";
function s2(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var r = 1, n = 1;
  function s(b) {
    var g = b.match(G7);
    g && (r += g.length);
    var h = b.lastIndexOf(t2);
    n = ~h ? b.length - h : n + b.length;
  }
  function o() {
    var b = { line: r, column: n };
    return function(g) {
      return g.position = new i(b), u(), g;
    };
  }
  function i(b) {
    this.start = b, this.end = { line: r, column: n }, this.source = e.source;
  }
  i.prototype.content = t;
  function a(b) {
    var g = new Error(
      e.source + ":" + r + ":" + n + ": " + b
    );
    if (g.reason = b, g.filename = e.source, g.line = r, g.column = n, g.source = t, !e.silent) throw g;
  }
  function l(b) {
    var g = b.exec(t);
    if (g) {
      var h = g[0];
      return s(h), t = t.slice(h.length), g;
    }
  }
  function u() {
    l(Y7);
  }
  function c(b) {
    var g;
    for (b = b || []; g = f(); )
      g !== !1 && b.push(g);
    return b;
  }
  function f() {
    var b = o();
    if (!(hm != t.charAt(0) || gm != t.charAt(1))) {
      for (var g = 2; _s != t.charAt(g) && (gm != t.charAt(g) || hm != t.charAt(g + 1)); )
        ++g;
      if (g += 2, _s === t.charAt(g - 1))
        return a("End of comment missing");
      var h = t.slice(2, g - 2);
      return n += 2, s(h), t = t.slice(g), n += 2, b({
        type: r2,
        comment: h
      });
    }
  }
  function p() {
    var b = o(), g = l(X7);
    if (g) {
      if (f(), !l(J7)) return a("property missing ':'");
      var h = l(Z7), y = b({
        type: n2,
        property: pm(g[0].replace(fm, _s)),
        value: h ? pm(h[0].replace(fm, _s)) : _s
      });
      return l(Q7), y;
    }
  }
  function _() {
    var b = [];
    c(b);
    for (var g; g = p(); )
      g !== !1 && (b.push(g), c(b));
    return b;
  }
  return u(), _();
}
function pm(t) {
  return t ? t.replace(e2, _s) : _s;
}
function o2(t, e) {
  let r = null;
  if (!t || typeof t != "string")
    return r;
  const n = s2(t), s = typeof e == "function";
  return n.forEach((o) => {
    if (o.type !== "declaration")
      return;
    const { property: i, value: a } = o;
    s ? e(i, a, o) : a && (r = r || {}, r[i] = a);
  }), r;
}
const i2 = /\d/, a2 = ["-", "_", "/", "."];
function l2(t = "") {
  if (!i2.test(t))
    return t !== t.toLowerCase();
}
function u2(t) {
  const e = [];
  let r = "", n, s;
  for (const o of t) {
    const i = a2.includes(o);
    if (i === !0) {
      e.push(r), r = "", n = void 0;
      continue;
    }
    const a = l2(o);
    if (s === !1) {
      if (n === !1 && a === !0) {
        e.push(r), r = o, n = a;
        continue;
      }
      if (n === !0 && a === !1 && r.length > 1) {
        const l = r.at(-1);
        e.push(r.slice(0, Math.max(0, r.length - 1))), r = l + o, n = a;
        continue;
      }
    }
    r += o, n = a, s = i;
  }
  return e.push(r), e;
}
function K_(t) {
  return t ? u2(t).map((e) => d2(e)).join("") : "";
}
function c2(t) {
  return f2(K_(t || ""));
}
function d2(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
function f2(t) {
  return t ? t[0].toLowerCase() + t.slice(1) : "";
}
function li(t) {
  if (!t)
    return {};
  const e = {};
  function r(n, s) {
    if (n.startsWith("-moz-") || n.startsWith("-webkit-") || n.startsWith("-ms-") || n.startsWith("-o-")) {
      e[K_(n)] = s;
      return;
    }
    if (n.startsWith("--")) {
      e[n] = s;
      return;
    }
    e[c2(n)] = s;
  }
  return o2(t, r), e;
}
function ks(...t) {
  return (...e) => {
    for (const r of t)
      typeof r == "function" && r(...e);
  };
}
function h2(t, e) {
  const r = RegExp(t, "g");
  return (n) => {
    if (typeof n != "string")
      throw new TypeError(`expected an argument of type string, but got ${typeof n}`);
    return n.match(r) ? n.replace(r, e) : n;
  };
}
const g2 = h2(/[A-Z]/, (t) => `-${t.toLowerCase()}`);
function p2(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw new TypeError(`expected an argument of type object, but got ${typeof t}`);
  return Object.keys(t).map((e) => `${g2(e)}: ${t[e]};`).join(`
`);
}
function su(t = {}) {
  return p2(t).replace(`
`, " ");
}
const m2 = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
], v2 = new Set(m2);
function y2(t) {
  return v2.has(t);
}
function Ce(...t) {
  const e = { ...t[0] };
  for (let r = 1; r < t.length; r++) {
    const n = t[r];
    if (n) {
      for (const s of Object.keys(n)) {
        const o = e[s], i = n[s], a = typeof o == "function", l = typeof i == "function";
        if (a && y2(s)) {
          const u = o, c = i;
          e[s] = U_(u, c);
        } else if (a && l)
          e[s] = ks(o, i);
        else if (s === "class") {
          const u = Fc(o), c = Fc(i);
          u && c ? e[s] = so(o, i) : u ? e[s] = so(o) : c && (e[s] = so(i));
        } else if (s === "style") {
          const u = typeof o == "object", c = typeof i == "object", f = typeof o == "string", p = typeof i == "string";
          if (u && c)
            e[s] = { ...o, ...i };
          else if (u && p) {
            const _ = li(i);
            e[s] = { ...o, ..._ };
          } else if (f && c) {
            const _ = li(o);
            e[s] = { ..._, ...i };
          } else if (f && p) {
            const _ = li(o), b = li(i);
            e[s] = { ..._, ...b };
          } else u ? e[s] = o : c ? e[s] = i : f ? e[s] = o : p && (e[s] = i);
        } else
          e[s] = i !== void 0 ? i : o;
      }
      for (const s of Object.getOwnPropertySymbols(n)) {
        const o = e[s], i = n[s];
        e[s] = i !== void 0 ? i : o;
      }
    }
  }
  return typeof e.style == "object" && (e.style = su(e.style).replaceAll(`
`, " ")), e.hidden === !1 && (e.hidden = void 0, delete e.hidden), e.disabled === !1 && (e.disabled = void 0, delete e.disabled), e;
}
const H_ = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
}, W_ = su(H_), G_ = typeof window < "u" ? window : void 0;
function b2(t) {
  let e = t.activeElement;
  for (; e?.shadowRoot; ) {
    const r = e.shadowRoot.activeElement;
    if (r === e)
      break;
    e = r;
  }
  return e;
}
class _2 {
  #e;
  #t;
  constructor(e = {}) {
    const { window: r = G_, document: n = r?.document } = e;
    r !== void 0 && (this.#e = n, this.#t = ld((s) => {
      const o = Ye(r, "focusin", s), i = Ye(r, "focusout", s);
      return () => {
        o(), i();
      };
    }));
  }
  get current() {
    return this.#t?.(), this.#e ? b2(this.#e) : null;
  }
}
new _2();
function w2(t) {
  return typeof t == "function";
}
class ht {
  #e;
  #t;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(e) {
    this.#e = e, this.#t = Symbol(e);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#t;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return Hx(this.#t);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const e = Es(this.#t);
    if (e === void 0)
      throw new Error(`Context "${this.#e}" not found`);
    return e;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(e) {
    const r = Es(this.#t);
    return r === void 0 ? e : r;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(e) {
    return Po(this.#t, e);
  }
}
function S2(t, e) {
  switch (t) {
    case "post":
      Ze(e);
      break;
    case "pre":
      Co(e);
      break;
  }
}
function Y_(t, e, r, n = {}) {
  const { lazy: s = !1 } = n;
  let o = !s, i = Array.isArray(t) ? [] : void 0;
  S2(e, () => {
    const a = Array.isArray(t) ? t.map((u) => u()) : t();
    if (!o) {
      o = !0, i = a;
      return;
    }
    const l = ot(() => r(a, i));
    return i = a, l;
  });
}
function Ne(t, e, r) {
  Y_(t, "post", e, r);
}
function x2(t, e, r) {
  Y_(t, "pre", e, r);
}
Ne.pre = x2;
function mm(t) {
  return w2(t) ? t() : t;
}
class P2 {
  // no need to use `$state` here since we are using createSubscriber
  #e = { width: 0, height: 0 };
  #t = !1;
  #r;
  #n;
  #s;
  // we use a derived here to extract the width so that if the width doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #o = /* @__PURE__ */ C(() => (d(this.#a)?.(), this.getSize().width));
  // we use a derived here to extract the height so that if the height doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #i = /* @__PURE__ */ C(() => (d(this.#a)?.(), this.getSize().height));
  // we need to use a derived here because the class will be created before the node is bound to the ref
  #a = /* @__PURE__ */ C(() => {
    const e = mm(this.#n);
    if (e)
      return ld((r) => {
        if (!this.#s) return;
        const n = new this.#s.ResizeObserver((s) => {
          this.#t = !0;
          for (const o of s) {
            const i = this.#r.box === "content-box" ? o.contentBoxSize : o.borderBoxSize, a = Array.isArray(i) ? i : [i];
            this.#e.width = a.reduce((l, u) => Math.max(l, u.inlineSize), 0), this.#e.height = a.reduce((l, u) => Math.max(l, u.blockSize), 0);
          }
          r();
        });
        return n.observe(e), () => {
          this.#t = !1, n.disconnect();
        };
      });
  });
  constructor(e, r = { box: "border-box" }) {
    this.#s = r.window ?? G_, this.#r = r, this.#n = e, this.#e = { width: 0, height: 0 };
  }
  calculateSize() {
    const e = mm(this.#n);
    if (!e || !this.#s)
      return;
    const r = e.offsetWidth, n = e.offsetHeight;
    if (this.#r.box === "border-box")
      return { width: r, height: n };
    const s = this.#s.getComputedStyle(e), o = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight), i = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom), a = parseFloat(s.borderLeftWidth) + parseFloat(s.borderRightWidth), l = parseFloat(s.borderTopWidth) + parseFloat(s.borderBottomWidth), u = r - o - a, c = n - i - l;
    return { width: u, height: c };
  }
  getSize() {
    return this.#t ? this.#e : this.calculateSize() ?? this.#e;
  }
  get current() {
    return d(this.#a)?.(), this.getSize();
  }
  get width() {
    return d(this.#o);
  }
  get height() {
    return d(this.#i);
  }
}
class O2 {
  #e = () => {
  };
  #t = /* @__PURE__ */ C(() => this.#e());
  constructor(e, r) {
    let n;
    r !== void 0 && (n = r), this.#e = () => {
      try {
        return n;
      } finally {
        n = e();
      }
    };
  }
  get current() {
    return d(this.#t);
  }
}
function Ws(t) {
  Ze(() => () => {
    t();
  });
}
function Zd(t) {
  Ze(() => ot(() => t()));
}
function Qd(t, e) {
  return setTimeout(e, t);
}
function Jt(t) {
  Rl().then(t);
}
const C2 = 1, k2 = 9, $2 = 11;
function Rc(t) {
  return Vi(t) && t.nodeType === C2 && typeof t.nodeName == "string";
}
function X_(t) {
  return Vi(t) && t.nodeType === k2;
}
function A2(t) {
  return Vi(t) && t.constructor?.name === "VisualViewport";
}
function E2(t) {
  return Vi(t) && t.nodeType !== void 0;
}
function J_(t) {
  return E2(t) && t.nodeType === $2 && "host" in t;
}
function T2(t, e) {
  if (!t || !e || !Rc(t) || !Rc(e))
    return !1;
  const r = e.getRootNode?.();
  if (t === e || t.contains(e))
    return !0;
  if (r && J_(r)) {
    let n = e;
    for (; n; ) {
      if (t === n)
        return !0;
      n = n.parentNode || n.host;
    }
  }
  return !1;
}
function ef(t) {
  return X_(t) ? t : A2(t) ? t.document : t?.ownerDocument ?? document;
}
function Z_(t) {
  return J_(t) ? Z_(t.host) : X_(t) ? t.defaultView ?? window : Rc(t) ? t.ownerDocument?.defaultView ?? window : window;
}
function D2(t) {
  let e = t.activeElement;
  for (; e?.shadowRoot; ) {
    const r = e.shadowRoot.activeElement;
    if (r === e)
      break;
    e = r;
  }
  return e;
}
class Nn {
  element;
  #e = /* @__PURE__ */ C(() => this.element.current ? this.element.current.getRootNode() ?? document : document);
  get root() {
    return d(this.#e);
  }
  set root(e) {
    q(this.#e, e);
  }
  constructor(e) {
    typeof e == "function" ? this.element = z(e) : this.element = e;
  }
  getDocument = () => ef(this.root);
  getWindow = () => this.getDocument().defaultView ?? window;
  getActiveElement = () => D2(this.root);
  isActiveElement = (e) => e === this.getActiveElement();
  getElementById(e) {
    return this.root.getElementById(e);
  }
  querySelector = (e) => this.root ? this.root.querySelector(e) : null;
  querySelectorAll = (e) => this.root ? this.root.querySelectorAll(e) : [];
  setTimeout = (e, r) => this.getWindow().setTimeout(e, r);
  clearTimeout = (e) => this.getWindow().clearTimeout(e);
}
function Ee(t, e) {
  return {
    [Jv()]: (r) => Li(t) ? (t.current = r, ot(() => e?.(r)), () => {
      "isConnected" in r && r.isConnected || (t.current = null, e?.(null));
    }) : (t(r), ot(() => e?.(r)), () => {
      "isConnected" in r && r.isConnected || (t(null), e?.(null));
    })
  };
}
function at(t) {
  return t ? "true" : "false";
}
function tf(t) {
  return t ? "true" : void 0;
}
function Fe(t) {
  return t ? "" : void 0;
}
function _i(t) {
  return t ? !0 : void 0;
}
function ji(t) {
  return t ? "open" : "closed";
}
function M2(t) {
  return t ? "checked" : "unchecked";
}
function ou(t, e) {
  return e ? "mixed" : t ? "true" : "false";
}
class I2 {
  #e;
  #t;
  attrs;
  constructor(e) {
    this.#e = e.getVariant ? e.getVariant() : null, this.#t = this.#e ? `data-${this.#e}-` : `data-${e.component}-`, this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(e.parts.map((r) => [r, this.getAttr(r)]));
  }
  getAttr(e, r) {
    return r ? `data-${r}-${e}` : `${this.#t}${e}`;
  }
  selector(e, r) {
    return `[${this.getAttr(e, r)}]`;
  }
}
function rr(t) {
  const e = new I2(t);
  return {
    ...e.attrs,
    selector: e.selector,
    getAttr: e.getAttr
  };
}
const cr = "ArrowDown", ls = "ArrowLeft", us = "ArrowRight", Qt = "ArrowUp", Ro = "End", Vr = "Enter", N2 = "Escape", Vo = "Home", Q_ = "PageDown", e0 = "PageUp", wr = " ", vm = "Tab", F2 = "p", R2 = "n", V2 = "j", L2 = "k", j2 = "h", B2 = "l";
function z2(t) {
  return window.getComputedStyle(t).getPropertyValue("direction");
}
function q2(t = "ltr", e = "horizontal") {
  return {
    horizontal: t === "rtl" ? ls : us,
    vertical: cr
  }[e];
}
function U2(t = "ltr", e = "horizontal") {
  return {
    horizontal: t === "rtl" ? us : ls,
    vertical: Qt
  }[e];
}
function K2(t = "ltr", e = "horizontal") {
  return ["ltr", "rtl"].includes(t) || (t = "ltr"), ["horizontal", "vertical"].includes(e) || (e = "horizontal"), {
    nextKey: q2(t, e),
    prevKey: U2(t, e)
  };
}
const Bi = typeof document < "u", Vc = H2();
function H2() {
  return Bi && window?.navigator?.userAgent && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function xn(t) {
  return t instanceof HTMLElement;
}
function di(t) {
  return t instanceof Element;
}
function rf(t) {
  return t instanceof Element || t instanceof SVGElement;
}
function ul(t) {
  return t.pointerType === "touch";
}
function W2(t) {
  return t !== null;
}
class t0 {
  #e;
  #t = Hs(null);
  constructor(e) {
    this.#e = e;
  }
  getCandidateNodes() {
    return this.#e.rootNode.current ? this.#e.candidateSelector ? Array.from(this.#e.rootNode.current.querySelectorAll(this.#e.candidateSelector)) : this.#e.candidateAttr ? Array.from(this.#e.rootNode.current.querySelectorAll(`[${this.#e.candidateAttr}]:not([data-disabled])`)) : [] : [];
  }
  focusFirstCandidate() {
    const e = this.getCandidateNodes();
    e.length && e[0]?.focus();
  }
  handleKeydown(e, r, n = !1) {
    const s = this.#e.rootNode.current;
    if (!s || !e)
      return;
    const o = this.getCandidateNodes();
    if (!o.length)
      return;
    const i = o.indexOf(e), a = z2(s), { nextKey: l, prevKey: u } = K2(a, this.#e.orientation.current), c = this.#e.loop.current, f = {
      [l]: i + 1,
      [u]: i - 1,
      [Vo]: 0,
      [Ro]: o.length - 1
    };
    if (n) {
      const b = l === cr ? us : cr, g = u === Qt ? ls : Qt;
      f[b] = i + 1, f[g] = i - 1;
    }
    let p = f[r.key];
    if (p === void 0)
      return;
    r.preventDefault(), p < 0 && c ? p = o.length - 1 : p === o.length && c && (p = 0);
    const _ = o[p];
    if (_)
      return _.focus(), this.#t.current = _.id, this.#e.onCandidateFocus?.(_), _;
  }
  getTabIndex(e) {
    const r = this.getCandidateNodes(), n = this.#t.current !== null;
    return e && !n && r[0] === e ? (this.#t.current = e.id, 0) : e?.id === this.#t.current ? 0 : -1;
  }
  setCurrentTabStopId(e) {
    this.#t.current = e;
  }
  focusCurrentTabStop() {
    const e = this.#t.current;
    if (!e)
      return;
    const r = this.#e.rootNode.current?.querySelector(`#${e}`);
    !r || !xn(r) || r.focus();
  }
}
class G2 {
  #e;
  #t = null;
  constructor(e) {
    this.#e = e, Ws(() => this.#r());
  }
  #r() {
    this.#t && (window.cancelAnimationFrame(this.#t), this.#t = null);
  }
  run(e) {
    this.#r();
    const r = this.#e.ref.current;
    if (r) {
      if (typeof r.getAnimations != "function") {
        this.#n(e);
        return;
      }
      this.#t = window.requestAnimationFrame(() => {
        const n = r.getAnimations();
        if (n.length === 0) {
          this.#n(e);
          return;
        }
        Promise.allSettled(n.map((s) => s.finished)).then(() => {
          this.#n(e);
        });
      });
    }
  }
  #n(e) {
    const r = () => {
      e();
    };
    this.#e.afterTick ? Jt(r) : r();
  }
}
class wi {
  #e;
  #t;
  #r;
  #n = /* @__PURE__ */ xe(!1);
  constructor(e) {
    this.#e = e, q(this.#n, e.open.current, !0), this.#t = e.enabled ?? !0, this.#r = new G2({ ref: this.#e.ref, afterTick: this.#e.open }), Ne(() => this.#e.open.current, (r) => {
      r && q(this.#n, !0), this.#t && this.#r.run(() => {
        r === this.#e.open.current && (this.#e.open.current || q(this.#n, !1), this.#e.onComplete?.());
      });
    });
  }
  get shouldRender() {
    return d(this.#n);
  }
}
function _e() {
}
function me(t, e) {
  return `bits-${t}`;
}
const Y2 = rr({
  component: "dialog",
  parts: [
    "content",
    "trigger",
    "overlay",
    "title",
    "description",
    "close",
    "cancel",
    "action"
  ]
}), Zn = new ht("Dialog.Root | AlertDialog.Root");
class nf {
  static create(e) {
    const r = Zn.getOr(null);
    return Zn.set(new nf(e, r));
  }
  opts;
  #e = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#e);
  }
  set triggerNode(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#t);
  }
  set contentNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get overlayNode() {
    return d(this.#r);
  }
  set overlayNode(e) {
    q(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ xe(null);
  get descriptionNode() {
    return d(this.#n);
  }
  set descriptionNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(void 0);
  get contentId() {
    return d(this.#s);
  }
  set contentId(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(void 0);
  get titleId() {
    return d(this.#o);
  }
  set titleId(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(void 0);
  get triggerId() {
    return d(this.#i);
  }
  set triggerId(e) {
    q(this.#i, e, !0);
  }
  #a = /* @__PURE__ */ xe(void 0);
  get descriptionId() {
    return d(this.#a);
  }
  set descriptionId(e) {
    q(this.#a, e, !0);
  }
  #u = /* @__PURE__ */ xe(null);
  get cancelNode() {
    return d(this.#u);
  }
  set cancelNode(e) {
    q(this.#u, e, !0);
  }
  #l = /* @__PURE__ */ xe(0);
  get nestedOpenCount() {
    return d(this.#l);
  }
  set nestedOpenCount(e) {
    q(this.#l, e, !0);
  }
  depth;
  parent;
  contentPresence;
  overlayPresence;
  constructor(e, r) {
    this.opts = e, this.parent = r, this.depth = r ? r.depth + 1 : 0, this.handleOpen = this.handleOpen.bind(this), this.handleClose = this.handleClose.bind(this), this.contentPresence = new wi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      enabled: !0,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), this.overlayPresence = new wi({
      ref: z(() => this.overlayNode),
      open: this.opts.open,
      enabled: !0
    }), Ne(
      () => this.opts.open.current,
      (n) => {
        this.parent && (n ? this.parent.incrementNested() : this.parent.decrementNested());
      },
      { lazy: !0 }
    ), Ws(() => {
      this.opts.open.current && this.parent?.decrementNested();
    });
  }
  handleOpen() {
    this.opts.open.current || (this.opts.open.current = !0);
  }
  handleClose() {
    this.opts.open.current && (this.opts.open.current = !1);
  }
  getBitsAttr = (e) => Y2.getAttr(e, this.opts.variant.current);
  incrementNested() {
    this.nestedOpenCount++, this.parent?.incrementNested();
  }
  decrementNested() {
    this.nestedOpenCount !== 0 && (this.nestedOpenCount--, this.parent?.decrementNested());
  }
  #c = /* @__PURE__ */ C(() => ({ "data-state": ji(this.opts.open.current) }));
  get sharedProps() {
    return d(this.#c);
  }
  set sharedProps(e) {
    q(this.#c, e);
  }
}
class sf {
  static create(e) {
    return new sf(e, Zn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => {
      this.root.triggerNode = n, this.root.triggerId = n?.id;
    }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || e.button > 0 || this.root.handleOpen();
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === wr || e.key === Vr) && (e.preventDefault(), this.root.handleOpen());
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "aria-haspopup": "dialog",
    "aria-expanded": at(this.root.opts.open.current),
    "aria-controls": this.root.contentId,
    [this.root.getBitsAttr("trigger")]: "",
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    disabled: this.opts.disabled.current ? !0 : void 0,
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class of {
  static create(e) {
    return new of(e, Zn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || e.button > 0 || this.root.handleClose();
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === wr || e.key === Vr) && (e.preventDefault(), this.root.handleClose());
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr(this.opts.variant.current)]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    disabled: this.opts.disabled.current ? !0 : void 0,
    tabindex: 0,
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class af {
  static create(e) {
    return new af(e, Zn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.root.titleId = this.opts.id.current, this.attachment = Ee(this.opts.ref), Ne.pre(() => this.opts.id.current, (n) => {
      this.root.titleId = n;
    });
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "heading",
    "aria-level": this.opts.level.current,
    [this.root.getBitsAttr("title")]: "",
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class lf {
  static create(e) {
    return new lf(e, Zn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.root.descriptionId = this.opts.id.current, this.attachment = Ee(this.opts.ref, (n) => {
      this.root.descriptionNode = n;
    }), Ne.pre(() => this.opts.id.current, (n) => {
      this.root.descriptionId = n;
    });
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr("description")]: "",
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class uf {
  static create(e) {
    return new uf(e, Zn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => {
      this.root.contentNode = n, this.root.contentId = n?.id;
    });
  }
  #e = /* @__PURE__ */ C(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: this.root.opts.variant.current === "alert-dialog" ? "alertdialog" : "dialog",
    "aria-modal": "true",
    "aria-describedby": this.root.descriptionId,
    "aria-labelledby": this.root.titleId,
    [this.root.getBitsAttr("content")]: "",
    style: {
      pointerEvents: "auto",
      outline: this.root.opts.variant.current === "alert-dialog" ? "none" : void 0,
      "--bits-dialog-depth": this.root.depth,
      "--bits-dialog-nested-count": this.root.nestedOpenCount,
      contain: "layout style paint"
    },
    tabindex: this.root.opts.variant.current === "alert-dialog" ? -1 : void 0,
    "data-nested-open": Fe(this.root.nestedOpenCount > 0),
    "data-nested": Fe(this.root.parent !== null),
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
}
class cf {
  static create(e) {
    return new cf(e, Zn.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => this.root.overlayNode = n);
  }
  #e = /* @__PURE__ */ C(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [this.root.getBitsAttr("overlay")]: "",
    style: {
      pointerEvents: "auto",
      "--bits-dialog-depth": this.root.depth,
      "--bits-dialog-nested-count": this.root.nestedOpenCount
    },
    "data-nested-open": Fe(this.root.nestedOpenCount > 0),
    "data-nested": Fe(this.root.parent !== null),
    ...this.root.sharedProps,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  get shouldRender() {
    return this.root.overlayPresence.shouldRender;
  }
}
var X2 = /* @__PURE__ */ ne("<div><!></div>");
function r0(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "level", 7, 2), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "level"
  ]);
  const u = af.create({
    id: z(() => n()),
    level: z(() => a()),
    ref: z(() => s(), (h) => s(h))
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(h = me(r)) {
      n(h), m();
    },
    get ref() {
      return s();
    },
    set ref(h = null) {
      s(h), m();
    },
    get child() {
      return o();
    },
    set child(h) {
      o(h), m();
    },
    get children() {
      return i();
    },
    set children(h) {
      i(h), m();
    },
    get level() {
      return a();
    },
    set level(h = 2) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, o, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = X2();
      ve(y, () => ({ ...d(c) }));
      var S = he(y);
      te(S, () => i() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      o() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(r0, { id: {}, ref: {}, child: {}, children: {}, level: {} }, [], [], { mode: "open" });
function n0(t, e) {
  H(e, !0);
  const r = v(e, "children", 7);
  var n = {
    get children() {
      return r();
    },
    set children(i) {
      r(i), m();
    }
  }, s = I(), o = D(s);
  return Vl(o, r, (i) => {
    var a = I(), l = D(a);
    te(l, () => r() ?? ge), A(i, a);
  }), A(t, s), W(n);
}
K(n0, { children: {} }, [], [], { mode: "open" });
const J2 = new ht("BitsConfig");
function Z2() {
  const t = new Q2(null, {});
  return J2.getOr(t).opts;
}
class Q2 {
  opts;
  constructor(e, r) {
    const n = eT(e, r);
    this.opts = {
      defaultPortalTo: n((s) => s.defaultPortalTo),
      defaultLocale: n((s) => s.defaultLocale)
    };
  }
}
function eT(t, e) {
  return (r) => z(() => {
    const s = r(e)?.current;
    if (s !== void 0)
      return s;
    if (t !== null)
      return r(t.opts)?.current;
  });
}
function s0(t, e) {
  return (r) => {
    const n = Z2();
    return z(() => {
      const s = r();
      if (s !== void 0)
        return s;
      const o = t(n).current;
      return o !== void 0 ? o : e;
    });
  };
}
const o0 = s0((t) => t.defaultLocale, "en"), tT = s0((t) => t.defaultPortalTo, "body");
function iu(t, e) {
  H(e, !0);
  let r = v(e, "to", 7), n = v(e, "children", 7), s = v(e, "disabled", 7);
  const o = tT(() => r()), i = Wx();
  let a = /* @__PURE__ */ C(l);
  function l() {
    if (!Bi || s()) return null;
    let g = null;
    return typeof o.current == "string" ? g = document.querySelector(o.current) : g = o.current, g;
  }
  let u;
  function c() {
    u && (Xv(u), u = null);
  }
  Ne([() => d(a), () => s()], ([g, h]) => {
    if (!g || h) {
      c();
      return;
    }
    return u = pd(n0, { target: g, props: { children: n() }, context: i }), () => {
      c();
    };
  });
  var f = {
    get to() {
      return r();
    },
    set to(g) {
      r(g), m();
    },
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get disabled() {
      return s();
    },
    set disabled(g) {
      s(g), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (g) => {
      var h = I(), y = D(h);
      te(y, () => n() ?? ge), A(g, h);
    };
    ue(_, (g) => {
      s() && g(b);
    });
  }
  return A(t, p), W(f);
}
K(iu, { to: {}, children: {}, disabled: {} }, [], [], { mode: "open" });
function ym(t, e = 500) {
  let r = null;
  const n = (...s) => {
    r !== null && clearTimeout(r), r = setTimeout(() => {
      t(...s);
    }, e);
  };
  return n.destroy = () => {
    r !== null && (clearTimeout(r), r = null);
  }, n;
}
function i0(t, e) {
  return t === e || t.contains(e);
}
function a0(t) {
  return t?.ownerDocument ?? document;
}
function rT(t) {
  if (!t)
    return null;
  for (const e of t.childNodes)
    if (e.nodeType !== Node.COMMENT_NODE)
      return e;
  return null;
}
function nT(t, e) {
  const { clientX: r, clientY: n } = t, s = e.getBoundingClientRect();
  return r < s.left || r > s.right || n < s.top || n > s.bottom;
}
var l0 = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"], cl = /* @__PURE__ */ l0.join(","), u0 = typeof Element > "u", Is = u0 ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, dl = !u0 && Element.prototype.getRootNode ? function(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
} : function(t) {
  return t?.ownerDocument;
}, fl = function(e, r) {
  var n;
  r === void 0 && (r = !0);
  var s = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "inert"), o = s === "" || s === "true", i = o || r && e && // closest does not exist on shadow roots, so we fall back to a manual
  // lookup upward, in case it is not defined.
  (typeof e.closest == "function" ? e.closest("[inert]") : fl(e.parentNode));
  return i;
}, sT = function(e) {
  var r, n = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "contenteditable");
  return n === "" || n === "true";
}, c0 = function(e, r, n) {
  if (fl(e))
    return [];
  var s = Array.prototype.slice.apply(e.querySelectorAll(cl));
  return r && Is.call(e, cl) && s.unshift(e), s = s.filter(n), s;
}, hl = function(e, r, n) {
  for (var s = [], o = Array.from(e); o.length; ) {
    var i = o.shift();
    if (!fl(i, !1))
      if (i.tagName === "SLOT") {
        var a = i.assignedElements(), l = a.length ? a : i.children, u = hl(l, !0, n);
        n.flatten ? s.push.apply(s, u) : s.push({
          scopeParent: i,
          candidates: u
        });
      } else {
        var c = Is.call(i, cl);
        c && n.filter(i) && (r || !e.includes(i)) && s.push(i);
        var f = i.shadowRoot || // check for an undisclosed shadow
        typeof n.getShadowRoot == "function" && n.getShadowRoot(i), p = !fl(f, !1) && (!n.shadowRootFilter || n.shadowRootFilter(i));
        if (f && p) {
          var _ = hl(f === !0 ? i.children : f.children, !0, n);
          n.flatten ? s.push.apply(s, _) : s.push({
            scopeParent: i,
            candidates: _
          });
        } else
          o.unshift.apply(o, i.children);
      }
  }
  return s;
}, d0 = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, f0 = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || sT(e)) && !d0(e) ? 0 : e.tabIndex;
}, oT = function(e, r) {
  var n = f0(e);
  return n < 0 && r && !d0(e) ? 0 : n;
}, iT = function(e, r) {
  return e.tabIndex === r.tabIndex ? e.documentOrder - r.documentOrder : e.tabIndex - r.tabIndex;
}, h0 = function(e) {
  return e.tagName === "INPUT";
}, aT = function(e) {
  return h0(e) && e.type === "hidden";
}, lT = function(e) {
  var r = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return r;
}, uT = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (e[n].checked && e[n].form === r)
      return e[n];
}, cT = function(e) {
  if (!e.name)
    return !0;
  var r = e.form || dl(e), n = function(a) {
    return r.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, s;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    s = n(window.CSS.escape(e.name));
  else
    try {
      s = n(e.name);
    } catch (i) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", i.message), !1;
    }
  var o = uT(s, e.form);
  return !o || o === e;
}, dT = function(e) {
  return h0(e) && e.type === "radio";
}, fT = function(e) {
  return dT(e) && !cT(e);
}, hT = function(e) {
  var r, n = e && dl(e), s = (r = n) === null || r === void 0 ? void 0 : r.host, o = !1;
  if (n && n !== e) {
    var i, a, l;
    for (o = !!((i = s) !== null && i !== void 0 && (a = i.ownerDocument) !== null && a !== void 0 && a.contains(s) || e != null && (l = e.ownerDocument) !== null && l !== void 0 && l.contains(e)); !o && s; ) {
      var u, c, f;
      n = dl(s), s = (u = n) === null || u === void 0 ? void 0 : u.host, o = !!((c = s) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(s));
    }
  }
  return o;
}, bm = function(e) {
  var r = e.getBoundingClientRect(), n = r.width, s = r.height;
  return n === 0 && s === 0;
}, gT = function(e, r) {
  var n = r.displayCheck, s = r.getShadowRoot;
  if (n === "full-native" && "checkVisibility" in e) {
    var o = e.checkVisibility({
      // Checking opacity might be desirable for some use cases, but natively,
      // opacity zero elements _are_ focusable and tabbable.
      checkOpacity: !1,
      opacityProperty: !1,
      contentVisibilityAuto: !0,
      visibilityProperty: !0,
      // This is an alias for `visibilityProperty`. Contemporary browsers
      // support both. However, this alias has wider browser support (Chrome
      // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
      // we include it anyway.
      checkVisibilityCSS: !0
    });
    return !o;
  }
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var i = Is.call(e, "details>summary:first-of-type"), a = i ? e.parentElement : e;
  if (Is.call(a, "details:not([open]) *"))
    return !0;
  if (!n || n === "full" || // full-native can run this branch when it falls through in case
  // Element#checkVisibility is unsupported
  n === "full-native" || n === "legacy-full") {
    if (typeof s == "function") {
      for (var l = e; e; ) {
        var u = e.parentElement, c = dl(e);
        if (u && !u.shadowRoot && s(u) === !0)
          return bm(e);
        e.assignedSlot ? e = e.assignedSlot : !u && c !== e.ownerDocument ? e = c.host : e = u;
      }
      e = l;
    }
    if (hT(e))
      return !e.getClientRects().length;
    if (n !== "legacy-full")
      return !0;
  } else if (n === "non-zero-area")
    return bm(e);
  return !1;
}, pT = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var r = e.parentElement; r; ) {
      if (r.tagName === "FIELDSET" && r.disabled) {
        for (var n = 0; n < r.children.length; n++) {
          var s = r.children.item(n);
          if (s.tagName === "LEGEND")
            return Is.call(r, "fieldset[disabled] *") ? !0 : !s.contains(e);
        }
        return !0;
      }
      r = r.parentElement;
    }
  return !1;
}, gl = function(e, r) {
  return !(r.disabled || aT(r) || gT(r, e) || // For a details element with a summary, the summary element gets the focus
  lT(r) || pT(r));
}, Lc = function(e, r) {
  return !(fT(r) || f0(r) < 0 || !gl(e, r));
}, mT = function(e) {
  var r = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(r) || r >= 0);
}, g0 = function(e) {
  var r = [], n = [];
  return e.forEach(function(s, o) {
    var i = !!s.scopeParent, a = i ? s.scopeParent : s, l = oT(a, i), u = i ? g0(s.candidates) : a;
    l === 0 ? i ? r.push.apply(r, u) : r.push(a) : n.push({
      documentOrder: o,
      tabIndex: l,
      item: s,
      isScope: i,
      content: u
    });
  }), n.sort(iT).reduce(function(s, o) {
    return o.isScope ? s.push.apply(s, o.content) : s.push(o.content), s;
  }, []).concat(r);
}, vT = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = hl([e], r.includeContainer, {
    filter: Lc.bind(null, r),
    flatten: !1,
    getShadowRoot: r.getShadowRoot,
    shadowRootFilter: mT
  }) : n = c0(e, r.includeContainer, Lc.bind(null, r)), g0(n);
}, yT = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = hl([e], r.includeContainer, {
    filter: gl.bind(null, r),
    flatten: !0,
    getShadowRoot: r.getShadowRoot
  }) : n = c0(e, r.includeContainer, gl.bind(null, r)), n;
}, bT = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return Is.call(e, cl) === !1 ? !1 : Lc(r, e);
}, _T = /* @__PURE__ */ l0.concat("iframe:not([inert]):not([inert] *)").join(","), wT = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return Is.call(e, _T) === !1 ? !1 : gl(r, e);
};
function ST(t, e) {
  const r = [];
  for (let n = 0; n < t.length; n += e)
    r.push(t.slice(n, n + e));
  return r;
}
function Wa(t, e) {
  return t >= 0 && t < e.length;
}
function xT(t, e, r = !0) {
  if (!(t.length === 0 || e < 0 || e >= t.length))
    return t.length === 1 && e === 0 ? t[0] : e === t.length - 1 ? r ? t[0] : void 0 : t[e + 1];
}
function PT(t, e, r = !0) {
  if (!(t.length === 0 || e < 0 || e >= t.length))
    return t.length === 1 && e === 0 ? t[0] : e === 0 ? r ? t[t.length - 1] : void 0 : t[e - 1];
}
function OT(t, e, r, n = !0) {
  if (t.length === 0 || e < 0 || e >= t.length)
    return;
  let s = e + r;
  return n ? s = (s % t.length + t.length) % t.length : s = Math.max(0, Math.min(s, t.length - 1)), t[s];
}
function CT(t, e, r, n = !0) {
  if (t.length === 0 || e < 0 || e >= t.length)
    return;
  let s = e - r;
  return n ? s = (s % t.length + t.length) % t.length : s = Math.max(0, Math.min(s, t.length - 1)), t[s];
}
function df(t, e, r) {
  const n = e.toLowerCase();
  if (n.endsWith(" ")) {
    const f = n.slice(0, -1);
    if (t.filter((g) => g.toLowerCase().startsWith(f)).length <= 1)
      return df(t, f, r);
    const _ = r?.toLowerCase();
    if (_ && _.startsWith(f) && _.charAt(f.length) === " " && e.trim() === f)
      return r;
    const b = t.filter((g) => g.toLowerCase().startsWith(n));
    if (b.length > 0) {
      const g = r ? t.indexOf(r) : -1;
      return _m(b, Math.max(g, 0)).find((S) => S !== r) || r;
    }
  }
  const o = e.length > 1 && Array.from(e).every((f) => f === e[0]) ? e[0] : e, i = o.toLowerCase(), a = r ? t.indexOf(r) : -1;
  let l = _m(t, Math.max(a, 0));
  o.length === 1 && (l = l.filter((f) => f !== r));
  const c = l.find((f) => f?.toLowerCase().startsWith(i));
  return c !== r ? c : void 0;
}
function _m(t, e) {
  return t.map((r, n) => t[(e + n) % t.length]);
}
const kT = { afterMs: 1e4, onChange: _e };
function p0(t, e) {
  const { afterMs: r, onChange: n, getWindow: s } = { ...kT, ...e };
  let o = null, i = /* @__PURE__ */ xe(Pt(t));
  function a() {
    return s().setTimeout(
      () => {
        q(i, t, !0), n?.(t);
      },
      r
    );
  }
  return Ze(() => () => {
    o && s().clearTimeout(o);
  }), z(() => d(i), (l) => {
    q(i, l, !0), n?.(l), o && s().clearTimeout(o), o = a();
  });
}
class $T {
  #e;
  #t;
  #r = /* @__PURE__ */ C(() => this.#e.onMatch ? this.#e.onMatch : (e) => e.focus());
  #n = /* @__PURE__ */ C(() => this.#e.getCurrentItem ? this.#e.getCurrentItem : this.#e.getActiveElement);
  constructor(e) {
    this.#e = e, this.#t = p0("", { afterMs: 1e3, getWindow: e.getWindow }), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(e, r) {
    if (!r.length) return;
    this.#t.current = this.#t.current + e;
    const n = d(this.#n)(), s = r.find((l) => l === n)?.textContent?.trim() ?? "", o = r.map((l) => l.textContent?.trim() ?? ""), i = df(o, this.#t.current, s), a = r.find((l) => l.textContent?.trim() === i);
    return a && d(this.#r)(a), a;
  }
  resetTypeahead() {
    this.#t.current = "";
  }
  get search() {
    return this.#t.current;
  }
}
const AT = "data-context-menu-trigger", ET = "data-context-menu-content";
rr({
  component: "menu",
  parts: [
    "trigger",
    "content",
    "sub-trigger",
    "item",
    "group",
    "group-heading",
    "checkbox-group",
    "checkbox-item",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "arrow"
  ]
});
globalThis.bitsDismissableLayers ??= /* @__PURE__ */ new Map();
class ff {
  static create(e) {
    return new ff(e);
  }
  opts;
  #e;
  #t;
  #r = { pointerdown: !1 };
  #n = !1;
  #s = !1;
  #o = void 0;
  #i;
  #a = _e;
  constructor(e) {
    this.opts = e, this.#t = e.interactOutsideBehavior, this.#e = e.onInteractOutside, this.#i = e.onFocusOutside, Ze(() => {
      this.#o = a0(this.opts.ref.current);
    });
    let r = _e;
    const n = () => {
      this.#h(), globalThis.bitsDismissableLayers.delete(this), this.#d.destroy(), r();
    };
    Ne([() => this.opts.enabled.current, () => this.opts.ref.current], () => {
      if (!(!this.opts.enabled.current || !this.opts.ref.current))
        return Qd(1, () => {
          this.opts.ref.current && (globalThis.bitsDismissableLayers.set(this, this.#t), r(), r = this.#l());
        }), n;
    }), Ws(() => {
      this.#h.destroy(), globalThis.bitsDismissableLayers.delete(this), this.#d.destroy(), this.#a(), r();
    });
  }
  #u = (e) => {
    e.defaultPrevented || this.opts.ref.current && Jt(() => {
      !this.opts.ref.current || this.#f(e.target) || e.target && !this.#s && this.#i.current?.(e);
    });
  };
  #l() {
    return ks(
      /**
       * CAPTURE INTERACTION START
       * mark interaction-start event as intercepted.
       * mark responsible layer during interaction start
       * to avoid checking if is responsible layer during interaction end
       * when a new floating element may have been opened.
       */
      Ye(this.#o, "pointerdown", ks(this.#g, this.#p), { capture: !0 }),
      /**
       * BUBBLE INTERACTION START
       * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
       * to avoid prematurely checking if other events were intercepted.
       */
      Ye(this.#o, "pointerdown", ks(this.#m, this.#d)),
      /**
       * HANDLE FOCUS OUTSIDE
       */
      Ye(this.#o, "focusin", this.#u)
    );
  }
  #c = (e) => {
    let r = e;
    r.defaultPrevented && (r = wm(e)), this.#e.current(e);
  };
  #d = ym(
    (e) => {
      if (!this.opts.ref.current) {
        this.#a();
        return;
      }
      const r = this.opts.isValidEvent.current(e, this.opts.ref.current) || MT(e, this.opts.ref.current);
      if (!this.#n || this.#b() || !r) {
        this.#a();
        return;
      }
      let n = e;
      if (n.defaultPrevented && (n = wm(n)), this.#t.current !== "close" && this.#t.current !== "defer-otherwise-close") {
        this.#a();
        return;
      }
      e.pointerType === "touch" ? (this.#a(), this.#a = Ye(this.#o, "click", this.#c, { once: !0 })) : this.#e.current(n);
    },
    10
  );
  #g = (e) => {
    this.#r[e.type] = !0;
  };
  #m = (e) => {
    this.#r[e.type] = !1;
  };
  #p = () => {
    this.opts.ref.current && (this.#n = DT(this.opts.ref.current));
  };
  #f = (e) => this.opts.ref.current ? i0(this.opts.ref.current, e) : !1;
  #h = ym(
    () => {
      for (const e in this.#r)
        this.#r[e] = !1;
      this.#n = !1;
    },
    20
  );
  #b() {
    return Object.values(this.#r).some(Boolean);
  }
  #y = () => {
    this.#s = !0;
  };
  #v = () => {
    this.#s = !1;
  };
  props = {
    onfocuscapture: this.#y,
    onblurcapture: this.#v
  };
}
function TT(t = [...globalThis.bitsDismissableLayers]) {
  return t.findLast(([e, { current: r }]) => r === "close" || r === "ignore");
}
function DT(t) {
  const e = [...globalThis.bitsDismissableLayers], r = TT(e);
  if (r) return r[0].opts.ref.current === t;
  const [n] = e[0];
  return n.opts.ref.current === t;
}
function MT(t, e) {
  const r = t.target;
  if (!rf(r)) return !1;
  const n = !!r.closest(`[${AT}]`);
  if ("button" in t && t.button > 0 && !n) return !1;
  if ("button" in t && t.button === 0 && n) return !0;
  const s = !!e.closest(`[${ET}]`);
  return n && s ? !1 : a0(r).documentElement.contains(r) && !i0(e, r) && nT(t, e);
}
function wm(t) {
  const e = t.currentTarget, r = t.target;
  let n;
  t instanceof PointerEvent ? n = new PointerEvent(t.type, t) : n = new PointerEvent("pointerdown", t);
  let s = !1;
  return new Proxy(n, {
    get: (i, a) => a === "currentTarget" ? e : a === "target" ? r : a === "preventDefault" ? () => {
      s = !0, typeof i.preventDefault == "function" && i.preventDefault();
    } : a === "defaultPrevented" ? s : a in i ? i[a] : t[a]
  });
}
function hf(t, e) {
  H(e, !0);
  let r = v(e, "interactOutsideBehavior", 7, "close"), n = v(e, "onInteractOutside", 7, _e), s = v(e, "onFocusOutside", 7, _e), o = v(e, "id", 7), i = v(e, "children", 7), a = v(e, "enabled", 7), l = v(e, "isValidEvent", 7, () => !1), u = v(e, "ref", 7);
  const c = ff.create({
    id: z(() => o()),
    interactOutsideBehavior: z(() => r()),
    onInteractOutside: z(() => n()),
    enabled: z(() => a()),
    onFocusOutside: z(() => s()),
    isValidEvent: z(() => l()),
    ref: u()
  });
  var f = {
    get interactOutsideBehavior() {
      return r();
    },
    set interactOutsideBehavior(b = "close") {
      r(b), m();
    },
    get onInteractOutside() {
      return n();
    },
    set onInteractOutside(b = _e) {
      n(b), m();
    },
    get onFocusOutside() {
      return s();
    },
    set onFocusOutside(b = _e) {
      s(b), m();
    },
    get id() {
      return o();
    },
    set id(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get enabled() {
      return a();
    },
    set enabled(b) {
      a(b), m();
    },
    get isValidEvent() {
      return l();
    },
    set isValidEvent(b = () => !1) {
      l(b), m();
    },
    get ref() {
      return u();
    },
    set ref(b) {
      u(b), m();
    }
  }, p = I(), _ = D(p);
  return te(_, () => i() ?? ge, () => ({ props: c.props })), A(t, p), W(f);
}
K(
  hf,
  {
    interactOutsideBehavior: {},
    onInteractOutside: {},
    onFocusOutside: {},
    id: {},
    children: {},
    enabled: {},
    isValidEvent: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsEscapeLayers ??= /* @__PURE__ */ new Map();
class gf {
  static create(e) {
    return new gf(e);
  }
  opts;
  domContext;
  constructor(e) {
    this.opts = e, this.domContext = new Nn(this.opts.ref);
    let r = _e;
    Ne(() => e.enabled.current, (n) => (n && (globalThis.bitsEscapeLayers.set(this, e.escapeKeydownBehavior), r = this.#e()), () => {
      r(), globalThis.bitsEscapeLayers.delete(this);
    }));
  }
  #e = () => Ye(this.domContext.getDocument(), "keydown", this.#t, { passive: !1 });
  #t = (e) => {
    if (e.key !== N2 || !IT(this)) return;
    const r = new KeyboardEvent(e.type, e);
    e.preventDefault();
    const n = this.opts.escapeKeydownBehavior.current;
    n !== "close" && n !== "defer-otherwise-close" || this.opts.onEscapeKeydown.current(r);
  };
}
function IT(t) {
  const e = [...globalThis.bitsEscapeLayers], r = e.findLast(([s, { current: o }]) => o === "close" || o === "ignore");
  if (r) return r[0] === t;
  const [n] = e[0];
  return n === t;
}
function pf(t, e) {
  H(e, !0);
  let r = v(e, "escapeKeydownBehavior", 7, "close"), n = v(e, "onEscapeKeydown", 7, _e), s = v(e, "children", 7), o = v(e, "enabled", 7), i = v(e, "ref", 7);
  gf.create({
    escapeKeydownBehavior: z(() => r()),
    onEscapeKeydown: z(() => n()),
    enabled: z(() => o()),
    ref: i()
  });
  var a = {
    get escapeKeydownBehavior() {
      return r();
    },
    set escapeKeydownBehavior(c = "close") {
      r(c), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(c = _e) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get enabled() {
      return o();
    },
    set enabled(c) {
      o(c), m();
    },
    get ref() {
      return i();
    },
    set ref(c) {
      i(c), m();
    }
  }, l = I(), u = D(l);
  return te(u, () => s() ?? ge), A(t, l), W(a);
}
K(
  pf,
  {
    escapeKeydownBehavior: {},
    onEscapeKeydown: {},
    children: {},
    enabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
class mf {
  static instance;
  #e = Gr([]);
  #t = /* @__PURE__ */ new WeakMap();
  #r = /* @__PURE__ */ new WeakMap();
  static getInstance() {
    return this.instance || (this.instance = new mf()), this.instance;
  }
  register(e) {
    const r = this.getActive();
    r && r !== e && r.pause();
    const n = document.activeElement;
    n && n !== document.body && this.#r.set(e, n), this.#e.current = this.#e.current.filter((s) => s !== e), this.#e.current.unshift(e);
  }
  unregister(e) {
    this.#e.current = this.#e.current.filter((n) => n !== e);
    const r = this.getActive();
    r && r.resume();
  }
  getActive() {
    return this.#e.current[0];
  }
  setFocusMemory(e, r) {
    this.#t.set(e, r);
  }
  getFocusMemory(e) {
    return this.#t.get(e);
  }
  isActiveScope(e) {
    return this.getActive() === e;
  }
  setPreFocusMemory(e, r) {
    this.#r.set(e, r);
  }
  getPreFocusMemory(e) {
    return this.#r.get(e);
  }
  clearPreFocusMemory(e) {
    this.#r.delete(e);
  }
}
class vf {
  #e = !1;
  #t = null;
  #r = mf.getInstance();
  #n = [];
  #s;
  constructor(e) {
    this.#s = e;
  }
  get paused() {
    return this.#e;
  }
  pause() {
    this.#e = !0;
  }
  resume() {
    this.#e = !1;
  }
  #o() {
    for (const e of this.#n)
      e();
    this.#n = [];
  }
  mount(e) {
    this.#t && this.unmount(), this.#t = e, this.#r.register(this), this.#u(), this.#i();
  }
  unmount() {
    this.#t && (this.#o(), this.#a(), this.#r.unregister(this), this.#r.clearPreFocusMemory(this), this.#t = null);
  }
  #i() {
    if (!this.#t) return;
    const e = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: !1, cancelable: !0 });
    this.#s.onOpenAutoFocus.current(e), e.defaultPrevented || requestAnimationFrame(() => {
      if (!this.#t) return;
      const r = this.#c();
      r ? (r.focus(), this.#r.setFocusMemory(this, r)) : this.#t.focus();
    });
  }
  #a() {
    const e = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: !1, cancelable: !0 });
    if (this.#s.onCloseAutoFocus.current?.(e), !e.defaultPrevented) {
      const r = this.#r.getPreFocusMemory(this);
      if (r && document.contains(r))
        try {
          r.focus();
        } catch {
          document.body.focus();
        }
    }
  }
  #u() {
    if (!this.#t || !this.#s.trap.current) return;
    const e = this.#t, r = e.ownerDocument, n = (i) => {
      if (this.#e || !this.#r.isActiveScope(this)) return;
      const a = i.target;
      if (!a) return;
      if (e.contains(a))
        this.#r.setFocusMemory(this, a);
      else {
        const u = this.#r.getFocusMemory(this);
        if (u && e.contains(u) && wT(u))
          i.preventDefault(), u.focus();
        else {
          const c = this.#c(), f = this.#d()[0];
          (c || f || e).focus();
        }
      }
    }, s = (i) => {
      if (!this.#s.loop || this.#e || i.key !== "Tab" || !this.#r.isActiveScope(this)) return;
      const a = this.#l();
      if (a.length === 0) return;
      const l = a[0], u = a[a.length - 1];
      !i.shiftKey && r.activeElement === u ? (i.preventDefault(), l.focus()) : i.shiftKey && r.activeElement === l && (i.preventDefault(), u.focus());
    };
    this.#n.push(Ye(r, "focusin", n, { capture: !0 }), Ye(e, "keydown", s));
    const o = new MutationObserver(() => {
      const i = this.#r.getFocusMemory(this);
      if (i && !e.contains(i)) {
        const a = this.#c(), l = this.#d()[0], u = a || l;
        u ? (u.focus(), this.#r.setFocusMemory(this, u)) : e.focus();
      }
    });
    o.observe(e, { childList: !0, subtree: !0 }), this.#n.push(() => o.disconnect());
  }
  #l() {
    return this.#t ? vT(this.#t, { includeContainer: !1, getShadowRoot: !0 }) : [];
  }
  #c() {
    return this.#l()[0] || null;
  }
  #d() {
    return this.#t ? yT(this.#t, { includeContainer: !1, getShadowRoot: !0 }) : [];
  }
  static use(e) {
    let r = null;
    return Ne([() => e.ref.current, () => e.enabled.current], ([n, s]) => {
      n && s ? (r || (r = new vf(e)), r.mount(n)) : r && (r.unmount(), r = null);
    }), Ws(() => {
      r?.unmount();
    }), {
      get props() {
        return { tabindex: -1 };
      }
    };
  }
}
function yf(t, e) {
  H(e, !0);
  let r = v(e, "enabled", 7, !1), n = v(e, "trapFocus", 7, !1), s = v(e, "loop", 7, !1), o = v(e, "onCloseAutoFocus", 7, _e), i = v(e, "onOpenAutoFocus", 7, _e), a = v(e, "focusScope", 7), l = v(e, "ref", 7);
  const u = vf.use({
    enabled: z(() => r()),
    trap: z(() => n()),
    loop: s(),
    onCloseAutoFocus: z(() => o()),
    onOpenAutoFocus: z(() => i()),
    ref: l()
  });
  var c = {
    get enabled() {
      return r();
    },
    set enabled(_ = !1) {
      r(_), m();
    },
    get trapFocus() {
      return n();
    },
    set trapFocus(_ = !1) {
      n(_), m();
    },
    get loop() {
      return s();
    },
    set loop(_ = !1) {
      s(_), m();
    },
    get onCloseAutoFocus() {
      return o();
    },
    set onCloseAutoFocus(_ = _e) {
      o(_), m();
    },
    get onOpenAutoFocus() {
      return i();
    },
    set onOpenAutoFocus(_ = _e) {
      i(_), m();
    },
    get focusScope() {
      return a();
    },
    set focusScope(_) {
      a(_), m();
    },
    get ref() {
      return l();
    },
    set ref(_) {
      l(_), m();
    }
  }, f = I(), p = D(f);
  return te(p, () => a() ?? ge, () => ({ props: u.props })), A(t, f), W(c);
}
K(
  yf,
  {
    enabled: {},
    trapFocus: {},
    loop: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    focusScope: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsTextSelectionLayers ??= /* @__PURE__ */ new Map();
class bf {
  static create(e) {
    return new bf(e);
  }
  opts;
  domContext;
  #e = _e;
  constructor(e) {
    this.opts = e, this.domContext = new Nn(e.ref);
    let r = _e;
    Ne(() => this.opts.enabled.current, (n) => (n && (globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled), r(), r = this.#t()), () => {
      r(), this.#n(), globalThis.bitsTextSelectionLayers.delete(this);
    }));
  }
  #t() {
    return ks(Ye(this.domContext.getDocument(), "pointerdown", this.#r), Ye(this.domContext.getDocument(), "pointerup", U_(this.#n, this.opts.onPointerUp.current)));
  }
  #r = (e) => {
    const r = this.opts.ref.current, n = e.target;
    !xn(r) || !xn(n) || !this.opts.enabled.current || !FT(this) || !T2(r, n) || (this.opts.onPointerDown.current(e), !e.defaultPrevented && (this.#e = NT(r, this.domContext.getDocument().body)));
  };
  #n = () => {
    this.#e(), this.#e = _e;
  };
}
const Sm = (t) => t.style.userSelect || t.style.webkitUserSelect;
function NT(t, e) {
  const r = Sm(e), n = Sm(t);
  return Na(e, "none"), Na(t, "text"), () => {
    Na(e, r), Na(t, n);
  };
}
function Na(t, e) {
  t.style.userSelect = e, t.style.webkitUserSelect = e;
}
function FT(t) {
  const e = [...globalThis.bitsTextSelectionLayers];
  if (!e.length) return !1;
  const r = e.at(-1);
  return r ? r[0] === t : !1;
}
function _f(t, e) {
  H(e, !0);
  let r = v(e, "preventOverflowTextSelection", 7, !0), n = v(e, "onPointerDown", 7, _e), s = v(e, "onPointerUp", 7, _e), o = v(e, "id", 7), i = v(e, "children", 7), a = v(e, "enabled", 7), l = v(e, "ref", 7);
  bf.create({
    id: z(() => o()),
    onPointerDown: z(() => n()),
    onPointerUp: z(() => s()),
    enabled: z(() => a() && r()),
    ref: l()
  });
  var u = {
    get preventOverflowTextSelection() {
      return r();
    },
    set preventOverflowTextSelection(p = !0) {
      r(p), m();
    },
    get onPointerDown() {
      return n();
    },
    set onPointerDown(p = _e) {
      n(p), m();
    },
    get onPointerUp() {
      return s();
    },
    set onPointerUp(p = _e) {
      s(p), m();
    },
    get id() {
      return o();
    },
    set id(p) {
      o(p), m();
    },
    get children() {
      return i();
    },
    set children(p) {
      i(p), m();
    },
    get enabled() {
      return a();
    },
    set enabled(p) {
      a(p), m();
    },
    get ref() {
      return l();
    },
    set ref(p) {
      l(p), m();
    }
  }, c = I(), f = D(c);
  return te(f, () => i() ?? ge), A(t, c), W(u);
}
K(
  _f,
  {
    preventOverflowTextSelection: {},
    onPointerDown: {},
    onPointerUp: {},
    id: {},
    children: {},
    enabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
globalThis.bitsIdCounter ??= { current: 0 };
function kn(t = "bits") {
  return globalThis.bitsIdCounter.current++, `${t}-${globalThis.bitsIdCounter.current}`;
}
class RT {
  #e;
  #t = 0;
  #r = /* @__PURE__ */ xe();
  #n;
  constructor(e) {
    this.#e = e;
  }
  #s() {
    this.#t -= 1, this.#n && this.#t <= 0 && (this.#n(), q(this.#r, void 0), this.#n = void 0);
  }
  get(...e) {
    return this.#t += 1, d(this.#r) === void 0 && (this.#n = Tv(() => {
      q(this.#r, this.#e(...e), !0);
    })), Ze(() => () => {
      this.#s();
    }), d(this.#r);
  }
}
const Ga = new Cd();
let Fa = /* @__PURE__ */ xe(null), Wu = null, ti = null, ri = !1;
const xm = z(() => {
  for (const t of Ga.values())
    if (t) return !0;
  return !1;
});
let Gu = null;
const VT = new RT(() => {
  function t() {
    document.body.setAttribute("style", d(Fa) ?? ""), document.body.style.removeProperty("--scrollbar-width"), Vc && Wu?.(), q(Fa, null);
  }
  function e() {
    ti !== null && (window.clearTimeout(ti), ti = null);
  }
  function r(s, o) {
    e(), ri = !0, Gu = Date.now();
    const i = Gu, a = () => {
      ti = null, Gu === i && (m0(Ga) ? ri = !1 : (ri = !1, o()));
    }, l = s === null ? 24 : s;
    ti = window.setTimeout(a, l);
  }
  function n() {
    d(Fa) === null && Ga.size === 0 && !ri && q(Fa, document.body.getAttribute("style"), !0);
  }
  return Ne(() => xm.current, () => {
    if (!xm.current) return;
    n(), ri = !1;
    const s = getComputedStyle(document.documentElement), o = getComputedStyle(document.body), i = s.scrollbarGutter?.includes("stable") || o.scrollbarGutter?.includes("stable"), a = window.innerWidth - document.documentElement.clientWidth, u = {
      padding: Number.parseInt(o.paddingRight ?? "0", 10) + a,
      margin: Number.parseInt(o.marginRight ?? "0", 10)
    };
    a > 0 && !i && (document.body.style.paddingRight = `${u.padding}px`, document.body.style.marginRight = `${u.margin}px`, document.body.style.setProperty("--scrollbar-width", `${a}px`)), document.body.style.overflow = "hidden", Vc && (Wu = Ye(
      document,
      "touchmove",
      (c) => {
        c.target === document.documentElement && (c.touches.length > 1 || c.preventDefault());
      },
      { passive: !1 }
    )), Jt(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }), Ws(() => () => {
    Wu?.();
  }), {
    get lockMap() {
      return Ga;
    },
    resetBodyStyle: t,
    scheduleCleanupIfNoNewLocks: r,
    cancelPendingCleanup: e,
    ensureInitialStyleCaptured: n
  };
});
class LT {
  #e = kn();
  #t;
  #r = () => null;
  #n;
  locked;
  constructor(e, r = () => null) {
    this.#t = e, this.#r = r, this.#n = VT.get(), this.#n && (this.#n.cancelPendingCleanup(), this.#n.ensureInitialStyleCaptured(), this.#n.lockMap.set(this.#e, this.#t ?? !1), this.locked = z(() => this.#n.lockMap.get(this.#e) ?? !1, (n) => this.#n.lockMap.set(this.#e, n)), Ws(() => {
      if (this.#n.lockMap.delete(this.#e), m0(this.#n.lockMap)) return;
      const n = this.#r();
      this.#n.scheduleCleanupIfNoNewLocks(n, () => {
        this.#n.resetBodyStyle();
      });
    }));
  }
}
function m0(t) {
  for (const [e, r] of t)
    if (r) return !0;
  return !1;
}
function Si(t, e) {
  H(e, !0);
  let r = v(e, "preventScroll", 7, !0), n = v(e, "restoreScrollDelay", 7, null);
  r() && new LT(r(), () => n());
  var s = {
    get preventScroll() {
      return r();
    },
    set preventScroll(o = !0) {
      r(o), m();
    },
    get restoreScrollDelay() {
      return n();
    },
    set restoreScrollDelay(o = null) {
      n(o), m();
    }
  };
  return W(s);
}
K(Si, { preventScroll: {}, restoreScrollDelay: {} }, [], [], { mode: "open" });
var jT = /* @__PURE__ */ ne("<div><!></div>");
function v0(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "forceMount", 7, !1), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "ref", 15, null), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "forceMount",
    "child",
    "children",
    "ref"
  ]);
  const u = cf.create({
    id: z(() => n()),
    ref: z(() => a(), (g) => a(g))
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get forceMount() {
      return s();
    },
    set forceMount(g = !1) {
      s(g), m();
    },
    get child() {
      return o();
    },
    set child(g) {
      o(g), m();
    },
    get children() {
      return i();
    },
    set children(g) {
      i(g), m();
    },
    get ref() {
      return a();
    },
    set ref(g = null) {
      a(g), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (g) => {
      var h = I(), y = D(h);
      {
        var S = (P) => {
          var w = I(), O = D(w);
          {
            let k = /* @__PURE__ */ C(() => ({
              props: Ce(d(c)),
              ...u.snippetProps
            }));
            te(O, o, () => d(k));
          }
          A(P, w);
        }, x = (P) => {
          var w = jT();
          ve(w, (k) => ({ ...k }), [() => Ce(d(c))]);
          var O = he(w);
          te(O, () => i() ?? ge, () => u.snippetProps), de(w), A(P, w);
        };
        ue(y, (P) => {
          o() ? P(S) : P(x, !1);
        });
      }
      A(g, h);
    };
    ue(_, (g) => {
      (u.shouldRender || s()) && g(b);
    });
  }
  return A(t, p), W(f);
}
K(v0, { id: {}, forceMount: {}, child: {}, children: {}, ref: {} }, [], [], { mode: "open" });
var BT = /* @__PURE__ */ ne("<button><!></button>");
function y0(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = v(e, "disabled", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child",
    "disabled"
  ]);
  const u = sf.create({
    id: z(() => n()),
    ref: z(() => s(), (h) => s(h)),
    disabled: z(() => !!a())
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(h = me(r)) {
      n(h), m();
    },
    get ref() {
      return s();
    },
    set ref(h = null) {
      s(h), m();
    },
    get children() {
      return o();
    },
    set children(h) {
      o(h), m();
    },
    get child() {
      return i();
    },
    set child(h) {
      i(h), m();
    },
    get disabled() {
      return a();
    },
    set disabled(h = !1) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, i, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = BT();
      ve(y, () => ({ ...d(c) }));
      var S = he(y);
      te(S, () => o() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      i() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(y0, { id: {}, ref: {}, children: {}, child: {}, disabled: {} }, [], [], { mode: "open" });
var zT = /* @__PURE__ */ ne("<div><!></div>");
function b0(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "ref"
  ]);
  const l = lf.create({
    id: z(() => n()),
    ref: z(() => i(), (g) => i(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get children() {
      return s();
    },
    set children(g) {
      s(g), m();
    },
    get child() {
      return o();
    },
    set child(g) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, o, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = zT();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => s() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      o() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(b0, { id: {}, children: {}, child: {}, ref: {} }, [], [], { mode: "open" });
function Yu(t, e) {
  return t - e * Math.floor(t / e);
}
const _0 = 1721426;
function Ra(t, e, r, n) {
  e = wf(t, e);
  let s = e - 1, o = -2;
  return r <= 2 ? o = 0 : Ya(e) && (o = -1), _0 - 1 + 365 * s + Math.floor(s / 4) - Math.floor(s / 100) + Math.floor(s / 400) + Math.floor((367 * r - 362) / 12 + o + n);
}
function Ya(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function wf(t, e) {
  return t === "BC" ? 1 - e : e;
}
function qT(t) {
  let e = "AD";
  return t <= 0 && (e = "BC", t = 1 - t), [
    e,
    t
  ];
}
const UT = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class _o {
  fromJulianDay(e) {
    let r = e, n = r - _0, s = Math.floor(n / 146097), o = Yu(n, 146097), i = Math.floor(o / 36524), a = Yu(o, 36524), l = Math.floor(a / 1461), u = Yu(a, 1461), c = Math.floor(u / 365), f = s * 400 + i * 100 + l * 4 + c + (i !== 4 && c !== 4 ? 1 : 0), [p, _] = qT(f), b = r - Ra(p, _, 1, 1), g = 2;
    r < Ra(p, _, 3, 1) ? g = 0 : Ya(_) && (g = 1);
    let h = Math.floor(((b + g) * 12 + 373) / 367), y = r - Ra(p, _, h, 1) + 1;
    return new ts(p, _, h, y);
  }
  toJulianDay(e) {
    return Ra(e.era, e.year, e.month, e.day);
  }
  getDaysInMonth(e) {
    return UT[Ya(e.year) ? "leapyear" : "standard"][e.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(e) {
    return 12;
  }
  getDaysInYear(e) {
    return Ya(e.year) ? 366 : 365;
  }
  getMaximumMonthsInYear() {
    return 12;
  }
  getMaximumDaysInMonth() {
    return 31;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(e) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(e) {
    return e.era === "BC";
  }
  balanceDate(e) {
    e.year <= 0 && (e.era = e.era === "BC" ? "AD" : "BC", e.year = 1 - e.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const KT = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function _t(t, e) {
  return e = dr(e, t.calendar), t.era === e.era && t.year === e.year && t.month === e.month && t.day === e.day;
}
function Lo(t, e) {
  return e = dr(e, t.calendar), t = jc(t), e = jc(e), t.era === e.era && t.year === e.year && t.month === e.month;
}
function w0(t, e) {
  return S0(t.calendar, e.calendar) && Lo(t, e);
}
function S0(t, e) {
  var r, n, s, o;
  return (o = (s = (r = t.isEqual) === null || r === void 0 ? void 0 : r.call(t, e)) !== null && s !== void 0 ? s : (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && o !== void 0 ? o : t.identifier === e.identifier;
}
function x0(t, e) {
  return _t(t, WT(e));
}
function P0(t, e, r) {
  let n = t.calendar.toJulianDay(t), s = JT(e), o = Math.ceil(n + 1 - s) % 7;
  return o < 0 && (o += 7), o;
}
function HT(t) {
  return Yr(Date.now(), t);
}
function WT(t) {
  return eD(HT(t));
}
function O0(t, e) {
  return t.calendar.toJulianDay(t) - e.calendar.toJulianDay(e);
}
function GT(t, e) {
  return Pm(t) - Pm(e);
}
function Pm(t) {
  return t.hour * 36e5 + t.minute * 6e4 + t.second * 1e3 + t.millisecond;
}
let Xu = null;
function ft() {
  return Xu == null && (Xu = new Intl.DateTimeFormat().resolvedOptions().timeZone), Xu;
}
function jc(t) {
  return t.subtract({
    days: t.day - 1
  });
}
function YT(t) {
  return t.add({
    days: t.calendar.getDaysInMonth(t) - t.day
  });
}
const Om = /* @__PURE__ */ new Map(), Ju = /* @__PURE__ */ new Map();
function XT(t) {
  if (Intl.Locale) {
    let r = Om.get(t);
    return r || (r = new Intl.Locale(t).maximize().region, r && Om.set(t, r)), r;
  }
  let e = t.split("-")[1];
  return e === "u" ? void 0 : e;
}
function JT(t) {
  let e = Ju.get(t);
  if (!e) {
    if (Intl.Locale) {
      let n = new Intl.Locale(t);
      if ("getWeekInfo" in n && (e = n.getWeekInfo(), e))
        return Ju.set(t, e), e.firstDay;
    }
    let r = XT(t);
    if (t.includes("-fw-")) {
      let n = t.split("-fw-")[1].split("-")[0];
      n === "mon" ? e = {
        firstDay: 1
      } : n === "tue" ? e = {
        firstDay: 2
      } : n === "wed" ? e = {
        firstDay: 3
      } : n === "thu" ? e = {
        firstDay: 4
      } : n === "fri" ? e = {
        firstDay: 5
      } : n === "sat" ? e = {
        firstDay: 6
      } : e = {
        firstDay: 0
      };
    } else t.includes("-ca-iso8601") ? e = {
      firstDay: 1
    } : e = {
      firstDay: r && KT[r] || 0
    };
    Ju.set(t, e);
  }
  return e.firstDay;
}
function Qn(t) {
  t = dr(t, new _o());
  let e = wf(t.era, t.year);
  return C0(e, t.month, t.day, t.hour, t.minute, t.second, t.millisecond);
}
function C0(t, e, r, n, s, o, i) {
  let a = /* @__PURE__ */ new Date();
  return a.setUTCHours(n, s, o, i), a.setUTCFullYear(t, e - 1, r), a.getTime();
}
function xi(t, e) {
  if (e === "UTC") return 0;
  if (t > 0 && e === ft()) return new Date(t).getTimezoneOffset() * -6e4;
  let { year: r, month: n, day: s, hour: o, minute: i, second: a } = k0(t, e);
  return C0(r, n, s, o, i, a, 0) - Math.floor(t / 1e3) * 1e3;
}
const Cm = /* @__PURE__ */ new Map();
function k0(t, e) {
  let r = Cm.get(e);
  r || (r = new Intl.DateTimeFormat("en-US", {
    timeZone: e,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), Cm.set(e, r));
  let n = r.formatToParts(new Date(t)), s = {};
  for (let o of n) o.type !== "literal" && (s[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: s.era === "BC" || s.era === "B" ? -s.year + 1 : +s.year,
    month: +s.month,
    day: +s.day,
    hour: s.hour === "24" ? 0 : +s.hour,
    minute: +s.minute,
    second: +s.second
  };
}
const pl = 864e5;
function ZT(t, e) {
  let r = Qn(t), n = r - xi(r - pl, e), s = r - xi(r + pl, e);
  return $0(t, e, n, s);
}
function $0(t, e, r, n) {
  return (r === n ? [
    r
  ] : [
    r,
    n
  ]).filter((o) => QT(t, e, o));
}
function QT(t, e, r) {
  let n = k0(r, e);
  return t.year === n.year && t.month === n.month && t.day === n.day && t.hour === n.hour && t.minute === n.minute && t.second === n.second;
}
function Kr(t, e, r = "compatible") {
  let n = es(t);
  if (e === "UTC") return Qn(n);
  if (e === ft() && r === "compatible") {
    n = dr(n, new _o());
    let l = /* @__PURE__ */ new Date(), u = wf(n.era, n.year);
    return l.setFullYear(u, n.month - 1, n.day), l.setHours(n.hour, n.minute, n.second, n.millisecond), l.getTime();
  }
  let s = Qn(n), o = xi(s - pl, e), i = xi(s + pl, e), a = $0(n, e, s - o, s - i);
  if (a.length === 1) return a[0];
  if (a.length > 1) switch (r) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return a[0];
    case "later":
      return a[a.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (r) {
    case "earlier":
      return Math.min(s - o, s - i);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(s - o, s - i);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function A0(t, e, r = "compatible") {
  return new Date(Kr(t, e, r));
}
function Yr(t, e) {
  let r = xi(t, e), n = new Date(t + r), s = n.getUTCFullYear(), o = n.getUTCMonth() + 1, i = n.getUTCDate(), a = n.getUTCHours(), l = n.getUTCMinutes(), u = n.getUTCSeconds(), c = n.getUTCMilliseconds();
  return new rn(s < 1 ? "BC" : "AD", s < 1 ? -s + 1 : s, o, i, e, r, a, l, u, c);
}
function eD(t) {
  return new ts(t.calendar, t.era, t.year, t.month, t.day);
}
function es(t, e) {
  let r = 0, n = 0, s = 0, o = 0;
  if ("timeZone" in t) ({ hour: r, minute: n, second: s, millisecond: o } = t);
  else if ("hour" in t && !e) return t;
  return e && ({ hour: r, minute: n, second: s, millisecond: o } = e), new $n(t.calendar, t.era, t.year, t.month, t.day, r, n, s, o);
}
function dr(t, e) {
  if (S0(t.calendar, e)) return t;
  let r = e.fromJulianDay(t.calendar.toJulianDay(t)), n = t.copy();
  return n.calendar = e, n.era = r.era, n.year = r.year, n.month = r.month, n.day = r.day, Ns(n), n;
}
function tD(t, e, r) {
  if (t instanceof rn)
    return t.timeZone === e ? t : nD(t, e);
  let n = Kr(t, e, r);
  return Yr(n, e);
}
function rD(t) {
  let e = Qn(t) - t.offset;
  return new Date(e);
}
function nD(t, e) {
  let r = Qn(t) - t.offset;
  return dr(Yr(r, e), t.calendar);
}
const ni = 36e5;
function au(t, e) {
  let r = t.copy(), n = "hour" in r ? aD(r, e) : 0;
  Bc(r, e.years || 0), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, t), r.month += e.months || 0, zc(r), E0(r), r.day += (e.weeks || 0) * 7, r.day += e.days || 0, r.day += n, sD(r), r.calendar.balanceDate && r.calendar.balanceDate(r), r.year < 1 && (r.year = 1, r.month = 1, r.day = 1);
  let s = r.calendar.getYearsInEra(r);
  if (r.year > s) {
    var o, i;
    let l = (o = (i = r.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(i, r);
    r.year = s, r.month = l ? 1 : r.calendar.getMonthsInYear(r), r.day = l ? 1 : r.calendar.getDaysInMonth(r);
  }
  r.month < 1 && (r.month = 1, r.day = 1);
  let a = r.calendar.getMonthsInYear(r);
  return r.month > a && (r.month = a, r.day = r.calendar.getDaysInMonth(r)), r.day = Math.max(1, Math.min(r.calendar.getDaysInMonth(r), r.day)), r;
}
function Bc(t, e) {
  var r, n;
  !((r = (n = t.calendar).isInverseEra) === null || r === void 0) && r.call(n, t) && (e = -e), t.year += e;
}
function zc(t) {
  for (; t.month < 1; )
    Bc(t, -1), t.month += t.calendar.getMonthsInYear(t);
  let e = 0;
  for (; t.month > (e = t.calendar.getMonthsInYear(t)); )
    t.month -= e, Bc(t, 1);
}
function sD(t) {
  for (; t.day < 1; )
    t.month--, zc(t), t.day += t.calendar.getDaysInMonth(t);
  for (; t.day > t.calendar.getDaysInMonth(t); )
    t.day -= t.calendar.getDaysInMonth(t), t.month++, zc(t);
}
function E0(t) {
  t.month = Math.max(1, Math.min(t.calendar.getMonthsInYear(t), t.month)), t.day = Math.max(1, Math.min(t.calendar.getDaysInMonth(t), t.day));
}
function Ns(t) {
  t.calendar.constrainDate && t.calendar.constrainDate(t), t.year = Math.max(1, Math.min(t.calendar.getYearsInEra(t), t.year)), E0(t);
}
function T0(t) {
  let e = {};
  for (let r in t) typeof t[r] == "number" && (e[r] = -t[r]);
  return e;
}
function D0(t, e) {
  return au(t, T0(e));
}
function Sf(t, e) {
  let r = t.copy();
  return e.era != null && (r.era = e.era), e.year != null && (r.year = e.year), e.month != null && (r.month = e.month), e.day != null && (r.day = e.day), Ns(r), r;
}
function ml(t, e) {
  let r = t.copy();
  return e.hour != null && (r.hour = e.hour), e.minute != null && (r.minute = e.minute), e.second != null && (r.second = e.second), e.millisecond != null && (r.millisecond = e.millisecond), iD(r), r;
}
function oD(t) {
  t.second += Math.floor(t.millisecond / 1e3), t.millisecond = Va(t.millisecond, 1e3), t.minute += Math.floor(t.second / 60), t.second = Va(t.second, 60), t.hour += Math.floor(t.minute / 60), t.minute = Va(t.minute, 60);
  let e = Math.floor(t.hour / 24);
  return t.hour = Va(t.hour, 24), e;
}
function iD(t) {
  t.millisecond = Math.max(0, Math.min(t.millisecond, 1e3)), t.second = Math.max(0, Math.min(t.second, 59)), t.minute = Math.max(0, Math.min(t.minute, 59)), t.hour = Math.max(0, Math.min(t.hour, 23));
}
function Va(t, e) {
  let r = t % e;
  return r < 0 && (r += e), r;
}
function aD(t, e) {
  return t.hour += e.hours || 0, t.minute += e.minutes || 0, t.second += e.seconds || 0, t.millisecond += e.milliseconds || 0, oD(t);
}
function xf(t, e, r, n) {
  let s = t.copy();
  switch (e) {
    case "era": {
      let a = t.calendar.getEras(), l = a.indexOf(t.era);
      if (l < 0) throw new Error("Invalid era: " + t.era);
      l = yn(l, r, 0, a.length - 1, n?.round), s.era = a[l], Ns(s);
      break;
    }
    case "year":
      var o, i;
      !((o = (i = s.calendar).isInverseEra) === null || o === void 0) && o.call(i, s) && (r = -r), s.year = yn(t.year, r, -1 / 0, 9999, n?.round), s.year === -1 / 0 && (s.year = 1), s.calendar.balanceYearMonth && s.calendar.balanceYearMonth(s, t);
      break;
    case "month":
      s.month = yn(t.month, r, 1, t.calendar.getMonthsInYear(t), n?.round);
      break;
    case "day":
      s.day = yn(t.day, r, 1, t.calendar.getDaysInMonth(t), n?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return t.calendar.balanceDate && t.calendar.balanceDate(s), Ns(s), s;
}
function M0(t, e, r, n) {
  let s = t.copy();
  switch (e) {
    case "hour": {
      let o = t.hour, i = 0, a = 23;
      if (n?.hourCycle === 12) {
        let l = o >= 12;
        i = l ? 12 : 0, a = l ? 23 : 11;
      }
      s.hour = yn(o, r, i, a, n?.round);
      break;
    }
    case "minute":
      s.minute = yn(t.minute, r, 0, 59, n?.round);
      break;
    case "second":
      s.second = yn(t.second, r, 0, 59, n?.round);
      break;
    case "millisecond":
      s.millisecond = yn(t.millisecond, r, 0, 999, n?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return s;
}
function yn(t, e, r, n, s = !1) {
  if (s) {
    t += Math.sign(e), t < r && (t = n);
    let o = Math.abs(e);
    e > 0 ? t = Math.ceil(t / o) * o : t = Math.floor(t / o) * o, t > n && (t = r);
  } else
    t += e, t < r ? t = n - (r - t - 1) : t > n && (t = r + (t - n - 1));
  return t;
}
function I0(t, e) {
  let r;
  if (e.years != null && e.years !== 0 || e.months != null && e.months !== 0 || e.weeks != null && e.weeks !== 0 || e.days != null && e.days !== 0) {
    let s = au(es(t), {
      years: e.years,
      months: e.months,
      weeks: e.weeks,
      days: e.days
    });
    r = Kr(s, t.timeZone);
  } else
    r = Qn(t) - t.offset;
  r += e.milliseconds || 0, r += (e.seconds || 0) * 1e3, r += (e.minutes || 0) * 6e4, r += (e.hours || 0) * 36e5;
  let n = Yr(r, t.timeZone);
  return dr(n, t.calendar);
}
function lD(t, e) {
  return I0(t, T0(e));
}
function uD(t, e, r, n) {
  switch (e) {
    case "hour": {
      let s = 0, o = 23;
      if (n?.hourCycle === 12) {
        let b = t.hour >= 12;
        s = b ? 12 : 0, o = b ? 23 : 11;
      }
      let i = es(t), a = dr(ml(i, {
        hour: s
      }), new _o()), l = [
        Kr(a, t.timeZone, "earlier"),
        Kr(a, t.timeZone, "later")
      ].filter((b) => Yr(b, t.timeZone).day === a.day)[0], u = dr(ml(i, {
        hour: o
      }), new _o()), c = [
        Kr(u, t.timeZone, "earlier"),
        Kr(u, t.timeZone, "later")
      ].filter((b) => Yr(b, t.timeZone).day === u.day).pop(), f = Qn(t) - t.offset, p = Math.floor(f / ni), _ = f % ni;
      return f = yn(p, r, Math.floor(l / ni), Math.floor(c / ni), n?.round) * ni + _, dr(Yr(f, t.timeZone), t.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return M0(t, e, r, n);
    case "era":
    case "year":
    case "month":
    case "day": {
      let s = xf(es(t), e, r, n), o = Kr(s, t.timeZone);
      return dr(Yr(o, t.timeZone), t.calendar);
    }
    default:
      throw new Error("Unsupported field " + e);
  }
}
function cD(t, e, r) {
  let n = es(t), s = ml(Sf(n, e), e);
  if (s.compare(n) === 0) return t;
  let o = Kr(s, t.timeZone, r);
  return dr(Yr(o, t.timeZone), t.calendar);
}
const dD = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})$/, fD = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/, hD = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?(?::?(\d{2}))?)?\[(.*?)\]$/, N0 = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
function Pi(t) {
  let e = t.match(dD);
  if (!e)
    throw N0.test(t) ? new Error(`Invalid ISO 8601 date string: ${t}. Use parseAbsolute() instead.`) : new Error("Invalid ISO 8601 date string: " + t);
  let r = new ts(mt(e[1], 0, 9999), mt(e[2], 1, 12), 1);
  return r.day = mt(e[3], 1, r.calendar.getDaysInMonth(r)), r;
}
function F0(t) {
  let e = t.match(fD);
  if (!e)
    throw N0.test(t) ? new Error(`Invalid ISO 8601 date time string: ${t}. Use parseAbsolute() instead.`) : new Error("Invalid ISO 8601 date time string: " + t);
  let r = mt(e[1], -9999, 9999), n = r < 1 ? "BC" : "AD", s = new $n(n, r < 1 ? -r + 1 : r, mt(e[2], 1, 12), 1, e[4] ? mt(e[4], 0, 23) : 0, e[5] ? mt(e[5], 0, 59) : 0, e[6] ? mt(e[6], 0, 59) : 0, e[7] ? mt(e[7], 0, 1 / 0) * 1e3 : 0);
  return s.day = mt(e[3], 0, s.calendar.getDaysInMonth(s)), s;
}
function R0(t, e) {
  let r = t.match(hD);
  if (!r) throw new Error("Invalid ISO 8601 date time string: " + t);
  let n = mt(r[1], -9999, 9999), s = n < 1 ? "BC" : "AD", o = new rn(s, n < 1 ? -n + 1 : n, mt(r[2], 1, 12), 1, r[11], 0, r[4] ? mt(r[4], 0, 23) : 0, r[5] ? mt(r[5], 0, 59) : 0, r[6] ? mt(r[6], 0, 59) : 0, r[7] ? mt(r[7], 0, 1 / 0) * 1e3 : 0);
  o.day = mt(r[3], 0, o.calendar.getDaysInMonth(o));
  let i = es(o), a;
  if (r[8]) {
    let c = mt(r[8], -23, 23);
    var l, u;
    if (o.offset = Math.sign(c) * (Math.abs(c) * 36e5 + mt((l = r[9]) !== null && l !== void 0 ? l : "0", 0, 59) * 6e4 + mt((u = r[10]) !== null && u !== void 0 ? u : "0", 0, 59) * 1e3), a = Qn(o) - o.offset, !ZT(i, o.timeZone).includes(a)) throw new Error(`Offset ${L0(o.offset)} is invalid for ${Pf(o)} in ${o.timeZone}`);
  } else
    a = Kr(es(i), o.timeZone, e);
  return Yr(a, o.timeZone);
}
function mt(t, e, r) {
  let n = Number(t);
  if (n < e || n > r) throw new RangeError(`Value out of range: ${e} <= ${n} <= ${r}`);
  return n;
}
function gD(t) {
  return `${String(t.hour).padStart(2, "0")}:${String(t.minute).padStart(2, "0")}:${String(t.second).padStart(2, "0")}${t.millisecond ? String(t.millisecond / 1e3).slice(1) : ""}`;
}
function V0(t) {
  let e = dr(t, new _o()), r;
  return e.era === "BC" ? r = e.year === 1 ? "0000" : "-" + String(Math.abs(1 - e.year)).padStart(6, "00") : r = String(e.year).padStart(4, "0"), `${r}-${String(e.month).padStart(2, "0")}-${String(e.day).padStart(2, "0")}`;
}
function Pf(t) {
  return `${V0(t)}T${gD(t)}`;
}
function L0(t) {
  let e = Math.sign(t) < 0 ? "-" : "+";
  t = Math.abs(t);
  let r = Math.floor(t / 36e5), n = Math.floor(t % 36e5 / 6e4), s = Math.floor(t % 36e5 % 6e4 / 1e3), o = `${e}${String(r).padStart(2, "0")}:${String(n).padStart(2, "0")}`;
  return s !== 0 && (o += `:${String(s).padStart(2, "0")}`), o;
}
function pD(t) {
  return `${Pf(t)}${L0(t.offset)}[${t.timeZone}]`;
}
function mD(t, e) {
  if (e.has(t))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Of(t, e, r) {
  mD(t, e), e.set(t, r);
}
function Cf(t) {
  let e = typeof t[0] == "object" ? t.shift() : new _o(), r;
  if (typeof t[0] == "string") r = t.shift();
  else {
    let i = e.getEras();
    r = i[i.length - 1];
  }
  let n = t.shift(), s = t.shift(), o = t.shift();
  return [
    e,
    r,
    n,
    s,
    o
  ];
}
var vD = /* @__PURE__ */ new WeakMap();
class ts {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new ts(this.calendar, this.era, this.year, this.month, this.day) : new ts(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(e) {
    return au(this, e);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(e) {
    return D0(this, e);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return Sf(this, e);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    return xf(this, e, r, n);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(e) {
    return A0(this, e);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return V0(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return O0(this, e);
  }
  constructor(...e) {
    Of(this, vD, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = Cf(e);
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, Ns(this);
  }
}
var yD = /* @__PURE__ */ new WeakMap();
class $n {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new $n(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new $n(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(e) {
    return au(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return D0(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return Sf(ml(this, e), e);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    switch (e) {
      case "era":
      case "year":
      case "month":
      case "day":
        return xf(this, e, r, n);
      default:
        return M0(this, e, r, n);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(e, r) {
    return A0(this, e, r);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Pf(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    let r = O0(this, e);
    return r === 0 ? GT(this, es(e)) : r;
  }
  constructor(...e) {
    Of(this, yD, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = Cf(e);
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, Ns(this);
  }
}
var bD = /* @__PURE__ */ new WeakMap();
class rn {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new rn(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new rn(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(e) {
    return I0(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return lD(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e, r) {
    return cD(this, e, r);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, r, n) {
    return uD(this, e, r, n);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return rD(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return pD(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return this.toDate().getTime() - tD(e, this.timeZone).toDate().getTime();
  }
  constructor(...e) {
    Of(this, bD, {
      writable: !0,
      value: void 0
    });
    let [r, n, s, o, i] = Cf(e), a = e.shift(), l = e.shift();
    this.calendar = r, this.era = n, this.year = s, this.month = o, this.day = i, this.timeZone = a, this.offset = l, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, Ns(this);
  }
}
let Zu = /* @__PURE__ */ new Map();
class Lt {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(e) {
    return this.formatter.format(e);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(e) {
    return this.formatter.formatToParts(e);
  }
  /** Formats a date range as a string. */
  formatRange(e, r) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(e, r);
    if (r < e) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(e)} â€“ ${this.formatter.format(r)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(e, r) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(e, r);
    if (r < e) throw new RangeError("End date must be >= start date");
    let n = this.formatter.formatToParts(e), s = this.formatter.formatToParts(r);
    return [
      ...n.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " â€“ ",
        source: "shared"
      },
      ...s.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let e = this.formatter.resolvedOptions();
    return SD() && (this.resolvedHourCycle || (this.resolvedHourCycle = xD(e.locale, this.options)), e.hourCycle = this.resolvedHourCycle, e.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), e.calendar === "ethiopic-amete-alem" && (e.calendar = "ethioaa"), e;
  }
  constructor(e, r = {}) {
    this.formatter = j0(e, r), this.options = r;
  }
}
const _D = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function j0(t, e = {}) {
  if (typeof e.hour12 == "boolean" && wD()) {
    e = {
      ...e
    };
    let s = _D[String(e.hour12)][t.split("-")[0]], o = e.hour12 ? "h12" : "h23";
    e.hourCycle = s ?? o, delete e.hour12;
  }
  let r = t + (e ? Object.entries(e).sort((s, o) => s[0] < o[0] ? -1 : 1).join() : "");
  if (Zu.has(r)) return Zu.get(r);
  let n = new Intl.DateTimeFormat(t, e);
  return Zu.set(r, n), n;
}
let Qu = null;
function wD() {
  return Qu == null && (Qu = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Qu;
}
let ec = null;
function SD() {
  return ec == null && (ec = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), ec;
}
function xD(t, e) {
  if (!e.timeStyle && !e.hour) return;
  t = t.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), t += (t.includes("-u-") ? "" : "-u") + "-nu-latn";
  let r = j0(t, {
    ...e,
    timeZone: void 0
    // use local timezone
  }), n = parseInt(r.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), s = parseInt(r.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (n === 0 && s === 23) return "h23";
  if (n === 24 && s === 23) return "h24";
  if (n === 0 && s === 11) return "h11";
  if (n === 12 && s === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function PD(t) {
  if (!Bi || !t)
    return null;
  let e = t.querySelector("[data-bits-announcer]");
  const r = (s) => {
    const o = t.createElement("div");
    return o.role = "log", o.ariaLive = s, o.setAttribute("aria-relevant", "additions"), o;
  };
  if (!xn(e)) {
    const s = t.createElement("div");
    s.style.cssText = W_, s.setAttribute("data-bits-announcer", ""), s.appendChild(r("assertive")), s.appendChild(r("polite")), e = s, t.body.insertBefore(e, t.body.firstChild);
  }
  return {
    getLog: (s) => {
      if (!xn(e))
        return null;
      const o = e.querySelector(`[aria-live="${s}"]`);
      return xn(o) ? o : null;
    }
  };
}
function vl(t) {
  const e = PD(t);
  function r(n, s = "assertive", o = 7500) {
    if (!e || !Bi || !t)
      return;
    const i = e.getLog(s), a = t.createElement("div");
    return typeof n == "number" ? n = n.toString() : n === null ? n = "Empty" : n = n.trim(), a.innerText = n, s === "assertive" ? i?.replaceChildren(a) : i?.appendChild(a), setTimeout(() => {
      a.remove();
    }, o);
  }
  return {
    announce: r
  };
}
const OD = {
  defaultValue: void 0,
  granularity: "day"
};
function B0(t) {
  const e = { ...OD, ...t }, { defaultValue: r, granularity: n, minValue: s, maxValue: o } = e;
  if (Array.isArray(r) && r.length)
    return r[r.length - 1];
  if (r && !Array.isArray(r))
    return r;
  {
    let i = /* @__PURE__ */ new Date();
    s && i < s.toDate(ft()) ? i = s.toDate(ft()) : o && i > o.toDate(ft()) && (i = o.toDate(ft()));
    const a = i.getFullYear(), l = i.getMonth() + 1, u = i.getDate();
    return ["hour", "minute", "second"].includes(n ?? "day") ? new $n(a, l, u, 0, 0, 0) : new ts(a, l, u);
  }
}
function z0(t, e) {
  let r;
  return e instanceof rn ? r = R0(t) : e instanceof $n ? r = F0(t) : r = Pi(t), r.calendar !== e.calendar ? dr(r, e.calendar) : r;
}
function yr(t, e = ft()) {
  return t instanceof rn ? t.toDate() : t.toDate(e);
}
function q0(t) {
  if (t instanceof ts)
    return "date";
  if (t instanceof $n)
    return "datetime";
  if (t instanceof rn)
    return "zoneddatetime";
  throw new Error("Unknown date type");
}
function CD(t, e) {
  switch (e) {
    case "date":
      return Pi(t);
    case "datetime":
      return F0(t);
    case "zoneddatetime":
      return R0(t);
    default:
      throw new Error(`Unknown date type: ${e}`);
  }
}
function kD(t) {
  return t instanceof $n;
}
function U0(t) {
  return t instanceof rn;
}
function qc(t) {
  return kD(t) || U0(t);
}
function $D(t) {
  if (t instanceof Date) {
    const e = t.getFullYear(), r = t.getMonth() + 1;
    return new Date(e, r, 0).getDate();
  } else
    return t.set({ day: 100 }).day;
}
function jt(t, e) {
  return t.compare(e) < 0;
}
function K0(t, e) {
  return t.compare(e) > 0;
}
function AD(t, e) {
  return t.compare(e) <= 0;
}
function ED(t, e) {
  return t.compare(e) >= 0;
}
function H0(t, e, r) {
  return ED(t, e) && AD(t, r);
}
function km(t, e, r) {
  const n = P0(t, r);
  return e > n ? t.subtract({ days: n + 7 - e }) : e === n ? t : t.subtract({ days: n - e });
}
function $m(t, e, r) {
  const n = P0(t, r), s = e === 0 ? 6 : e - 1;
  return n === s ? t : n > s ? t.add({ days: 7 - n + s }) : t.add({ days: s - n });
}
function TD(t, e, r, n) {
  if (r === void 0 && n === void 0)
    return !0;
  let s = t.add({ days: 1 });
  if (n?.(s) || r?.(s))
    return !1;
  const o = e;
  for (; s.compare(o) < 0; )
    if (s = s.add({ days: 1 }), n?.(s) || r?.(s))
      return !1;
  return !0;
}
const DD = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function W0(t) {
  let e = t.initialLocale;
  function r(_) {
    e = _;
  }
  function n() {
    return e;
  }
  function s(_, b) {
    return new Lt(e, b).format(_);
  }
  function o(_, b = !0) {
    return qc(_) && b ? s(yr(_), {
      dateStyle: "long",
      timeStyle: "long"
    }) : s(yr(_), {
      dateStyle: "long"
    });
  }
  function i(_) {
    if (typeof t.monthFormat.current != "function" && typeof t.yearFormat.current != "function")
      return new Lt(e, {
        month: t.monthFormat.current,
        year: t.yearFormat.current
      }).format(_);
    const b = typeof t.monthFormat.current == "function" ? t.monthFormat.current(_.getMonth() + 1) : new Lt(e, { month: t.monthFormat.current }).format(_), g = typeof t.yearFormat.current == "function" ? t.yearFormat.current(_.getFullYear()) : new Lt(e, { year: t.yearFormat.current }).format(_);
    return `${b} ${g}`;
  }
  function a(_) {
    return new Lt(e, { month: "long" }).format(_);
  }
  function l(_) {
    return new Lt(e, { year: "numeric" }).format(_);
  }
  function u(_, b) {
    return U0(_) ? new Lt(e, {
      ...b,
      timeZone: _.timeZone
    }).formatToParts(yr(_)) : new Lt(e, b).formatToParts(yr(_));
  }
  function c(_, b = "narrow") {
    return new Lt(e, { weekday: b }).format(_);
  }
  function f(_, b = void 0) {
    return new Lt(e, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: b === 24 ? "h23" : void 0
    }).formatToParts(_).find((y) => y.type === "dayPeriod")?.value === "PM" ? "PM" : "AM";
  }
  function p(_, b, g = {}) {
    const h = { ...DD, ...g }, S = u(_, h).find((x) => x.type === b);
    return S ? S.value : "";
  }
  return {
    setLocale: r,
    getLocale: n,
    fullMonth: a,
    fullYear: l,
    fullMonthAndYear: i,
    toParts: u,
    custom: s,
    part: p,
    dayPeriod: f,
    selectedDate: o,
    dayOfWeek: c
  };
}
function MD(t) {
  return !(!xn(t) || !t.hasAttribute("data-bits-day"));
}
function Am(t, e) {
  const r = [];
  let n = t.add({ days: 1 });
  const s = e;
  for (; n.compare(s) < 0; )
    r.push(n), n = n.add({ days: 1 });
  return r;
}
function tc(t) {
  const { dateObj: e, weekStartsOn: r, fixedWeeks: n, locale: s } = t, o = $D(e), i = Array.from({ length: o }, (h, y) => e.set({ day: y + 1 })), a = jc(e), l = YT(e), u = r !== void 0 ? km(a, r, "en-US") : km(a, 0, s), c = r !== void 0 ? $m(l, r, "en-US") : $m(l, 0, s), f = Am(u.subtract({ days: 1 }), a), p = Am(l, c.add({ days: 1 })), _ = f.length + i.length + p.length;
  if (n && _ < 42) {
    const h = 42 - _;
    let y = p[p.length - 1];
    y || (y = e.add({ months: 1 }).set({ day: 1 }));
    let S = h;
    p.length === 0 && (S = h - 1, p.push(y));
    const x = Array.from({ length: S }, (P, w) => {
      const O = w + 1;
      return y.add({ days: O });
    });
    p.push(...x);
  }
  const b = f.concat(i, p), g = ST(b, 7);
  return { value: e, dates: b, weeks: g };
}
function jo(t) {
  const { numberOfMonths: e, dateObj: r, ...n } = t, s = [];
  if (!e || e === 1)
    return s.push(tc({ ...n, dateObj: r })), s;
  s.push(tc({ ...n, dateObj: r }));
  for (let o = 1; o < e; o++) {
    const i = r.add({ months: o });
    s.push(tc({ ...n, dateObj: i }));
  }
  return s;
}
function rc(t) {
  return t ? Array.from(t.querySelectorAll("[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])")).filter((r) => xn(r)) : [];
}
function Em(t, e) {
  const r = t.getAttribute("data-value");
  r && (e.current = z0(r, e.current));
}
function G0({
  node: t,
  add: e,
  placeholder: r,
  calendarNode: n,
  isPrevButtonDisabled: s,
  isNextButtonDisabled: o,
  months: i,
  numberOfMonths: a
}) {
  const l = rc(n);
  if (!l.length) return;
  const c = l.indexOf(t) + e;
  if (Wa(c, l)) {
    const f = l[c];
    return Em(f, r), f.focus();
  }
  if (c < 0) {
    if (s) return;
    const f = i[0]?.value;
    if (!f) return;
    r.current = f.subtract({ months: a }), Jt(() => {
      const p = rc(n);
      if (!p.length) return;
      const _ = p.length - Math.abs(c);
      if (Wa(_, p)) {
        const b = p[_];
        return Em(b, r), b.focus();
      }
    });
  }
  if (c >= l.length) {
    if (o) return;
    const f = i[0]?.value;
    if (!f) return;
    r.current = f.add({ months: a }), Jt(() => {
      const p = rc(n);
      if (!p.length) return;
      const _ = c - l.length;
      if (Wa(_, p))
        return p[_].focus();
    });
  }
}
const Tm = [
  cr,
  Qt,
  ls,
  us
], Dm = [Vr, wr];
function Y0({ event: t, handleCellClick: e, shiftFocus: r, placeholderValue: n }) {
  const s = t.target;
  if (!MD(s) || !Tm.includes(t.key) && !Dm.includes(t.key)) return;
  t.preventDefault();
  const o = {
    [cr]: 7,
    [Qt]: -7,
    [ls]: -1,
    [us]: 1
  };
  if (Tm.includes(t.key)) {
    const i = o[t.key];
    i !== void 0 && r(s, i);
  }
  if (Dm.includes(t.key)) {
    const i = s.getAttribute("data-value");
    if (!i) return;
    e(t, z0(i, n));
  }
}
function X0({
  months: t,
  setMonths: e,
  numberOfMonths: r,
  pagedNavigation: n,
  weekStartsOn: s,
  locale: o,
  fixedWeeks: i,
  setPlaceholder: a
}) {
  const l = t[0]?.value;
  if (l)
    if (n)
      a(l.add({ months: r }));
    else {
      const u = l.add({ months: 1 }), c = jo({
        dateObj: u,
        weekStartsOn: s,
        locale: o,
        fixedWeeks: i,
        numberOfMonths: r
      });
      a(u), e(c);
    }
}
function J0({
  months: t,
  setMonths: e,
  numberOfMonths: r,
  pagedNavigation: n,
  weekStartsOn: s,
  locale: o,
  fixedWeeks: i,
  setPlaceholder: a
}) {
  const l = t[0]?.value;
  if (l)
    if (n)
      a(l.subtract({ months: r }));
    else {
      const u = l.subtract({ months: 1 }), c = jo({
        dateObj: u,
        weekStartsOn: s,
        locale: o,
        fixedWeeks: i,
        numberOfMonths: r
      });
      a(u), e(c);
    }
}
function Z0({ months: t, formatter: e, weekdayFormat: r }) {
  if (!t.length) return [];
  const s = t[0].weeks[0];
  return s ? s.map((o) => e.dayOfWeek(yr(o), r)) : [];
}
function Q0(t) {
  Ze(() => {
    const e = t.weekStartsOn.current, r = t.locale.current, n = t.fixedWeeks.current, s = t.numberOfMonths.current;
    ot(() => {
      const o = t.placeholder.current;
      if (!o) return;
      const i = { weekStartsOn: e, locale: r, fixedWeeks: n, numberOfMonths: s };
      t.setMonths(jo({ ...i, dateObj: o }));
    });
  });
}
function ID({ calendarNode: t, label: e, accessibleHeadingId: r }) {
  const n = ef(t), s = n.createElement("div");
  s.style.cssText = su({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const o = n.createElement("div");
  return o.textContent = e, o.id = r, o.role = "heading", o.ariaLevel = "2", t.insertBefore(s, t.firstChild), s.appendChild(o), () => {
    const i = n.getElementById(r);
    i && (s.parentElement?.removeChild(s), i.remove());
  };
}
function ew({
  placeholder: t,
  getVisibleMonths: e,
  weekStartsOn: r,
  locale: n,
  fixedWeeks: s,
  numberOfMonths: o,
  setMonths: i
}) {
  Ze(() => {
    t.current, ot(() => {
      if (e().some((l) => Lo(l, t.current)))
        return;
      const a = {
        weekStartsOn: r.current,
        locale: n.current,
        fixedWeeks: s.current,
        numberOfMonths: o.current
      };
      i(jo({ ...a, dateObj: t.current }));
    });
  });
}
function tw({ maxValue: t, months: e, disabled: r }) {
  if (!t || !e.length) return !1;
  if (r) return !0;
  const n = e[e.length - 1]?.value;
  if (!n) return !1;
  const s = n.add({ months: 1 }).set({ day: 1 });
  return K0(s, t);
}
function rw({ minValue: t, months: e, disabled: r }) {
  if (!t || !e.length) return !1;
  if (r) return !0;
  const n = e[0]?.value;
  if (!n) return !1;
  const s = n.subtract({ months: 1 }).set({ day: 35 });
  return jt(s, t);
}
function nw({ months: t, locale: e, formatter: r }) {
  if (!t.length) return "";
  if (e !== r.getLocale() && r.setLocale(e), t.length === 1) {
    const c = yr(t[0].value);
    return `${r.fullMonthAndYear(c)}`;
  }
  const n = yr(t[0].value), s = yr(t[t.length - 1].value), o = r.fullMonth(n), i = r.fullMonth(s), a = r.fullYear(n), l = r.fullYear(s);
  return a === l ? `${o} - ${i} ${l}` : `${o} ${a} - ${i} ${l}`;
}
function sw({ fullCalendarLabel: t, id: e, isInvalid: r, disabled: n, readonly: s }) {
  return {
    id: e,
    role: "application",
    "aria-label": t,
    "data-invalid": Fe(r),
    "data-disabled": Fe(n),
    "data-readonly": Fe(s)
  };
}
function ND(t) {
  if (!Bi) return;
  const e = Array.from(t.querySelectorAll("[data-bits-day]:not([aria-disabled=true])"));
  if (e.length === 0) return;
  const r = e[0], n = r?.getAttribute("data-value"), s = r?.getAttribute("data-type");
  if (!(!n || !s))
    return CD(n, s);
}
function ow({
  ref: t,
  placeholder: e,
  defaultPlaceholder: r,
  minValue: n,
  maxValue: s,
  isDateDisabled: o
}) {
  function i(a) {
    return !!(o.current(a) || n.current && jt(a, n.current) || s.current && jt(s.current, a));
  }
  Ne(() => t.current, () => {
    t.current && e.current && _t(e.current, r) && i(r) && (e.current = ND(t.current) ?? r);
  });
}
function FD(t, e) {
  return !t || !e ? t : qc(t) && qc(e) ? t.set({
    hour: e.hour,
    minute: e.minute,
    millisecond: e.millisecond,
    second: e.second
  }) : t;
}
const iw = rr({
  component: "calendar",
  parts: [
    "root",
    "grid",
    "cell",
    "next-button",
    "prev-button",
    "day",
    "grid-body",
    "grid-head",
    "grid-row",
    "head-cell",
    "header",
    "heading",
    "month-select",
    "year-select"
  ]
});
function aw(t) {
  const e = (/* @__PURE__ */ new Date()).getFullYear(), r = Math.max(t.placeholderYear, e);
  let n, s;
  if (t.minValue)
    n = t.minValue.year;
  else {
    const i = r - 100;
    n = t.placeholderYear < i ? t.placeholderYear - 10 : i;
  }
  t.maxValue ? s = t.maxValue.year : s = r + 10, n > s && (n = s);
  const o = s - n + 1;
  return Array.from({ length: o }, (i, a) => n + a);
}
const Ut = new ht("Calendar.Root | RangeCalender.Root");
class kf {
  static create(e) {
    return Ut.set(new kf(e));
  }
  opts;
  #e = /* @__PURE__ */ C(() => this.months.map((e) => e.value));
  get visibleMonths() {
    return d(this.#e);
  }
  set visibleMonths(e) {
    q(this.#e, e);
  }
  formatter;
  accessibleHeadingId = kn();
  domContext;
  attachment;
  #t = /* @__PURE__ */ xe(Pt([]));
  get months() {
    return d(this.#t);
  }
  set months(e) {
    q(this.#t, e, !0);
  }
  announcer;
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref), this.domContext = new Nn(e.ref), this.announcer = vl(null), this.formatter = W0({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    }), this.setMonths = this.setMonths.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.prevYear = this.prevYear.bind(this), this.nextYear = this.nextYear.bind(this), this.setYear = this.setYear.bind(this), this.setMonth = this.setMonth.bind(this), this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this), this.isDateDisabled = this.isDateDisabled.bind(this), this.isDateSelected = this.isDateSelected.bind(this), this.shiftFocus = this.shiftFocus.bind(this), this.handleCellClick = this.handleCellClick.bind(this), this.handleMultipleUpdate = this.handleMultipleUpdate.bind(this), this.handleSingleUpdate = this.handleSingleUpdate.bind(this), this.onkeydown = this.onkeydown.bind(this), this.getBitsAttr = this.getBitsAttr.bind(this), ko(() => {
      this.announcer = vl(this.domContext.getDocument());
    }), this.months = jo({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    }), this.#o(), this.#i(), this.#a(), ew({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: (r) => this.months = r
    }), Q0({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    }), Ne(() => this.fullCalendarLabel, (r) => {
      const n = this.domContext.getElementById(this.accessibleHeadingId);
      n && (n.textContent = r);
    }), Ne(() => this.opts.value.current, () => {
      const r = this.opts.value.current;
      if (Array.isArray(r) && r.length) {
        const n = r[r.length - 1];
        n && this.opts.placeholder.current !== n && (this.opts.placeholder.current = n);
      } else !Array.isArray(r) && r && this.opts.placeholder.current !== r && (this.opts.placeholder.current = r);
    }), ow({
      placeholder: e.placeholder,
      defaultPlaceholder: e.defaultPlaceholder,
      isDateDisabled: e.isDateDisabled,
      maxValue: e.maxValue,
      minValue: e.minValue,
      ref: e.ref
    });
  }
  setMonths(e) {
    this.months = e;
  }
  #r = /* @__PURE__ */ C(
    /**
     * This derived state holds an array of localized day names for the current
     * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,
     * updating its content when the option changes. Using this state to render the
     * calendar's days of the week is strongly recommended, as it guarantees that
     * the days are correctly formatted for the current locale and calendar view.
     */
    () => Z0({
      months: this.months,
      formatter: this.formatter,
      weekdayFormat: this.opts.weekdayFormat.current
    })
  );
  get weekdays() {
    return d(this.#r);
  }
  set weekdays(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => ot(() => this.opts.placeholder.current.year));
  get initialPlaceholderYear() {
    return d(this.#n);
  }
  set initialPlaceholderYear(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => aw({
    minValue: this.opts.minValue.current,
    maxValue: this.opts.maxValue.current,
    placeholderYear: this.initialPlaceholderYear
  }));
  get defaultYears() {
    return d(this.#s);
  }
  set defaultYears(e) {
    q(this.#s, e);
  }
  #o() {
    Ze(() => {
      if (ot(() => this.opts.initialFocus.current)) {
        const r = this.opts.ref.current?.querySelector("[data-focused]");
        r && r.focus();
      }
    });
  }
  #i() {
    Ze(() => this.opts.ref.current ? ID({
      calendarNode: this.opts.ref.current,
      label: this.fullCalendarLabel,
      accessibleHeadingId: this.accessibleHeadingId
    }) : void 0);
  }
  #a() {
    Co(() => {
      this.formatter.getLocale() !== this.opts.locale.current && this.formatter.setLocale(this.opts.locale.current);
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    X0({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    J0({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year: e });
  }
  setMonth(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month: e });
  }
  #u = /* @__PURE__ */ C(() => tw({
    maxValue: this.opts.maxValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isNextButtonDisabled() {
    return d(this.#u);
  }
  set isNextButtonDisabled(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ C(() => rw({
    minValue: this.opts.minValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isPrevButtonDisabled() {
    return d(this.#l);
  }
  set isPrevButtonDisabled(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ C(() => {
    const e = this.opts.value.current, r = this.opts.isDateDisabled.current, n = this.opts.isDateUnavailable.current;
    if (Array.isArray(e)) {
      if (!e.length) return !1;
      for (const s of e)
        if (r(s) || n(s)) return !0;
    } else {
      if (!e) return !1;
      if (r(e) || n(e)) return !0;
    }
    return !1;
  });
  get isInvalid() {
    return d(this.#c);
  }
  set isInvalid(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ C(() => (this.opts.monthFormat.current, this.opts.yearFormat.current, nw({
    months: this.months,
    formatter: this.formatter,
    locale: this.opts.locale.current
  })));
  get headingValue() {
    return d(this.#d);
  }
  set headingValue(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ C(() => `${this.opts.calendarLabel.current} ${this.headingValue}`);
  get fullCalendarLabel() {
    return d(this.#g);
  }
  set fullCalendarLabel(e) {
    q(this.#g, e);
  }
  isOutsideVisibleMonths(e) {
    return !this.visibleMonths.some((r) => Lo(e, r));
  }
  isDateDisabled(e) {
    if (this.opts.isDateDisabled.current(e) || this.opts.disabled.current) return !0;
    const r = this.opts.minValue.current, n = this.opts.maxValue.current;
    return !!(r && jt(e, r) || n && jt(n, e));
  }
  isDateSelected(e) {
    const r = this.opts.value.current;
    return Array.isArray(r) ? r.some((n) => _t(n, e)) : r ? _t(r, e) : !1;
  }
  shiftFocus(e, r) {
    return G0({
      node: e,
      add: r,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #m(e) {
    if (this.opts.type.current !== "multiple" || !this.opts.maxDays.current) return !0;
    const r = e.length;
    return !(this.opts.maxDays.current && r > this.opts.maxDays.current);
  }
  handleCellClick(e, r) {
    if (this.opts.readonly.current || this.opts.isDateDisabled.current?.(r) || this.opts.isDateUnavailable.current?.(r))
      return;
    const n = this.opts.value.current;
    if (this.opts.type.current === "multiple")
      (Array.isArray(n) || n === void 0) && (this.opts.value.current = this.handleMultipleUpdate(n, r));
    else if (!Array.isArray(n)) {
      const o = this.handleSingleUpdate(n, r);
      o ? this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(o, !1)}`, "polite") : this.announcer.announce("Selected date is now empty.", "polite", 5e3), this.opts.value.current = FD(o, n), o !== void 0 && this.opts.onDateSelect?.current?.();
    }
  }
  handleMultipleUpdate(e, r) {
    if (!e) {
      const o = [r];
      return this.#m(o) ? o : [r];
    }
    if (!Array.isArray(e))
      return;
    const n = e.findIndex((o) => _t(o, r)), s = this.opts.preventDeselect.current;
    if (n === -1) {
      const o = [...e, r];
      return this.#m(o) ? o : [r];
    } else {
      if (s)
        return e;
      {
        const o = e.filter((i) => !_t(i, r));
        if (!o.length) {
          this.opts.placeholder.current = r;
          return;
        }
        return o;
      }
    }
  }
  handleSingleUpdate(e, r) {
    if (!e) return r;
    if (!this.opts.preventDeselect.current && _t(e, r)) {
      this.opts.placeholder.current = r;
      return;
    }
    return r;
  }
  onkeydown(e) {
    Y0({
      event: e,
      handleCellClick: this.handleCellClick,
      shiftFocus: this.shiftFocus,
      placeholderValue: this.opts.placeholder.current
    });
  }
  #p = /* @__PURE__ */ C(() => ({ months: this.months, weekdays: this.weekdays }));
  get snippetProps() {
    return d(this.#p);
  }
  set snippetProps(e) {
    q(this.#p, e);
  }
  getBitsAttr = (e) => iw.getAttr(e);
  #f = /* @__PURE__ */ C(() => ({
    ...sw({
      fullCalendarLabel: this.fullCalendarLabel,
      id: this.opts.id.current,
      isInvalid: this.isInvalid,
      disabled: this.opts.disabled.current,
      readonly: this.opts.readonly.current
    }),
    [this.getBitsAttr("root")]: "",
    //
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#f);
  }
  set props(e) {
    q(this.#f, e);
  }
}
class $f {
  static create(e) {
    return new $f(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "aria-hidden": tf(!0),
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    [this.root.getBitsAttr("heading")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
const lw = new ht("Calendar.Cell | RangeCalendar.Cell");
class Af {
  static create(e) {
    return lw.set(new Af(e, Ut.get()));
  }
  opts;
  root;
  #e = /* @__PURE__ */ C(() => yr(this.opts.date.current));
  get cellDate() {
    return d(this.#e);
  }
  set cellDate(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.root.opts.isDateUnavailable.current(this.opts.date.current));
  get isUnavailable() {
    return d(this.#t);
  }
  set isUnavailable(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => x0(this.opts.date.current, ft()));
  get isDateToday() {
    return d(this.#r);
  }
  set isDateToday(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => !Lo(this.opts.date.current, this.opts.month.current));
  get isOutsideMonth() {
    return d(this.#n);
  }
  set isOutsideMonth(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => this.root.isOutsideVisibleMonths(this.opts.date.current));
  get isOutsideVisibleMonths() {
    return d(this.#s);
  }
  set isOutsideVisibleMonths(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ C(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current);
  get isDisabled() {
    return d(this.#o);
  }
  set isDisabled(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => _t(this.opts.date.current, this.root.opts.placeholder.current));
  get isFocusedDate() {
    return d(this.#i);
  }
  set isFocusedDate(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ C(() => this.root.isDateSelected(this.opts.date.current));
  get isSelectedDate() {
    return d(this.#a);
  }
  set isSelectedDate(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ C(() => this.root.formatter.custom(this.cellDate, {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  }));
  get labelText() {
    return d(this.#u);
  }
  set labelText(e) {
    q(this.#u, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #l = /* @__PURE__ */ C(() => ({
    disabled: this.isDisabled,
    unavailable: this.isUnavailable,
    selected: this.isSelectedDate,
    day: `${this.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#l);
  }
  set snippetProps(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ C(() => this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable);
  get ariaDisabled() {
    return d(this.#c);
  }
  set ariaDisabled(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ C(() => ({
    "data-unavailable": Fe(this.isUnavailable),
    "data-today": this.isDateToday ? "" : void 0,
    "data-outside-month": this.isOutsideMonth ? "" : void 0,
    "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
    "data-focused": this.isFocusedDate ? "" : void 0,
    "data-selected": Fe(this.isSelectedDate),
    "data-value": this.opts.date.current.toString(),
    "data-type": q0(this.opts.date.current),
    "data-disabled": Fe(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
  }));
  get sharedDataAttrs() {
    return d(this.#d);
  }
  set sharedDataAttrs(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "gridcell",
    "aria-selected": at(this.isSelectedDate),
    "aria-disabled": at(this.ariaDisabled),
    ...this.sharedDataAttrs,
    [this.root.getBitsAttr("cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#g);
  }
  set props(e) {
    q(this.#g, e);
  }
}
class Ef {
  static create(e) {
    return new Ef(e, lw.get());
  }
  opts;
  cell;
  attachment;
  constructor(e, r) {
    this.opts = e, this.cell = r, this.onclick = this.onclick.bind(this), this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1);
  onclick(e) {
    this.cell.isDisabled || this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  #t = /* @__PURE__ */ C(() => ({
    disabled: this.cell.isDisabled,
    unavailable: this.cell.isUnavailable,
    selected: this.cell.isSelectedDate,
    day: `${this.cell.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#t);
  }
  set snippetProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "button",
    "aria-label": this.cell.labelText,
    "aria-disabled": at(this.cell.ariaDisabled),
    ...this.cell.sharedDataAttrs,
    tabindex: d(this.#e),
    [this.cell.root.getBitsAttr("day")]: "",
    "data-bits-day": "",
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
class Tf {
  static create(e) {
    return new Tf(e, Ut.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ C(() => this.root.isNextButtonDisabled);
  get isDisabled() {
    return d(this.#e);
  }
  set isDisabled(e) {
    q(this.#e, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onclick = this.onclick.bind(this), this.attachment = Ee(this.opts.ref);
  }
  onclick(e) {
    this.isDisabled || this.root.nextPage();
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "button",
    type: "button",
    "aria-label": "Next",
    "aria-disabled": at(this.isDisabled),
    "data-disabled": Fe(this.isDisabled),
    disabled: this.isDisabled,
    [this.root.getBitsAttr("next-button")]: "",
    //
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Df {
  static create(e) {
    return new Df(e, Ut.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ C(() => this.root.isPrevButtonDisabled);
  get isDisabled() {
    return d(this.#e);
  }
  set isDisabled(e) {
    q(this.#e, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onclick = this.onclick.bind(this), this.attachment = Ee(this.opts.ref);
  }
  onclick(e) {
    this.isDisabled || this.root.prevPage();
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "button",
    type: "button",
    "aria-label": "Previous",
    "aria-disabled": at(this.isDisabled),
    "data-disabled": Fe(this.isDisabled),
    disabled: this.isDisabled,
    [this.root.getBitsAttr("prev-button")]: "",
    //
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Mf {
  static create(e) {
    return new Mf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    tabindex: -1,
    role: "grid",
    "aria-readonly": at(this.root.opts.readonly.current),
    "aria-disabled": at(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    "data-disabled": Fe(this.root.opts.disabled.current),
    [this.root.getBitsAttr("grid")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class If {
  static create(e) {
    return new If(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-body")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Nf {
  static create(e) {
    return new Nf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-head")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Ff {
  static create(e) {
    return new Ff(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    [this.root.getBitsAttr("grid-row")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Rf {
  static create(e) {
    return new Rf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    [this.root.getBitsAttr("head-cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Vf {
  static create(e) {
    return new Vf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-readonly": Fe(this.root.opts.readonly.current),
    [this.root.getBitsAttr("header")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Lf {
  static create(e) {
    return new Lf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onchange = this.onchange.bind(this), this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => {
    this.root.opts.locale.current;
    const e = this.opts.months.current, r = this.opts.monthFormat.current, n = [];
    for (const s of e) {
      const o = this.root.opts.placeholder.current.set({ month: s });
      let i;
      typeof r == "function" ? i = r(s) : i = this.root.formatter.custom(yr(o), { month: r }), n.push({ value: s, label: i });
    }
    return n;
  });
  get monthItems() {
    return d(this.#e);
  }
  set monthItems(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.root.opts.placeholder.current.month);
  get currentMonth() {
    return d(this.#t);
  }
  set currentMonth(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => this.root.opts.disabled.current || this.opts.disabled.current);
  get isDisabled() {
    return d(this.#r);
  }
  set isDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => ({
    monthItems: this.monthItems,
    selectedMonthItem: this.monthItems.find((e) => e.value === this.currentMonth)
  }));
  get snippetProps() {
    return d(this.#n);
  }
  set snippetProps(e) {
    q(this.#n, e);
  }
  onchange(e) {
    if (this.isDisabled) return;
    const r = e.target, n = parseInt(r.value, 10);
    isNaN(n) || (this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ month: n }));
  }
  #s = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    value: this.currentMonth,
    disabled: this.isDisabled,
    "data-disabled": Fe(this.isDisabled),
    [this.root.getBitsAttr("month-select")]: "",
    //
    onchange: this.onchange,
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class jf {
  static create(e) {
    return new jf(e, Ut.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.onchange = this.onchange.bind(this), this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => this.opts.years.current && this.opts.years.current.length ? this.opts.years.current : this.root.defaultYears);
  get years() {
    return d(this.#e);
  }
  set years(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => {
    this.root.opts.locale.current;
    const e = this.opts.yearFormat.current, r = [];
    for (const n of this.years) {
      const s = this.root.opts.placeholder.current.set({ year: n });
      let o;
      typeof e == "function" ? o = e(n) : o = this.root.formatter.custom(yr(s), { year: e }), r.push({ value: n, label: o });
    }
    return r;
  });
  get yearItems() {
    return d(this.#t);
  }
  set yearItems(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => this.root.opts.placeholder.current.year);
  get currentYear() {
    return d(this.#r);
  }
  set currentYear(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => this.root.opts.disabled.current || this.opts.disabled.current);
  get isDisabled() {
    return d(this.#n);
  }
  set isDisabled(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => ({
    yearItems: this.yearItems,
    selectedYearItem: this.yearItems.find((e) => e.value === this.currentYear)
  }));
  get snippetProps() {
    return d(this.#s);
  }
  set snippetProps(e) {
    q(this.#s, e);
  }
  onchange(e) {
    if (this.isDisabled) return;
    const r = e.target, n = parseInt(r.value, 10);
    isNaN(n) || (this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ year: n }));
  }
  #o = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    value: this.currentYear,
    disabled: this.isDisabled,
    "data-disabled": Fe(this.isDisabled),
    [this.root.getBitsAttr("year-select")]: "",
    //
    onchange: this.onchange,
    ...this.attachment
  }));
  get props() {
    return d(this.#o);
  }
  set props(e) {
    q(this.#o, e);
  }
}
var RD = /* @__PURE__ */ ne("<div><!></div>");
function uw(t, e) {
  H(e, !0);
  let r = v(e, "child", 7), n = v(e, "children", 7), s = v(e, "id", 23, kn), o = v(e, "ref", 15, null), i = v(e, "value", 15), a = v(e, "onValueChange", 7, _e), l = v(e, "placeholder", 15), u = v(e, "onPlaceholderChange", 7, _e), c = v(e, "weekdayFormat", 7, "narrow"), f = v(e, "weekStartsOn", 7), p = v(e, "pagedNavigation", 7, !1), _ = v(e, "isDateDisabled", 7, () => !1), b = v(e, "isDateUnavailable", 7, () => !1), g = v(e, "fixedWeeks", 7, !1), h = v(e, "numberOfMonths", 7, 1), y = v(e, "locale", 7), S = v(e, "calendarLabel", 7, "Event"), x = v(e, "disabled", 7, !1), P = v(e, "readonly", 7, !1), w = v(e, "minValue", 7, void 0), O = v(e, "maxValue", 7, void 0), k = v(e, "preventDeselect", 7, !1), $ = v(e, "type", 7), T = v(e, "disableDaysOutsideMonth", 7, !0), E = v(e, "initialFocus", 7, !1), M = v(e, "maxDays", 7), R = v(e, "monthFormat", 7, "long"), U = v(e, "yearFormat", 7, "numeric"), B = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "type",
    "disableDaysOutsideMonth",
    "initialFocus",
    "maxDays",
    "monthFormat",
    "yearFormat"
  ]);
  const F = B0({
    defaultValue: i(),
    minValue: w(),
    maxValue: O()
  });
  function Z() {
    l() === void 0 && l(F);
  }
  Z(), Ne.pre(() => l(), () => {
    Z();
  });
  function Y() {
    i() === void 0 && i($() === "single" ? void 0 : []);
  }
  Y(), Ne.pre(() => i(), () => {
    Y();
  });
  const X = kf.create({
    id: z(() => s()),
    ref: z(() => o(), (V) => o(V)),
    weekdayFormat: z(() => c()),
    weekStartsOn: z(() => f()),
    pagedNavigation: z(() => p()),
    isDateDisabled: z(() => _()),
    isDateUnavailable: z(() => b()),
    fixedWeeks: z(() => g()),
    numberOfMonths: z(() => h()),
    locale: o0(() => y()),
    calendarLabel: z(() => S()),
    readonly: z(() => P()),
    disabled: z(() => x()),
    minValue: z(() => w()),
    maxValue: z(() => O()),
    disableDaysOutsideMonth: z(() => T()),
    initialFocus: z(() => E()),
    maxDays: z(() => M()),
    placeholder: z(() => l(), (V) => {
      l(V), u()(V);
    }),
    preventDeselect: z(() => k()),
    value: z(() => i(), (V) => {
      i(V), a()(V);
    }),
    type: z(() => $()),
    monthFormat: z(() => R()),
    yearFormat: z(() => U()),
    defaultPlaceholder: F
  }), ae = /* @__PURE__ */ C(() => Ce(B, X.props));
  var J = {
    get child() {
      return r();
    },
    set child(V) {
      r(V), m();
    },
    get children() {
      return n();
    },
    set children(V) {
      n(V), m();
    },
    get id() {
      return s();
    },
    set id(V = kn()) {
      s(V), m();
    },
    get ref() {
      return o();
    },
    set ref(V = null) {
      o(V), m();
    },
    get value() {
      return i();
    },
    set value(V) {
      i(V), m();
    },
    get onValueChange() {
      return a();
    },
    set onValueChange(V = _e) {
      a(V), m();
    },
    get placeholder() {
      return l();
    },
    set placeholder(V) {
      l(V), m();
    },
    get onPlaceholderChange() {
      return u();
    },
    set onPlaceholderChange(V = _e) {
      u(V), m();
    },
    get weekdayFormat() {
      return c();
    },
    set weekdayFormat(V = "narrow") {
      c(V), m();
    },
    get weekStartsOn() {
      return f();
    },
    set weekStartsOn(V) {
      f(V), m();
    },
    get pagedNavigation() {
      return p();
    },
    set pagedNavigation(V = !1) {
      p(V), m();
    },
    get isDateDisabled() {
      return _();
    },
    set isDateDisabled(V = () => !1) {
      _(V), m();
    },
    get isDateUnavailable() {
      return b();
    },
    set isDateUnavailable(V = () => !1) {
      b(V), m();
    },
    get fixedWeeks() {
      return g();
    },
    set fixedWeeks(V = !1) {
      g(V), m();
    },
    get numberOfMonths() {
      return h();
    },
    set numberOfMonths(V = 1) {
      h(V), m();
    },
    get locale() {
      return y();
    },
    set locale(V) {
      y(V), m();
    },
    get calendarLabel() {
      return S();
    },
    set calendarLabel(V = "Event") {
      S(V), m();
    },
    get disabled() {
      return x();
    },
    set disabled(V = !1) {
      x(V), m();
    },
    get readonly() {
      return P();
    },
    set readonly(V = !1) {
      P(V), m();
    },
    get minValue() {
      return w();
    },
    set minValue(V = void 0) {
      w(V), m();
    },
    get maxValue() {
      return O();
    },
    set maxValue(V = void 0) {
      O(V), m();
    },
    get preventDeselect() {
      return k();
    },
    set preventDeselect(V = !1) {
      k(V), m();
    },
    get type() {
      return $();
    },
    set type(V) {
      $(V), m();
    },
    get disableDaysOutsideMonth() {
      return T();
    },
    set disableDaysOutsideMonth(V = !0) {
      T(V), m();
    },
    get initialFocus() {
      return E();
    },
    set initialFocus(V = !1) {
      E(V), m();
    },
    get maxDays() {
      return M();
    },
    set maxDays(V) {
      M(V), m();
    },
    get monthFormat() {
      return R();
    },
    set monthFormat(V = "long") {
      R(V), m();
    },
    get yearFormat() {
      return U();
    },
    set yearFormat(V = "numeric") {
      U(V), m();
    }
  }, j = I(), ee = D(j);
  {
    var L = (V) => {
      var G = I(), fe = D(G);
      {
        let se = /* @__PURE__ */ C(() => ({ props: d(ae), ...X.snippetProps }));
        te(fe, r, () => d(se));
      }
      A(V, G);
    }, N = (V) => {
      var G = RD();
      ve(G, () => ({ ...d(ae) }));
      var fe = he(G);
      te(fe, () => n() ?? ge, () => X.snippetProps), de(G), A(V, G);
    };
    ue(ee, (V) => {
      r() ? V(L) : V(N, !1);
    });
  }
  return A(t, j), W(J);
}
K(
  uw,
  {
    child: {},
    children: {},
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    placeholder: {},
    onPlaceholderChange: {},
    weekdayFormat: {},
    weekStartsOn: {},
    pagedNavigation: {},
    isDateDisabled: {},
    isDateUnavailable: {},
    fixedWeeks: {},
    numberOfMonths: {},
    locale: {},
    calendarLabel: {},
    disabled: {},
    readonly: {},
    minValue: {},
    maxValue: {},
    preventDeselect: {},
    type: {},
    disableDaysOutsideMonth: {},
    initialFocus: {},
    maxDays: {},
    monthFormat: {},
    yearFormat: {}
  },
  [],
  [],
  { mode: "open" }
);
var VD = /* @__PURE__ */ ne("<div><!></div>");
function cw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Ef.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      {
        let S = /* @__PURE__ */ C(() => ({ props: d(u), ...l.snippetProps }));
        te(y, s, () => d(S));
      }
      A(g, h);
    }, b = (g) => {
      var h = VD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      {
        var S = (P) => {
          var w = I(), O = D(w);
          te(O, () => n() ?? ge, () => l.snippetProps), A(P, w);
        }, x = (P) => {
          var w = tt();
          ke(() => Me(w, l.cell.opts.date.current.day)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(cw, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var LD = /* @__PURE__ */ ne("<table><!></table>");
function Bf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Mf.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = LD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Bf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var jD = /* @__PURE__ */ ne("<tbody><!></tbody>");
function zf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = If.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = jD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(zf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var BD = /* @__PURE__ */ ne("<td><!></td>");
function dw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "date", 7), l = v(e, "month", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "date",
    "month"
  ]);
  const c = Af.create({
    id: z(() => i()),
    ref: z(() => o(), (y) => o(y)),
    date: z(() => a()),
    month: z(() => l())
  }), f = /* @__PURE__ */ C(() => Ce(u, c.props));
  var p = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get ref() {
      return o();
    },
    set ref(y = null) {
      o(y), m();
    },
    get id() {
      return i();
    },
    set id(y = me(r)) {
      i(y), m();
    },
    get date() {
      return a();
    },
    set date(y) {
      a(y), m();
    },
    get month() {
      return l();
    },
    set month(y) {
      l(y), m();
    }
  }, _ = I(), b = D(_);
  {
    var g = (y) => {
      var S = I(), x = D(S);
      {
        let P = /* @__PURE__ */ C(() => ({ props: d(f), ...c.snippetProps }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = BD();
      ve(S, () => ({ ...d(f) }));
      var x = he(S);
      te(x, () => n() ?? ge, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(g) : y(h, !1);
    });
  }
  return A(t, _), W(p);
}
K(
  dw,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    date: {},
    month: {}
  },
  [],
  [],
  { mode: "open" }
);
var zD = /* @__PURE__ */ ne("<thead><!></thead>");
function qf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Nf.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = zD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(qf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var qD = /* @__PURE__ */ ne("<th><!></th>");
function Uf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Rf.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = qD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Uf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var UD = /* @__PURE__ */ ne("<tr><!></tr>");
function Kf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Ff.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = UD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Kf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var KD = /* @__PURE__ */ ne("<header><!></header>");
function Hf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Vf.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = KD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Hf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var HD = /* @__PURE__ */ ne("<div><!></div>");
function Wf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = $f.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({
        props: d(u),
        headingValue: l.root.headingValue
      })), A(g, h);
    }, b = (g) => {
      var h = HD();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      {
        var S = (P) => {
          var w = I(), O = D(w);
          te(O, () => n() ?? ge, () => ({ headingValue: l.root.headingValue })), A(P, w);
        }, x = (P) => {
          var w = tt();
          ke(() => Me(w, l.root.headingValue)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Wf, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var WD = /* @__PURE__ */ ne("<option> </option>"), GD = /* @__PURE__ */ ne("<!>", 1), YD = /* @__PURE__ */ ne("<select><!></select>");
function Gf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "months", 23, () => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), l = v(e, "monthFormat", 7, "long"), u = v(e, "disabled", 7, !1), c = v(e, "aria-label", 7, "Select a month"), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "months",
    "monthFormat",
    "disabled",
    "aria-label"
  ]);
  const p = Lf.create({
    id: z(() => i()),
    ref: z(() => o(), (x) => o(x)),
    months: z(() => a()),
    monthFormat: z(() => l()),
    disabled: z(() => !!u())
  }), _ = /* @__PURE__ */ C(() => Ce(f, p.props, { "aria-label": c() }));
  var b = {
    get children() {
      return n();
    },
    set children(x) {
      n(x), m();
    },
    get child() {
      return s();
    },
    set child(x) {
      s(x), m();
    },
    get ref() {
      return o();
    },
    set ref(x = null) {
      o(x), m();
    },
    get id() {
      return i();
    },
    set id(x = me(r)) {
      i(x), m();
    },
    get months() {
      return a();
    },
    set months(x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) {
      a(x), m();
    },
    get monthFormat() {
      return l();
    },
    set monthFormat(x = "long") {
      l(x), m();
    },
    get disabled() {
      return u();
    },
    set disabled(x = !1) {
      u(x), m();
    },
    get "aria-label"() {
      return c();
    },
    set "aria-label"(x = "Select a month") {
      c(x), m();
    }
  }, g = I(), h = D(g);
  {
    var y = (x) => {
      var P = I(), w = D(P);
      {
        let O = /* @__PURE__ */ C(() => ({ props: d(_), ...p.snippetProps }));
        te(w, s, () => d(O));
      }
      A(x, P);
    }, S = (x) => {
      var P = YD();
      ve(P, () => ({ ...d(_) })), ny(P, () => {
        var w = he(P), O = GD(), k = D(O);
        {
          var $ = (E) => {
            var M = I(), R = D(M);
            te(R, () => n() ?? ge, () => p.snippetProps), A(E, M);
          }, T = (E) => {
            var M = I(), R = D(M);
            st(R, 17, () => p.monthItems, (U) => U.value, (U, B) => {
              var F = WD(), Z = he(F, !0);
              de(F);
              var Y = {};
              ke(() => {
                zs(F, d(B).value === p.currentMonth), Me(Z, d(B).label), Y !== (Y = d(B).value) && (F.value = (F.__value = d(B).value) ?? "");
              }), A(U, F);
            }), A(E, M);
          };
          ue(k, (E) => {
            n() ? E($) : E(T, !1);
          });
        }
        A(w, O);
      }), A(x, P);
    };
    ue(h, (x) => {
      s() ? x(y) : x(S, !1);
    });
  }
  return A(t, g), W(b);
}
K(
  Gf,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    months: {},
    monthFormat: {},
    disabled: {},
    "aria-label": {}
  },
  [],
  [],
  { mode: "open" }
);
var XD = /* @__PURE__ */ ne("<button><!></button>");
function Yf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "tabindex", 7, 0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const u = Tf.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h))
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props, { tabindex: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get tabindex() {
      return a();
    },
    set tabindex(h = 0) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = XD();
      ve(y, () => ({ ...d(c) }));
      var S = he(y);
      te(S, () => n() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(Yf, { children: {}, child: {}, id: {}, ref: {}, tabindex: {} }, [], [], { mode: "open" });
var JD = /* @__PURE__ */ ne("<button><!></button>");
function Xf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "tabindex", 7, 0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const u = Df.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h))
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props, { tabindex: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get tabindex() {
      return a();
    },
    set tabindex(h = 0) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = JD();
      ve(y, () => ({ ...d(c) }));
      var S = he(y);
      te(S, () => n() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(Xf, { children: {}, child: {}, id: {}, ref: {}, tabindex: {} }, [], [], { mode: "open" });
var ZD = /* @__PURE__ */ ne("<option> </option>"), QD = /* @__PURE__ */ ne("<!>", 1), eM = /* @__PURE__ */ ne("<select><!></select>");
function Jf(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "years", 7), l = v(e, "yearFormat", 7, "numeric"), u = v(e, "disabled", 7, !1), c = v(e, "aria-label", 7, "Select a year"), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "years",
    "yearFormat",
    "disabled",
    "aria-label"
  ]);
  const p = jf.create({
    id: z(() => i()),
    ref: z(() => o(), (x) => o(x)),
    years: z(() => a()),
    yearFormat: z(() => l()),
    disabled: z(() => !!u())
  }), _ = /* @__PURE__ */ C(() => Ce(f, p.props, { "aria-label": c() }));
  var b = {
    get children() {
      return n();
    },
    set children(x) {
      n(x), m();
    },
    get child() {
      return s();
    },
    set child(x) {
      s(x), m();
    },
    get ref() {
      return o();
    },
    set ref(x = null) {
      o(x), m();
    },
    get id() {
      return i();
    },
    set id(x = me(r)) {
      i(x), m();
    },
    get years() {
      return a();
    },
    set years(x) {
      a(x), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(x = "numeric") {
      l(x), m();
    },
    get disabled() {
      return u();
    },
    set disabled(x = !1) {
      u(x), m();
    },
    get "aria-label"() {
      return c();
    },
    set "aria-label"(x = "Select a year") {
      c(x), m();
    }
  }, g = I(), h = D(g);
  {
    var y = (x) => {
      var P = I(), w = D(P);
      {
        let O = /* @__PURE__ */ C(() => ({ props: d(_), ...p.snippetProps }));
        te(w, s, () => d(O));
      }
      A(x, P);
    }, S = (x) => {
      var P = eM();
      ve(P, () => ({ ...d(_) })), ny(P, () => {
        var w = he(P), O = QD(), k = D(O);
        {
          var $ = (E) => {
            var M = I(), R = D(M);
            te(R, () => n() ?? ge, () => p.snippetProps), A(E, M);
          }, T = (E) => {
            var M = I(), R = D(M);
            st(R, 17, () => p.yearItems, (U) => U.value, (U, B) => {
              var F = ZD(), Z = he(F, !0);
              de(F);
              var Y = {};
              ke(() => {
                zs(F, d(B).value === p.currentYear), Me(Z, d(B).label), Y !== (Y = d(B).value) && (F.value = (F.__value = d(B).value) ?? "");
              }), A(U, F);
            }), A(E, M);
          };
          ue(k, (E) => {
            n() ? E($) : E(T, !1);
          });
        }
        A(w, O);
      }), A(x, P);
    };
    ue(h, (x) => {
      s() ? x(y) : x(S, !1);
    });
  }
  return A(t, g), W(b);
}
K(
  Jf,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    years: {},
    yearFormat: {},
    disabled: {},
    "aria-label": {}
  },
  [],
  [],
  { mode: "open" }
);
const tM = rr({
  component: "checkbox",
  parts: ["root", "group", "group-label", "input"]
}), rM = new ht("Checkbox.Group"), fw = new ht("Checkbox.Root");
class Zf {
  static create(e, r = null) {
    return fw.set(new Zf(e, r));
  }
  opts;
  group;
  #e = /* @__PURE__ */ C(() => this.group && this.group.opts.name.current ? this.group.opts.name.current : this.opts.name.current);
  get trueName() {
    return d(this.#e);
  }
  set trueName(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.group && this.group.opts.required.current ? !0 : this.opts.required.current);
  get trueRequired() {
    return d(this.#t);
  }
  set trueRequired(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => this.group && this.group.opts.disabled.current ? !0 : this.opts.disabled.current);
  get trueDisabled() {
    return d(this.#r);
  }
  set trueDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => this.group && this.group.opts.readonly.current ? !0 : this.opts.readonly.current);
  get trueReadonly() {
    return d(this.#n);
  }
  set trueReadonly(e) {
    q(this.#n, e);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Ee(this.opts.ref), this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this), Ne.pre(
      [
        () => xo(this.group?.opts.value.current),
        () => this.opts.value.current
      ],
      ([n, s]) => {
        !n || !s || (this.opts.checked.current = n.includes(s));
      }
    ), Ne.pre(() => this.opts.checked.current, (n) => {
      this.group && (n ? this.group?.addValue(this.opts.value.current) : this.group?.removeValue(this.opts.value.current));
    });
  }
  onkeydown(e) {
    if (!(this.trueDisabled || this.trueReadonly)) {
      if (e.key === Vr) {
        e.preventDefault(), this.opts.type.current === "submit" && e.currentTarget.closest("form")?.requestSubmit();
        return;
      }
      e.key === wr && (e.preventDefault(), this.#s());
    }
  }
  #s() {
    this.opts.indeterminate.current ? (this.opts.indeterminate.current = !1, this.opts.checked.current = !0) : this.opts.checked.current = !this.opts.checked.current;
  }
  onclick(e) {
    if (!(this.trueDisabled || this.trueReadonly)) {
      if (this.opts.type.current === "submit") {
        this.#s();
        return;
      }
      e.preventDefault(), this.#s();
    }
  }
  #o = /* @__PURE__ */ C(() => ({
    checked: this.opts.checked.current,
    indeterminate: this.opts.indeterminate.current
  }));
  get snippetProps() {
    return d(this.#o);
  }
  set snippetProps(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "checkbox",
    type: this.opts.type.current,
    disabled: this.trueDisabled,
    "aria-checked": ou(this.opts.checked.current, this.opts.indeterminate.current),
    "aria-required": at(this.trueRequired),
    "aria-readonly": at(this.trueReadonly),
    "data-disabled": Fe(this.trueDisabled),
    "data-readonly": Fe(this.trueReadonly),
    "data-state": nM(this.opts.checked.current, this.opts.indeterminate.current),
    [tM.root]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#i);
  }
  set props(e) {
    q(this.#i, e);
  }
}
class Qf {
  static create() {
    return new Qf(fw.get());
  }
  root;
  #e = /* @__PURE__ */ C(() => this.root.group ? !!(this.root.opts.value.current !== void 0 && this.root.group.opts.value.current.includes(this.root.opts.value.current)) : this.root.opts.checked.current);
  get trueChecked() {
    return d(this.#e);
  }
  set trueChecked(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => !!this.root.trueName);
  get shouldRender() {
    return d(this.#t);
  }
  set shouldRender(e) {
    q(this.#t, e);
  }
  constructor(e) {
    this.root = e, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    xn(this.root.opts.ref.current) && this.root.opts.ref.current.focus();
  }
  #r = /* @__PURE__ */ C(() => ({
    type: "checkbox",
    checked: this.root.opts.checked.current === !0,
    disabled: this.root.trueDisabled,
    required: this.root.trueRequired,
    name: this.root.trueName,
    value: this.root.opts.value.current,
    readonly: this.root.trueReadonly,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
function nM(t, e) {
  return e ? "indeterminate" : t ? "checked" : "unchecked";
}
var sM = /* @__PURE__ */ ne("<input/>"), oM = /* @__PURE__ */ ne("<input/>");
function zi(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "value"]);
  const s = /* @__PURE__ */ C(() => Ce(n, {
    "aria-hidden": "true",
    tabindex: -1,
    style: W_
  }));
  var o = {
    get value() {
      return r();
    },
    set value(c) {
      r(c), m();
    }
  }, i = I(), a = D(i);
  {
    var l = (c) => {
      var f = sM();
      ve(f, () => ({ ...d(s), value: r() }), void 0, void 0, void 0, void 0, !0), A(c, f);
    }, u = (c) => {
      var f = oM();
      ve(f, () => ({ ...d(s) }), void 0, void 0, void 0, void 0, !0), fo(f, r), A(c, f);
    };
    ue(a, (c) => {
      d(s).type === "checkbox" ? c(l) : c(u, !1);
    });
  }
  return A(t, i), W(o);
}
K(zi, { value: {} }, [], [], { mode: "open" });
function hw(t, e) {
  H(e, !1);
  const r = Qf.create();
  vd();
  var n = I(), s = D(n);
  {
    var o = (i) => {
      zi(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), W();
}
K(hw, {}, [], [], { mode: "open" });
var iM = /* @__PURE__ */ ne("<button><!></button>"), aM = /* @__PURE__ */ ne("<!> <!>", 1);
function gw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "checked", 15, !1), s = v(e, "ref", 15, null), o = v(e, "onCheckedChange", 7), i = v(e, "children", 7), a = v(e, "disabled", 7, !1), l = v(e, "required", 7, !1), u = v(e, "name", 7, void 0), c = v(e, "value", 7, "on"), f = v(e, "id", 23, () => me(r)), p = v(e, "indeterminate", 15, !1), _ = v(e, "onIndeterminateChange", 7), b = v(e, "child", 7), g = v(e, "type", 7, "button"), h = v(e, "readonly", 7), y = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "checked",
    "ref",
    "onCheckedChange",
    "children",
    "disabled",
    "required",
    "name",
    "value",
    "id",
    "indeterminate",
    "onIndeterminateChange",
    "child",
    "type",
    "readonly"
  ]);
  const S = rM.getOr(null);
  S && c() && (S.opts.value.current.includes(c()) ? n(!0) : n(!1)), Ne.pre(() => c(), () => {
    S && c() && (S.opts.value.current.includes(c()) ? n(!0) : n(!1));
  });
  const x = Zf.create(
    {
      checked: z(() => n(), (M) => {
        n(M), o()?.(M);
      }),
      disabled: z(() => a() ?? !1),
      required: z(() => l()),
      name: z(() => u()),
      value: z(() => c()),
      id: z(() => f()),
      ref: z(() => s(), (M) => s(M)),
      indeterminate: z(() => p(), (M) => {
        p(M), _()?.(M);
      }),
      type: z(() => g()),
      readonly: z(() => !!h())
    },
    S
  ), P = /* @__PURE__ */ C(() => Ce({ ...y }, x.props));
  var w = {
    get checked() {
      return n();
    },
    set checked(M = !1) {
      n(M), m();
    },
    get ref() {
      return s();
    },
    set ref(M = null) {
      s(M), m();
    },
    get onCheckedChange() {
      return o();
    },
    set onCheckedChange(M) {
      o(M), m();
    },
    get children() {
      return i();
    },
    set children(M) {
      i(M), m();
    },
    get disabled() {
      return a();
    },
    set disabled(M = !1) {
      a(M), m();
    },
    get required() {
      return l();
    },
    set required(M = !1) {
      l(M), m();
    },
    get name() {
      return u();
    },
    set name(M = void 0) {
      u(M), m();
    },
    get value() {
      return c();
    },
    set value(M = "on") {
      c(M), m();
    },
    get id() {
      return f();
    },
    set id(M = me(r)) {
      f(M), m();
    },
    get indeterminate() {
      return p();
    },
    set indeterminate(M = !1) {
      p(M), m();
    },
    get onIndeterminateChange() {
      return _();
    },
    set onIndeterminateChange(M) {
      _(M), m();
    },
    get child() {
      return b();
    },
    set child(M) {
      b(M), m();
    },
    get type() {
      return g();
    },
    set type(M = "button") {
      g(M), m();
    },
    get readonly() {
      return h();
    },
    set readonly(M) {
      h(M), m();
    }
  }, O = aM(), k = D(O);
  {
    var $ = (M) => {
      var R = I(), U = D(R);
      {
        let B = /* @__PURE__ */ C(() => ({ props: d(P), ...x.snippetProps }));
        te(U, b, () => d(B));
      }
      A(M, R);
    }, T = (M) => {
      var R = iM();
      ve(R, () => ({ ...d(P) }));
      var U = he(R);
      te(U, () => i() ?? ge, () => x.snippetProps), de(R), A(M, R);
    };
    ue(k, (M) => {
      b() ? M($) : M(T, !1);
    });
  }
  var E = be(k, 2);
  return hw(E, {}), A(t, O), W(w);
}
K(
  gw,
  {
    checked: {},
    ref: {},
    onCheckedChange: {},
    children: {},
    disabled: {},
    required: {},
    name: {},
    value: {},
    id: {},
    indeterminate: {},
    onIndeterminateChange: {},
    child: {},
    type: {},
    readonly: {}
  },
  [],
  [],
  { mode: "open" }
);
const lM = ["top", "right", "bottom", "left"], rs = Math.min, ur = Math.max, yl = Math.round, La = Math.floor, Qr = (t) => ({
  x: t,
  y: t
}), uM = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, cM = {
  start: "end",
  end: "start"
};
function Uc(t, e, r) {
  return ur(t, rs(e, r));
}
function An(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function En(t) {
  return t.split("-")[0];
}
function Bo(t) {
  return t.split("-")[1];
}
function eh(t) {
  return t === "x" ? "y" : "x";
}
function th(t) {
  return t === "y" ? "height" : "width";
}
const dM = /* @__PURE__ */ new Set(["top", "bottom"]);
function Xr(t) {
  return dM.has(En(t)) ? "y" : "x";
}
function rh(t) {
  return eh(Xr(t));
}
function fM(t, e, r) {
  r === void 0 && (r = !1);
  const n = Bo(t), s = rh(t), o = th(s);
  let i = s === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (i = bl(i)), [i, bl(i)];
}
function hM(t) {
  const e = bl(t);
  return [Kc(t), e, Kc(e)];
}
function Kc(t) {
  return t.replace(/start|end/g, (e) => cM[e]);
}
const Mm = ["left", "right"], Im = ["right", "left"], gM = ["top", "bottom"], pM = ["bottom", "top"];
function mM(t, e, r) {
  switch (t) {
    case "top":
    case "bottom":
      return r ? e ? Im : Mm : e ? Mm : Im;
    case "left":
    case "right":
      return e ? gM : pM;
    default:
      return [];
  }
}
function vM(t, e, r, n) {
  const s = Bo(t);
  let o = mM(En(t), r === "start", n);
  return s && (o = o.map((i) => i + "-" + s), e && (o = o.concat(o.map(Kc)))), o;
}
function bl(t) {
  return t.replace(/left|right|bottom|top/g, (e) => uM[e]);
}
function yM(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function pw(t) {
  return typeof t != "number" ? yM(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function _l(t) {
  const {
    x: e,
    y: r,
    width: n,
    height: s
  } = t;
  return {
    width: n,
    height: s,
    top: r,
    left: e,
    right: e + n,
    bottom: r + s,
    x: e,
    y: r
  };
}
function Nm(t, e, r) {
  let {
    reference: n,
    floating: s
  } = t;
  const o = Xr(e), i = rh(e), a = th(i), l = En(e), u = o === "y", c = n.x + n.width / 2 - s.width / 2, f = n.y + n.height / 2 - s.height / 2, p = n[a] / 2 - s[a] / 2;
  let _;
  switch (l) {
    case "top":
      _ = {
        x: c,
        y: n.y - s.height
      };
      break;
    case "bottom":
      _ = {
        x: c,
        y: n.y + n.height
      };
      break;
    case "right":
      _ = {
        x: n.x + n.width,
        y: f
      };
      break;
    case "left":
      _ = {
        x: n.x - s.width,
        y: f
      };
      break;
    default:
      _ = {
        x: n.x,
        y: n.y
      };
  }
  switch (Bo(e)) {
    case "start":
      _[i] -= p * (r && u ? -1 : 1);
      break;
    case "end":
      _[i] += p * (r && u ? -1 : 1);
      break;
  }
  return _;
}
async function bM(t, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: n,
    y: s,
    platform: o,
    rects: i,
    elements: a,
    strategy: l
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: _ = 0
  } = An(e, t), b = pw(_), h = a[p ? f === "floating" ? "reference" : "floating" : f], y = _l(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(h))) == null || r ? h : h.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), S = f === "floating" ? {
    x: n,
    y: s,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), P = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = _l(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: S,
    offsetParent: x,
    strategy: l
  }) : S);
  return {
    top: (y.top - w.top + b.top) / P.y,
    bottom: (w.bottom - y.bottom + b.bottom) / P.y,
    left: (y.left - w.left + b.left) / P.x,
    right: (w.right - y.right + b.right) / P.x
  };
}
const _M = async (t, e, r) => {
  const {
    placement: n = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: i
  } = r, a = o.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(e));
  let u = await i.getElementRects({
    reference: t,
    floating: e,
    strategy: s
  }), {
    x: c,
    y: f
  } = Nm(u, n, l), p = n, _ = {}, b = 0;
  for (let h = 0; h < a.length; h++) {
    var g;
    const {
      name: y,
      fn: S
    } = a[h], {
      x,
      y: P,
      data: w,
      reset: O
    } = await S({
      x: c,
      y: f,
      initialPlacement: n,
      placement: p,
      strategy: s,
      middlewareData: _,
      rects: u,
      platform: {
        ...i,
        detectOverflow: (g = i.detectOverflow) != null ? g : bM
      },
      elements: {
        reference: t,
        floating: e
      }
    });
    c = x ?? c, f = P ?? f, _ = {
      ..._,
      [y]: {
        ..._[y],
        ...w
      }
    }, O && b <= 50 && (b++, typeof O == "object" && (O.placement && (p = O.placement), O.rects && (u = O.rects === !0 ? await i.getElementRects({
      reference: t,
      floating: e,
      strategy: s
    }) : O.rects), {
      x: c,
      y: f
    } = Nm(u, p, l)), h = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: s,
    middlewareData: _
  };
}, wM = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: r,
      y: n,
      placement: s,
      rects: o,
      platform: i,
      elements: a,
      middlewareData: l
    } = e, {
      element: u,
      padding: c = 0
    } = An(t, e) || {};
    if (u == null)
      return {};
    const f = pw(c), p = {
      x: r,
      y: n
    }, _ = rh(s), b = th(_), g = await i.getDimensions(u), h = _ === "y", y = h ? "top" : "left", S = h ? "bottom" : "right", x = h ? "clientHeight" : "clientWidth", P = o.reference[b] + o.reference[_] - p[_] - o.floating[b], w = p[_] - o.reference[_], O = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u));
    let k = O ? O[x] : 0;
    (!k || !await (i.isElement == null ? void 0 : i.isElement(O))) && (k = a.floating[x] || o.floating[b]);
    const $ = P / 2 - w / 2, T = k / 2 - g[b] / 2 - 1, E = rs(f[y], T), M = rs(f[S], T), R = E, U = k - g[b] - M, B = k / 2 - g[b] / 2 + $, F = Uc(R, B, U), Z = !l.arrow && Bo(s) != null && B !== F && o.reference[b] / 2 - (B < R ? E : M) - g[b] / 2 < 0, Y = Z ? B < R ? B - R : B - U : 0;
    return {
      [_]: p[_] + Y,
      data: {
        [_]: F,
        centerOffset: B - F - Y,
        ...Z && {
          alignmentOffset: Y
        }
      },
      reset: Z
    };
  }
}), SM = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var r, n;
      const {
        placement: s,
        middlewareData: o,
        rects: i,
        initialPlacement: a,
        platform: l,
        elements: u
      } = e, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: _ = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: g = !0,
        ...h
      } = An(t, e);
      if ((r = o.arrow) != null && r.alignmentOffset)
        return {};
      const y = En(s), S = Xr(a), x = En(a) === a, P = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), w = p || (x || !g ? [bl(a)] : hM(a)), O = b !== "none";
      !p && O && w.push(...vM(a, g, b, P));
      const k = [a, ...w], $ = await l.detectOverflow(e, h), T = [];
      let E = ((n = o.flip) == null ? void 0 : n.overflows) || [];
      if (c && T.push($[y]), f) {
        const B = fM(s, i, P);
        T.push($[B[0]], $[B[1]]);
      }
      if (E = [...E, {
        placement: s,
        overflows: T
      }], !T.every((B) => B <= 0)) {
        var M, R;
        const B = (((M = o.flip) == null ? void 0 : M.index) || 0) + 1, F = k[B];
        if (F && (!(f === "alignment" ? S !== Xr(F) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        E.every((X) => Xr(X.placement) === S ? X.overflows[0] > 0 : !0)))
          return {
            data: {
              index: B,
              overflows: E
            },
            reset: {
              placement: F
            }
          };
        let Z = (R = E.filter((Y) => Y.overflows[0] <= 0).sort((Y, X) => Y.overflows[1] - X.overflows[1])[0]) == null ? void 0 : R.placement;
        if (!Z)
          switch (_) {
            case "bestFit": {
              var U;
              const Y = (U = E.filter((X) => {
                if (O) {
                  const ae = Xr(X.placement);
                  return ae === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ae === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((ae) => ae > 0).reduce((ae, J) => ae + J, 0)]).sort((X, ae) => X[1] - ae[1])[0]) == null ? void 0 : U[0];
              Y && (Z = Y);
              break;
            }
            case "initialPlacement":
              Z = a;
              break;
          }
        if (s !== Z)
          return {
            reset: {
              placement: Z
            }
          };
      }
      return {};
    }
  };
};
function Fm(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function Rm(t) {
  return lM.some((e) => t[e] >= 0);
}
const xM = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: r,
        platform: n
      } = e, {
        strategy: s = "referenceHidden",
        ...o
      } = An(t, e);
      switch (s) {
        case "referenceHidden": {
          const i = await n.detectOverflow(e, {
            ...o,
            elementContext: "reference"
          }), a = Fm(i, r.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: Rm(a)
            }
          };
        }
        case "escaped": {
          const i = await n.detectOverflow(e, {
            ...o,
            altBoundary: !0
          }), a = Fm(i, r.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: Rm(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, mw = /* @__PURE__ */ new Set(["left", "top"]);
async function PM(t, e) {
  const {
    placement: r,
    platform: n,
    elements: s
  } = t, o = await (n.isRTL == null ? void 0 : n.isRTL(s.floating)), i = En(r), a = Bo(r), l = Xr(r) === "y", u = mw.has(i) ? -1 : 1, c = o && l ? -1 : 1, f = An(e, t);
  let {
    mainAxis: p,
    crossAxis: _,
    alignmentAxis: b
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return a && typeof b == "number" && (_ = a === "end" ? b * -1 : b), l ? {
    x: _ * c,
    y: p * u
  } : {
    x: p * u,
    y: _ * c
  };
}
const OM = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var r, n;
      const {
        x: s,
        y: o,
        placement: i,
        middlewareData: a
      } = e, l = await PM(e, t);
      return i === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: s + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: i
        }
      };
    }
  };
}, CM = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: r,
        y: n,
        placement: s,
        platform: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: a = !1,
        limiter: l = {
          fn: (y) => {
            let {
              x: S,
              y: x
            } = y;
            return {
              x: S,
              y: x
            };
          }
        },
        ...u
      } = An(t, e), c = {
        x: r,
        y: n
      }, f = await o.detectOverflow(e, u), p = Xr(En(s)), _ = eh(p);
      let b = c[_], g = c[p];
      if (i) {
        const y = _ === "y" ? "top" : "left", S = _ === "y" ? "bottom" : "right", x = b + f[y], P = b - f[S];
        b = Uc(x, b, P);
      }
      if (a) {
        const y = p === "y" ? "top" : "left", S = p === "y" ? "bottom" : "right", x = g + f[y], P = g - f[S];
        g = Uc(x, g, P);
      }
      const h = l.fn({
        ...e,
        [_]: b,
        [p]: g
      });
      return {
        ...h,
        data: {
          x: h.x - r,
          y: h.y - n,
          enabled: {
            [_]: i,
            [p]: a
          }
        }
      };
    }
  };
}, kM = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: r,
        y: n,
        placement: s,
        rects: o,
        middlewareData: i
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: u = !0
      } = An(t, e), c = {
        x: r,
        y: n
      }, f = Xr(s), p = eh(f);
      let _ = c[p], b = c[f];
      const g = An(a, e), h = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (l) {
        const x = p === "y" ? "height" : "width", P = o.reference[p] - o.floating[x] + h.mainAxis, w = o.reference[p] + o.reference[x] - h.mainAxis;
        _ < P ? _ = P : _ > w && (_ = w);
      }
      if (u) {
        var y, S;
        const x = p === "y" ? "width" : "height", P = mw.has(En(s)), w = o.reference[f] - o.floating[x] + (P && ((y = i.offset) == null ? void 0 : y[f]) || 0) + (P ? 0 : h.crossAxis), O = o.reference[f] + o.reference[x] + (P ? 0 : ((S = i.offset) == null ? void 0 : S[f]) || 0) - (P ? h.crossAxis : 0);
        b < w ? b = w : b > O && (b = O);
      }
      return {
        [p]: _,
        [f]: b
      };
    }
  };
}, $M = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var r, n;
      const {
        placement: s,
        rects: o,
        platform: i,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...u
      } = An(t, e), c = await i.detectOverflow(e, u), f = En(s), p = Bo(s), _ = Xr(s) === "y", {
        width: b,
        height: g
      } = o.floating;
      let h, y;
      f === "top" || f === "bottom" ? (h = f, y = p === (await (i.isRTL == null ? void 0 : i.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (y = f, h = p === "end" ? "top" : "bottom");
      const S = g - c.top - c.bottom, x = b - c.left - c.right, P = rs(g - c[h], S), w = rs(b - c[y], x), O = !e.middlewareData.shift;
      let k = P, $ = w;
      if ((r = e.middlewareData.shift) != null && r.enabled.x && ($ = x), (n = e.middlewareData.shift) != null && n.enabled.y && (k = S), O && !p) {
        const E = ur(c.left, 0), M = ur(c.right, 0), R = ur(c.top, 0), U = ur(c.bottom, 0);
        _ ? $ = b - 2 * (E !== 0 || M !== 0 ? E + M : ur(c.left, c.right)) : k = g - 2 * (R !== 0 || U !== 0 ? R + U : ur(c.top, c.bottom));
      }
      await l({
        ...e,
        availableWidth: $,
        availableHeight: k
      });
      const T = await i.getDimensions(a.floating);
      return b !== T.width || g !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function lu() {
  return typeof window < "u";
}
function zo(t) {
  return vw(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function hr(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ln(t) {
  var e;
  return (e = (vw(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function vw(t) {
  return lu() ? t instanceof Node || t instanceof hr(t).Node : !1;
}
function Lr(t) {
  return lu() ? t instanceof Element || t instanceof hr(t).Element : !1;
}
function nn(t) {
  return lu() ? t instanceof HTMLElement || t instanceof hr(t).HTMLElement : !1;
}
function Vm(t) {
  return !lu() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof hr(t).ShadowRoot;
}
const AM = /* @__PURE__ */ new Set(["inline", "contents"]);
function qi(t) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: n,
    display: s
  } = jr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !AM.has(s);
}
const EM = /* @__PURE__ */ new Set(["table", "td", "th"]);
function TM(t) {
  return EM.has(zo(t));
}
const DM = [":popover-open", ":modal"];
function uu(t) {
  return DM.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const MM = ["transform", "translate", "scale", "rotate", "perspective"], IM = ["transform", "translate", "scale", "rotate", "perspective", "filter"], NM = ["paint", "layout", "strict", "content"];
function nh(t) {
  const e = sh(), r = Lr(t) ? jr(t) : t;
  return MM.some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || IM.some((n) => (r.willChange || "").includes(n)) || NM.some((n) => (r.contain || "").includes(n));
}
function FM(t) {
  let e = ns(t);
  for (; nn(e) && !wo(e); ) {
    if (nh(e))
      return e;
    if (uu(e))
      return null;
    e = ns(e);
  }
  return null;
}
function sh() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const RM = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function wo(t) {
  return RM.has(zo(t));
}
function jr(t) {
  return hr(t).getComputedStyle(t);
}
function cu(t) {
  return Lr(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function ns(t) {
  if (zo(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Vm(t) && t.host || // Fallback.
    ln(t)
  );
  return Vm(e) ? e.host : e;
}
function yw(t) {
  const e = ns(t);
  return wo(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : nn(e) && qi(e) ? e : yw(e);
}
function Oi(t, e, r) {
  var n;
  e === void 0 && (e = []), r === void 0 && (r = !0);
  const s = yw(t), o = s === ((n = t.ownerDocument) == null ? void 0 : n.body), i = hr(s);
  if (o) {
    const a = Hc(i);
    return e.concat(i, i.visualViewport || [], qi(s) ? s : [], a && r ? Oi(a) : []);
  }
  return e.concat(s, Oi(s, [], r));
}
function Hc(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function bw(t) {
  const e = jr(t);
  let r = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const s = nn(t), o = s ? t.offsetWidth : r, i = s ? t.offsetHeight : n, a = yl(r) !== o || yl(n) !== i;
  return a && (r = o, n = i), {
    width: r,
    height: n,
    $: a
  };
}
function oh(t) {
  return Lr(t) ? t : t.contextElement;
}
function oo(t) {
  const e = oh(t);
  if (!nn(e))
    return Qr(1);
  const r = e.getBoundingClientRect(), {
    width: n,
    height: s,
    $: o
  } = bw(e);
  let i = (o ? yl(r.width) : r.width) / n, a = (o ? yl(r.height) : r.height) / s;
  return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: i,
    y: a
  };
}
const VM = /* @__PURE__ */ Qr(0);
function _w(t) {
  const e = hr(t);
  return !sh() || !e.visualViewport ? VM : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function LM(t, e, r) {
  return e === void 0 && (e = !1), !r || e && r !== hr(t) ? !1 : e;
}
function Fs(t, e, r, n) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  const s = t.getBoundingClientRect(), o = oh(t);
  let i = Qr(1);
  e && (n ? Lr(n) && (i = oo(n)) : i = oo(t));
  const a = LM(o, r, n) ? _w(o) : Qr(0);
  let l = (s.left + a.x) / i.x, u = (s.top + a.y) / i.y, c = s.width / i.x, f = s.height / i.y;
  if (o) {
    const p = hr(o), _ = n && Lr(n) ? hr(n) : n;
    let b = p, g = Hc(b);
    for (; g && n && _ !== b; ) {
      const h = oo(g), y = g.getBoundingClientRect(), S = jr(g), x = y.left + (g.clientLeft + parseFloat(S.paddingLeft)) * h.x, P = y.top + (g.clientTop + parseFloat(S.paddingTop)) * h.y;
      l *= h.x, u *= h.y, c *= h.x, f *= h.y, l += x, u += P, b = hr(g), g = Hc(b);
    }
  }
  return _l({
    width: c,
    height: f,
    x: l,
    y: u
  });
}
function du(t, e) {
  const r = cu(t).scrollLeft;
  return e ? e.left + r : Fs(ln(t)).left + r;
}
function ww(t, e) {
  const r = t.getBoundingClientRect(), n = r.left + e.scrollLeft - du(t, r), s = r.top + e.scrollTop;
  return {
    x: n,
    y: s
  };
}
function jM(t) {
  let {
    elements: e,
    rect: r,
    offsetParent: n,
    strategy: s
  } = t;
  const o = s === "fixed", i = ln(n), a = e ? uu(e.floating) : !1;
  if (n === i || a && o)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Qr(1);
  const c = Qr(0), f = nn(n);
  if ((f || !f && !o) && ((zo(n) !== "body" || qi(i)) && (l = cu(n)), nn(n))) {
    const _ = Fs(n);
    u = oo(n), c.x = _.x + n.clientLeft, c.y = _.y + n.clientTop;
  }
  const p = i && !f && !o ? ww(i, l) : Qr(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - l.scrollLeft * u.x + c.x + p.x,
    y: r.y * u.y - l.scrollTop * u.y + c.y + p.y
  };
}
function BM(t) {
  return Array.from(t.getClientRects());
}
function zM(t) {
  const e = ln(t), r = cu(t), n = t.ownerDocument.body, s = ur(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), o = ur(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let i = -r.scrollLeft + du(t);
  const a = -r.scrollTop;
  return jr(n).direction === "rtl" && (i += ur(e.clientWidth, n.clientWidth) - s), {
    width: s,
    height: o,
    x: i,
    y: a
  };
}
const Lm = 25;
function qM(t, e) {
  const r = hr(t), n = ln(t), s = r.visualViewport;
  let o = n.clientWidth, i = n.clientHeight, a = 0, l = 0;
  if (s) {
    o = s.width, i = s.height;
    const c = sh();
    (!c || c && e === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  const u = du(n);
  if (u <= 0) {
    const c = n.ownerDocument, f = c.body, p = getComputedStyle(f), _ = c.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, b = Math.abs(n.clientWidth - f.clientWidth - _);
    b <= Lm && (o -= b);
  } else u <= Lm && (o += u);
  return {
    width: o,
    height: i,
    x: a,
    y: l
  };
}
const UM = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function KM(t, e) {
  const r = Fs(t, !0, e === "fixed"), n = r.top + t.clientTop, s = r.left + t.clientLeft, o = nn(t) ? oo(t) : Qr(1), i = t.clientWidth * o.x, a = t.clientHeight * o.y, l = s * o.x, u = n * o.y;
  return {
    width: i,
    height: a,
    x: l,
    y: u
  };
}
function jm(t, e, r) {
  let n;
  if (e === "viewport")
    n = qM(t, r);
  else if (e === "document")
    n = zM(ln(t));
  else if (Lr(e))
    n = KM(e, r);
  else {
    const s = _w(t);
    n = {
      x: e.x - s.x,
      y: e.y - s.y,
      width: e.width,
      height: e.height
    };
  }
  return _l(n);
}
function Sw(t, e) {
  const r = ns(t);
  return r === e || !Lr(r) || wo(r) ? !1 : jr(r).position === "fixed" || Sw(r, e);
}
function HM(t, e) {
  const r = e.get(t);
  if (r)
    return r;
  let n = Oi(t, [], !1).filter((a) => Lr(a) && zo(a) !== "body"), s = null;
  const o = jr(t).position === "fixed";
  let i = o ? ns(t) : t;
  for (; Lr(i) && !wo(i); ) {
    const a = jr(i), l = nh(i);
    !l && a.position === "fixed" && (s = null), (o ? !l && !s : !l && a.position === "static" && !!s && UM.has(s.position) || qi(i) && !l && Sw(t, i)) ? n = n.filter((c) => c !== i) : s = a, i = ns(i);
  }
  return e.set(t, n), n;
}
function WM(t) {
  let {
    element: e,
    boundary: r,
    rootBoundary: n,
    strategy: s
  } = t;
  const i = [...r === "clippingAncestors" ? uu(e) ? [] : HM(e, this._c) : [].concat(r), n], a = i[0], l = i.reduce((u, c) => {
    const f = jm(e, c, s);
    return u.top = ur(f.top, u.top), u.right = rs(f.right, u.right), u.bottom = rs(f.bottom, u.bottom), u.left = ur(f.left, u.left), u;
  }, jm(e, a, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function GM(t) {
  const {
    width: e,
    height: r
  } = bw(t);
  return {
    width: e,
    height: r
  };
}
function YM(t, e, r) {
  const n = nn(e), s = ln(e), o = r === "fixed", i = Fs(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Qr(0);
  function u() {
    l.x = du(s);
  }
  if (n || !n && !o)
    if ((zo(e) !== "body" || qi(s)) && (a = cu(e)), n) {
      const _ = Fs(e, !0, o, e);
      l.x = _.x + e.clientLeft, l.y = _.y + e.clientTop;
    } else s && u();
  o && !n && s && u();
  const c = s && !n && !o ? ww(s, a) : Qr(0), f = i.left + a.scrollLeft - l.x - c.x, p = i.top + a.scrollTop - l.y - c.y;
  return {
    x: f,
    y: p,
    width: i.width,
    height: i.height
  };
}
function nc(t) {
  return jr(t).position === "static";
}
function Bm(t, e) {
  if (!nn(t) || jr(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let r = t.offsetParent;
  return ln(t) === r && (r = r.ownerDocument.body), r;
}
function xw(t, e) {
  const r = hr(t);
  if (uu(t))
    return r;
  if (!nn(t)) {
    let s = ns(t);
    for (; s && !wo(s); ) {
      if (Lr(s) && !nc(s))
        return s;
      s = ns(s);
    }
    return r;
  }
  let n = Bm(t, e);
  for (; n && TM(n) && nc(n); )
    n = Bm(n, e);
  return n && wo(n) && nc(n) && !nh(n) ? r : n || FM(t) || r;
}
const XM = async function(t) {
  const e = this.getOffsetParent || xw, r = this.getDimensions, n = await r(t.floating);
  return {
    reference: YM(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function JM(t) {
  return jr(t).direction === "rtl";
}
const ZM = {
  convertOffsetParentRelativeRectToViewportRelativeRect: jM,
  getDocumentElement: ln,
  getClippingRect: WM,
  getOffsetParent: xw,
  getElementRects: XM,
  getClientRects: BM,
  getDimensions: GM,
  getScale: oo,
  isElement: Lr,
  isRTL: JM
};
function Pw(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function QM(t, e) {
  let r = null, n;
  const s = ln(t);
  function o() {
    var a;
    clearTimeout(n), (a = r) == null || a.disconnect(), r = null;
  }
  function i(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const u = t.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: _
    } = u;
    if (a || e(), !p || !_)
      return;
    const b = La(f), g = La(s.clientWidth - (c + p)), h = La(s.clientHeight - (f + _)), y = La(c), x = {
      rootMargin: -b + "px " + -g + "px " + -h + "px " + -y + "px",
      threshold: ur(0, rs(1, l)) || 1
    };
    let P = !0;
    function w(O) {
      const k = O[0].intersectionRatio;
      if (k !== l) {
        if (!P)
          return i();
        k ? i(!1, k) : n = setTimeout(() => {
          i(!1, 1e-7);
        }, 1e3);
      }
      k === 1 && !Pw(u, t.getBoundingClientRect()) && i(), P = !1;
    }
    try {
      r = new IntersectionObserver(w, {
        ...x,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(w, x);
    }
    r.observe(t);
  }
  return i(!0), o;
}
function eI(t, e, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, u = oh(t), c = s || o ? [...u ? Oi(u) : [], ...Oi(e)] : [];
  c.forEach((y) => {
    s && y.addEventListener("scroll", r, {
      passive: !0
    }), o && y.addEventListener("resize", r);
  });
  const f = u && a ? QM(u, r) : null;
  let p = -1, _ = null;
  i && (_ = new ResizeObserver((y) => {
    let [S] = y;
    S && S.target === u && _ && (_.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var x;
      (x = _) == null || x.observe(e);
    })), r();
  }), u && !l && _.observe(u), _.observe(e));
  let b, g = l ? Fs(t) : null;
  l && h();
  function h() {
    const y = Fs(t);
    g && !Pw(g, y) && r(), g = y, b = requestAnimationFrame(h);
  }
  return r(), () => {
    var y;
    c.forEach((S) => {
      s && S.removeEventListener("scroll", r), o && S.removeEventListener("resize", r);
    }), f?.(), (y = _) == null || y.disconnect(), _ = null, l && cancelAnimationFrame(b);
  };
}
const tI = OM, rI = CM, nI = SM, sI = $M, oI = xM, iI = wM, aI = kM, lI = (t, e, r) => {
  const n = /* @__PURE__ */ new Map(), s = {
    platform: ZM,
    ...r
  }, o = {
    ...s.platform,
    _c: n
  };
  return _M(t, e, {
    ...s,
    platform: o
  });
};
function bs(t) {
  return typeof t == "function" ? t() : t;
}
function Ow(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function zm(t, e) {
  const r = Ow(t);
  return Math.round(e * r) / r;
}
function Wc(t) {
  return {
    [`--bits-${t}-content-transform-origin`]: "var(--bits-floating-transform-origin)",
    [`--bits-${t}-content-available-width`]: "var(--bits-floating-available-width)",
    [`--bits-${t}-content-available-height`]: "var(--bits-floating-available-height)",
    [`--bits-${t}-anchor-width`]: "var(--bits-floating-anchor-width)",
    [`--bits-${t}-anchor-height`]: "var(--bits-floating-anchor-height)"
  };
}
function uI(t) {
  const e = t.whileElementsMounted, r = /* @__PURE__ */ C(() => bs(t.open) ?? !0), n = /* @__PURE__ */ C(() => bs(t.middleware)), s = /* @__PURE__ */ C(() => bs(t.transform) ?? !0), o = /* @__PURE__ */ C(() => bs(t.placement) ?? "bottom"), i = /* @__PURE__ */ C(() => bs(t.strategy) ?? "absolute"), a = /* @__PURE__ */ C(() => bs(t.sideOffset) ?? 0), l = /* @__PURE__ */ C(() => bs(t.alignOffset) ?? 0), u = t.reference;
  let c = /* @__PURE__ */ xe(0), f = /* @__PURE__ */ xe(0);
  const p = Gr(null);
  let _ = /* @__PURE__ */ xe(Pt(d(i))), b = /* @__PURE__ */ xe(Pt(d(o))), g = /* @__PURE__ */ xe(Pt({})), h = /* @__PURE__ */ xe(!1);
  const y = /* @__PURE__ */ C(() => {
    const k = p.current ? zm(p.current, d(c)) : d(c), $ = p.current ? zm(p.current, d(f)) : d(f);
    return d(s) ? {
      position: d(_),
      left: "0",
      top: "0",
      transform: `translate(${k}px, ${$}px)`,
      ...p.current && Ow(p.current) >= 1.5 && { willChange: "transform" }
    } : {
      position: d(_),
      left: `${k}px`,
      top: `${$}px`
    };
  });
  let S;
  function x() {
    u.current === null || p.current === null || lI(u.current, p.current, {
      middleware: d(n),
      placement: d(o),
      strategy: d(i)
    }).then((k) => {
      if (!d(r) && d(c) !== 0 && d(f) !== 0) {
        const $ = Math.max(Math.abs(d(a)), Math.abs(d(l)), 15);
        if (k.x <= $ && k.y <= $) return;
      }
      q(c, k.x, !0), q(f, k.y, !0), q(_, k.strategy, !0), q(b, k.placement, !0), q(g, k.middlewareData, !0), q(h, !0);
    });
  }
  function P() {
    typeof S == "function" && (S(), S = void 0);
  }
  function w() {
    if (P(), e === void 0) {
      x();
      return;
    }
    u.current === null || p.current === null || (S = e(u.current, p.current, x));
  }
  function O() {
    d(r) || q(h, !1);
  }
  return Ze(x), Ze(w), Ze(O), Ze(() => P), {
    floating: p,
    reference: u,
    get strategy() {
      return d(_);
    },
    get placement() {
      return d(b);
    },
    get middlewareData() {
      return d(g);
    },
    get isPositioned() {
      return d(h);
    },
    get floatingStyles() {
      return d(y);
    },
    get update() {
      return x;
    }
  };
}
const cI = { top: "bottom", right: "left", bottom: "top", left: "right" }, ih = new ht("Floating.Root"), qm = new ht("Floating.Content"), ah = new ht("Floating.Root");
class wl {
  static create(e = !1) {
    return e ? ah.set(new wl()) : ih.set(new wl());
  }
  anchorNode = Gr(null);
  customAnchorNode = Gr(null);
  triggerNode = Gr(null);
  constructor() {
    Ze(() => {
      this.customAnchorNode.current ? typeof this.customAnchorNode.current == "string" ? this.anchorNode.current = document.querySelector(this.customAnchorNode.current) : this.anchorNode.current = this.customAnchorNode.current : this.anchorNode.current = this.triggerNode.current;
    });
  }
}
class Sl {
  static create(e, r = !1) {
    return r ? qm.set(new Sl(e, ah.get())) : qm.set(new Sl(e, ih.get()));
  }
  opts;
  root;
  // nodes
  contentRef = Gr(null);
  wrapperRef = Gr(null);
  arrowRef = Gr(null);
  contentAttachment = Ee(this.contentRef);
  wrapperAttachment = Ee(this.wrapperRef);
  arrowAttachment = Ee(this.arrowRef);
  // ids
  arrowId = Gr(kn());
  #e = /* @__PURE__ */ C(() => {
    if (typeof this.opts.style == "string") return li(this.opts.style);
    if (!this.opts.style) return {};
  });
  #t = void 0;
  #r = new P2(() => this.arrowRef.current ?? void 0);
  #n = /* @__PURE__ */ C(() => this.#r?.width ?? 0);
  #s = /* @__PURE__ */ C(() => this.#r?.height ?? 0);
  #o = /* @__PURE__ */ C(() => this.opts.side?.current + (this.opts.align.current !== "center" ? `-${this.opts.align.current}` : ""));
  #i = /* @__PURE__ */ C(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current]);
  #a = /* @__PURE__ */ C(() => d(this.#i).length > 0);
  get hasExplicitBoundaries() {
    return d(this.#a);
  }
  set hasExplicitBoundaries(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ C(() => ({
    padding: this.opts.collisionPadding.current,
    boundary: d(this.#i).filter(W2),
    altBoundary: this.hasExplicitBoundaries
  }));
  get detectOverflowOptions() {
    return d(this.#u);
  }
  set detectOverflowOptions(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ xe(void 0);
  #c = /* @__PURE__ */ xe(void 0);
  #d = /* @__PURE__ */ xe(void 0);
  #g = /* @__PURE__ */ xe(void 0);
  #m = /* @__PURE__ */ C(() => [
    tI({
      mainAxis: this.opts.sideOffset.current + d(this.#s),
      alignmentAxis: this.opts.alignOffset.current
    }),
    this.opts.avoidCollisions.current && rI({
      mainAxis: !0,
      crossAxis: !1,
      limiter: this.opts.sticky.current === "partial" ? aI() : void 0,
      ...this.detectOverflowOptions
    }),
    this.opts.avoidCollisions.current && nI({ ...this.detectOverflowOptions }),
    sI({
      ...this.detectOverflowOptions,
      apply: ({ rects: e, availableWidth: r, availableHeight: n }) => {
        const { width: s, height: o } = e.reference;
        q(this.#l, r, !0), q(this.#c, n, !0), q(this.#d, s, !0), q(this.#g, o, !0);
      }
    }),
    this.arrowRef.current && iI({
      element: this.arrowRef.current,
      padding: this.opts.arrowPadding.current
    }),
    dI({
      arrowWidth: d(this.#n),
      arrowHeight: d(this.#s)
    }),
    this.opts.hideWhenDetached.current && oI({ strategy: "referenceHidden", ...this.detectOverflowOptions })
  ].filter(Boolean));
  get middleware() {
    return d(this.#m);
  }
  set middleware(e) {
    q(this.#m, e);
  }
  floating;
  #p = /* @__PURE__ */ C(() => fI(this.floating.placement));
  get placedSide() {
    return d(this.#p);
  }
  set placedSide(e) {
    q(this.#p, e);
  }
  #f = /* @__PURE__ */ C(() => hI(this.floating.placement));
  get placedAlign() {
    return d(this.#f);
  }
  set placedAlign(e) {
    q(this.#f, e);
  }
  #h = /* @__PURE__ */ C(() => this.floating.middlewareData.arrow?.x ?? 0);
  get arrowX() {
    return d(this.#h);
  }
  set arrowX(e) {
    q(this.#h, e);
  }
  #b = /* @__PURE__ */ C(() => this.floating.middlewareData.arrow?.y ?? 0);
  get arrowY() {
    return d(this.#b);
  }
  set arrowY(e) {
    q(this.#b, e);
  }
  #y = /* @__PURE__ */ C(() => this.floating.middlewareData.arrow?.centerOffset !== 0);
  get cannotCenterArrow() {
    return d(this.#y);
  }
  set cannotCenterArrow(e) {
    q(this.#y, e);
  }
  #v = /* @__PURE__ */ xe();
  get contentZIndex() {
    return d(this.#v);
  }
  set contentZIndex(e) {
    q(this.#v, e, !0);
  }
  #S = /* @__PURE__ */ C(() => cI[this.placedSide]);
  get arrowBaseSide() {
    return d(this.#S);
  }
  set arrowBaseSide(e) {
    q(this.#S, e);
  }
  #w = /* @__PURE__ */ C(() => ({
    id: this.opts.wrapperId.current,
    "data-bits-floating-content-wrapper": "",
    style: {
      ...this.floating.floatingStyles,
      transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: this.contentZIndex,
      "--bits-floating-transform-origin": `${this.floating.middlewareData.transformOrigin?.x} ${this.floating.middlewareData.transformOrigin?.y}`,
      "--bits-floating-available-width": `${d(this.#l)}px`,
      "--bits-floating-available-height": `${d(this.#c)}px`,
      "--bits-floating-anchor-width": `${d(this.#d)}px`,
      "--bits-floating-anchor-height": `${d(this.#g)}px`,
      ...this.floating.middlewareData.hide?.referenceHidden && { visibility: "hidden", "pointer-events": "none" },
      ...d(this.#e)
    },
    dir: this.opts.dir.current,
    ...this.wrapperAttachment
  }));
  get wrapperProps() {
    return d(this.#w);
  }
  set wrapperProps(e) {
    q(this.#w, e);
  }
  #x = /* @__PURE__ */ C(() => ({
    "data-side": this.placedSide,
    "data-align": this.placedAlign,
    style: su({ ...d(this.#e) }),
    ...this.contentAttachment
  }));
  get props() {
    return d(this.#x);
  }
  set props(e) {
    q(this.#x, e);
  }
  #_ = /* @__PURE__ */ C(() => ({
    position: "absolute",
    left: this.arrowX ? `${this.arrowX}px` : void 0,
    top: this.arrowY ? `${this.arrowY}px` : void 0,
    [this.arrowBaseSide]: 0,
    "transform-origin": { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[this.placedSide],
    transform: {
      top: "translateY(100%)",
      right: "translateY(50%) rotate(90deg) translateX(-50%)",
      bottom: "rotate(180deg)",
      left: "translateY(50%) rotate(-90deg) translateX(50%)"
    }[this.placedSide],
    visibility: this.cannotCenterArrow ? "hidden" : void 0
  }));
  get arrowStyle() {
    return d(this.#_);
  }
  set arrowStyle(e) {
    q(this.#_, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, e.customAnchor && (this.root.customAnchorNode.current = e.customAnchor.current), Ne(() => e.customAnchor.current, (n) => {
      this.root.customAnchorNode.current = n;
    }), this.floating = uI({
      strategy: () => this.opts.strategy.current,
      placement: () => d(this.#o),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...n) => eI(...n, {
        animationFrame: this.#t?.current === "always"
      }),
      open: () => this.opts.enabled.current,
      sideOffset: () => this.opts.sideOffset.current,
      alignOffset: () => this.opts.alignOffset.current
    }), Ze(() => {
      this.floating.isPositioned && this.opts.onPlaced?.current();
    }), Ne(() => this.contentRef.current, (n) => {
      if (!n) return;
      const s = Z_(n);
      this.contentZIndex = s.getComputedStyle(n).zIndex;
    }), Ze(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
}
class xl {
  static create(e, r = !1) {
    return r ? new xl(e, ah.get()) : new xl(e, ih.get());
  }
  opts;
  root;
  constructor(e, r) {
    this.opts = e, this.root = r, e.virtualEl && e.virtualEl.current ? r.triggerNode = q_(e.virtualEl.current) : r.triggerNode = e.ref;
  }
}
function dI(t) {
  return {
    name: "transformOrigin",
    options: t,
    fn(e) {
      const { placement: r, rects: n, middlewareData: s } = e, i = s.arrow?.centerOffset !== 0, a = i ? 0 : t.arrowWidth, l = i ? 0 : t.arrowHeight, [u, c] = lh(r), f = { start: "0%", center: "50%", end: "100%" }[c], p = (s.arrow?.x ?? 0) + a / 2, _ = (s.arrow?.y ?? 0) + l / 2;
      let b = "", g = "";
      return u === "bottom" ? (b = i ? f : `${p}px`, g = `${-l}px`) : u === "top" ? (b = i ? f : `${p}px`, g = `${n.floating.height + l}px`) : u === "right" ? (b = `${-l}px`, g = i ? f : `${_}px`) : u === "left" && (b = `${n.floating.width + l}px`, g = i ? f : `${_}px`), { data: { x: b, y: g } };
    }
  };
}
function lh(t) {
  const [e, r = "center"] = t.split("-");
  return [e, r];
}
function fI(t) {
  return lh(t)[0];
}
function hI(t) {
  return lh(t)[1];
}
function uh(t, e) {
  H(e, !0);
  let r = v(e, "children", 7), n = v(e, "tooltip", 7, !1);
  wl.create(n());
  var s = {
    get children() {
      return r();
    },
    set children(a) {
      r(a), m();
    },
    get tooltip() {
      return n();
    },
    set tooltip(a = !1) {
      n(a), m();
    }
  }, o = I(), i = D(o);
  return te(i, () => r() ?? ge), A(t, o), W(s);
}
K(uh, { children: {}, tooltip: {} }, [], [], { mode: "open" });
class gI {
  #e;
  #t = /* @__PURE__ */ C(() => this.#e.candidateValues());
  #r;
  constructor(e) {
    this.#e = e, this.#r = p0("", { afterMs: 1e3, getWindow: this.#e.getWindow }), this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this), this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(e) {
    if (!this.#e.enabled() || !d(this.#t).length) return;
    this.#r.current = this.#r.current + e;
    const r = this.#e.getCurrentItem(), n = d(this.#t).find((a) => a === r) ?? "", s = d(this.#t).map((a) => a ?? ""), o = df(s, this.#r.current, n), i = d(this.#t).find((a) => a === o);
    return i && this.#e.onMatch(i), i;
  }
  resetTypeahead() {
    this.#r.current = "";
  }
}
const pI = [cr, e0, Vo], mI = [Qt, Q_, Ro], vI = [...pI, ...mI], yI = rr({
  component: "select",
  parts: [
    "trigger",
    "content",
    "item",
    "viewport",
    "scroll-up-button",
    "scroll-down-button",
    "group",
    "group-label",
    "separator",
    "arrow",
    "input",
    "content-wrapper",
    "item-text",
    "value"
  ]
}), qo = new ht("Select.Root | Combobox.Root"), Cw = new ht("Select.Group | Combobox.Group"), fu = new ht("Select.Content | Combobox.Content");
class kw {
  opts;
  #e = /* @__PURE__ */ xe(!1);
  get touchedInput() {
    return d(this.#e);
  }
  set touchedInput(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(null);
  get inputNode() {
    return d(this.#t);
  }
  set inputNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#r);
  }
  set contentNode(e) {
    q(this.#r, e, !0);
  }
  contentPresence;
  #n = /* @__PURE__ */ xe(null);
  get viewportNode() {
    return d(this.#n);
  }
  set viewportNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#s);
  }
  set triggerNode(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe("");
  get valueId() {
    return d(this.#o);
  }
  set valueId(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(null);
  get highlightedNode() {
    return d(this.#i);
  }
  set highlightedNode(e) {
    q(this.#i, e, !0);
  }
  #a = /* @__PURE__ */ C(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-value") : null);
  get highlightedValue() {
    return d(this.#a);
  }
  set highlightedValue(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ C(() => {
    if (this.highlightedNode)
      return this.highlightedNode.id;
  });
  get highlightedId() {
    return d(this.#u);
  }
  set highlightedId(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ C(() => this.highlightedNode ? this.highlightedNode.getAttribute("data-label") : null);
  get highlightedLabel() {
    return d(this.#l);
  }
  set highlightedLabel(e) {
    q(this.#l, e);
  }
  isUsingKeyboard = !1;
  isCombobox = !1;
  domContext = new Nn(() => null);
  constructor(e) {
    this.opts = e, this.isCombobox = e.isCombobox, this.contentPresence = new wi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), Co(() => {
      this.opts.open.current || this.setHighlightedNode(null);
    });
  }
  setHighlightedNode(e, r = !1) {
    this.highlightedNode = e, e && (this.isUsingKeyboard || r) && e.scrollIntoView({ block: this.opts.scrollAlignment.current });
  }
  getCandidateNodes() {
    const e = this.contentNode;
    return e ? Array.from(e.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`)) : [];
  }
  setHighlightedToFirstCandidate(e = !1) {
    this.setHighlightedNode(null);
    let r = this.getCandidateNodes();
    if (r.length) {
      if (this.viewportNode) {
        const n = this.viewportNode.getBoundingClientRect();
        r = r.filter((s) => {
          if (!this.viewportNode) return !1;
          const o = s.getBoundingClientRect();
          return o.right < n.right && o.left > n.left && o.bottom < n.bottom && o.top > n.top;
        });
      }
      this.setHighlightedNode(r[0], e);
    }
  }
  getNodeByValue(e) {
    return this.getCandidateNodes().find((n) => n.dataset.value === e) ?? null;
  }
  setOpen(e) {
    this.opts.open.current = e;
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleOpen() {
    this.setOpen(!0);
  }
  handleClose() {
    this.setHighlightedNode(null), this.setOpen(!1);
  }
  toggleMenu() {
    this.toggleOpen();
  }
  getBitsAttr = (e) => yI.getAttr(e, this.isCombobox ? "combobox" : void 0);
}
class bI extends kw {
  opts;
  isMulti = !1;
  #e = /* @__PURE__ */ C(() => this.opts.value.current !== "");
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.opts.items.current.length ? this.opts.items.current.find((e) => e.value === this.opts.value.current)?.label ?? "" : "");
  get currentLabel() {
    return d(this.#t);
  }
  set currentLabel(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => this.opts.items.current.length ? this.opts.items.current.filter((r) => !r.disabled).map((r) => r.label) : []);
  get candidateLabels() {
    return d(this.#r);
  }
  set candidateLabels(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => !(this.isMulti || this.opts.items.current.length === 0));
  get dataTypeaheadEnabled() {
    return d(this.#n);
  }
  set dataTypeaheadEnabled(e) {
    q(this.#n, e);
  }
  constructor(e) {
    super(e), this.opts = e, Ze(() => {
      !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null);
    }), Ne(() => this.opts.open.current, () => {
      this.opts.open.current && this.setInitialHighlightedNode();
    });
  }
  includesItem(e) {
    return this.opts.value.current === e;
  }
  toggleItem(e, r = e) {
    const n = this.includesItem(e) ? "" : e;
    this.opts.value.current = n, n !== "" && (this.opts.inputValue.current = r);
  }
  setInitialHighlightedNode() {
    Jt(() => {
      if (!(this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode))) {
        if (this.opts.value.current !== "") {
          const e = this.getNodeByValue(this.opts.value.current);
          if (e) {
            this.setHighlightedNode(e, !0);
            return;
          }
        }
        this.setHighlightedToFirstCandidate(!0);
      }
    });
  }
}
class _I extends kw {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ C(() => this.opts.value.current.length > 0);
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e, Ze(() => {
      !this.opts.open.current && this.highlightedNode && this.setHighlightedNode(null);
    }), Ne(() => this.opts.open.current, () => {
      this.opts.open.current && this.setInitialHighlightedNode();
    });
  }
  includesItem(e) {
    return this.opts.value.current.includes(e);
  }
  toggleItem(e, r = e) {
    this.includesItem(e) ? this.opts.value.current = this.opts.value.current.filter((n) => n !== e) : this.opts.value.current = [...this.opts.value.current, e], this.opts.inputValue.current = r;
  }
  setInitialHighlightedNode() {
    Jt(() => {
      if (this.domContext && !(this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode))) {
        if (this.opts.value.current.length && this.opts.value.current[0] !== "") {
          const e = this.getNodeByValue(this.opts.value.current[0]);
          if (e) {
            this.setHighlightedNode(e, !0);
            return;
          }
        }
        this.setHighlightedToFirstCandidate(!0);
      }
    });
  }
}
class wI {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new bI(n) : new _I(n);
    return qo.set(s);
  }
}
class ch {
  static create(e) {
    return new ch(e, qo.get());
  }
  opts;
  root;
  attachment;
  #e;
  #t;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref, (n) => this.root.triggerNode = n), this.root.domContext = new Nn(e.ref), this.#e = new $T({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (n) => {
        this.root.setHighlightedNode(n);
      },
      getActiveElement: () => this.root.domContext.getActiveElement(),
      getWindow: () => this.root.domContext.getWindow()
    }), this.#t = new gI({
      getCurrentItem: () => this.root.isMulti ? "" : this.root.currentLabel,
      onMatch: (n) => {
        if (this.root.isMulti || !this.root.opts.items.current) return;
        const s = this.root.opts.items.current.find((o) => o.label === n);
        s && (this.root.opts.value.current = s.value);
      },
      enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled,
      candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels,
      getWindow: () => this.root.domContext.getWindow()
    }), this.onkeydown = this.onkeydown.bind(this), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onclick = this.onclick.bind(this);
  }
  #r() {
    this.root.opts.open.current = !0, this.#t.resetTypeahead(), this.#e.resetTypeahead();
  }
  #n(e) {
    this.#r();
  }
  /**
   * Logic used to handle keyboard selection/deselection.
   *
   * If it returns true, it means the item was selected and whatever is calling
   * this function should return early
   *
   */
  #s() {
    const e = this.root.highlightedValue === this.root.opts.value.current;
    return !this.root.opts.allowDeselect.current && e && !this.root.isMulti ? (this.root.handleClose(), !0) : (this.root.highlightedValue !== null && this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0), !this.root.isMulti && !e ? (this.root.handleClose(), !0) : !1);
  }
  onkeydown(e) {
    if (this.root.isUsingKeyboard = !0, (e.key === Qt || e.key === cr) && e.preventDefault(), !this.root.opts.open.current) {
      if (e.key === Vr || e.key === wr || e.key === cr || e.key === Qt)
        e.preventDefault(), this.root.handleOpen();
      else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
        this.#t.handleTypeaheadSearch(e.key);
        return;
      }
      if (this.root.hasValue) return;
      const i = this.root.getCandidateNodes();
      if (!i.length) return;
      if (e.key === cr) {
        const a = i[0];
        this.root.setHighlightedNode(a);
      } else if (e.key === Qt) {
        const a = i[i.length - 1];
        this.root.setHighlightedNode(a);
      }
      return;
    }
    if (e.key === vm) {
      this.root.handleClose();
      return;
    }
    if ((e.key === Vr || // if we're currently "typing ahead", we don't want to select the item
    // just yet as the item the user is trying to get to may have a space in it,
    // so we defer handling the close for this case until further down
    e.key === wr && this.#e.search === "") && !e.isComposing && (e.preventDefault(), this.#s()))
      return;
    if (e.key === Qt && e.altKey && this.root.handleClose(), vI.includes(e.key)) {
      e.preventDefault();
      const i = this.root.getCandidateNodes(), a = this.root.highlightedNode, l = a ? i.indexOf(a) : -1, u = this.root.opts.loop.current;
      let c;
      if (e.key === cr ? c = xT(i, l, u) : e.key === Qt ? c = PT(i, l, u) : e.key === Q_ ? c = OT(i, l, 10, u) : e.key === e0 ? c = CT(i, l, 10, u) : e.key === Vo ? c = i[0] : e.key === Ro && (c = i[i.length - 1]), !c) return;
      this.root.setHighlightedNode(c);
      return;
    }
    const r = e.ctrlKey || e.altKey || e.metaKey, n = e.key.length === 1, s = e.key === wr, o = this.root.getCandidateNodes();
    if (e.key !== vm) {
      if (!r && (n || s)) {
        !this.#e.handleTypeaheadSearch(e.key, o) && s && (e.preventDefault(), this.#s());
        return;
      }
      this.root.highlightedNode || this.root.setHighlightedToFirstCandidate();
    }
  }
  onclick(e) {
    e.currentTarget.focus();
  }
  onpointerdown(e) {
    if (this.root.opts.disabled.current) return;
    if (e.pointerType === "touch") return e.preventDefault();
    const r = e.target;
    r?.hasPointerCapture(e.pointerId) && r?.releasePointerCapture(e.pointerId), e.button === 0 && e.ctrlKey === !1 && (this.root.opts.open.current === !1 ? this.#n(e) : this.root.handleClose());
  }
  onpointerup(e) {
    this.root.opts.disabled.current || (e.preventDefault(), e.pointerType === "touch" && (this.root.opts.open.current === !1 ? this.#n(e) : this.root.handleClose()));
  }
  #o = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    disabled: this.root.opts.disabled.current ? !0 : void 0,
    "aria-haspopup": "listbox",
    "aria-expanded": at(this.root.opts.open.current),
    "aria-activedescendant": this.root.highlightedId,
    "data-state": ji(this.root.opts.open.current),
    "data-disabled": Fe(this.root.opts.disabled.current),
    "data-placeholder": this.root.hasValue ? void 0 : "",
    [this.root.getBitsAttr("trigger")]: "",
    onpointerdown: this.onpointerdown,
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    onpointerup: this.onpointerup,
    ...this.attachment
  }));
  get props() {
    return d(this.#o);
  }
  set props(e) {
    q(this.#o, e);
  }
}
class dh {
  static create(e) {
    return fu.set(new dh(e, qo.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ xe(!1);
  get isPositioned() {
    return d(this.#e);
  }
  set isPositioned(e) {
    q(this.#e, e, !0);
  }
  domContext;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref, (n) => this.root.contentNode = n), this.domContext = new Nn(this.opts.ref), this.root.domContext === null && (this.root.domContext = this.domContext), Ws(() => {
      this.root.contentNode = null, this.isPositioned = !1;
    }), Ne(() => this.root.opts.open.current, () => {
      this.root.opts.open.current || (this.isPositioned = !1);
    }), this.onpointermove = this.onpointermove.bind(this);
  }
  onpointermove(e) {
    this.root.isUsingKeyboard = !1;
  }
  #t = /* @__PURE__ */ C(() => Wc(this.root.isCombobox ? "combobox" : "select"));
  onInteractOutside = (e) => {
    if (e.target === this.root.triggerNode || e.target === this.root.inputNode) {
      e.preventDefault();
      return;
    }
    this.opts.onInteractOutside.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  #r = /* @__PURE__ */ C(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#r);
  }
  set snippetProps(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "listbox",
    "aria-multiselectable": this.root.isMulti ? "true" : void 0,
    "data-state": ji(this.root.opts.open.current),
    [this.root.getBitsAttr("content")]: "",
    style: {
      display: "flex",
      flexDirection: "column",
      outline: "none",
      boxSizing: "border-box",
      pointerEvents: "auto",
      ...d(this.#t)
    },
    onpointermove: this.onpointermove,
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onOpenAutoFocus: this.onOpenAutoFocus,
    onCloseAutoFocus: this.onCloseAutoFocus,
    trapFocus: !1,
    loop: !1,
    onPlaced: () => {
      this.root.opts.open.current && (this.isPositioned = !0);
    }
  };
}
class fh {
  static create(e) {
    return new fh(e, qo.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => this.root.includesItem(this.opts.value.current));
  get isSelected() {
    return d(this.#e);
  }
  set isSelected(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.root.highlightedValue === this.opts.value.current);
  get isHighlighted() {
    return d(this.#t);
  }
  set isHighlighted(e) {
    q(this.#t, e);
  }
  prevHighlighted = new O2(() => this.isHighlighted);
  #r = /* @__PURE__ */ xe(!1);
  get mounted() {
    return d(this.#r);
  }
  set mounted(e) {
    q(this.#r, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref), Ne([() => this.isHighlighted, () => this.prevHighlighted.current], () => {
      this.isHighlighted ? this.opts.onHighlight.current() : this.prevHighlighted.current && this.opts.onUnhighlight.current();
    }), Ne(() => this.mounted, () => {
      this.mounted && this.root.setInitialHighlightedNode();
    }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointerup = this.onpointerup.bind(this), this.onpointermove = this.onpointermove.bind(this);
  }
  handleSelect() {
    if (this.opts.disabled.current) return;
    const e = this.opts.value.current === this.root.opts.value.current;
    if (!this.root.opts.allowDeselect.current && e && !this.root.isMulti) {
      this.root.handleClose();
      return;
    }
    this.root.toggleItem(this.opts.value.current, this.opts.label.current), !this.root.isMulti && !e && this.root.handleClose();
  }
  #n = /* @__PURE__ */ C(() => ({ selected: this.isSelected, highlighted: this.isHighlighted }));
  get snippetProps() {
    return d(this.#n);
  }
  set snippetProps(e) {
    q(this.#n, e);
  }
  onpointerdown(e) {
    e.preventDefault();
  }
  /**
   * Using `pointerup` instead of `click` allows power users to pointerdown
   * the trigger, then release pointerup on an item to select it vs having to do
   * multiple clicks.
   */
  onpointerup(e) {
    if (!(e.defaultPrevented || !this.opts.ref.current)) {
      if (e.pointerType === "touch" && !Vc) {
        Ye(
          this.opts.ref.current,
          "click",
          () => {
            this.handleSelect(), this.root.setHighlightedNode(this.opts.ref.current);
          },
          { once: !0 }
        );
        return;
      }
      e.preventDefault(), this.handleSelect(), e.pointerType === "touch" && this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  onpointermove(e) {
    e.pointerType !== "touch" && this.root.highlightedNode !== this.opts.ref.current && this.root.setHighlightedNode(this.opts.ref.current);
  }
  #s = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "option",
    "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0,
    "data-value": this.opts.value.current,
    "data-disabled": Fe(this.opts.disabled.current),
    "data-highlighted": this.root.highlightedValue === this.opts.value.current && !this.opts.disabled.current ? "" : void 0,
    "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0,
    "data-label": this.opts.label.current,
    [this.root.getBitsAttr("item")]: "",
    onpointermove: this.onpointermove,
    onpointerdown: this.onpointerdown,
    onpointerup: this.onpointerup,
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class hh {
  static create(e) {
    return Cw.set(new hh(e, qo.get()));
  }
  opts;
  root;
  #e = /* @__PURE__ */ xe(null);
  get labelNode() {
    return d(this.#e);
  }
  set labelNode(e) {
    q(this.#e, e, !0);
  }
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref);
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "group",
    [this.root.getBitsAttr("group")]: "",
    "aria-labelledby": this.labelNode?.id ?? void 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class gh {
  static create(e) {
    return new gh(e, Cw.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Ee(e.ref, (n) => this.group.labelNode = n);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [this.group.root.getBitsAttr("group-label")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class ph {
  static create(e) {
    return new ph(e, qo.get());
  }
  opts;
  root;
  #e = /* @__PURE__ */ C(() => this.root.opts.name.current !== "");
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    e.preventDefault(), this.root.isCombobox ? this.root.inputNode?.focus() : this.root.triggerNode?.focus();
  }
  #t = /* @__PURE__ */ C(() => ({
    disabled: _i(this.root.opts.disabled.current),
    required: _i(this.root.opts.required.current),
    name: this.root.opts.name.current,
    value: this.opts.value.current,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class mh {
  static create(e) {
    return new mh(e, fu.get());
  }
  opts;
  content;
  root;
  attachment;
  #e = /* @__PURE__ */ xe(0);
  get prevScrollTop() {
    return d(this.#e);
  }
  set prevScrollTop(e) {
    q(this.#e, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.content = r, this.root = r.root, this.attachment = Ee(e.ref, (n) => {
      this.root.viewportNode = n;
    });
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "presentation",
    [this.root.getBitsAttr("viewport")]: "",
    style: {
      // we use position: 'relative' here on the `viewport` so that when we call
      // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
      // (independent of the scrollUpButton).
      position: "relative",
      flex: 1,
      overflow: "auto"
    },
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class $w {
  opts;
  content;
  root;
  attachment;
  autoScrollTimer = null;
  userScrollTimer = -1;
  isUserScrolling = !1;
  onAutoScroll = _e;
  #e = /* @__PURE__ */ xe(!1);
  get mounted() {
    return d(this.#e);
  }
  set mounted(e) {
    q(this.#e, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.content = r, this.root = r.root, this.attachment = Ee(e.ref), Ne([() => this.mounted], () => {
      if (!this.mounted) {
        this.isUserScrolling = !1;
        return;
      }
      this.isUserScrolling;
    }), Ze(() => {
      this.mounted || this.clearAutoScrollInterval();
    }), this.onpointerdown = this.onpointerdown.bind(this), this.onpointermove = this.onpointermove.bind(this), this.onpointerleave = this.onpointerleave.bind(this);
  }
  handleUserScroll() {
    this.content.domContext.clearTimeout(this.userScrollTimer), this.isUserScrolling = !0, this.userScrollTimer = this.content.domContext.setTimeout(
      () => {
        this.isUserScrolling = !1;
      },
      200
    );
  }
  clearAutoScrollInterval() {
    this.autoScrollTimer !== null && (this.content.domContext.clearTimeout(this.autoScrollTimer), this.autoScrollTimer = null);
  }
  onpointerdown(e) {
    if (this.autoScrollTimer !== null) return;
    const r = (n) => {
      this.onAutoScroll(), this.autoScrollTimer = this.content.domContext.setTimeout(() => r(n + 1), this.opts.delay.current(n));
    };
    this.autoScrollTimer = this.content.domContext.setTimeout(() => r(1), this.opts.delay.current(0));
  }
  onpointermove(e) {
    this.onpointerdown(e);
  }
  onpointerleave(e) {
    this.clearAutoScrollInterval();
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "aria-hidden": tf(!0),
    style: { flexShrink: 0 },
    onpointerdown: this.onpointerdown,
    onpointermove: this.onpointermove,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class vh {
  static create(e) {
    return new vh(new $w(e, fu.get()));
  }
  scrollButtonState;
  content;
  root;
  #e = /* @__PURE__ */ xe(!1);
  get canScrollDown() {
    return d(this.#e);
  }
  set canScrollDown(e) {
    q(this.#e, e, !0);
  }
  scrollIntoViewTimer = null;
  constructor(e) {
    this.scrollButtonState = e, this.content = e.content, this.root = e.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, Ne(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!(!this.root.viewportNode || !this.content.isPositioned))
          return this.handleScroll(!0), Ye(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    ), Ne(
      [
        () => this.root.opts.inputValue.current,
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        !this.root.viewportNode || !this.content.isPositioned || this.handleScroll(!0);
      }
    ), Ne(() => this.scrollButtonState.mounted, () => {
      this.scrollButtonState.mounted && (this.scrollIntoViewTimer && clearTimeout(this.scrollIntoViewTimer), this.scrollIntoViewTimer = Qd(5, () => {
        this.root.highlightedNode?.scrollIntoView({ block: this.root.opts.scrollAlignment.current });
      }));
    });
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (e = !1) => {
    if (e || this.scrollButtonState.handleUserScroll(), !this.root.viewportNode) return;
    const r = this.root.viewportNode.scrollHeight - this.root.viewportNode.clientHeight, n = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
    this.canScrollDown = Math.ceil(this.root.viewportNode.scrollTop) < r - n;
  };
  handleAutoScroll = () => {
    const e = this.root.viewportNode, r = this.root.highlightedNode;
    !e || !r || (e.scrollTop = e.scrollTop + r.offsetHeight);
  };
  #t = /* @__PURE__ */ C(() => ({
    ...this.scrollButtonState.props,
    [this.root.getBitsAttr("scroll-down-button")]: ""
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class yh {
  static create(e) {
    return new yh(new $w(e, fu.get()));
  }
  scrollButtonState;
  content;
  root;
  #e = /* @__PURE__ */ xe(!1);
  get canScrollUp() {
    return d(this.#e);
  }
  set canScrollUp(e) {
    q(this.#e, e, !0);
  }
  constructor(e) {
    this.scrollButtonState = e, this.content = e.content, this.root = e.root, this.scrollButtonState.onAutoScroll = this.handleAutoScroll, Ne(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!(!this.root.viewportNode || !this.content.isPositioned))
          return this.handleScroll(!0), Ye(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    );
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (e = !1) => {
    if (e || this.scrollButtonState.handleUserScroll(), !this.root.viewportNode) return;
    const r = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
    this.canScrollUp = this.root.viewportNode.scrollTop - r > 0.1;
  };
  handleAutoScroll = () => {
    !this.root.viewportNode || !this.root.highlightedNode || (this.root.viewportNode.scrollTop = this.root.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight);
  };
  #t = /* @__PURE__ */ C(() => ({
    ...this.scrollButtonState.props,
    [this.root.getBitsAttr("scroll-up-button")]: ""
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function Xa(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "autocomplete", 7);
  const s = ph.create({ value: z(() => r()) });
  var o = {
    get value() {
      return r();
    },
    set value(u) {
      r(u), m();
    },
    get autocomplete() {
      return n();
    },
    set autocomplete(u) {
      n(u), m();
    }
  }, i = I(), a = D(i);
  {
    var l = (u) => {
      zi(u, ce(() => s.props, {
        get autocomplete() {
          return n();
        },
        get value() {
          return r();
        },
        set value(c) {
          r(c);
        }
      }));
    };
    ue(a, (u) => {
      s.shouldRender && u(l);
    });
  }
  return A(t, i), W(o);
}
K(Xa, { value: {}, autocomplete: {} }, [], [], { mode: "open" });
function bh(t, e) {
  H(e, !0);
  let r = v(e, "id", 7), n = v(e, "children", 7), s = v(e, "virtualEl", 7), o = v(e, "ref", 7), i = v(e, "tooltip", 7, !1);
  xl.create(
    {
      id: z(() => r()),
      virtualEl: z(() => s()),
      ref: o()
    },
    i()
  );
  var a = {
    get id() {
      return r();
    },
    set id(c) {
      r(c), m();
    },
    get children() {
      return n();
    },
    set children(c) {
      n(c), m();
    },
    get virtualEl() {
      return s();
    },
    set virtualEl(c) {
      s(c), m();
    },
    get ref() {
      return o();
    },
    set ref(c) {
      o(c), m();
    },
    get tooltip() {
      return i();
    },
    set tooltip(c = !1) {
      i(c), m();
    }
  }, l = I(), u = D(l);
  return te(u, () => n() ?? ge), A(t, l), W(a);
}
K(bh, { id: {}, children: {}, virtualEl: {}, ref: {}, tooltip: {} }, [], [], { mode: "open" });
function Aw(t, e) {
  H(e, !0);
  let r = v(e, "content", 7), n = v(e, "side", 7, "bottom"), s = v(e, "sideOffset", 7, 0), o = v(e, "align", 7, "center"), i = v(e, "alignOffset", 7, 0), a = v(e, "id", 7), l = v(e, "arrowPadding", 7, 0), u = v(e, "avoidCollisions", 7, !0), c = v(e, "collisionBoundary", 23, () => []), f = v(e, "collisionPadding", 7, 0), p = v(e, "hideWhenDetached", 7, !1), _ = v(e, "onPlaced", 7, () => {
  }), b = v(e, "sticky", 7, "partial"), g = v(e, "updatePositionStrategy", 7, "optimized"), h = v(e, "strategy", 7, "fixed"), y = v(e, "dir", 7, "ltr"), S = v(e, "style", 23, () => ({})), x = v(e, "wrapperId", 23, kn), P = v(e, "customAnchor", 7, null), w = v(e, "enabled", 7), O = v(e, "tooltip", 7, !1);
  const k = Sl.create(
    {
      side: z(() => n()),
      sideOffset: z(() => s()),
      align: z(() => o()),
      alignOffset: z(() => i()),
      id: z(() => a()),
      arrowPadding: z(() => l()),
      avoidCollisions: z(() => u()),
      collisionBoundary: z(() => c()),
      collisionPadding: z(() => f()),
      hideWhenDetached: z(() => p()),
      onPlaced: z(() => _()),
      sticky: z(() => b()),
      updatePositionStrategy: z(() => g()),
      strategy: z(() => h()),
      dir: z(() => y()),
      style: z(() => S()),
      enabled: z(() => w()),
      wrapperId: z(() => x()),
      customAnchor: z(() => P())
    },
    O()
  ), $ = /* @__PURE__ */ C(() => Ce(k.wrapperProps, { style: { pointerEvents: "auto" } }));
  var T = {
    get content() {
      return r();
    },
    set content(R) {
      r(R), m();
    },
    get side() {
      return n();
    },
    set side(R = "bottom") {
      n(R), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(R = 0) {
      s(R), m();
    },
    get align() {
      return o();
    },
    set align(R = "center") {
      o(R), m();
    },
    get alignOffset() {
      return i();
    },
    set alignOffset(R = 0) {
      i(R), m();
    },
    get id() {
      return a();
    },
    set id(R) {
      a(R), m();
    },
    get arrowPadding() {
      return l();
    },
    set arrowPadding(R = 0) {
      l(R), m();
    },
    get avoidCollisions() {
      return u();
    },
    set avoidCollisions(R = !0) {
      u(R), m();
    },
    get collisionBoundary() {
      return c();
    },
    set collisionBoundary(R = []) {
      c(R), m();
    },
    get collisionPadding() {
      return f();
    },
    set collisionPadding(R = 0) {
      f(R), m();
    },
    get hideWhenDetached() {
      return p();
    },
    set hideWhenDetached(R = !1) {
      p(R), m();
    },
    get onPlaced() {
      return _();
    },
    set onPlaced(R = () => {
    }) {
      _(R), m();
    },
    get sticky() {
      return b();
    },
    set sticky(R = "partial") {
      b(R), m();
    },
    get updatePositionStrategy() {
      return g();
    },
    set updatePositionStrategy(R = "optimized") {
      g(R), m();
    },
    get strategy() {
      return h();
    },
    set strategy(R = "fixed") {
      h(R), m();
    },
    get dir() {
      return y();
    },
    set dir(R = "ltr") {
      y(R), m();
    },
    get style() {
      return S();
    },
    set style(R = {}) {
      S(R), m();
    },
    get wrapperId() {
      return x();
    },
    set wrapperId(R = kn()) {
      x(R), m();
    },
    get customAnchor() {
      return P();
    },
    set customAnchor(R = null) {
      P(R), m();
    },
    get enabled() {
      return w();
    },
    set enabled(R) {
      w(R), m();
    },
    get tooltip() {
      return O();
    },
    set tooltip(R = !1) {
      O(R), m();
    }
  }, E = I(), M = D(E);
  return te(M, () => r() ?? ge, () => ({ props: k.props, wrapperProps: d($) })), A(t, E), W(T);
}
K(
  Aw,
  {
    content: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    id: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    hideWhenDetached: {},
    onPlaced: {},
    sticky: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    style: {},
    wrapperId: {},
    customAnchor: {},
    enabled: {},
    tooltip: {}
  },
  [],
  [],
  { mode: "open" }
);
function Ew(t, e) {
  H(e, !0);
  let r = v(e, "content", 7), n = v(e, "onPlaced", 7);
  ko(() => {
    n()?.();
  });
  var s = {
    get content() {
      return r();
    },
    set content(a) {
      r(a), m();
    },
    get onPlaced() {
      return n();
    },
    set onPlaced(a) {
      n(a), m();
    }
  }, o = I(), i = D(o);
  return te(i, () => r() ?? ge, () => ({ props: {}, wrapperProps: {} })), A(t, o), W(s);
}
K(Ew, { content: {}, onPlaced: {} }, [], [], { mode: "open" });
const SI = rr({ component: "separator", parts: ["root"] });
class _h {
  static create(e) {
    return new _h(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(e.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: this.opts.decorative.current ? "none" : "separator",
    "aria-orientation": this.opts.orientation.current,
    "aria-hidden": tf(this.opts.decorative.current),
    "data-orientation": this.opts.orientation.current,
    [SI.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var xI = /* @__PURE__ */ ne("<div><!></div>");
function Tw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "decorative", 7, !1), l = v(e, "orientation", 7, "horizontal"), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "decorative",
    "orientation"
  ]);
  const c = _h.create({
    ref: z(() => s(), (y) => s(y)),
    id: z(() => n()),
    decorative: z(() => a()),
    orientation: z(() => l())
  }), f = /* @__PURE__ */ C(() => Ce(u, c.props));
  var p = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get ref() {
      return s();
    },
    set ref(y = null) {
      s(y), m();
    },
    get child() {
      return o();
    },
    set child(y) {
      o(y), m();
    },
    get children() {
      return i();
    },
    set children(y) {
      i(y), m();
    },
    get decorative() {
      return a();
    },
    set decorative(y = !1) {
      a(y), m();
    },
    get orientation() {
      return l();
    },
    set orientation(y = "horizontal") {
      l(y), m();
    }
  }, _ = I(), b = D(_);
  {
    var g = (y) => {
      var S = I(), x = D(S);
      te(x, o, () => ({ props: d(f) })), A(y, S);
    }, h = (y) => {
      var S = xI();
      ve(S, () => ({ ...d(f) }));
      var x = he(S);
      te(x, () => i() ?? ge), de(S), A(y, S);
    };
    ue(b, (y) => {
      o() ? y(g) : y(h, !1);
    });
  }
  return A(t, _), W(p);
}
K(
  Tw,
  {
    id: {},
    ref: {},
    child: {},
    children: {},
    decorative: {},
    orientation: {}
  },
  [],
  [],
  { mode: "open" }
);
function Dw(t, e) {
  H(e, !0);
  let r = v(e, "content", 7), n = v(e, "isStatic", 7, !1), s = v(e, "onPlaced", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "content",
    "isStatic",
    "onPlaced"
  ]);
  var i = {
    get content() {
      return r();
    },
    set content(f) {
      r(f), m();
    },
    get isStatic() {
      return n();
    },
    set isStatic(f = !1) {
      n(f), m();
    },
    get onPlaced() {
      return s();
    },
    set onPlaced(f) {
      s(f), m();
    }
  }, a = I(), l = D(a);
  {
    var u = (f) => {
      Ew(f, {
        get content() {
          return r();
        },
        get onPlaced() {
          return s();
        }
      });
    }, c = (f) => {
      Aw(f, ce(
        {
          get content() {
            return r();
          },
          get onPlaced() {
            return s();
          }
        },
        () => o
      ));
    };
    ue(l, (f) => {
      n() ? f(u) : f(c, !1);
    });
  }
  return A(t, a), W(i);
}
K(Dw, { content: {}, isStatic: {}, onPlaced: {} }, [], [], { mode: "open" });
var PI = /* @__PURE__ */ ne("<!> <!>", 1);
function wh(t, e) {
  H(e, !0);
  let r = v(e, "popper", 7), n = v(e, "onEscapeKeydown", 7), s = v(e, "escapeKeydownBehavior", 7), o = v(e, "preventOverflowTextSelection", 7), i = v(e, "id", 7), a = v(e, "onPointerDown", 7), l = v(e, "onPointerUp", 7), u = v(e, "side", 7), c = v(e, "sideOffset", 7), f = v(e, "align", 7), p = v(e, "alignOffset", 7), _ = v(e, "arrowPadding", 7), b = v(e, "avoidCollisions", 7), g = v(e, "collisionBoundary", 7), h = v(e, "collisionPadding", 7), y = v(e, "sticky", 7), S = v(e, "hideWhenDetached", 7), x = v(e, "updatePositionStrategy", 7), P = v(e, "strategy", 7), w = v(e, "dir", 7), O = v(e, "preventScroll", 7), k = v(e, "wrapperId", 7), $ = v(e, "style", 7), T = v(e, "onPlaced", 7), E = v(e, "onInteractOutside", 7), M = v(e, "onCloseAutoFocus", 7), R = v(e, "onOpenAutoFocus", 7), U = v(e, "onFocusOutside", 7), B = v(e, "interactOutsideBehavior", 7, "close"), F = v(e, "loop", 7), Z = v(e, "trapFocus", 7, !0), Y = v(e, "isValidEvent", 7, () => !1), X = v(e, "customAnchor", 7, null), ae = v(e, "isStatic", 7, !1), J = v(e, "enabled", 7), j = v(e, "ref", 7), ee = v(e, "tooltip", 7, !1), L = v(e, "contentPointerEvents", 7, "auto"), N = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled",
    "ref",
    "tooltip",
    "contentPointerEvents"
  ]);
  var V = {
    get popper() {
      return r();
    },
    set popper(G) {
      r(G), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(G) {
      n(G), m();
    },
    get escapeKeydownBehavior() {
      return s();
    },
    set escapeKeydownBehavior(G) {
      s(G), m();
    },
    get preventOverflowTextSelection() {
      return o();
    },
    set preventOverflowTextSelection(G) {
      o(G), m();
    },
    get id() {
      return i();
    },
    set id(G) {
      i(G), m();
    },
    get onPointerDown() {
      return a();
    },
    set onPointerDown(G) {
      a(G), m();
    },
    get onPointerUp() {
      return l();
    },
    set onPointerUp(G) {
      l(G), m();
    },
    get side() {
      return u();
    },
    set side(G) {
      u(G), m();
    },
    get sideOffset() {
      return c();
    },
    set sideOffset(G) {
      c(G), m();
    },
    get align() {
      return f();
    },
    set align(G) {
      f(G), m();
    },
    get alignOffset() {
      return p();
    },
    set alignOffset(G) {
      p(G), m();
    },
    get arrowPadding() {
      return _();
    },
    set arrowPadding(G) {
      _(G), m();
    },
    get avoidCollisions() {
      return b();
    },
    set avoidCollisions(G) {
      b(G), m();
    },
    get collisionBoundary() {
      return g();
    },
    set collisionBoundary(G) {
      g(G), m();
    },
    get collisionPadding() {
      return h();
    },
    set collisionPadding(G) {
      h(G), m();
    },
    get sticky() {
      return y();
    },
    set sticky(G) {
      y(G), m();
    },
    get hideWhenDetached() {
      return S();
    },
    set hideWhenDetached(G) {
      S(G), m();
    },
    get updatePositionStrategy() {
      return x();
    },
    set updatePositionStrategy(G) {
      x(G), m();
    },
    get strategy() {
      return P();
    },
    set strategy(G) {
      P(G), m();
    },
    get dir() {
      return w();
    },
    set dir(G) {
      w(G), m();
    },
    get preventScroll() {
      return O();
    },
    set preventScroll(G) {
      O(G), m();
    },
    get wrapperId() {
      return k();
    },
    set wrapperId(G) {
      k(G), m();
    },
    get style() {
      return $();
    },
    set style(G) {
      $(G), m();
    },
    get onPlaced() {
      return T();
    },
    set onPlaced(G) {
      T(G), m();
    },
    get onInteractOutside() {
      return E();
    },
    set onInteractOutside(G) {
      E(G), m();
    },
    get onCloseAutoFocus() {
      return M();
    },
    set onCloseAutoFocus(G) {
      M(G), m();
    },
    get onOpenAutoFocus() {
      return R();
    },
    set onOpenAutoFocus(G) {
      R(G), m();
    },
    get onFocusOutside() {
      return U();
    },
    set onFocusOutside(G) {
      U(G), m();
    },
    get interactOutsideBehavior() {
      return B();
    },
    set interactOutsideBehavior(G = "close") {
      B(G), m();
    },
    get loop() {
      return F();
    },
    set loop(G) {
      F(G), m();
    },
    get trapFocus() {
      return Z();
    },
    set trapFocus(G = !0) {
      Z(G), m();
    },
    get isValidEvent() {
      return Y();
    },
    set isValidEvent(G = () => !1) {
      Y(G), m();
    },
    get customAnchor() {
      return X();
    },
    set customAnchor(G = null) {
      X(G), m();
    },
    get isStatic() {
      return ae();
    },
    set isStatic(G = !1) {
      ae(G), m();
    },
    get enabled() {
      return J();
    },
    set enabled(G) {
      J(G), m();
    },
    get ref() {
      return j();
    },
    set ref(G) {
      j(G), m();
    },
    get tooltip() {
      return ee();
    },
    set tooltip(G = !1) {
      ee(G), m();
    },
    get contentPointerEvents() {
      return L();
    },
    set contentPointerEvents(G = "auto") {
      L(G), m();
    }
  };
  return Dw(t, {
    get isStatic() {
      return ae();
    },
    get id() {
      return i();
    },
    get side() {
      return u();
    },
    get sideOffset() {
      return c();
    },
    get align() {
      return f();
    },
    get alignOffset() {
      return p();
    },
    get arrowPadding() {
      return _();
    },
    get avoidCollisions() {
      return b();
    },
    get collisionBoundary() {
      return g();
    },
    get collisionPadding() {
      return h();
    },
    get sticky() {
      return y();
    },
    get hideWhenDetached() {
      return S();
    },
    get updatePositionStrategy() {
      return x();
    },
    get strategy() {
      return P();
    },
    get dir() {
      return w();
    },
    get wrapperId() {
      return k();
    },
    get style() {
      return $();
    },
    get onPlaced() {
      return T();
    },
    get customAnchor() {
      return X();
    },
    get enabled() {
      return J();
    },
    get tooltip() {
      return ee();
    },
    content: (fe, se) => {
      let we = () => se?.().props, le = () => se?.().wrapperProps;
      var re = PI(), oe = D(re);
      {
        var pe = (Oe) => {
          Si(Oe, {
            get preventScroll() {
              return O();
            }
          });
        }, ye = (Oe) => {
          var Re = I(), Ke = D(Re);
          {
            var Ve = (je) => {
              Si(je, {
                get preventScroll() {
                  return O();
                }
              });
            };
            ue(
              Ke,
              (je) => {
                e.forceMount || je(Ve);
              },
              !0
            );
          }
          A(Oe, Re);
        };
        ue(oe, (Oe) => {
          e.forceMount && J() ? Oe(pe) : Oe(ye, !1);
        });
      }
      var Pe = be(oe, 2);
      yf(Pe, {
        get onOpenAutoFocus() {
          return R();
        },
        get onCloseAutoFocus() {
          return M();
        },
        get loop() {
          return F();
        },
        get enabled() {
          return J();
        },
        get trapFocus() {
          return Z();
        },
        get forceMount() {
          return e.forceMount;
        },
        get ref() {
          return j();
        },
        focusScope: (Re, Ke) => {
          let Ve = () => Ke?.().props;
          pf(Re, {
            get onEscapeKeydown() {
              return n();
            },
            get escapeKeydownBehavior() {
              return s();
            },
            get enabled() {
              return J();
            },
            get ref() {
              return j();
            },
            children: (je, He) => {
              hf(je, {
                get id() {
                  return i();
                },
                get onInteractOutside() {
                  return E();
                },
                get onFocusOutside() {
                  return U();
                },
                get interactOutsideBehavior() {
                  return B();
                },
                get isValidEvent() {
                  return Y();
                },
                get enabled() {
                  return J();
                },
                get ref() {
                  return j();
                },
                children: (Je, kt) => {
                  let lt = () => kt?.().props;
                  _f(Je, {
                    get id() {
                      return i();
                    },
                    get preventOverflowTextSelection() {
                      return o();
                    },
                    get onPointerDown() {
                      return a();
                    },
                    get onPointerUp() {
                      return l();
                    },
                    get enabled() {
                      return J();
                    },
                    get ref() {
                      return j();
                    },
                    children: (ct, pt) => {
                      var Kt = I(), yt = D(Kt);
                      {
                        let Rt = /* @__PURE__ */ C(() => ({
                          props: Ce(N, we(), lt(), Ve(), { style: { pointerEvents: L() } }),
                          wrapperProps: le()
                        }));
                        te(yt, () => r() ?? ge, () => d(Rt));
                      }
                      A(ct, Kt);
                    },
                    $$slots: { default: !0 }
                  });
                },
                $$slots: { default: !0 }
              });
            },
            $$slots: { default: !0 }
          });
        },
        $$slots: { focusScope: !0 }
      }), A(fe, re);
    },
    $$slots: { content: !0 }
  }), W(V);
}
K(
  wh,
  {
    popper: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    enabled: {},
    ref: {},
    tooltip: {},
    contentPointerEvents: {}
  },
  [],
  [],
  { mode: "open" }
);
function Sh(t, e) {
  H(e, !0);
  let r = v(e, "popper", 7), n = v(e, "open", 7), s = v(e, "onEscapeKeydown", 7), o = v(e, "escapeKeydownBehavior", 7), i = v(e, "preventOverflowTextSelection", 7), a = v(e, "id", 7), l = v(e, "onPointerDown", 7), u = v(e, "onPointerUp", 7), c = v(e, "side", 7), f = v(e, "sideOffset", 7), p = v(e, "align", 7), _ = v(e, "alignOffset", 7), b = v(e, "arrowPadding", 7), g = v(e, "avoidCollisions", 7), h = v(e, "collisionBoundary", 7), y = v(e, "collisionPadding", 7), S = v(e, "sticky", 7), x = v(e, "hideWhenDetached", 7), P = v(e, "updatePositionStrategy", 7), w = v(e, "strategy", 7), O = v(e, "dir", 7), k = v(e, "preventScroll", 7), $ = v(e, "wrapperId", 7), T = v(e, "style", 7), E = v(e, "onPlaced", 7), M = v(e, "onInteractOutside", 7), R = v(e, "onCloseAutoFocus", 7), U = v(e, "onOpenAutoFocus", 7), B = v(e, "onFocusOutside", 7), F = v(e, "interactOutsideBehavior", 7, "close"), Z = v(e, "loop", 7), Y = v(e, "trapFocus", 7, !0), X = v(e, "isValidEvent", 7, () => !1), ae = v(e, "customAnchor", 7, null), J = v(e, "isStatic", 7, !1), j = v(e, "ref", 7), ee = v(e, "shouldRender", 7), L = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "open",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "ref",
    "shouldRender"
  ]);
  var N = {
    get popper() {
      return r();
    },
    set popper(se) {
      r(se), m();
    },
    get open() {
      return n();
    },
    set open(se) {
      n(se), m();
    },
    get onEscapeKeydown() {
      return s();
    },
    set onEscapeKeydown(se) {
      s(se), m();
    },
    get escapeKeydownBehavior() {
      return o();
    },
    set escapeKeydownBehavior(se) {
      o(se), m();
    },
    get preventOverflowTextSelection() {
      return i();
    },
    set preventOverflowTextSelection(se) {
      i(se), m();
    },
    get id() {
      return a();
    },
    set id(se) {
      a(se), m();
    },
    get onPointerDown() {
      return l();
    },
    set onPointerDown(se) {
      l(se), m();
    },
    get onPointerUp() {
      return u();
    },
    set onPointerUp(se) {
      u(se), m();
    },
    get side() {
      return c();
    },
    set side(se) {
      c(se), m();
    },
    get sideOffset() {
      return f();
    },
    set sideOffset(se) {
      f(se), m();
    },
    get align() {
      return p();
    },
    set align(se) {
      p(se), m();
    },
    get alignOffset() {
      return _();
    },
    set alignOffset(se) {
      _(se), m();
    },
    get arrowPadding() {
      return b();
    },
    set arrowPadding(se) {
      b(se), m();
    },
    get avoidCollisions() {
      return g();
    },
    set avoidCollisions(se) {
      g(se), m();
    },
    get collisionBoundary() {
      return h();
    },
    set collisionBoundary(se) {
      h(se), m();
    },
    get collisionPadding() {
      return y();
    },
    set collisionPadding(se) {
      y(se), m();
    },
    get sticky() {
      return S();
    },
    set sticky(se) {
      S(se), m();
    },
    get hideWhenDetached() {
      return x();
    },
    set hideWhenDetached(se) {
      x(se), m();
    },
    get updatePositionStrategy() {
      return P();
    },
    set updatePositionStrategy(se) {
      P(se), m();
    },
    get strategy() {
      return w();
    },
    set strategy(se) {
      w(se), m();
    },
    get dir() {
      return O();
    },
    set dir(se) {
      O(se), m();
    },
    get preventScroll() {
      return k();
    },
    set preventScroll(se) {
      k(se), m();
    },
    get wrapperId() {
      return $();
    },
    set wrapperId(se) {
      $(se), m();
    },
    get style() {
      return T();
    },
    set style(se) {
      T(se), m();
    },
    get onPlaced() {
      return E();
    },
    set onPlaced(se) {
      E(se), m();
    },
    get onInteractOutside() {
      return M();
    },
    set onInteractOutside(se) {
      M(se), m();
    },
    get onCloseAutoFocus() {
      return R();
    },
    set onCloseAutoFocus(se) {
      R(se), m();
    },
    get onOpenAutoFocus() {
      return U();
    },
    set onOpenAutoFocus(se) {
      U(se), m();
    },
    get onFocusOutside() {
      return B();
    },
    set onFocusOutside(se) {
      B(se), m();
    },
    get interactOutsideBehavior() {
      return F();
    },
    set interactOutsideBehavior(se = "close") {
      F(se), m();
    },
    get loop() {
      return Z();
    },
    set loop(se) {
      Z(se), m();
    },
    get trapFocus() {
      return Y();
    },
    set trapFocus(se = !0) {
      Y(se), m();
    },
    get isValidEvent() {
      return X();
    },
    set isValidEvent(se = () => !1) {
      X(se), m();
    },
    get customAnchor() {
      return ae();
    },
    set customAnchor(se = null) {
      ae(se), m();
    },
    get isStatic() {
      return J();
    },
    set isStatic(se = !1) {
      J(se), m();
    },
    get ref() {
      return j();
    },
    set ref(se) {
      j(se), m();
    },
    get shouldRender() {
      return ee();
    },
    set shouldRender(se) {
      ee(se), m();
    }
  }, V = I(), G = D(V);
  {
    var fe = (se) => {
      wh(se, ce(
        {
          get popper() {
            return r();
          },
          get onEscapeKeydown() {
            return s();
          },
          get escapeKeydownBehavior() {
            return o();
          },
          get preventOverflowTextSelection() {
            return i();
          },
          get id() {
            return a();
          },
          get onPointerDown() {
            return l();
          },
          get onPointerUp() {
            return u();
          },
          get side() {
            return c();
          },
          get sideOffset() {
            return f();
          },
          get align() {
            return p();
          },
          get alignOffset() {
            return _();
          },
          get arrowPadding() {
            return b();
          },
          get avoidCollisions() {
            return g();
          },
          get collisionBoundary() {
            return h();
          },
          get collisionPadding() {
            return y();
          },
          get sticky() {
            return S();
          },
          get hideWhenDetached() {
            return x();
          },
          get updatePositionStrategy() {
            return P();
          },
          get strategy() {
            return w();
          },
          get dir() {
            return O();
          },
          get preventScroll() {
            return k();
          },
          get wrapperId() {
            return $();
          },
          get style() {
            return T();
          },
          get onPlaced() {
            return E();
          },
          get customAnchor() {
            return ae();
          },
          get isStatic() {
            return J();
          },
          get enabled() {
            return n();
          },
          get onInteractOutside() {
            return M();
          },
          get onCloseAutoFocus() {
            return R();
          },
          get onOpenAutoFocus() {
            return U();
          },
          get interactOutsideBehavior() {
            return F();
          },
          get loop() {
            return Z();
          },
          get trapFocus() {
            return Y();
          },
          get isValidEvent() {
            return X();
          },
          get onFocusOutside() {
            return B();
          },
          forceMount: !1,
          get ref() {
            return j();
          }
        },
        () => L
      ));
    };
    ue(G, (se) => {
      ee() && se(fe);
    });
  }
  return A(t, V), W(N);
}
K(
  Sh,
  {
    popper: {},
    open: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    ref: {},
    shouldRender: {}
  },
  [],
  [],
  { mode: "open" }
);
function xh(t, e) {
  H(e, !0);
  let r = v(e, "popper", 7), n = v(e, "onEscapeKeydown", 7), s = v(e, "escapeKeydownBehavior", 7), o = v(e, "preventOverflowTextSelection", 7), i = v(e, "id", 7), a = v(e, "onPointerDown", 7), l = v(e, "onPointerUp", 7), u = v(e, "side", 7), c = v(e, "sideOffset", 7), f = v(e, "align", 7), p = v(e, "alignOffset", 7), _ = v(e, "arrowPadding", 7), b = v(e, "avoidCollisions", 7), g = v(e, "collisionBoundary", 7), h = v(e, "collisionPadding", 7), y = v(e, "sticky", 7), S = v(e, "hideWhenDetached", 7), x = v(e, "updatePositionStrategy", 7), P = v(e, "strategy", 7), w = v(e, "dir", 7), O = v(e, "preventScroll", 7), k = v(e, "wrapperId", 7), $ = v(e, "style", 7), T = v(e, "onPlaced", 7), E = v(e, "onInteractOutside", 7), M = v(e, "onCloseAutoFocus", 7), R = v(e, "onOpenAutoFocus", 7), U = v(e, "onFocusOutside", 7), B = v(e, "interactOutsideBehavior", 7, "close"), F = v(e, "loop", 7), Z = v(e, "trapFocus", 7, !0), Y = v(e, "isValidEvent", 7, () => !1), X = v(e, "customAnchor", 7, null), ae = v(e, "isStatic", 7, !1), J = v(e, "enabled", 7), j = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled"
  ]);
  var ee = {
    get popper() {
      return r();
    },
    set popper(L) {
      r(L), m();
    },
    get onEscapeKeydown() {
      return n();
    },
    set onEscapeKeydown(L) {
      n(L), m();
    },
    get escapeKeydownBehavior() {
      return s();
    },
    set escapeKeydownBehavior(L) {
      s(L), m();
    },
    get preventOverflowTextSelection() {
      return o();
    },
    set preventOverflowTextSelection(L) {
      o(L), m();
    },
    get id() {
      return i();
    },
    set id(L) {
      i(L), m();
    },
    get onPointerDown() {
      return a();
    },
    set onPointerDown(L) {
      a(L), m();
    },
    get onPointerUp() {
      return l();
    },
    set onPointerUp(L) {
      l(L), m();
    },
    get side() {
      return u();
    },
    set side(L) {
      u(L), m();
    },
    get sideOffset() {
      return c();
    },
    set sideOffset(L) {
      c(L), m();
    },
    get align() {
      return f();
    },
    set align(L) {
      f(L), m();
    },
    get alignOffset() {
      return p();
    },
    set alignOffset(L) {
      p(L), m();
    },
    get arrowPadding() {
      return _();
    },
    set arrowPadding(L) {
      _(L), m();
    },
    get avoidCollisions() {
      return b();
    },
    set avoidCollisions(L) {
      b(L), m();
    },
    get collisionBoundary() {
      return g();
    },
    set collisionBoundary(L) {
      g(L), m();
    },
    get collisionPadding() {
      return h();
    },
    set collisionPadding(L) {
      h(L), m();
    },
    get sticky() {
      return y();
    },
    set sticky(L) {
      y(L), m();
    },
    get hideWhenDetached() {
      return S();
    },
    set hideWhenDetached(L) {
      S(L), m();
    },
    get updatePositionStrategy() {
      return x();
    },
    set updatePositionStrategy(L) {
      x(L), m();
    },
    get strategy() {
      return P();
    },
    set strategy(L) {
      P(L), m();
    },
    get dir() {
      return w();
    },
    set dir(L) {
      w(L), m();
    },
    get preventScroll() {
      return O();
    },
    set preventScroll(L) {
      O(L), m();
    },
    get wrapperId() {
      return k();
    },
    set wrapperId(L) {
      k(L), m();
    },
    get style() {
      return $();
    },
    set style(L) {
      $(L), m();
    },
    get onPlaced() {
      return T();
    },
    set onPlaced(L) {
      T(L), m();
    },
    get onInteractOutside() {
      return E();
    },
    set onInteractOutside(L) {
      E(L), m();
    },
    get onCloseAutoFocus() {
      return M();
    },
    set onCloseAutoFocus(L) {
      M(L), m();
    },
    get onOpenAutoFocus() {
      return R();
    },
    set onOpenAutoFocus(L) {
      R(L), m();
    },
    get onFocusOutside() {
      return U();
    },
    set onFocusOutside(L) {
      U(L), m();
    },
    get interactOutsideBehavior() {
      return B();
    },
    set interactOutsideBehavior(L = "close") {
      B(L), m();
    },
    get loop() {
      return F();
    },
    set loop(L) {
      F(L), m();
    },
    get trapFocus() {
      return Z();
    },
    set trapFocus(L = !0) {
      Z(L), m();
    },
    get isValidEvent() {
      return Y();
    },
    set isValidEvent(L = () => !1) {
      Y(L), m();
    },
    get customAnchor() {
      return X();
    },
    set customAnchor(L = null) {
      X(L), m();
    },
    get isStatic() {
      return ae();
    },
    set isStatic(L = !1) {
      ae(L), m();
    },
    get enabled() {
      return J();
    },
    set enabled(L) {
      J(L), m();
    }
  };
  return wh(t, ce(
    {
      get popper() {
        return r();
      },
      get onEscapeKeydown() {
        return n();
      },
      get escapeKeydownBehavior() {
        return s();
      },
      get preventOverflowTextSelection() {
        return o();
      },
      get id() {
        return i();
      },
      get onPointerDown() {
        return a();
      },
      get onPointerUp() {
        return l();
      },
      get side() {
        return u();
      },
      get sideOffset() {
        return c();
      },
      get align() {
        return f();
      },
      get alignOffset() {
        return p();
      },
      get arrowPadding() {
        return _();
      },
      get avoidCollisions() {
        return b();
      },
      get collisionBoundary() {
        return g();
      },
      get collisionPadding() {
        return h();
      },
      get sticky() {
        return y();
      },
      get hideWhenDetached() {
        return S();
      },
      get updatePositionStrategy() {
        return x();
      },
      get strategy() {
        return P();
      },
      get dir() {
        return w();
      },
      get preventScroll() {
        return O();
      },
      get wrapperId() {
        return k();
      },
      get style() {
        return $();
      },
      get onPlaced() {
        return T();
      },
      get customAnchor() {
        return X();
      },
      get isStatic() {
        return ae();
      },
      get enabled() {
        return J();
      },
      get onInteractOutside() {
        return E();
      },
      get onCloseAutoFocus() {
        return M();
      },
      get onOpenAutoFocus() {
        return R();
      },
      get interactOutsideBehavior() {
        return B();
      },
      get loop() {
        return F();
      },
      get trapFocus() {
        return Z();
      },
      get isValidEvent() {
        return Y();
      },
      get onFocusOutside() {
        return U();
      }
    },
    () => j,
    { forceMount: !0 }
  )), W(ee);
}
K(
  xh,
  {
    popper: {},
    onEscapeKeydown: {},
    escapeKeydownBehavior: {},
    preventOverflowTextSelection: {},
    id: {},
    onPointerDown: {},
    onPointerUp: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    arrowPadding: {},
    avoidCollisions: {},
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: {},
    updatePositionStrategy: {},
    strategy: {},
    dir: {},
    preventScroll: {},
    wrapperId: {},
    style: {},
    onPlaced: {},
    onInteractOutside: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onFocusOutside: {},
    interactOutsideBehavior: {},
    loop: {},
    trapFocus: {},
    isValidEvent: {},
    customAnchor: {},
    isStatic: {},
    enabled: {}
  },
  [],
  [],
  { mode: "open" }
);
var OI = /* @__PURE__ */ ne("<div><div><!></div></div>"), CI = /* @__PURE__ */ ne("<div><div><!></div></div>");
function Mw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "forceMount", 7, !1), i = v(e, "side", 7, "bottom"), a = v(e, "onInteractOutside", 7, _e), l = v(e, "onEscapeKeydown", 7, _e), u = v(e, "children", 7), c = v(e, "child", 7), f = v(e, "preventScroll", 7, !1), p = v(e, "style", 7), _ = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "forceMount",
    "side",
    "onInteractOutside",
    "onEscapeKeydown",
    "children",
    "child",
    "preventScroll",
    "style"
  ]);
  const b = dh.create({
    id: z(() => n()),
    ref: z(() => s(), (w) => s(w)),
    onInteractOutside: z(() => a()),
    onEscapeKeydown: z(() => l())
  }), g = /* @__PURE__ */ C(() => Ce(_, b.props));
  var h = {
    get id() {
      return n();
    },
    set id(w = me(r)) {
      n(w), m();
    },
    get ref() {
      return s();
    },
    set ref(w = null) {
      s(w), m();
    },
    get forceMount() {
      return o();
    },
    set forceMount(w = !1) {
      o(w), m();
    },
    get side() {
      return i();
    },
    set side(w = "bottom") {
      i(w), m();
    },
    get onInteractOutside() {
      return a();
    },
    set onInteractOutside(w = _e) {
      a(w), m();
    },
    get onEscapeKeydown() {
      return l();
    },
    set onEscapeKeydown(w = _e) {
      l(w), m();
    },
    get children() {
      return u();
    },
    set children(w) {
      u(w), m();
    },
    get child() {
      return c();
    },
    set child(w) {
      c(w), m();
    },
    get preventScroll() {
      return f();
    },
    set preventScroll(w = !1) {
      f(w), m();
    },
    get style() {
      return p();
    },
    set style(w) {
      p(w), m();
    }
  }, y = I(), S = D(y);
  {
    var x = (w) => {
      xh(w, ce(() => d(g), () => b.popperProps, {
        get ref() {
          return b.opts.ref;
        },
        get side() {
          return i();
        },
        get enabled() {
          return b.root.opts.open.current;
        },
        get id() {
          return n();
        },
        get preventScroll() {
          return f();
        },
        forceMount: !0,
        get shouldRender() {
          return b.shouldRender;
        },
        popper: (k, $) => {
          let T = () => $?.().props, E = () => $?.().wrapperProps;
          const M = /* @__PURE__ */ C(() => Ce(T(), { style: b.props.style }, { style: p() }));
          var R = I(), U = D(R);
          {
            var B = (Z) => {
              var Y = I(), X = D(Y);
              {
                let ae = /* @__PURE__ */ C(() => ({
                  props: d(M),
                  wrapperProps: E(),
                  ...b.snippetProps
                }));
                te(X, c, () => d(ae));
              }
              A(Z, Y);
            }, F = (Z) => {
              var Y = OI();
              ve(Y, () => ({ ...E() }));
              var X = he(Y);
              ve(X, () => ({ ...d(M) }));
              var ae = he(X);
              te(ae, () => u() ?? ge), de(X), de(Y), A(Z, Y);
            };
            ue(U, (Z) => {
              c() ? Z(B) : Z(F, !1);
            });
          }
          A(k, R);
        },
        $$slots: { popper: !0 }
      }));
    }, P = (w) => {
      var O = I(), k = D(O);
      {
        var $ = (T) => {
          Sh(T, ce(() => d(g), () => b.popperProps, {
            get ref() {
              return b.opts.ref;
            },
            get side() {
              return i();
            },
            get open() {
              return b.root.opts.open.current;
            },
            get id() {
              return n();
            },
            get preventScroll() {
              return f();
            },
            forceMount: !1,
            get shouldRender() {
              return b.shouldRender;
            },
            popper: (M, R) => {
              let U = () => R?.().props, B = () => R?.().wrapperProps;
              const F = /* @__PURE__ */ C(() => Ce(U(), { style: b.props.style }, { style: p() }));
              var Z = I(), Y = D(Z);
              {
                var X = (J) => {
                  var j = I(), ee = D(j);
                  {
                    let L = /* @__PURE__ */ C(() => ({
                      props: d(F),
                      wrapperProps: B(),
                      ...b.snippetProps
                    }));
                    te(ee, c, () => d(L));
                  }
                  A(J, j);
                }, ae = (J) => {
                  var j = CI();
                  ve(j, () => ({ ...B() }));
                  var ee = he(j);
                  ve(ee, () => ({ ...d(F) }));
                  var L = he(ee);
                  te(L, () => u() ?? ge), de(ee), de(j), A(J, j);
                };
                ue(Y, (J) => {
                  c() ? J(X) : J(ae, !1);
                });
              }
              A(M, Z);
            },
            $$slots: { popper: !0 }
          }));
        };
        ue(
          k,
          (T) => {
            o() || T($);
          },
          !0
        );
      }
      A(w, O);
    };
    ue(S, (w) => {
      o() ? w(x) : w(P, !1);
    });
  }
  return A(t, y), W(h);
}
K(
  Mw,
  {
    id: {},
    ref: {},
    forceMount: {},
    side: {},
    onInteractOutside: {},
    onEscapeKeydown: {},
    children: {},
    child: {},
    preventScroll: {},
    style: {}
  },
  [],
  [],
  { mode: "open" }
);
function hu(t, e) {
  H(e, !0);
  let r = v(e, "mounted", 15, !1), n = v(e, "onMountedChange", 7, _e);
  Zd(() => (r(!0), n()(!0), () => {
    r(!1), n()(!1);
  }));
  var s = {
    get mounted() {
      return r();
    },
    set mounted(o = !1) {
      r(o), m();
    },
    get onMountedChange() {
      return n();
    },
    set onMountedChange(o = _e) {
      n(o), m();
    }
  };
  return W(s);
}
K(hu, { mounted: {}, onMountedChange: {} }, [], [], { mode: "open" });
var kI = /* @__PURE__ */ ne("<div><!></div>"), $I = /* @__PURE__ */ ne("<!> <!>", 1);
function Iw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7), i = v(e, "label", 23, o), a = v(e, "disabled", 7, !1), l = v(e, "children", 7), u = v(e, "child", 7), c = v(e, "onHighlight", 7, _e), f = v(e, "onUnhighlight", 7, _e), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "label",
    "disabled",
    "children",
    "child",
    "onHighlight",
    "onUnhighlight"
  ]);
  const _ = fh.create({
    id: z(() => n()),
    ref: z(() => s(), (w) => s(w)),
    value: z(() => o()),
    disabled: z(() => a()),
    label: z(() => i()),
    onHighlight: z(() => c()),
    onUnhighlight: z(() => f())
  }), b = /* @__PURE__ */ C(() => Ce(p, _.props));
  var g = {
    get id() {
      return n();
    },
    set id(w = me(r)) {
      n(w), m();
    },
    get ref() {
      return s();
    },
    set ref(w = null) {
      s(w), m();
    },
    get value() {
      return o();
    },
    set value(w) {
      o(w), m();
    },
    get label() {
      return i();
    },
    set label(w = o) {
      i(w), m();
    },
    get disabled() {
      return a();
    },
    set disabled(w = !1) {
      a(w), m();
    },
    get children() {
      return l();
    },
    set children(w) {
      l(w), m();
    },
    get child() {
      return u();
    },
    set child(w) {
      u(w), m();
    },
    get onHighlight() {
      return c();
    },
    set onHighlight(w = _e) {
      c(w), m();
    },
    get onUnhighlight() {
      return f();
    },
    set onUnhighlight(w = _e) {
      f(w), m();
    }
  }, h = $I(), y = D(h);
  {
    var S = (w) => {
      var O = I(), k = D(O);
      {
        let $ = /* @__PURE__ */ C(() => ({ props: d(b), ..._.snippetProps }));
        te(k, u, () => d($));
      }
      A(w, O);
    }, x = (w) => {
      var O = kI();
      ve(O, () => ({ ...d(b) }));
      var k = he(O);
      te(k, () => l() ?? ge, () => _.snippetProps), de(O), A(w, O);
    };
    ue(y, (w) => {
      u() ? w(S) : w(x, !1);
    });
  }
  var P = be(y, 2);
  return hu(P, {
    get mounted() {
      return _.mounted;
    },
    set mounted(w) {
      _.mounted = w;
    }
  }), A(t, h), W(g);
}
K(
  Iw,
  {
    id: {},
    ref: {},
    value: {},
    label: {},
    disabled: {},
    children: {},
    child: {},
    onHighlight: {},
    onUnhighlight: {}
  },
  [],
  [],
  { mode: "open" }
);
var AI = /* @__PURE__ */ ne("<div><!></div>");
function Nw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = hh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = AI();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => o() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      i() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Nw, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var EI = /* @__PURE__ */ ne("<div><!></div>");
function Fw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children"
  ]);
  const l = gh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get child() {
      return o();
    },
    set child(g) {
      o(g), m();
    },
    get children() {
      return i();
    },
    set children(g) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, o, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = EI();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => i() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      o() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Fw, { id: {}, ref: {}, child: {}, children: {} }, [], [], { mode: "open" });
var TI = /* @__PURE__ */ ne("<div><!></div>");
const DI = {
  hash: "svelte-18zq11a",
  code: `
	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */[data-select-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport]::-webkit-scrollbar {display:none !important;}[data-select-viewport]::-webkit-scrollbar {display:none !important;}`
};
function Rw(t, e) {
  const r = Te();
  H(e, !0), NP(t, DI);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = mh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = TI();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => o() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      i() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Rw, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var MI = /* @__PURE__ */ ne("<div><!></div>"), II = /* @__PURE__ */ ne("<!> <!>", 1);
function Vw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "delay", 7, () => 50), i = v(e, "child", 7), a = v(e, "children", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const u = vh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g)),
    delay: z(() => o())
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get delay() {
      return o();
    },
    set delay(g = () => 50) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    },
    get children() {
      return a();
    },
    set children(g) {
      a(g), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (g) => {
      var h = II(), y = D(h);
      hu(y, {
        get mounted() {
          return u.scrollButtonState.mounted;
        },
        set mounted(w) {
          u.scrollButtonState.mounted = w;
        }
      });
      var S = be(y, 2);
      {
        var x = (w) => {
          var O = I(), k = D(O);
          te(k, i, () => ({ props: l })), A(w, O);
        }, P = (w) => {
          var O = MI();
          ve(O, () => ({ ...d(c) }));
          var k = he(O);
          te(k, () => a() ?? ge), de(O), A(w, O);
        };
        ue(S, (w) => {
          i() ? w(x) : w(P, !1);
        });
      }
      A(g, h);
    };
    ue(_, (g) => {
      u.canScrollDown && g(b);
    });
  }
  return A(t, p), W(f);
}
K(Vw, { id: {}, ref: {}, delay: {}, child: {}, children: {} }, [], [], { mode: "open" });
var NI = /* @__PURE__ */ ne("<div><!></div>"), FI = /* @__PURE__ */ ne("<!> <!>", 1);
function Lw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "delay", 7, () => 50), i = v(e, "child", 7), a = v(e, "children", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const u = yh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g)),
    delay: z(() => o())
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get delay() {
      return o();
    },
    set delay(g = () => 50) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    },
    get children() {
      return a();
    },
    set children(g) {
      a(g), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (g) => {
      var h = FI(), y = D(h);
      hu(y, {
        get mounted() {
          return u.scrollButtonState.mounted;
        },
        set mounted(w) {
          u.scrollButtonState.mounted = w;
        }
      });
      var S = be(y, 2);
      {
        var x = (w) => {
          var O = I(), k = D(O);
          te(k, i, () => ({ props: l })), A(w, O);
        }, P = (w) => {
          var O = NI();
          ve(O, () => ({ ...d(c) }));
          var k = he(O);
          te(k, () => a() ?? ge), de(O), A(w, O);
        };
        ue(S, (w) => {
          i() ? w(x) : w(P, !1);
        });
      }
      A(g, h);
    };
    ue(_, (g) => {
      u.canScrollUp && g(b);
    });
  }
  return A(t, p), W(f);
}
K(Lw, { id: {}, ref: {}, delay: {}, child: {}, children: {} }, [], [], { mode: "open" });
function RI(t, e) {
  let r = t.nextElementSibling;
  for (; r; ) {
    if (r.matches(e))
      return r;
    r = r.nextElementSibling;
  }
}
function VI(t, e) {
  let r = t.previousElementSibling;
  for (; r; ) {
    if (r.matches(e))
      return r;
    r = r.previousElementSibling;
  }
}
function jw(t) {
  if (typeof CSS < "u" && typeof CSS.escape == "function")
    return CSS.escape(t);
  const e = t.length;
  let r = -1, n, s = "";
  const o = t.charCodeAt(0);
  if (e === 1 && o === 45)
    return "\\" + t;
  for (; ++r < e; ) {
    if (n = t.charCodeAt(r), n === 0) {
      s += "ï¿½";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is U+007F
      n >= 1 && n <= 31 || n === 127 || // If the character is the first character and is in the range [0-9] (U+0030 to U+0039)
      r === 0 && n >= 48 && n <= 57 || // If the character is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D)
      r === 1 && n >= 48 && n <= 57 && o === 45
    ) {
      s += "\\" + n.toString(16) + " ";
      continue;
    }
    if (n >= 128 || n === 45 || n === 95 || n >= 48 && n <= 57 || n >= 65 && n <= 90 || n >= 97 && n <= 122) {
      s += t.charAt(r);
      continue;
    }
    s += "\\" + t.charAt(r);
  }
  return s;
}
const ws = "data-value", Ft = rr({
  component: "command",
  parts: [
    "root",
    "list",
    "input",
    "separator",
    "loading",
    "empty",
    "group",
    "group-items",
    "group-heading",
    "item",
    "viewport",
    "input-label"
  ]
}), Qs = Ft.selector("group"), sc = Ft.selector("group-items"), Um = Ft.selector("group-heading"), Bw = Ft.selector("item"), oc = `${Ft.selector("item")}:not([aria-disabled="true"])`, cs = new ht("Command.Root"), LI = new ht("Command.List"), Ci = new ht("Command.Group"), Km = {
  search: "",
  value: "",
  filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() }
};
class Ph {
  static create(e) {
    return cs.set(new Ph(e));
  }
  opts;
  attachment;
  #e = !1;
  #t = !0;
  sortAfterTick = !1;
  sortAndFilterAfterTick = !1;
  allItems = /* @__PURE__ */ new Set();
  allGroups = /* @__PURE__ */ new Map();
  allIds = /* @__PURE__ */ new Map();
  #r = (
    // attempt to prevent the harsh delay when user is typing fast
    /* @__PURE__ */ xe(0)
  );
  get key() {
    return d(this.#r);
  }
  set key(e) {
    q(this.#r, e, !0);
  }
  #n = /* @__PURE__ */ xe(null);
  get viewportNode() {
    return d(this.#n);
  }
  set viewportNode(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(null);
  get inputNode() {
    return d(this.#s);
  }
  set inputNode(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(null);
  get labelNode() {
    return d(this.#o);
  }
  set labelNode(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(Km);
  get commandState() {
    return d(this.#i);
  }
  set commandState(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ xe(Pt(Km));
  get _commandState() {
    return d(this.#a);
  }
  set _commandState(e) {
    q(this.#a, e, !0);
  }
  #u() {
    return xo(this._commandState);
  }
  #l() {
    this.#e || (this.#e = !0, Jt(() => {
      this.#e = !1;
      const e = this.#u();
      !Object.is(this.commandState, e) && (this.commandState = e, this.opts.onStateChange?.current?.(e));
    }));
  }
  setState(e, r, n) {
    Object.is(this._commandState[e], r) || (this._commandState[e] = r, e === "search" ? (this.#p(), this.#d()) : e === "value" && (n || this.#h()), this.#l());
  }
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref);
    const r = { ...this._commandState, value: this.opts.value.current ?? "" };
    this._commandState = r, this.commandState = r, this.onkeydown = this.onkeydown.bind(this);
  }
  /**
   * Calculates score for an item based on search text and keywords.
   * Higher score = better match.
   *
   * @param value - Item's display text
   * @param keywords - Optional keywords to boost scoring
   * @returns Score from 0-1, where 0 = no match
   */
  #c(e, r) {
    const n = this.opts.filter.current ?? Yc;
    return e ? n(e, this._commandState.search, r) : 0;
  }
  /**
   * Sorts items and groups based on search scores.
   * Groups are sorted by their highest scoring item.
   * When no search active, selects first item.
   */
  #d() {
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      !this._commandState.value || !this.#t ? this.#g() : this.#t && this._commandState.value && this.#m();
      return;
    }
    const e = this._commandState.filtered.items, r = [];
    for (const i of this._commandState.filtered.groups) {
      const a = this.allGroups.get(i);
      let l = 0;
      if (!a) {
        r.push([i, l]);
        continue;
      }
      for (const u of a) {
        const c = e.get(u);
        l = Math.max(c ?? 0, l);
      }
      r.push([i, l]);
    }
    const n = this.viewportNode, s = this.getValidItems().sort((i, a) => {
      const l = i.getAttribute("data-value"), u = a.getAttribute("data-value"), c = e.get(l) ?? 0;
      return (e.get(u) ?? 0) - c;
    });
    for (const i of s) {
      const a = i.closest(sc);
      if (a) {
        const l = i.parentElement === a ? i : i.closest(`${sc} > *`);
        l && a.appendChild(l);
      } else {
        const l = i.parentElement === n ? i : i.closest(`${sc} > *`);
        l && n?.appendChild(l);
      }
    }
    const o = r.sort((i, a) => a[1] - i[1]);
    for (const i of o) {
      const a = n?.querySelector(`${Qs}[${ws}="${jw(i[0])}"]`);
      a?.parentElement?.appendChild(a);
    }
    this.#g();
  }
  /**
   * Sets current value and triggers re-render if cleared.
   *
   * @param value - New value to set
   */
  setValue(e, r) {
    e !== this.opts.value.current && e === "" && Jt(() => {
      this.key++;
    }), this.setState("value", e, r), this.opts.value.current = e;
  }
  /**
   * Selects first non-disabled item on next tick.
   */
  #g() {
    Jt(() => {
      const r = this.getValidItems().find((s) => s.getAttribute("aria-disabled") !== "true")?.getAttribute(ws), n = this.#t && this.opts.disableInitialScroll.current;
      this.setValue(r ?? "", n), this.#t = !1;
    });
  }
  /**
   * Scrolls the initial value into view if it exists and is not the first item.
   * Called during initial mount when a value is provided.
   */
  #m() {
    Jt(() => {
      this.opts.disableInitialScroll.current || this.#h(), this.#t = !1;
    });
  }
  /**
   * Updates filtered items/groups based on search.
   * Recalculates scores and filtered count.
   */
  #p() {
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
      this._commandState.filtered.count = this.allItems.size;
      return;
    }
    this._commandState.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (const r of this.allItems) {
      const n = this.allIds.get(r)?.value ?? "", s = this.allIds.get(r)?.keywords ?? [], o = this.#c(n, s);
      this._commandState.filtered.items.set(r, o), o > 0 && e++;
    }
    for (const [r, n] of this.allGroups)
      for (const s of n) {
        const o = this._commandState.filtered.items.get(s);
        if (o && o > 0) {
          this._commandState.filtered.groups.add(r);
          break;
        }
      }
    this._commandState.filtered.count = e;
  }
  /**
   * Gets all non-disabled, visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getValidItems() {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(oc)).filter((n) => !!n) : [];
  }
  /**
   * Gets all visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getVisibleItems() {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Bw)).filter((n) => !!n) : [];
  }
  /** Returns all visible items in a matrix structure
   *
   * @remarks Returns empty if the command isn't configured as a grid
   *
   * @returns
   */
  get itemsGrid() {
    if (!this.isGrid) return [];
    const e = this.opts.columns.current ?? 1, r = this.getVisibleItems(), n = [[]];
    let s = r[0]?.getAttribute("data-group"), o = 0, i = 0;
    for (let a = 0; a < r.length; a++) {
      const l = r[a], u = l?.getAttribute("data-group");
      s !== u ? (s = u, o = 1, i++, n.push([{ index: a, firstRowOfGroup: !0, ref: l }])) : (o++, o > e && (i++, o = 1, n.push([])), n[i]?.push({
        index: a,
        firstRowOfGroup: n[i]?.[0]?.firstRowOfGroup ?? a === 0,
        ref: l
      }));
    }
    return n;
  }
  /**
   * Gets currently selected command item.
   *
   * @returns Selected element or undefined
   */
  #f() {
    const e = this.opts.ref.current;
    if (!e) return;
    const r = e.querySelector(`${oc}[data-selected]`);
    if (r)
      return r;
  }
  /**
   * Scrolls selected item into view.
   * Special handling for first items in groups.
   */
  #h() {
    Jt(() => {
      const e = this.#f();
      if (!e) return;
      const r = e.parentElement?.parentElement;
      if (r) {
        if (this.isGrid) {
          const n = this.#b(e);
          if (e.scrollIntoView({ block: "nearest" }), n) {
            e?.closest(Qs)?.querySelector(Um)?.scrollIntoView({ block: "nearest" });
            return;
          }
        } else {
          const n = rT(r);
          if (n && n.dataset?.value === e.dataset?.value) {
            e?.closest(Qs)?.querySelector(Um)?.scrollIntoView({ block: "nearest" });
            return;
          }
        }
        e.scrollIntoView({ block: "nearest" });
      }
    });
  }
  #b(e) {
    const r = this.itemsGrid;
    if (r.length === 0) return !1;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s !== void 0)
        for (let o = 0; o < s.length; o++) {
          const i = s[o];
          if (!(i === void 0 || i.ref !== e))
            return i.firstRowOfGroup;
        }
    }
    return !1;
  }
  /**
   * Sets selection to item at specified index in valid items array.
   * If index is out of bounds, does nothing.
   *
   * @param index - Zero-based index of item to select
   * @remarks
   * Uses `getValidItems()` to get selectable items, filtering out disabled/hidden ones.
   * Access valid items directly via `getValidItems()` to check bounds before calling.
   *
   * @example
   * // get valid items length for bounds check
   * const items = getValidItems()
   * if (index < items.length) {
   *   updateSelectedToIndex(index)
   * }
   */
  updateSelectedToIndex(e) {
    const r = this.getValidItems()[e];
    r && this.setValue(r.getAttribute(ws) ?? "");
  }
  /**
   * Updates selected item by moving up/down relative to current selection.
   * Handles wrapping when loop option is enabled.
   *
   * @param change - Direction to move: 1 for next item, -1 for previous item
   * @remarks
   * The loop behavior wraps:
   * - From last item to first when moving next
   * - From first item to last when moving previous
   *
   * Uses `getValidItems()` to get all selectable items, which filters out disabled/hidden items.
   * You can call `getValidItems()` directly to get the current valid items array.
   *
   * @example
   * // select next item
   * updateSelectedByItem(1)
   *
   * // get all valid items
   * const items = getValidItems()
   */
  updateSelectedByItem(e) {
    const r = this.#f(), n = this.getValidItems(), s = n.findIndex((i) => i === r);
    let o = n[s + e];
    this.opts.loop.current && (o = s + e < 0 ? n[n.length - 1] : s + e === n.length ? n[0] : n[s + e]), o && this.setValue(o.getAttribute(ws) ?? "");
  }
  /**
   * Moves selection to the first valid item in the next/previous group.
   * If no group is found, falls back to selecting the next/previous item globally.
   *
   * @param change - Direction to move: 1 for next group, -1 for previous group
   * @example
   * // move to first item in next group
   * updateSelectedByGroup(1)
   *
   * // move to first item in previous group
   * updateSelectedByGroup(-1)
   */
  updateSelectedByGroup(e) {
    let n = this.#f()?.closest(Qs), s;
    for (; n && !s; )
      n = e > 0 ? RI(n, Qs) : VI(n, Qs), s = n?.querySelector(oc);
    s ? this.setValue(s.getAttribute(ws) ?? "") : this.updateSelectedByItem(e);
  }
  /**
   * Maps item id to display value and search keywords.
   * Returns cleanup function to remove mapping.
   *
   * @param id - Unique item identifier
   * @param value - Display text
   * @param keywords - Optional search boost terms
   * @returns Cleanup function
   */
  registerValue(e, r) {
    return e && e === this.allIds.get(e)?.value || this.allIds.set(e, { value: e, keywords: r }), this._commandState.filtered.items.set(e, this.#c(e, r)), this.sortAfterTick || (this.sortAfterTick = !0, Jt(() => {
      this.#d(), this.sortAfterTick = !1;
    })), () => {
      this.allIds.delete(e);
    };
  }
  /**
   * Registers item in command list and its group.
   * Handles filtering, sorting and selection updates.
   *
   * @param id - Item identifier
   * @param groupId - Optional group to add item to
   * @returns Cleanup function that handles selection
   */
  registerItem(e, r) {
    return this.allItems.add(e), r && (this.allGroups.has(r) ? this.allGroups.get(r).add(e) : this.allGroups.set(r, /* @__PURE__ */ new Set([e]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Jt(() => {
      this.#p(), this.#d(), this.sortAndFilterAfterTick = !1;
    })), this.#l(), () => {
      const n = this.#f();
      this.allItems.delete(e), this.commandState.filtered.items.delete(e), this.#p(), n?.getAttribute("id") === e && this.#g(), this.#l();
    };
  }
  /**
   * Creates empty group if not exists.
   *
   * @param id - Group identifier
   * @returns Cleanup function
   */
  registerGroup(e) {
    return this.allGroups.has(e) || this.allGroups.set(e, /* @__PURE__ */ new Set()), () => {
      this.allIds.delete(e), this.allGroups.delete(e);
    };
  }
  get isGrid() {
    return this.opts.columns.current !== null;
  }
  /**
   * Selects last valid item.
   */
  #y() {
    return this.updateSelectedToIndex(this.getValidItems().length - 1);
  }
  /**
   * Handles next item selection:
   * - Meta: Jump to last
   * - Alt: Next group
   * - Default: Next item
   *
   * @param e - Keyboard event
   */
  #v(e) {
    e.preventDefault(), e.metaKey ? this.#y() : e.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1);
  }
  #S(e) {
    this.opts.columns.current !== null && (e.preventDefault(), e.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(this.#x(e)));
  }
  #w(e, r) {
    if (r.length === 0) return null;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s !== void 0)
        for (let o = 0; o < s.length; o++) {
          const i = s[o];
          if (!(i === void 0 || i.ref !== e))
            return { columnIndex: o, rowIndex: n };
        }
    }
    return null;
  }
  #x(e) {
    const r = this.itemsGrid, n = this.#f();
    if (!n) return 0;
    const s = this.#w(n, r);
    if (!s) return 0;
    let o = null;
    const i = e.altKey ? 1 : 0;
    if (e.altKey && s.rowIndex === r.length - 2 && !this.opts.loop.current)
      o = this.#_({
        start: r.length - 1,
        end: r.length,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    else if (s.rowIndex === r.length - 1) {
      if (!this.opts.loop.current) return 0;
      o = this.#_({
        start: 0 + i,
        end: s.rowIndex,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    } else
      o = this.#_({
        start: s.rowIndex + 1 + i,
        end: r.length,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }), o === null && this.opts.loop.current && (o = this.#_({
        start: 0,
        end: s.rowIndex,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }));
    return this.#C(n, o);
  }
  /** Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   *
   * @param param0
   * @returns
   */
  #_({ start: e, end: r, grid: n, expectedColumnIndex: s }) {
    let o = null;
    for (let i = e; i < r; i++) {
      const a = n[i];
      if (o = a[s]?.ref ?? null, o !== null && ja(o)) {
        o = null;
        continue;
      }
      if (o === null)
        for (let l = a.length - 1; l >= 0; l--) {
          const u = a[a.length - 1];
          if (!(u === void 0 || ja(u.ref))) {
            o = u.ref;
            break;
          }
        }
      break;
    }
    return o;
  }
  #C(e, r) {
    if (r === null) return 0;
    const n = this.getValidItems(), s = n.findIndex((i) => i === e);
    return n.findIndex((i) => i === r) - s;
  }
  #k(e) {
    this.opts.columns.current !== null && (e.preventDefault(), e.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(this.#A(e)));
  }
  #A(e) {
    const r = this.itemsGrid, n = this.#f();
    if (n === void 0) return 0;
    const s = this.#w(n, r);
    if (s === null) return 0;
    let o = null;
    const i = e.altKey ? 1 : 0;
    if (e.altKey && s.rowIndex === 1 && this.opts.loop.current === !1)
      o = this.#P({
        start: 0,
        end: 0,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    else if (s.rowIndex === 0) {
      if (this.opts.loop.current === !1) return 0;
      o = this.#P({
        start: r.length - 1 - i,
        end: s.rowIndex + 1,
        expectedColumnIndex: s.columnIndex,
        grid: r
      });
    } else
      o = this.#P({
        start: s.rowIndex - 1 - i,
        end: 0,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }), o === null && this.opts.loop.current && (o = this.#P({
        start: r.length - 1,
        end: s.rowIndex + 1,
        expectedColumnIndex: s.columnIndex,
        grid: r
      }));
    return this.#C(n, o);
  }
  /**
   * Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   */
  #P({ start: e, end: r, grid: n, expectedColumnIndex: s }) {
    let o = null;
    for (let i = e; i >= r; i--) {
      const a = n[i];
      if (a !== void 0) {
        if (o = a[s]?.ref ?? null, o !== null && ja(o)) {
          o = null;
          continue;
        }
        if (o === null)
          for (let l = a.length - 1; l >= 0; l--) {
            const u = a[a.length - 1];
            if (!(u === void 0 || ja(u.ref))) {
              o = u.ref;
              break;
            }
          }
        break;
      }
    }
    return o;
  }
  /**
   * Handles previous item selection:
   * - Meta: Jump to first
   * - Alt: Previous group
   * - Default: Previous item
   *
   * @param e - Keyboard event
   */
  #O(e) {
    e.preventDefault(), e.metaKey ? this.updateSelectedToIndex(0) : e.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1);
  }
  onkeydown(e) {
    const r = this.opts.vimBindings.current && e.ctrlKey;
    switch (e.key) {
      case R2:
      case V2: {
        r && (this.isGrid ? this.#S(e) : this.#v(e));
        break;
      }
      case B2: {
        r && this.isGrid && this.#v(e);
        break;
      }
      case cr:
        this.isGrid ? this.#S(e) : this.#v(e);
        break;
      case us:
        if (!this.isGrid) break;
        this.#v(e);
        break;
      case F2:
      case L2: {
        r && (this.isGrid ? this.#k(e) : this.#O(e));
        break;
      }
      case j2: {
        r && this.isGrid && this.#O(e);
        break;
      }
      case Qt:
        this.isGrid ? this.#k(e) : this.#O(e);
        break;
      case ls:
        if (!this.isGrid) break;
        this.#O(e);
        break;
      case Vo:
        e.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case Ro:
        e.preventDefault(), this.#y();
        break;
      case Vr:
        if (!e.isComposing && e.keyCode !== 229) {
          e.preventDefault();
          const n = this.#f();
          n && n?.click();
        }
    }
  }
  #$ = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "application",
    [Ft.root]: "",
    tabindex: -1,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#$);
  }
  set props(e) {
    q(this.#$, e);
  }
}
function ja(t) {
  return t.getAttribute("aria-disabled") === "true";
}
class Oh {
  static create(e) {
    return new Oh(e, cs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => this.root._commandState.filtered.count === 0 && this.#t === !1 || this.opts.forceMount.current);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  #t = !0;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref), Co(() => {
      this.#t = !1;
    });
  }
  #r = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "presentation",
    [Ft.empty]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
class Ch {
  static create(e) {
    return Ci.set(new Ch(e, cs.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue));
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ xe(null);
  get headingNode() {
    return d(this.#t);
  }
  set headingNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe("");
  get trueValue() {
    return d(this.#r);
  }
  set trueValue(e) {
    q(this.#r, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref), this.trueValue = e.value.current ?? e.id.current, Ne(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Ze(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)));
  }
  #n = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "presentation",
    hidden: this.shouldRender ? void 0 : !0,
    "data-value": this.trueValue,
    [Ft.group]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
}
class kh {
  static create(e) {
    return new kh(e, Ci.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Ee(this.opts.ref, (n) => this.group.headingNode = n);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [Ft["group-heading"]]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class $h {
  static create(e) {
    return new $h(e, Ci.get());
  }
  opts;
  group;
  attachment;
  constructor(e, r) {
    this.opts = e, this.group = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "group",
    [Ft["group-items"]]: "",
    "aria-labelledby": this.group.headingNode?.id ?? void 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Ah {
  static create(e) {
    return new Ah(e, cs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => {
    const e = this.root.viewportNode?.querySelector(`${Bw}[${ws}="${jw(this.root.opts.value.current)}"]`);
    if (e != null)
      return e.getAttribute("id") ?? void 0;
  });
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => this.root.inputNode = n), Ne(() => this.opts.ref.current, () => {
      const n = this.opts.ref.current;
      n && this.opts.autofocus.current && Qd(10, () => n.focus());
    }), Ne(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current);
    });
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    type: "text",
    [Ft.input]: "",
    autocomplete: "off",
    autocorrect: "off",
    spellcheck: !1,
    "aria-autocomplete": "list",
    role: "combobox",
    "aria-expanded": at(!0),
    "aria-controls": this.root.viewportNode?.id ?? void 0,
    "aria-labelledby": this.root.labelNode?.id ?? void 0,
    "aria-activedescendant": d(this.#e),
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class gu {
  static create(e) {
    const r = Ci.getOr(null);
    return new gu({ ...e, group: r }, cs.get());
  }
  opts;
  root;
  attachment;
  #e = null;
  #t = /* @__PURE__ */ C(() => this.opts.forceMount.current || this.#e?.opts.forceMount.current === !0);
  #r = /* @__PURE__ */ C(() => {
    if (this.opts.ref.current, d(this.#t) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search)
      return !0;
    const e = this.root.commandState.filtered.items.get(this.trueValue);
    return e === void 0 ? !1 : e > 0;
  });
  get shouldRender() {
    return d(this.#r);
  }
  set shouldRender(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => this.root.opts.value.current === this.trueValue && this.trueValue !== "");
  get isSelected() {
    return d(this.#n);
  }
  set isSelected(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ xe("");
  get trueValue() {
    return d(this.#s);
  }
  set trueValue(e) {
    q(this.#s, e, !0);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.#e = Ci.getOr(null), this.trueValue = e.value.current, this.attachment = Ee(this.opts.ref), Ne(
      [
        () => this.trueValue,
        () => this.#e?.trueValue,
        () => this.opts.forceMount.current
      ],
      () => {
        if (!(this.opts.forceMount.current || !this.trueValue))
          return this.root.registerItem(this.trueValue, this.#e?.trueValue);
      }
    ), Ne([() => this.opts.value.current, () => this.opts.ref.current], () => {
      this.opts.value.current ? this.trueValue = this.opts.value.current : this.opts.ref.current?.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, e.keywords.current.map((n) => n.trim())), this.opts.ref.current?.setAttribute(ws, this.trueValue));
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this);
  }
  #o() {
    this.opts.disabled.current || (this.#i(), this.opts.onSelect?.current());
  }
  #i() {
    this.opts.disabled.current || this.root.setValue(this.trueValue, !0);
  }
  onpointermove(e) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || this.#i();
  }
  onclick(e) {
    this.opts.disabled.current || this.#o();
  }
  #a = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "aria-disabled": at(this.opts.disabled.current),
    "aria-selected": at(this.isSelected),
    "data-disabled": Fe(this.opts.disabled.current),
    "data-selected": Fe(this.isSelected),
    "data-value": this.trueValue,
    "data-group": this.#e?.trueValue,
    [Ft.item]: "",
    role: "option",
    onpointermove: this.onpointermove,
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
class Eh {
  static create(e) {
    return new Eh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "progressbar",
    "aria-valuenow": this.opts.progress.current,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-label": "Loading...",
    [Ft.loading]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Th {
  static create(e) {
    return new Th(e, cs.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => !this.root._commandState.search || this.opts.forceMount.current);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    // role="separator" cannot belong to a role="listbox"
    "aria-hidden": "true",
    [Ft.separator]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Dh {
  static create(e) {
    return LI.set(new Dh(e, cs.get()));
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "listbox",
    "aria-label": this.opts.ariaLabel.current,
    [Ft.list]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class Mh {
  static create(e) {
    return new Mh(e, cs.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => this.root.labelNode = n);
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [Ft["input-label"]]: "",
    for: this.opts.for?.current,
    style: H_,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var jI = /* @__PURE__ */ ne("<label><!></label>");
function zw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children"
  ]);
  const a = Mh.create({
    id: z(() => n()),
    ref: z(() => s(), (p) => s(p))
  }), l = /* @__PURE__ */ C(() => Ce(i, a.props));
  var u = {
    get id() {
      return n();
    },
    set id(p = me(r)) {
      n(p), m();
    },
    get ref() {
      return s();
    },
    set ref(p = null) {
      s(p), m();
    },
    get children() {
      return o();
    },
    set children(p) {
      o(p), m();
    }
  }, c = jI();
  ve(c, () => ({ ...d(l) }));
  var f = he(c);
  return te(f, () => o() ?? ge), de(c), A(t, c), W(u);
}
K(zw, { id: {}, ref: {}, children: {} }, [], [], { mode: "open" });
var BI = /* @__PURE__ */ ne("<!> <!>", 1), zI = /* @__PURE__ */ ne("<div><!> <!></div>");
function qw(t, e) {
  const r = Te();
  H(e, !0);
  const n = (F) => {
    zw(F, {
      children: (Z, Y) => {
        vt();
        var X = tt();
        ke(() => Me(X, p())), A(Z, X);
      },
      $$slots: { default: !0 }
    });
  };
  let s = v(e, "id", 23, () => me(r)), o = v(e, "ref", 15, null), i = v(e, "value", 15, ""), a = v(e, "onValueChange", 7, _e), l = v(e, "onStateChange", 7, _e), u = v(e, "loop", 7, !1), c = v(e, "shouldFilter", 7, !0), f = v(e, "filter", 7, Yc), p = v(e, "label", 7, ""), _ = v(e, "vimBindings", 7, !0), b = v(e, "disablePointerSelection", 7, !1), g = v(e, "disableInitialScroll", 7, !1), h = v(e, "columns", 7, null), y = v(e, "children", 7), S = v(e, "child", 7), x = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "onValueChange",
    "onStateChange",
    "loop",
    "shouldFilter",
    "filter",
    "label",
    "vimBindings",
    "disablePointerSelection",
    "disableInitialScroll",
    "columns",
    "children",
    "child"
  ]);
  const P = Ph.create({
    id: z(() => s()),
    ref: z(() => o(), (F) => o(F)),
    filter: z(() => f()),
    shouldFilter: z(() => c()),
    loop: z(() => u()),
    value: z(() => i(), (F) => {
      i() !== F && (i(F), a()(F));
    }),
    vimBindings: z(() => _()),
    disablePointerSelection: z(() => b()),
    disableInitialScroll: z(() => g()),
    onStateChange: z(() => l()),
    columns: z(() => h())
  }), w = (F) => P.updateSelectedToIndex(F), O = (F) => P.updateSelectedByGroup(F), k = (F) => P.updateSelectedByItem(F), $ = () => P.getValidItems(), T = /* @__PURE__ */ C(() => Ce(x, P.props));
  var E = {
    updateSelectedToIndex: w,
    updateSelectedByGroup: O,
    updateSelectedByItem: k,
    getValidItems: $,
    get id() {
      return s();
    },
    set id(F = me(r)) {
      s(F), m();
    },
    get ref() {
      return o();
    },
    set ref(F = null) {
      o(F), m();
    },
    get value() {
      return i();
    },
    set value(F = "") {
      i(F), m();
    },
    get onValueChange() {
      return a();
    },
    set onValueChange(F = _e) {
      a(F), m();
    },
    get onStateChange() {
      return l();
    },
    set onStateChange(F = _e) {
      l(F), m();
    },
    get loop() {
      return u();
    },
    set loop(F = !1) {
      u(F), m();
    },
    get shouldFilter() {
      return c();
    },
    set shouldFilter(F = !0) {
      c(F), m();
    },
    get filter() {
      return f();
    },
    set filter(F = Yc) {
      f(F), m();
    },
    get label() {
      return p();
    },
    set label(F = "") {
      p(F), m();
    },
    get vimBindings() {
      return _();
    },
    set vimBindings(F = !0) {
      _(F), m();
    },
    get disablePointerSelection() {
      return b();
    },
    set disablePointerSelection(F = !1) {
      b(F), m();
    },
    get disableInitialScroll() {
      return g();
    },
    set disableInitialScroll(F = !1) {
      g(F), m();
    },
    get columns() {
      return h();
    },
    set columns(F = null) {
      h(F), m();
    },
    get children() {
      return y();
    },
    set children(F) {
      y(F), m();
    },
    get child() {
      return S();
    },
    set child(F) {
      S(F), m();
    }
  }, M = I(), R = D(M);
  {
    var U = (F) => {
      var Z = BI(), Y = D(Z);
      n(Y);
      var X = be(Y, 2);
      te(X, S, () => ({ props: d(T) })), A(F, Z);
    }, B = (F) => {
      var Z = zI();
      ve(Z, () => ({ ...d(T) }));
      var Y = he(Z);
      n(Y);
      var X = be(Y, 2);
      te(X, () => y() ?? ge), de(Z), A(F, Z);
    };
    ue(R, (F) => {
      S() ? F(U) : F(B, !1);
    });
  }
  return A(t, M), W(E);
}
K(
  qw,
  {
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    onStateChange: {},
    loop: {},
    shouldFilter: {},
    filter: {},
    label: {},
    vimBindings: {},
    disablePointerSelection: {},
    disableInitialScroll: {},
    columns: {},
    children: {},
    child: {}
  },
  [],
  [
    "updateSelectedToIndex",
    "updateSelectedByGroup",
    "updateSelectedByItem",
    "getValidItems"
  ],
  { mode: "open" }
);
var qI = /* @__PURE__ */ ne("<div><!></div>");
function Uw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = v(e, "forceMount", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child",
    "forceMount"
  ]);
  const u = Oh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g)),
    forceMount: z(() => a())
  }), c = /* @__PURE__ */ C(() => Ce(u.props, l));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(g = !1) {
      a(g), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (g) => {
      var h = I(), y = D(h);
      {
        var S = (P) => {
          var w = I(), O = D(w);
          te(O, i, () => ({ props: d(c) })), A(P, w);
        }, x = (P) => {
          var w = qI();
          ve(w, () => ({ ...d(c) }));
          var O = he(w);
          te(O, () => o() ?? ge), de(w), A(P, w);
        };
        ue(y, (P) => {
          i() ? P(S) : P(x, !1);
        });
      }
      A(g, h);
    };
    ue(_, (g) => {
      u.shouldRender && g(b);
    });
  }
  return A(t, p), W(f);
}
K(Uw, { id: {}, ref: {}, children: {}, child: {}, forceMount: {} }, [], [], { mode: "open" });
var UI = /* @__PURE__ */ ne("<div><!></div>");
function Kw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "forceMount", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "forceMount",
    "children",
    "child"
  ]);
  const c = Ch.create({
    id: z(() => n()),
    ref: z(() => s(), (y) => s(y)),
    forceMount: z(() => i()),
    value: z(() => o())
  }), f = /* @__PURE__ */ C(() => Ce(u, c.props));
  var p = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get ref() {
      return s();
    },
    set ref(y = null) {
      s(y), m();
    },
    get value() {
      return o();
    },
    set value(y = "") {
      o(y), m();
    },
    get forceMount() {
      return i();
    },
    set forceMount(y = !1) {
      i(y), m();
    },
    get children() {
      return a();
    },
    set children(y) {
      a(y), m();
    },
    get child() {
      return l();
    },
    set child(y) {
      l(y), m();
    }
  }, _ = I(), b = D(_);
  {
    var g = (y) => {
      var S = I(), x = D(S);
      te(x, l, () => ({ props: d(f) })), A(y, S);
    }, h = (y) => {
      var S = UI();
      ve(S, () => ({ ...d(f) }));
      var x = he(S);
      te(x, () => a() ?? ge), de(S), A(y, S);
    };
    ue(b, (y) => {
      l() ? y(g) : y(h, !1);
    });
  }
  return A(t, _), W(p);
}
K(
  Kw,
  {
    id: {},
    ref: {},
    value: {},
    forceMount: {},
    children: {},
    child: {}
  },
  [],
  [],
  { mode: "open" }
);
var KI = /* @__PURE__ */ ne("<div><!></div>");
function Hw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = kh.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = KI();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => o() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      i() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(Hw, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var HI = /* @__PURE__ */ ne("<div><!></div>"), WI = /* @__PURE__ */ ne('<div style="display: contents;"><!></div>');
function Ww(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "children", 7), i = v(e, "child", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const l = $h.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get children() {
      return o();
    },
    set children(g) {
      o(g), m();
    },
    get child() {
      return i();
    },
    set child(g) {
      i(g), m();
    }
  }, f = WI(), p = he(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, i, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = HI();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => o() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      i() ? g(_) : g(b, !1);
    });
  }
  return de(f), A(t, f), W(c);
}
K(Ww, { id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var GI = /* @__PURE__ */ ne("<input/>");
function Gw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "value", 15, ""), s = v(e, "autofocus", 7, !1), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "value",
    "autofocus",
    "id",
    "ref",
    "child"
  ]);
  const u = Ah.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h)),
    value: z(() => n(), (h) => {
      n(h);
    }),
    autofocus: z(() => s() ?? !1)
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get value() {
      return n();
    },
    set value(h = "") {
      n(h), m();
    },
    get autofocus() {
      return s();
    },
    set autofocus(h = !1) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get child() {
      return a();
    },
    set child(h) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, a, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = GI();
      ve(y, () => ({ ...d(c) }), void 0, void 0, void 0, void 0, !0), fo(y, n), A(h, y);
    };
    ue(_, (h) => {
      a() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(Gw, { value: {}, autofocus: {}, id: {}, ref: {}, child: {} }, [], [], { mode: "open" });
var YI = /* @__PURE__ */ ne("<div><!></div>"), XI = /* @__PURE__ */ ne('<div style="display: contents;" data-item-wrapper=""><!></div>');
function Yw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "disabled", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = v(e, "onSelect", 7, _e), c = v(e, "forceMount", 7, !1), f = v(e, "keywords", 23, () => []), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const _ = gu.create({
    id: z(() => n()),
    ref: z(() => s(), (S) => s(S)),
    value: z(() => o()),
    disabled: z(() => i()),
    onSelect: z(() => u()),
    forceMount: z(() => c()),
    keywords: z(() => f())
  }), b = /* @__PURE__ */ C(() => Ce(p, _.props));
  var g = {
    get id() {
      return n();
    },
    set id(S = me(r)) {
      n(S), m();
    },
    get ref() {
      return s();
    },
    set ref(S = null) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S = "") {
      o(S), m();
    },
    get disabled() {
      return i();
    },
    set disabled(S = !1) {
      i(S), m();
    },
    get children() {
      return a();
    },
    set children(S) {
      a(S), m();
    },
    get child() {
      return l();
    },
    set child(S) {
      l(S), m();
    },
    get onSelect() {
      return u();
    },
    set onSelect(S = _e) {
      u(S), m();
    },
    get forceMount() {
      return c();
    },
    set forceMount(S = !1) {
      c(S), m();
    },
    get keywords() {
      return f();
    },
    set keywords(S = []) {
      f(S), m();
    }
  }, h = I(), y = D(h);
  return Vl(y, () => _.root.key, (S) => {
    var x = XI(), P = he(x);
    {
      var w = (O) => {
        var k = I(), $ = D(k);
        {
          var T = (M) => {
            var R = I(), U = D(R);
            te(U, l, () => ({ props: d(b) })), A(M, R);
          }, E = (M) => {
            var R = YI();
            ve(R, () => ({ ...d(b) }));
            var U = he(R);
            te(U, () => a() ?? ge), de(R), A(M, R);
          };
          ue($, (M) => {
            l() ? M(T) : M(E, !1);
          });
        }
        A(O, k);
      };
      ue(P, (O) => {
        _.shouldRender && O(w);
      });
    }
    de(x), ke(() => Cn(x, "data-value", _.trueValue)), A(S, x);
  }), A(t, h), W(g);
}
K(
  Yw,
  {
    id: {},
    ref: {},
    value: {},
    disabled: {},
    children: {},
    child: {},
    onSelect: {},
    forceMount: {},
    keywords: {}
  },
  [],
  [],
  { mode: "open" }
);
var JI = /* @__PURE__ */ ne("<a><!></a>"), ZI = /* @__PURE__ */ ne('<div style="display: contents;"><!></div>');
function Xw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 7, ""), i = v(e, "disabled", 7, !1), a = v(e, "children", 7), l = v(e, "child", 7), u = v(e, "onSelect", 7, _e), c = v(e, "forceMount", 7, !1), f = v(e, "keywords", 23, () => []), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const _ = gu.create({
    id: z(() => n()),
    ref: z(() => s(), (S) => s(S)),
    value: z(() => o()),
    disabled: z(() => i()),
    onSelect: z(() => u()),
    forceMount: z(() => c()),
    keywords: z(() => f())
  }), b = /* @__PURE__ */ C(() => Ce(p, _.props));
  var g = {
    get id() {
      return n();
    },
    set id(S = me(r)) {
      n(S), m();
    },
    get ref() {
      return s();
    },
    set ref(S = null) {
      s(S), m();
    },
    get value() {
      return o();
    },
    set value(S = "") {
      o(S), m();
    },
    get disabled() {
      return i();
    },
    set disabled(S = !1) {
      i(S), m();
    },
    get children() {
      return a();
    },
    set children(S) {
      a(S), m();
    },
    get child() {
      return l();
    },
    set child(S) {
      l(S), m();
    },
    get onSelect() {
      return u();
    },
    set onSelect(S = _e) {
      u(S), m();
    },
    get forceMount() {
      return c();
    },
    set forceMount(S = !1) {
      c(S), m();
    },
    get keywords() {
      return f();
    },
    set keywords(S = []) {
      f(S), m();
    }
  }, h = I(), y = D(h);
  return Vl(y, () => _.root.key, (S) => {
    var x = ZI(), P = he(x);
    {
      var w = (O) => {
        var k = I(), $ = D(k);
        {
          var T = (M) => {
            var R = I(), U = D(R);
            te(U, l, () => ({ props: d(b) })), A(M, R);
          }, E = (M) => {
            var R = JI();
            ve(R, () => ({ ...d(b) }));
            var U = he(R);
            te(U, () => a() ?? ge), de(R), A(M, R);
          };
          ue($, (M) => {
            l() ? M(T) : M(E, !1);
          });
        }
        A(O, k);
      };
      ue(P, (O) => {
        _.shouldRender && O(w);
      });
    }
    de(x), A(S, x);
  }), A(t, h), W(g);
}
K(
  Xw,
  {
    id: {},
    ref: {},
    value: {},
    disabled: {},
    children: {},
    child: {},
    onSelect: {},
    forceMount: {},
    keywords: {}
  },
  [],
  [],
  { mode: "open" }
);
var QI = /* @__PURE__ */ ne("<div><!></div>");
function Jw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "aria-label", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "aria-label"
  ]);
  const u = Dh.create({
    id: z(() => n()),
    ref: z(() => s(), (b) => s(b)),
    ariaLabel: z(() => a() ?? "Suggestions...")
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(b = me(r)) {
      n(b), m();
    },
    get ref() {
      return s();
    },
    set ref(b = null) {
      s(b), m();
    },
    get child() {
      return o();
    },
    set child(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get "aria-label"() {
      return a();
    },
    set "aria-label"(b) {
      a(b), m();
    }
  }, p = I(), _ = D(p);
  return Vl(_, () => u.root._commandState.search === "", (b) => {
    var g = I(), h = D(g);
    {
      var y = (x) => {
        var P = I(), w = D(P);
        te(w, o, () => ({ props: d(c) })), A(x, P);
      }, S = (x) => {
        var P = QI();
        ve(P, () => ({ ...d(c) }));
        var w = he(P);
        te(w, () => i() ?? ge), de(P), A(x, P);
      };
      ue(h, (x) => {
        o() ? x(y) : x(S, !1);
      });
    }
    A(b, g);
  }), A(t, p), W(f);
}
K(Jw, { id: {}, ref: {}, child: {}, children: {}, "aria-label": {} }, [], [], { mode: "open" });
var eN = /* @__PURE__ */ ne("<div><!></div>");
function Zw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "progress", 7, 0), s = v(e, "id", 23, () => me(r)), o = v(e, "ref", 15, null), i = v(e, "children", 7), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "progress",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const u = Eh.create({
    id: z(() => s()),
    ref: z(() => o(), (h) => o(h)),
    progress: z(() => n())
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get progress() {
      return n();
    },
    set progress(h = 0) {
      n(h), m();
    },
    get id() {
      return s();
    },
    set id(h = me(r)) {
      s(h), m();
    },
    get ref() {
      return o();
    },
    set ref(h = null) {
      o(h), m();
    },
    get children() {
      return i();
    },
    set children(h) {
      i(h), m();
    },
    get child() {
      return a();
    },
    set child(h) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, a, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = eN();
      ve(y, () => ({ ...d(c) }));
      var S = he(y);
      te(S, () => i() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      a() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(Zw, { progress: {}, id: {}, ref: {}, children: {}, child: {} }, [], [], { mode: "open" });
var tN = /* @__PURE__ */ ne("<div><!></div>");
function Qw(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "forceMount", 7, !1), i = v(e, "children", 7), a = v(e, "child", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "forceMount",
    "children",
    "child"
  ]);
  const u = Th.create({
    id: z(() => n()),
    ref: z(() => s(), (g) => s(g)),
    forceMount: z(() => o())
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get id() {
      return n();
    },
    set id(g = me(r)) {
      n(g), m();
    },
    get ref() {
      return s();
    },
    set ref(g = null) {
      s(g), m();
    },
    get forceMount() {
      return o();
    },
    set forceMount(g = !1) {
      o(g), m();
    },
    get children() {
      return i();
    },
    set children(g) {
      i(g), m();
    },
    get child() {
      return a();
    },
    set child(g) {
      a(g), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (g) => {
      var h = I(), y = D(h);
      {
        var S = (P) => {
          var w = I(), O = D(w);
          te(O, a, () => ({ props: d(c) })), A(P, w);
        }, x = (P) => {
          var w = tN();
          ve(w, () => ({ ...d(c) }));
          var O = he(w);
          te(O, () => i() ?? ge), de(w), A(P, w);
        };
        ue(y, (P) => {
          a() ? P(S) : P(x, !1);
        });
      }
      A(g, h);
    };
    ue(_, (g) => {
      u.shouldRender && g(b);
    });
  }
  return A(t, p), W(f);
}
K(Qw, { id: {}, ref: {}, forceMount: {}, children: {}, child: {} }, [], [], { mode: "open" });
const Hm = 1, rN = 0.9, nN = 0.8, sN = 0.17, ic = 0.1, ac = 0.999, oN = 0.9999, iN = 0.99, aN = /[\\/_+.#"@[({&]/, lN = /[\\/_+.#"@[({&]/g, uN = /[\s-]/, e1 = /[\s-]/g;
function Gc(t, e, r, n, s, o, i) {
  if (o === e.length)
    return s === t.length ? Hm : iN;
  const a = `${s},${o}`;
  if (i[a] !== void 0)
    return i[a];
  const l = n.charAt(o);
  let u = r.indexOf(l, s), c = 0, f, p, _, b;
  for (; u >= 0; )
    f = Gc(t, e, r, n, u + 1, o + 1, i), f > c && (u === s ? f *= Hm : aN.test(t.charAt(u - 1)) ? (f *= nN, _ = t.slice(s, u - 1).match(lN), _ && s > 0 && (f *= ac ** _.length)) : uN.test(t.charAt(u - 1)) ? (f *= rN, b = t.slice(s, u - 1).match(e1), b && s > 0 && (f *= ac ** b.length)) : (f *= sN, s > 0 && (f *= ac ** (u - s))), t.charAt(u) !== e.charAt(o) && (f *= oN)), (f < ic && r.charAt(u - 1) === n.charAt(o + 1) || n.charAt(o + 1) === n.charAt(o) && r.charAt(u - 1) !== n.charAt(o)) && (p = Gc(t, e, r, n, u + 1, o + 2, i), p * ic > f && (f = p * ic)), f > c && (c = f), u = r.indexOf(l, u + 1);
  return i[a] = c, c;
}
function Wm(t) {
  return t.toLowerCase().replace(e1, " ");
}
function Yc(t, e, r) {
  return t = r && r.length > 0 ? `${`${t} ${r?.join(" ")}`}` : t, Gc(t, e, Wm(t), Wm(e), 0, 0, {});
}
function Gm(t, e) {
  const [r, n] = t;
  let s = !1;
  const o = e.length;
  for (let i = 0, a = o - 1; i < o; a = i++) {
    const [l, u] = e[i] ?? [0, 0], [c, f] = e[a] ?? [0, 0];
    u >= n != f >= n && r <= (c - l) * (n - u) / (f - u) + l && (s = !s);
  }
  return s;
}
function Ym(t, e) {
  return t[0] >= e.left && t[0] <= e.right && t[1] >= e.top && t[1] <= e.bottom;
}
function cN(t, e) {
  const r = t.left + t.width / 2, n = t.top + t.height / 2, s = e.left + e.width / 2, o = e.top + e.height / 2, i = s - r, a = o - n;
  return Math.abs(i) > Math.abs(a) ? i > 0 ? "right" : "left" : a > 0 ? "bottom" : "top";
}
class dN {
  #e;
  #t;
  // tracks the cursor position when leaving trigger or content
  #r = null;
  // tracks what we're moving toward: "content" when leaving trigger, "trigger" when leaving content
  #n = null;
  constructor(e) {
    this.#e = e, this.#t = e.buffer ?? 1, Ne([e.triggerNode, e.contentNode, e.enabled], ([r, n, s]) => {
      if (!r || !n || !s) {
        this.#r = null, this.#n = null;
        return;
      }
      const o = ef(r), i = (f) => {
        this.#s(f, r, n);
      }, a = (f) => {
        const p = f.relatedTarget;
        di(p) && n.contains(p) || (this.#r = [f.clientX, f.clientY], this.#n = "content");
      }, l = () => {
        this.#r = null, this.#n = null;
      }, u = () => {
        this.#r = null, this.#n = null;
      }, c = (f) => {
        const p = f.relatedTarget;
        di(p) && r.contains(p) || (this.#r = [f.clientX, f.clientY], this.#n = "trigger");
      };
      return [
        Ye(o, "pointermove", i),
        Ye(r, "pointerleave", a),
        Ye(r, "pointerenter", l),
        Ye(n, "pointerenter", u),
        Ye(n, "pointerleave", c)
      ].reduce(
        (f, p) => () => {
          f(), p();
        },
        () => {
        }
      );
    });
  }
  #s(e, r, n) {
    if (!this.#r || !this.#n) return;
    const s = [e.clientX, e.clientY], o = r.getBoundingClientRect(), i = n.getBoundingClientRect();
    if (this.#n === "content" && Ym(s, i)) {
      this.#r = null, this.#n = null;
      return;
    }
    if (this.#n === "trigger" && Ym(s, o)) {
      this.#r = null, this.#n = null;
      return;
    }
    const a = cN(o, i), l = this.#o(o, i, a);
    if (l && Gm(s, l))
      return;
    const u = this.#n === "content" ? i : o, c = this.#i(this.#r, u, a, this.#n);
    Gm(s, c) || (this.#r = null, this.#n = null, this.#e.onPointerExit());
  }
  /**
   * Creates a rectangular corridor between trigger and content
   * This prevents closing when cursor is in the gap between them
   */
  #o(e, r, n) {
    const s = this.#t;
    switch (n) {
      case "top":
        return [
          [
            Math.min(e.left, r.left) - s,
            e.top
          ],
          [
            Math.min(e.left, r.left) - s,
            r.bottom
          ],
          [
            Math.max(e.right, r.right) + s,
            r.bottom
          ],
          [
            Math.max(e.right, r.right) + s,
            e.top
          ]
        ];
      case "bottom":
        return [
          [
            Math.min(e.left, r.left) - s,
            e.bottom
          ],
          [
            Math.min(e.left, r.left) - s,
            r.top
          ],
          [
            Math.max(e.right, r.right) + s,
            r.top
          ],
          [
            Math.max(e.right, r.right) + s,
            e.bottom
          ]
        ];
      case "left":
        return [
          [
            e.left,
            Math.min(e.top, r.top) - s
          ],
          [
            r.right,
            Math.min(e.top, r.top) - s
          ],
          [
            r.right,
            Math.max(e.bottom, r.bottom) + s
          ],
          [
            e.left,
            Math.max(e.bottom, r.bottom) + s
          ]
        ];
      case "right":
        return [
          [
            e.right,
            Math.min(e.top, r.top) - s
          ],
          [
            r.left,
            Math.min(e.top, r.top) - s
          ],
          [
            r.left,
            Math.max(e.bottom, r.bottom) + s
          ],
          [
            e.right,
            Math.max(e.bottom, r.bottom) + s
          ]
        ];
    }
  }
  /**
   * Creates a triangular/trapezoidal safe zone from the exit point to the target
   */
  #i(e, r, n, s) {
    const o = this.#t * 4, [i, a] = e;
    switch (s === "trigger" ? this.#a(n) : n) {
      case "top":
        return [
          [i - o, a + o],
          [i + o, a + o],
          [r.right + o, r.bottom],
          [r.right + o, r.top],
          [r.left - o, r.top],
          [r.left - o, r.bottom]
        ];
      case "bottom":
        return [
          [i - o, a - o],
          [i + o, a - o],
          [r.right + o, r.top],
          [r.right + o, r.bottom],
          [r.left - o, r.bottom],
          [r.left - o, r.top]
        ];
      case "left":
        return [
          [i + o, a - o],
          [i + o, a + o],
          [r.right, r.bottom + o],
          [r.left, r.bottom + o],
          [r.left, r.top - o],
          [r.right, r.top - o]
        ];
      case "right":
        return [
          [i - o, a - o],
          [i - o, a + o],
          [r.left, r.bottom + o],
          [r.right, r.bottom + o],
          [r.right, r.top - o],
          [r.left, r.top - o]
        ];
    }
  }
  #a(e) {
    switch (e) {
      case "top":
        return "bottom";
      case "bottom":
        return "top";
      case "left":
        return "right";
      case "right":
        return "left";
    }
  }
}
const Pl = rr({
  component: "popover",
  parts: ["root", "trigger", "content", "close", "overlay"]
}), pu = new ht("Popover.Root");
class Ih {
  static create(e) {
    return pu.set(new Ih(e));
  }
  opts;
  #e = /* @__PURE__ */ xe(null);
  get contentNode() {
    return d(this.#e);
  }
  set contentNode(e) {
    q(this.#e, e, !0);
  }
  contentPresence;
  #t = /* @__PURE__ */ xe(null);
  get triggerNode() {
    return d(this.#t);
  }
  set triggerNode(e) {
    q(this.#t, e, !0);
  }
  #r = /* @__PURE__ */ xe(null);
  get overlayNode() {
    return d(this.#r);
  }
  set overlayNode(e) {
    q(this.#r, e, !0);
  }
  overlayPresence;
  #n = /* @__PURE__ */ xe(!1);
  get openedViaHover() {
    return d(this.#n);
  }
  set openedViaHover(e) {
    q(this.#n, e, !0);
  }
  #s = /* @__PURE__ */ xe(!1);
  get hasInteractedWithContent() {
    return d(this.#s);
  }
  set hasInteractedWithContent(e) {
    q(this.#s, e, !0);
  }
  #o = /* @__PURE__ */ xe(!1);
  get hoverCooldown() {
    return d(this.#o);
  }
  set hoverCooldown(e) {
    q(this.#o, e, !0);
  }
  #i = /* @__PURE__ */ xe(0);
  get closeDelay() {
    return d(this.#i);
  }
  set closeDelay(e) {
    q(this.#i, e, !0);
  }
  #a = null;
  #u = null;
  constructor(e) {
    this.opts = e, this.contentPresence = new wi({
      ref: z(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    }), this.overlayPresence = new wi({ ref: z(() => this.overlayNode), open: this.opts.open }), Ne(() => this.opts.open.current, (r) => {
      r || (this.openedViaHover = !1, this.hasInteractedWithContent = !1, this.#l());
    });
  }
  setDomContext(e) {
    this.#u = e;
  }
  #l() {
    this.#a !== null && this.#u && (this.#u.clearTimeout(this.#a), this.#a = null);
  }
  toggleOpen() {
    this.#l(), this.opts.open.current = !this.opts.open.current;
  }
  handleClose() {
    this.#l(), this.opts.open.current && (this.opts.open.current = !1);
  }
  handleHoverOpen() {
    this.#l(), !this.opts.open.current && (this.openedViaHover = !0, this.opts.open.current = !0);
  }
  handleHoverClose() {
    this.opts.open.current && this.openedViaHover && !this.hasInteractedWithContent && (this.opts.open.current = !1);
  }
  handleDelayedHoverClose() {
    this.opts.open.current && (!this.openedViaHover || this.hasInteractedWithContent || (this.#l(), this.closeDelay <= 0 ? this.opts.open.current = !1 : this.#u && (this.#a = this.#u.setTimeout(
      () => {
        this.openedViaHover && !this.hasInteractedWithContent && (this.opts.open.current = !1), this.#a = null;
      },
      this.closeDelay
    ))));
  }
  cancelDelayedClose() {
    this.#l();
  }
  markInteraction() {
    this.hasInteractedWithContent = !0, this.#l();
  }
}
class Nh {
  static create(e) {
    return new Nh(e, pu.get());
  }
  opts;
  root;
  attachment;
  domContext;
  #e = null;
  #t = null;
  #r = /* @__PURE__ */ xe(!1);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => this.root.triggerNode = n), this.domContext = new Nn(e.ref), this.root.setDomContext(this.domContext), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this), Ne(() => this.opts.closeDelay.current, (n) => {
      this.root.closeDelay = n;
    });
  }
  #n() {
    this.#e !== null && (this.domContext.clearTimeout(this.#e), this.#e = null);
  }
  #s() {
    this.#t !== null && (this.domContext.clearTimeout(this.#t), this.#t = null);
  }
  #o() {
    this.#n(), this.#s();
  }
  onpointerenter(e) {
    if (this.opts.disabled.current || !this.opts.openOnHover.current || ul(e) || (q(this.#r, !0), this.#s(), this.root.cancelDelayedClose(), this.root.opts.open.current || this.root.hoverCooldown)) return;
    const r = this.opts.openDelay.current;
    r <= 0 ? this.root.handleHoverOpen() : this.#e = this.domContext.setTimeout(
      () => {
        this.root.handleHoverOpen(), this.#e = null;
      },
      r
    );
  }
  onpointerleave(e) {
    this.opts.disabled.current || this.opts.openOnHover.current && (ul(e) || (q(this.#r, !1), this.#n(), this.root.hoverCooldown = !1));
  }
  onclick(e) {
    if (!this.opts.disabled.current && e.button === 0) {
      if (this.#o(), d(this.#r) && this.root.opts.open.current && this.root.openedViaHover) {
        this.root.openedViaHover = !1, this.root.hasInteractedWithContent = !0;
        return;
      }
      d(this.#r) && this.opts.openOnHover.current && this.root.opts.open.current && (this.root.hoverCooldown = !0), this.root.hoverCooldown && !this.root.opts.open.current && (this.root.hoverCooldown = !1), this.root.toggleOpen();
    }
  }
  onkeydown(e) {
    this.opts.disabled.current || (e.key === Vr || e.key === wr) && (e.preventDefault(), this.#o(), this.root.toggleOpen());
  }
  #i() {
    if (this.root.opts.open.current && this.root.contentNode?.id)
      return this.root.contentNode?.id;
  }
  #a = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "aria-haspopup": "dialog",
    "aria-expanded": at(this.root.opts.open.current),
    "data-state": ji(this.root.opts.open.current),
    "aria-controls": this.#i(),
    [Pl.trigger]: "",
    disabled: this.opts.disabled.current,
    //
    onkeydown: this.onkeydown,
    onclick: this.onclick,
    onpointerenter: this.onpointerenter,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
class Fh {
  static create(e) {
    return new Fh(e, pu.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref, (n) => this.root.contentNode = n), this.onpointerdown = this.onpointerdown.bind(this), this.onfocusin = this.onfocusin.bind(this), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this), new dN({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.root.contentNode,
      enabled: () => this.root.opts.open.current && this.root.openedViaHover && !this.root.hasInteractedWithContent,
      onPointerExit: () => {
        this.root.handleDelayedHoverClose();
      }
    });
  }
  onpointerdown(e) {
    this.root.markInteraction();
  }
  onfocusin(e) {
    const r = e.target;
    di(r) && bT(r) && this.root.markInteraction();
  }
  onpointerenter(e) {
    ul(e) || this.root.cancelDelayedClose();
  }
  onpointerleave(e) {
    ul(e);
  }
  onInteractOutside = (e) => {
    if (this.opts.onInteractOutside.current(e), e.defaultPrevented || !di(e.target)) return;
    const r = e.target.closest(Pl.selector("trigger"));
    if (!(r && r === this.root.triggerNode)) {
      if (this.opts.customAnchor.current) {
        if (di(this.opts.customAnchor.current)) {
          if (this.opts.customAnchor.current.contains(e.target)) return;
        } else if (typeof this.opts.customAnchor.current == "string") {
          const n = document.querySelector(this.opts.customAnchor.current);
          if (n && n.contains(e.target)) return;
        }
      }
      this.root.handleClose();
    }
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
  };
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get shouldTrapFocus() {
    return !(this.root.openedViaHover && !this.root.hasInteractedWithContent);
  }
  #e = /* @__PURE__ */ C(() => ({ open: this.root.opts.open.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    tabindex: -1,
    "data-state": ji(this.root.opts.open.current),
    [Pl.content]: "",
    style: { pointerEvents: "auto", contain: "layout style paint" },
    onpointerdown: this.onpointerdown,
    onfocusin: this.onfocusin,
    onpointerenter: this.onpointerenter,
    onpointerleave: this.onpointerleave,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown
  };
}
class Rh {
  static create(e) {
    return new Rh(e, pu.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    this.root.handleClose();
  }
  onkeydown(e) {
    (e.key === Vr || e.key === wr) && (e.preventDefault(), this.root.handleClose());
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    type: "button",
    [Pl.close]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var fN = /* @__PURE__ */ ne("<div><div><!></div></div>"), hN = /* @__PURE__ */ ne("<div><div><!></div></div>");
function t1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "forceMount", 7, !1), l = v(e, "onOpenAutoFocus", 7, _e), u = v(e, "onCloseAutoFocus", 7, _e), c = v(e, "onEscapeKeydown", 7, _e), f = v(e, "onInteractOutside", 7, _e), p = v(e, "trapFocus", 7, !0), _ = v(e, "preventScroll", 7, !1), b = v(e, "customAnchor", 7, null), g = v(e, "style", 7), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id",
    "forceMount",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "customAnchor",
    "style"
  ]);
  const y = Fh.create({
    id: z(() => i()),
    ref: z(() => o(), (E) => o(E)),
    onInteractOutside: z(() => f()),
    onEscapeKeydown: z(() => c()),
    customAnchor: z(() => b())
  }), S = /* @__PURE__ */ C(() => Ce(h, y.props)), x = /* @__PURE__ */ C(() => p() && y.shouldTrapFocus);
  function P(E) {
    y.shouldTrapFocus || E.preventDefault(), l()(E);
  }
  var w = {
    get child() {
      return n();
    },
    set child(E) {
      n(E), m();
    },
    get children() {
      return s();
    },
    set children(E) {
      s(E), m();
    },
    get ref() {
      return o();
    },
    set ref(E = null) {
      o(E), m();
    },
    get id() {
      return i();
    },
    set id(E = me(r)) {
      i(E), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(E = !1) {
      a(E), m();
    },
    get onOpenAutoFocus() {
      return l();
    },
    set onOpenAutoFocus(E = _e) {
      l(E), m();
    },
    get onCloseAutoFocus() {
      return u();
    },
    set onCloseAutoFocus(E = _e) {
      u(E), m();
    },
    get onEscapeKeydown() {
      return c();
    },
    set onEscapeKeydown(E = _e) {
      c(E), m();
    },
    get onInteractOutside() {
      return f();
    },
    set onInteractOutside(E = _e) {
      f(E), m();
    },
    get trapFocus() {
      return p();
    },
    set trapFocus(E = !0) {
      p(E), m();
    },
    get preventScroll() {
      return _();
    },
    set preventScroll(E = !1) {
      _(E), m();
    },
    get customAnchor() {
      return b();
    },
    set customAnchor(E = null) {
      b(E), m();
    },
    get style() {
      return g();
    },
    set style(E) {
      g(E), m();
    }
  }, O = I(), k = D(O);
  {
    var $ = (E) => {
      xh(E, ce(() => d(S), () => y.popperProps, {
        get ref() {
          return y.opts.ref;
        },
        get enabled() {
          return y.root.opts.open.current;
        },
        get id() {
          return i();
        },
        get trapFocus() {
          return d(x);
        },
        get preventScroll() {
          return _();
        },
        loop: !0,
        forceMount: !0,
        get customAnchor() {
          return b();
        },
        onOpenAutoFocus: P,
        get onCloseAutoFocus() {
          return u();
        },
        get shouldRender() {
          return y.shouldRender;
        },
        popper: (R, U) => {
          let B = () => U?.().props, F = () => U?.().wrapperProps;
          const Z = /* @__PURE__ */ C(() => Ce(B(), { style: Wc("popover") }, { style: g() }));
          var Y = I(), X = D(Y);
          {
            var ae = (j) => {
              var ee = I(), L = D(ee);
              {
                let N = /* @__PURE__ */ C(() => ({
                  props: d(Z),
                  wrapperProps: F(),
                  ...y.snippetProps
                }));
                te(L, n, () => d(N));
              }
              A(j, ee);
            }, J = (j) => {
              var ee = fN();
              ve(ee, () => ({ ...F() }));
              var L = he(ee);
              ve(L, () => ({ ...d(Z) }));
              var N = he(L);
              te(N, () => s() ?? ge), de(L), de(ee), A(j, ee);
            };
            ue(X, (j) => {
              n() ? j(ae) : j(J, !1);
            });
          }
          A(R, Y);
        },
        $$slots: { popper: !0 }
      }));
    }, T = (E) => {
      var M = I(), R = D(M);
      {
        var U = (B) => {
          Sh(B, ce(() => d(S), () => y.popperProps, {
            get ref() {
              return y.opts.ref;
            },
            get open() {
              return y.root.opts.open.current;
            },
            get id() {
              return i();
            },
            get trapFocus() {
              return d(x);
            },
            get preventScroll() {
              return _();
            },
            loop: !0,
            forceMount: !1,
            get customAnchor() {
              return b();
            },
            onOpenAutoFocus: P,
            get onCloseAutoFocus() {
              return u();
            },
            get shouldRender() {
              return y.shouldRender;
            },
            popper: (Z, Y) => {
              let X = () => Y?.().props, ae = () => Y?.().wrapperProps;
              const J = /* @__PURE__ */ C(() => Ce(X(), { style: Wc("popover") }, { style: g() }));
              var j = I(), ee = D(j);
              {
                var L = (V) => {
                  var G = I(), fe = D(G);
                  {
                    let se = /* @__PURE__ */ C(() => ({
                      props: d(J),
                      wrapperProps: ae(),
                      ...y.snippetProps
                    }));
                    te(fe, n, () => d(se));
                  }
                  A(V, G);
                }, N = (V) => {
                  var G = hN();
                  ve(G, () => ({ ...ae() }));
                  var fe = he(G);
                  ve(fe, () => ({ ...d(J) }));
                  var se = he(fe);
                  te(se, () => s() ?? ge), de(fe), de(G), A(V, G);
                };
                ue(ee, (V) => {
                  n() ? V(L) : V(N, !1);
                });
              }
              A(Z, j);
            },
            $$slots: { popper: !0 }
          }));
        };
        ue(
          R,
          (B) => {
            a() || B(U);
          },
          !0
        );
      }
      A(E, M);
    };
    ue(k, (E) => {
      a() ? E($) : E(T, !1);
    });
  }
  return A(t, O), W(w);
}
K(
  t1,
  {
    child: {},
    children: {},
    ref: {},
    id: {},
    forceMount: {},
    onOpenAutoFocus: {},
    onCloseAutoFocus: {},
    onEscapeKeydown: {},
    onInteractOutside: {},
    trapFocus: {},
    preventScroll: {},
    customAnchor: {},
    style: {}
  },
  [],
  [],
  { mode: "open" }
);
var gN = /* @__PURE__ */ ne("<button><!></button>");
function r1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7, !1), u = v(e, "openOnHover", 7, !1), c = v(e, "openDelay", 7, 700), f = v(e, "closeDelay", 7, 300), p = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "type",
    "disabled",
    "openOnHover",
    "openDelay",
    "closeDelay"
  ]);
  const _ = Nh.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h)),
    disabled: z(() => !!l()),
    openOnHover: z(() => u()),
    openDelay: z(() => c()),
    closeDelay: z(() => f())
  }), b = /* @__PURE__ */ C(() => Ce(p, _.props, { type: a() }));
  var g = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get type() {
      return a();
    },
    set type(h = "button") {
      a(h), m();
    },
    get disabled() {
      return l();
    },
    set disabled(h = !1) {
      l(h), m();
    },
    get openOnHover() {
      return u();
    },
    set openOnHover(h = !1) {
      u(h), m();
    },
    get openDelay() {
      return c();
    },
    set openDelay(h = 700) {
      c(h), m();
    },
    get closeDelay() {
      return f();
    },
    set closeDelay(h = 300) {
      f(h), m();
    }
  };
  return bh(t, {
    get id() {
      return o();
    },
    get ref() {
      return _.opts.ref;
    },
    children: (h, y) => {
      var S = I(), x = D(S);
      {
        var P = (O) => {
          var k = I(), $ = D(k);
          te($, s, () => ({ props: d(b) })), A(O, k);
        }, w = (O) => {
          var k = gN();
          ve(k, () => ({ ...d(b) }));
          var $ = he(k);
          te($, () => n() ?? ge), de(k), A(O, k);
        };
        ue(x, (O) => {
          s() ? O(P) : O(w, !1);
        });
      }
      A(h, S);
    },
    $$slots: { default: !0 }
  }), W(g);
}
K(
  r1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    type: {},
    disabled: {},
    openOnHover: {},
    openDelay: {},
    closeDelay: {}
  },
  [],
  [],
  { mode: "open" }
);
var pN = /* @__PURE__ */ ne("<button><!></button>");
function n1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "id",
    "ref"
  ]);
  const l = Rh.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get child() {
      return n();
    },
    set child(g) {
      n(g), m();
    },
    get children() {
      return s();
    },
    set children(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, n, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = pN();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => s() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      n() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(n1, { child: {}, children: {}, id: {}, ref: {} }, [], [], { mode: "open" });
const s1 = new ht("RangeCalendar.Cell");
class Vh {
  static create(e) {
    return Ut.set(new Vh(e));
  }
  opts;
  attachment;
  #e = /* @__PURE__ */ C(() => this.months.map((e) => e.value));
  get visibleMonths() {
    return d(this.#e);
  }
  set visibleMonths(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ xe(Pt([]));
  get months() {
    return d(this.#t);
  }
  set months(e) {
    q(this.#t, e, !0);
  }
  announcer;
  formatter;
  accessibleHeadingId = kn();
  #r = /* @__PURE__ */ xe(void 0);
  get focusedValue() {
    return d(this.#r);
  }
  set focusedValue(e) {
    q(this.#r, e, !0);
  }
  lastPressedDateValue = void 0;
  domContext;
  #n = /* @__PURE__ */ C(() => Z0({
    months: this.months,
    formatter: this.formatter,
    weekdayFormat: this.opts.weekdayFormat.current
  }));
  get weekdays() {
    return d(this.#n);
  }
  set weekdays(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => this.opts.startValue.current ? this.isDateUnavailable(this.opts.startValue.current) || this.isDateDisabled(this.opts.startValue.current) : !1);
  get isStartInvalid() {
    return d(this.#s);
  }
  set isStartInvalid(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ C(() => this.opts.endValue.current ? this.isDateUnavailable(this.opts.endValue.current) || this.isDateDisabled(this.opts.endValue.current) : !1);
  get isEndInvalid() {
    return d(this.#o);
  }
  set isEndInvalid(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => !!(this.isStartInvalid || this.isEndInvalid || this.opts.endValue.current && this.opts.startValue.current && jt(this.opts.endValue.current, this.opts.startValue.current)));
  get isInvalid() {
    return d(this.#i);
  }
  set isInvalid(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ C(() => tw({
    maxValue: this.opts.maxValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isNextButtonDisabled() {
    return d(this.#a);
  }
  set isNextButtonDisabled(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ C(() => rw({
    minValue: this.opts.minValue.current,
    months: this.months,
    disabled: this.opts.disabled.current
  }));
  get isPrevButtonDisabled() {
    return d(this.#u);
  }
  set isPrevButtonDisabled(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ C(() => (this.opts.monthFormat.current, this.opts.yearFormat.current, nw({
    months: this.months,
    formatter: this.formatter,
    locale: this.opts.locale.current
  })));
  get headingValue() {
    return d(this.#l);
  }
  set headingValue(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ C(() => `${this.opts.calendarLabel.current} ${this.headingValue}`);
  get fullCalendarLabel() {
    return d(this.#c);
  }
  set fullCalendarLabel(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ C(() => {
    if (this.opts.startValue.current && this.opts.endValue.current || !this.opts.startValue.current || !this.focusedValue) return null;
    const e = jt(this.opts.startValue.current, this.focusedValue), r = e ? this.opts.startValue.current : this.focusedValue, n = e ? this.focusedValue : this.opts.startValue.current, s = { start: r, end: n };
    return _t(r.add({ days: 1 }), n) || _t(r, n) || TD(r, n, this.isDateUnavailable, this.isDateDisabled) ? s : null;
  });
  get highlightedRange() {
    return d(this.#d);
  }
  set highlightedRange(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ C(() => ot(() => this.opts.placeholder.current.year));
  get initialPlaceholderYear() {
    return d(this.#g);
  }
  set initialPlaceholderYear(e) {
    q(this.#g, e);
  }
  #m = /* @__PURE__ */ C(() => aw({
    minValue: this.opts.minValue.current,
    maxValue: this.opts.maxValue.current,
    placeholderYear: this.initialPlaceholderYear
  }));
  get defaultYears() {
    return d(this.#m);
  }
  set defaultYears(e) {
    q(this.#m, e);
  }
  constructor(e) {
    this.opts = e, this.attachment = Ee(e.ref), this.domContext = new Nn(e.ref), this.announcer = vl(null), this.formatter = W0({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    }), this.months = jo({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    }), Co(() => {
      this.formatter.getLocale() !== this.opts.locale.current && this.formatter.setLocale(this.opts.locale.current);
    }), ko(() => {
      this.announcer = vl(this.domContext.getDocument());
    }), ew({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: this.setMonths
    }), Q0({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    }), Ze(() => {
      const r = this.domContext.getElementById(this.accessibleHeadingId);
      r && (r.textContent = this.fullCalendarLabel);
    }), Ne(() => this.opts.value.current, (r) => {
      r.start && r.end ? (this.opts.startValue.current = r.start, this.opts.endValue.current = r.end) : r.start ? (this.opts.startValue.current = r.start, this.opts.endValue.current = void 0) : r.start === void 0 && r.end === void 0 && (this.opts.startValue.current = void 0, this.opts.endValue.current = void 0);
    }), Ne(() => this.opts.value.current, (r) => {
      const n = r.start;
      n && this.opts.placeholder.current !== n && (this.opts.placeholder.current = n);
    }), Ne(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current,
        () => this.opts.excludeDisabled.current
      ],
      ([r, n, s]) => {
        !s || !r || !n || this.#_(r, n) && (this.#f(void 0), this.#h(void 0), this.#y());
      }
    ), Ne(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([r, n]) => {
        this.opts.value.current && this.opts.value.current.start === r && this.opts.value.current.end === n || (r && n ? this.#p((s) => {
          if (s.start === r && s.end === n)
            return s;
          if (jt(n, r)) {
            const o = r, i = n;
            return this.#f(i), this.#h(o), this.#b(n, r) ? { start: n, end: r } : (this.#f(r), this.#h(void 0), { start: r, end: void 0 });
          } else
            return this.#b(r, n) ? { start: r, end: n } : (this.#f(n), this.#h(void 0), { start: n, end: void 0 });
        }) : this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end && (this.opts.value.current.start = void 0, this.opts.value.current.end = void 0));
      }
    ), this.shiftFocus = this.shiftFocus.bind(this), this.handleCellClick = this.handleCellClick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.nextYear = this.nextYear.bind(this), this.prevYear = this.prevYear.bind(this), this.setYear = this.setYear.bind(this), this.setMonth = this.setMonth.bind(this), this.isDateDisabled = this.isDateDisabled.bind(this), this.isDateUnavailable = this.isDateUnavailable.bind(this), this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this), this.isSelected = this.isSelected.bind(this), ow({
      placeholder: e.placeholder,
      defaultPlaceholder: e.defaultPlaceholder,
      isDateDisabled: e.isDateDisabled,
      maxValue: e.maxValue,
      minValue: e.minValue,
      ref: e.ref
    });
  }
  #p(e) {
    const r = this.opts.value.current, n = e(r);
    this.opts.value.current = n, n.start && n.end && this.opts.onRangeSelect?.current?.();
  }
  #f(e) {
    this.opts.startValue.current = e, this.#p((r) => ({ ...r, start: e }));
  }
  #h(e) {
    this.opts.endValue.current = e, this.#p((r) => ({ ...r, end: e }));
  }
  setMonths = (e) => {
    this.months = e;
  };
  isOutsideVisibleMonths(e) {
    return !this.visibleMonths.some((r) => Lo(e, r));
  }
  isDateDisabled(e) {
    if (this.opts.isDateDisabled.current(e) || this.opts.disabled.current) return !0;
    const r = this.opts.minValue.current, n = this.opts.maxValue.current;
    return !!(r && jt(e, r) || n && K0(e, n));
  }
  isDateUnavailable(e) {
    return !!this.opts.isDateUnavailable.current(e);
  }
  isSelectionStart(e) {
    return this.opts.startValue.current ? _t(e, this.opts.startValue.current) : !1;
  }
  isSelectionEnd(e) {
    return this.opts.endValue.current ? _t(e, this.opts.endValue.current) : !1;
  }
  isSelected(e) {
    return this.opts.startValue.current && _t(this.opts.startValue.current, e) || this.opts.endValue.current && _t(this.opts.endValue.current, e) ? !0 : this.opts.startValue.current && this.opts.endValue.current ? H0(e, this.opts.startValue.current, this.opts.endValue.current) : !1;
  }
  #b(e, r) {
    const n = jt(r, e) ? r : e, s = jt(r, e) ? e : r, o = n.toDate(ft()), a = s.toDate(ft()).getTime() - o.getTime(), u = Math.floor(a / (1e3 * 60 * 60 * 24)) + 1;
    return !(this.opts.minDays.current && u < this.opts.minDays.current || this.opts.maxDays.current && u > this.opts.maxDays.current || this.opts.excludeDisabled.current && this.#_(n, s));
  }
  shiftFocus(e, r) {
    return G0({
      node: e,
      add: r,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #y() {
    this.announcer.announce("Selected date is now empty.", "polite");
  }
  #v(e) {
    this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(e, !1)}`, "polite");
  }
  #S(e, r) {
    this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(e, !1)} to ${this.formatter.selectedDate(r, !1)}`, "polite");
  }
  handleCellClick(e, r) {
    if (this.isDateDisabled(r) || this.isDateUnavailable(r)) return;
    const n = this.lastPressedDateValue;
    if (this.lastPressedDateValue = r, this.opts.startValue.current && this.highlightedRange === null)
      if (_t(this.opts.startValue.current, r) && !this.opts.preventDeselect.current && !this.opts.endValue.current) {
        this.#f(void 0), this.opts.placeholder.current = r, this.#y();
        return;
      } else this.opts.endValue.current || (e.preventDefault(), n && _t(n, r) && (this.#f(r), this.#v(r)));
    if (this.opts.startValue.current && this.opts.endValue.current && _t(this.opts.endValue.current, r) && !this.opts.preventDeselect.current) {
      this.#f(void 0), this.#h(void 0), this.opts.placeholder.current = r, this.#y();
      return;
    }
    if (!this.opts.startValue.current)
      this.#v(r), this.#f(r);
    else if (this.opts.endValue.current)
      this.opts.endValue.current && this.opts.startValue.current && (this.#h(void 0), this.#v(r), this.#f(r));
    else {
      const s = this.opts.startValue.current, o = r, i = jt(o, s) ? o : s, a = jt(o, s) ? s : o;
      this.#b(i, a) ? jt(o, s) ? (this.#f(o), this.#h(s), this.#S(o, s)) : (this.#h(r), this.#S(this.opts.startValue.current, r)) : (this.#f(r), this.#h(void 0), this.#v(r));
    }
  }
  onkeydown(e) {
    return Y0({
      event: e,
      handleCellClick: this.handleCellClick,
      placeholderValue: this.opts.placeholder.current,
      shiftFocus: this.shiftFocus
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    X0({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    J0({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (e) => this.opts.placeholder.current = e,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year: e });
  }
  setMonth(e) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month: e });
  }
  getBitsAttr = (e) => iw.getAttr(e, "range-calendar");
  #w = /* @__PURE__ */ C(() => ({ months: this.months, weekdays: this.weekdays }));
  get snippetProps() {
    return d(this.#w);
  }
  set snippetProps(e) {
    q(this.#w, e);
  }
  #x = /* @__PURE__ */ C(() => ({
    ...sw({
      fullCalendarLabel: this.fullCalendarLabel,
      id: this.opts.id.current,
      isInvalid: this.isInvalid,
      disabled: this.opts.disabled.current,
      readonly: this.opts.readonly.current
    }),
    [this.getBitsAttr("root")]: "",
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#x);
  }
  set props(e) {
    q(this.#x, e);
  }
  #_(e, r) {
    for (let n = e; jt(n, r) || _t(n, r); n = n.add({ days: 1 }))
      if (this.isDateDisabled(n)) return !0;
    return !1;
  }
}
class Lh {
  static create(e) {
    return s1.set(new Lh(e, Ut.get()));
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => yr(this.opts.date.current));
  get cellDate() {
    return d(this.#e);
  }
  set cellDate(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => !Lo(this.opts.date.current, this.opts.month.current));
  get isOutsideMonth() {
    return d(this.#t);
  }
  set isOutsideMonth(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current);
  get isDisabled() {
    return d(this.#r);
  }
  set isDisabled(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => this.root.opts.isDateUnavailable.current(this.opts.date.current));
  get isUnavailable() {
    return d(this.#n);
  }
  set isUnavailable(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => x0(this.opts.date.current, ft()));
  get isDateToday() {
    return d(this.#s);
  }
  set isDateToday(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ C(() => this.root.isOutsideVisibleMonths(this.opts.date.current));
  get isOutsideVisibleMonths() {
    return d(this.#o);
  }
  set isOutsideVisibleMonths(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => _t(this.opts.date.current, this.root.opts.placeholder.current));
  get isFocusedDate() {
    return d(this.#i);
  }
  set isFocusedDate(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ C(() => this.root.isSelected(this.opts.date.current));
  get isSelectedDate() {
    return d(this.#a);
  }
  set isSelectedDate(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ C(() => this.root.isSelectionStart(this.opts.date.current));
  get isSelectionStart() {
    return d(this.#u);
  }
  set isSelectionStart(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ C(() => this.root.isSelectionStart(this.opts.date.current));
  get isRangeStart() {
    return d(this.#l);
  }
  set isRangeStart(e) {
    q(this.#l, e);
  }
  #c = /* @__PURE__ */ C(() => this.root.opts.endValue.current ? this.root.isSelectionEnd(this.opts.date.current) : this.root.isSelectionStart(this.opts.date.current));
  get isRangeEnd() {
    return d(this.#c);
  }
  set isRangeEnd(e) {
    q(this.#c, e);
  }
  #d = /* @__PURE__ */ C(() => this.isSelectionMiddle);
  get isRangeMiddle() {
    return d(this.#d);
  }
  set isRangeMiddle(e) {
    q(this.#d, e);
  }
  #g = /* @__PURE__ */ C(() => this.isSelectedDate && !this.isSelectionStart && !this.isSelectionEnd);
  get isSelectionMiddle() {
    return d(this.#g);
  }
  set isSelectionMiddle(e) {
    q(this.#g, e);
  }
  #m = /* @__PURE__ */ C(() => this.root.isSelectionEnd(this.opts.date.current));
  get isSelectionEnd() {
    return d(this.#m);
  }
  set isSelectionEnd(e) {
    q(this.#m, e);
  }
  #p = /* @__PURE__ */ C(() => this.root.highlightedRange ? H0(this.opts.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : !1);
  get isHighlighted() {
    return d(this.#p);
  }
  set isHighlighted(e) {
    q(this.#p, e);
  }
  #f = /* @__PURE__ */ C(() => this.root.formatter.custom(this.cellDate, {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  }));
  get labelText() {
    return d(this.#f);
  }
  set labelText(e) {
    q(this.#f, e);
  }
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref);
  }
  #h = /* @__PURE__ */ C(() => ({
    disabled: this.isDisabled,
    unavailable: this.isUnavailable,
    selected: this.isSelectedDate
  }));
  get snippetProps() {
    return d(this.#h);
  }
  set snippetProps(e) {
    q(this.#h, e);
  }
  #b = /* @__PURE__ */ C(() => this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable);
  get ariaDisabled() {
    return d(this.#b);
  }
  set ariaDisabled(e) {
    q(this.#b, e);
  }
  #y = /* @__PURE__ */ C(() => ({
    "data-unavailable": Fe(this.isUnavailable),
    "data-today": this.isDateToday ? "" : void 0,
    "data-outside-month": this.isOutsideMonth ? "" : void 0,
    "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
    "data-focused": this.isFocusedDate ? "" : void 0,
    "data-selection-start": this.isSelectionStart ? "" : void 0,
    "data-selection-end": this.isSelectionEnd ? "" : void 0,
    "data-range-start": this.isRangeStart ? "" : void 0,
    "data-range-end": this.isRangeEnd ? "" : void 0,
    "data-range-middle": this.isRangeMiddle ? "" : void 0,
    "data-highlighted": this.isHighlighted ? "" : void 0,
    "data-selected": Fe(this.isSelectedDate),
    "data-value": this.opts.date.current.toString(),
    "data-type": q0(this.opts.date.current),
    "data-disabled": Fe(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
  }));
  get sharedDataAttrs() {
    return d(this.#y);
  }
  set sharedDataAttrs(e) {
    q(this.#y, e);
  }
  #v = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "gridcell",
    "aria-selected": at(this.isSelectedDate),
    "aria-disabled": at(this.ariaDisabled),
    ...this.sharedDataAttrs,
    [this.root.getBitsAttr("cell")]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#v);
  }
  set props(e) {
    q(this.#v, e);
  }
}
class jh {
  static create(e) {
    return new jh(e, s1.get());
  }
  opts;
  cell;
  attachment;
  constructor(e, r) {
    this.opts = e, this.cell = r, this.attachment = Ee(e.ref), this.onclick = this.onclick.bind(this), this.onmouseenter = this.onmouseenter.bind(this), this.onfocusin = this.onfocusin.bind(this);
  }
  #e = /* @__PURE__ */ C(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1);
  onclick(e) {
    this.cell.isDisabled || this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  onmouseenter(e) {
    this.cell.isDisabled || (this.cell.root.focusedValue = this.cell.opts.date.current);
  }
  onfocusin(e) {
    this.cell.isDisabled || (this.cell.root.focusedValue = this.cell.opts.date.current);
  }
  #t = /* @__PURE__ */ C(() => ({
    disabled: this.cell.isDisabled,
    unavailable: this.cell.isUnavailable,
    selected: this.cell.isSelectedDate,
    day: `${this.cell.opts.date.current.day}`
  }));
  get snippetProps() {
    return d(this.#t);
  }
  set snippetProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "button",
    "aria-label": this.cell.labelText,
    "aria-disabled": at(this.cell.ariaDisabled),
    ...this.cell.sharedDataAttrs,
    tabindex: d(this.#e),
    [this.cell.root.getBitsAttr("day")]: "",
    "data-bits-day": "",
    onclick: this.onclick,
    onmouseenter: this.onmouseenter,
    onfocusin: this.onfocusin,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
var mN = /* @__PURE__ */ ne("<td><!></td>");
function o1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "date", 7), l = v(e, "month", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "date",
    "month"
  ]);
  const c = Lh.create({
    id: z(() => o()),
    ref: z(() => i(), (y) => i(y)),
    date: z(() => a()),
    month: z(() => l())
  }), f = /* @__PURE__ */ C(() => Ce(u, c.props));
  var p = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get id() {
      return o();
    },
    set id(y = me(r)) {
      o(y), m();
    },
    get ref() {
      return i();
    },
    set ref(y = null) {
      i(y), m();
    },
    get date() {
      return a();
    },
    set date(y) {
      a(y), m();
    },
    get month() {
      return l();
    },
    set month(y) {
      l(y), m();
    }
  }, _ = I(), b = D(_);
  {
    var g = (y) => {
      var S = I(), x = D(S);
      {
        let P = /* @__PURE__ */ C(() => ({ props: d(f), ...c.snippetProps }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = mN();
      ve(S, () => ({ ...d(f) }));
      var x = he(S);
      te(x, () => n() ?? ge, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(g) : y(h, !1);
    });
  }
  return A(t, _), W(p);
}
K(
  o1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    date: {},
    month: {}
  },
  [],
  [],
  { mode: "open" }
);
var vN = /* @__PURE__ */ ne("<div><!></div>");
function i1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const l = jh.create({
    id: z(() => o()),
    ref: z(() => i(), (g) => i(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get id() {
      return o();
    },
    set id(g = me(r)) {
      o(g), m();
    },
    get ref() {
      return i();
    },
    set ref(g = null) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      {
        let S = /* @__PURE__ */ C(() => ({ props: d(u), ...l.snippetProps }));
        te(y, s, () => d(S));
      }
      A(g, h);
    }, b = (g) => {
      var h = vN();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      {
        var S = (P) => {
          var w = I(), O = D(w);
          te(O, () => n() ?? ge, () => l.snippetProps), A(P, w);
        }, x = (P) => {
          var w = tt();
          ke(() => Me(w, l.cell.opts.date.current.day)), A(P, w);
        };
        ue(y, (P) => {
          n() ? P(S) : P(x, !1);
        });
      }
      de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(i1, { children: {}, child: {}, id: {}, ref: {} }, [], [], { mode: "open" });
function a1(t, e) {
  H(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "onOpenChange", 7, _e), s = v(e, "onOpenChangeComplete", 7, _e), o = v(e, "children", 7);
  nf.create({
    variant: z(() => "dialog"),
    open: z(() => r(), (u) => {
      r(u), n()(u);
    }),
    onOpenChangeComplete: z(() => s())
  });
  var i = {
    get open() {
      return r();
    },
    set open(u = !1) {
      r(u), m();
    },
    get onOpenChange() {
      return n();
    },
    set onOpenChange(u = _e) {
      n(u), m();
    },
    get onOpenChangeComplete() {
      return s();
    },
    set onOpenChangeComplete(u = _e) {
      s(u), m();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), m();
    }
  }, a = I(), l = D(a);
  return te(l, () => o() ?? ge), A(t, a), W(i);
}
K(
  a1,
  {
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var yN = /* @__PURE__ */ ne("<button><!></button>");
function Bh(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "disabled", 7, !1), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "disabled"
  ]);
  const u = of.create({
    variant: z(() => "close"),
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h)),
    disabled: z(() => !!a())
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get disabled() {
      return a();
    },
    set disabled(h = !1) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = yN();
      ve(y, () => ({ ...d(c) }));
      var S = he(y);
      te(S, () => n() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(Bh, { children: {}, child: {}, id: {}, ref: {}, disabled: {} }, [], [], { mode: "open" });
var bN = /* @__PURE__ */ ne("<!> <!>", 1), _N = /* @__PURE__ */ ne("<!> <div><!></div>", 1);
function l1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "ref", 15, null), a = v(e, "forceMount", 7, !1), l = v(e, "onCloseAutoFocus", 7, _e), u = v(e, "onOpenAutoFocus", 7, _e), c = v(e, "onEscapeKeydown", 7, _e), f = v(e, "onInteractOutside", 7, _e), p = v(e, "trapFocus", 7, !0), _ = v(e, "preventScroll", 7, !0), b = v(e, "restoreScrollDelay", 7, null), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "ref",
    "forceMount",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "restoreScrollDelay"
  ]);
  const h = uf.create({
    id: z(() => n()),
    ref: z(() => i(), (O) => i(O))
  }), y = /* @__PURE__ */ C(() => Ce(g, h.props));
  var S = {
    get id() {
      return n();
    },
    set id(O = me(r)) {
      n(O), m();
    },
    get children() {
      return s();
    },
    set children(O) {
      s(O), m();
    },
    get child() {
      return o();
    },
    set child(O) {
      o(O), m();
    },
    get ref() {
      return i();
    },
    set ref(O = null) {
      i(O), m();
    },
    get forceMount() {
      return a();
    },
    set forceMount(O = !1) {
      a(O), m();
    },
    get onCloseAutoFocus() {
      return l();
    },
    set onCloseAutoFocus(O = _e) {
      l(O), m();
    },
    get onOpenAutoFocus() {
      return u();
    },
    set onOpenAutoFocus(O = _e) {
      u(O), m();
    },
    get onEscapeKeydown() {
      return c();
    },
    set onEscapeKeydown(O = _e) {
      c(O), m();
    },
    get onInteractOutside() {
      return f();
    },
    set onInteractOutside(O = _e) {
      f(O), m();
    },
    get trapFocus() {
      return p();
    },
    set trapFocus(O = !0) {
      p(O), m();
    },
    get preventScroll() {
      return _();
    },
    set preventScroll(O = !0) {
      _(O), m();
    },
    get restoreScrollDelay() {
      return b();
    },
    set restoreScrollDelay(O = null) {
      b(O), m();
    }
  }, x = I(), P = D(x);
  {
    var w = (O) => {
      yf(O, {
        get ref() {
          return h.opts.ref;
        },
        loop: !0,
        get trapFocus() {
          return p();
        },
        get enabled() {
          return h.root.opts.open.current;
        },
        get onOpenAutoFocus() {
          return u();
        },
        get onCloseAutoFocus() {
          return l();
        },
        focusScope: ($, T) => {
          let E = () => T?.().props;
          pf($, ce(() => d(y), {
            get enabled() {
              return h.root.opts.open.current;
            },
            get ref() {
              return h.opts.ref;
            },
            onEscapeKeydown: (M) => {
              c()(M), !M.defaultPrevented && h.root.handleClose();
            },
            children: (M, R) => {
              hf(M, ce(() => d(y), {
                get ref() {
                  return h.opts.ref;
                },
                get enabled() {
                  return h.root.opts.open.current;
                },
                onInteractOutside: (U) => {
                  f()(U), !U.defaultPrevented && h.root.handleClose();
                },
                children: (U, B) => {
                  _f(U, ce(() => d(y), {
                    get ref() {
                      return h.opts.ref;
                    },
                    get enabled() {
                      return h.root.opts.open.current;
                    },
                    children: (F, Z) => {
                      var Y = I(), X = D(Y);
                      {
                        var ae = (j) => {
                          var ee = bN(), L = D(ee);
                          {
                            var N = (G) => {
                              Si(G, {
                                get preventScroll() {
                                  return _();
                                },
                                get restoreScrollDelay() {
                                  return b();
                                }
                              });
                            };
                            ue(L, (G) => {
                              h.root.opts.open.current && G(N);
                            });
                          }
                          var V = be(L, 2);
                          {
                            let G = /* @__PURE__ */ C(() => ({
                              props: Ce(d(y), E()),
                              ...h.snippetProps
                            }));
                            te(V, o, () => d(G));
                          }
                          A(j, ee);
                        }, J = (j) => {
                          var ee = _N(), L = D(ee);
                          Si(L, {
                            get preventScroll() {
                              return _();
                            }
                          });
                          var N = be(L, 2);
                          ve(N, (G) => ({ ...G }), [() => Ce(d(y), E())]);
                          var V = he(N);
                          te(V, () => s() ?? ge), de(N), A(j, ee);
                        };
                        ue(X, (j) => {
                          o() ? j(ae) : j(J, !1);
                        });
                      }
                      A(F, Y);
                    },
                    $$slots: { default: !0 }
                  }));
                },
                $$slots: { default: !0 }
              }));
            },
            $$slots: { default: !0 }
          }));
        },
        $$slots: { focusScope: !0 }
      });
    };
    ue(P, (O) => {
      (h.shouldRender || a()) && O(w);
    });
  }
  return A(t, x), W(S);
}
K(
  l1,
  {
    id: {},
    children: {},
    child: {},
    ref: {},
    forceMount: {},
    onCloseAutoFocus: {},
    onOpenAutoFocus: {},
    onEscapeKeydown: {},
    onInteractOutside: {},
    trapFocus: {},
    preventScroll: {},
    restoreScrollDelay: {}
  },
  [],
  [],
  { mode: "open" }
);
const wN = rr({ component: "label", parts: ["root"] });
class zh {
  static create(e) {
    return new zh(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref), this.onmousedown = this.onmousedown.bind(this);
  }
  onmousedown(e) {
    e.detail > 1 && e.preventDefault();
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [wN.root]: "",
    onmousedown: this.onmousedown,
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
var SN = /* @__PURE__ */ ne("<label><!></label>");
function u1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "for", 7), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "for"
  ]);
  const u = zh.create({
    id: z(() => o()),
    ref: z(() => i(), (h) => i(h))
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props, { for: a() }));
  var f = {
    get children() {
      return n();
    },
    set children(h) {
      n(h), m();
    },
    get child() {
      return s();
    },
    set child(h) {
      s(h), m();
    },
    get id() {
      return o();
    },
    set id(h = me(r)) {
      o(h), m();
    },
    get ref() {
      return i();
    },
    set ref(h = null) {
      i(h), m();
    },
    get for() {
      return a();
    },
    set for(h) {
      a(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = I(), S = D(y);
      te(S, s, () => ({ props: d(c) })), A(h, y);
    }, g = (h) => {
      var y = SN();
      ve(y, () => ({ ...d(c), for: a() }));
      var S = he(y);
      te(S, () => n() ?? ge), de(y), A(h, y);
    };
    ue(_, (h) => {
      s() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(u1, { children: {}, child: {}, id: {}, ref: {}, for: {} }, [], [], { mode: "open" });
function c1(t, e) {
  H(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "onOpenChange", 7, _e), s = v(e, "onOpenChangeComplete", 7, _e), o = v(e, "children", 7);
  Ih.create({
    open: z(() => r(), (a) => {
      r(a), n()(a);
    }),
    onOpenChangeComplete: z(() => s())
  });
  var i = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    },
    get onOpenChange() {
      return n();
    },
    set onOpenChange(a = _e) {
      n(a), m();
    },
    get onOpenChangeComplete() {
      return s();
    },
    set onOpenChangeComplete(a = _e) {
      s(a), m();
    },
    get children() {
      return o();
    },
    set children(a) {
      o(a), m();
    }
  };
  return uh(t, {
    children: (a, l) => {
      var u = I(), c = D(u);
      te(c, () => o() ?? ge), A(a, u);
    },
    $$slots: { default: !0 }
  }), W(i);
}
K(
  c1,
  {
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
const Xc = rr({ component: "radio-group", parts: ["root", "item"] }), qh = new ht("RadioGroup.Root");
class Uh {
  static create(e) {
    return qh.set(new Uh(e));
  }
  opts;
  #e = /* @__PURE__ */ C(() => this.opts.value.current !== "");
  get hasValue() {
    return d(this.#e);
  }
  set hasValue(e) {
    q(this.#e, e);
  }
  rovingFocusGroup;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref), this.rovingFocusGroup = new t0({
      rootNode: this.opts.ref,
      candidateAttr: Xc.item,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  isChecked(e) {
    return this.opts.value.current === e;
  }
  setValue(e) {
    this.opts.value.current = e;
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: "radiogroup",
    "aria-required": at(this.opts.required.current),
    "aria-disabled": at(this.opts.disabled.current),
    "aria-readonly": this.opts.readonly.current ? "true" : void 0,
    "data-disabled": Fe(this.opts.disabled.current),
    "data-readonly": Fe(this.opts.readonly.current),
    "data-orientation": this.opts.orientation.current,
    [Xc.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Kh {
  static create(e) {
    return new Kh(e, qh.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => this.root.opts.value.current === this.opts.value.current);
  get checked() {
    return d(this.#e);
  }
  set checked(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.opts.disabled.current || this.root.opts.disabled.current);
  #r = /* @__PURE__ */ C(() => this.root.opts.readonly.current);
  #n = /* @__PURE__ */ C(() => this.root.isChecked(this.opts.value.current));
  #s = /* @__PURE__ */ xe(-1);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref), this.opts.value.current === this.root.opts.value.current ? (this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current), q(this.#s, 0)) : this.root.opts.value.current || q(this.#s, 0), Ze(() => {
      q(this.#s, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), !0);
    }), Ne(
      [
        () => this.opts.value.current,
        () => this.root.opts.value.current
      ],
      () => {
        this.opts.value.current === this.root.opts.value.current && (this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current), q(this.#s, 0));
      }
    ), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this), this.onfocus = this.onfocus.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || d(this.#r) || this.root.setValue(this.opts.value.current);
  }
  onfocus(e) {
    !this.root.hasValue || d(this.#r) || this.root.setValue(this.opts.value.current);
  }
  onkeydown(e) {
    if (!d(this.#t)) {
      if (e.key === wr) {
        e.preventDefault(), d(this.#r) || this.root.setValue(this.opts.value.current);
        return;
      }
      this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e, !0);
    }
  }
  #o = /* @__PURE__ */ C(() => ({ checked: d(this.#n) }));
  get snippetProps() {
    return d(this.#o);
  }
  set snippetProps(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    disabled: d(this.#t) ? !0 : void 0,
    "data-value": this.opts.value.current,
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Fe(d(this.#t)),
    "data-readonly": Fe(d(this.#r)),
    "data-state": d(this.#n) ? "checked" : "unchecked",
    "aria-checked": ou(d(this.#n), !1),
    [Xc.item]: "",
    type: "button",
    role: "radio",
    tabindex: d(this.#s),
    onkeydown: this.onkeydown,
    onfocus: this.onfocus,
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#i);
  }
  set props(e) {
    q(this.#i, e);
  }
}
class Hh {
  static create() {
    return new Hh(qh.get());
  }
  root;
  #e = /* @__PURE__ */ C(() => this.root.opts.name.current !== void 0);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e) {
    this.root = e, this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    this.root.rovingFocusGroup.focusCurrentTabStop();
  }
  #t = /* @__PURE__ */ C(() => ({
    name: this.root.opts.name.current,
    value: this.root.opts.value.current,
    required: this.root.opts.required.current,
    disabled: this.root.opts.disabled.current,
    onfocus: this.onfocus
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function d1(t, e) {
  H(e, !1);
  const r = Hh.create();
  vd();
  var n = I(), s = D(n);
  {
    var o = (i) => {
      zi(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), W();
}
K(d1, {}, [], [], { mode: "open" });
var xN = /* @__PURE__ */ ne("<div><!></div>"), PN = /* @__PURE__ */ ne("<!> <!>", 1);
function f1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "disabled", 7, !1), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "value", 15, ""), a = v(e, "ref", 15, null), l = v(e, "orientation", 7, "vertical"), u = v(e, "loop", 7, !0), c = v(e, "name", 7, void 0), f = v(e, "required", 7, !1), p = v(e, "readonly", 7, !1), _ = v(e, "id", 23, () => me(r)), b = v(e, "onValueChange", 7, _e), g = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "disabled",
    "children",
    "child",
    "value",
    "ref",
    "orientation",
    "loop",
    "name",
    "required",
    "readonly",
    "id",
    "onValueChange"
  ]);
  const h = Uh.create({
    orientation: z(() => l()),
    disabled: z(() => n()),
    loop: z(() => u()),
    name: z(() => c()),
    required: z(() => f()),
    readonly: z(() => p()),
    id: z(() => _()),
    value: z(() => i(), ($) => {
      $ !== i() && (i($), b()?.($));
    }),
    ref: z(() => a(), ($) => a($))
  }), y = /* @__PURE__ */ C(() => Ce(g, h.props));
  var S = {
    get disabled() {
      return n();
    },
    set disabled($ = !1) {
      n($), m();
    },
    get children() {
      return s();
    },
    set children($) {
      s($), m();
    },
    get child() {
      return o();
    },
    set child($) {
      o($), m();
    },
    get value() {
      return i();
    },
    set value($ = "") {
      i($), m();
    },
    get ref() {
      return a();
    },
    set ref($ = null) {
      a($), m();
    },
    get orientation() {
      return l();
    },
    set orientation($ = "vertical") {
      l($), m();
    },
    get loop() {
      return u();
    },
    set loop($ = !0) {
      u($), m();
    },
    get name() {
      return c();
    },
    set name($ = void 0) {
      c($), m();
    },
    get required() {
      return f();
    },
    set required($ = !1) {
      f($), m();
    },
    get readonly() {
      return p();
    },
    set readonly($ = !1) {
      p($), m();
    },
    get id() {
      return _();
    },
    set id($ = me(r)) {
      _($), m();
    },
    get onValueChange() {
      return b();
    },
    set onValueChange($ = _e) {
      b($), m();
    }
  }, x = PN(), P = D(x);
  {
    var w = ($) => {
      var T = I(), E = D(T);
      te(E, o, () => ({ props: d(y) })), A($, T);
    }, O = ($) => {
      var T = xN();
      ve(T, () => ({ ...d(y) }));
      var E = he(T);
      te(E, () => s() ?? ge), de(T), A($, T);
    };
    ue(P, ($) => {
      o() ? $(w) : $(O, !1);
    });
  }
  var k = be(P, 2);
  return d1(k, {}), A(t, x), W(S);
}
K(
  f1,
  {
    disabled: {},
    children: {},
    child: {},
    value: {},
    ref: {},
    orientation: {},
    loop: {},
    name: {},
    required: {},
    readonly: {},
    id: {},
    onValueChange: {}
  },
  [],
  [],
  { mode: "open" }
);
var ON = /* @__PURE__ */ ne("<button><!></button>");
function h1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "children", 7), o = v(e, "child", 7), i = v(e, "value", 7), a = v(e, "disabled", 7, !1), l = v(e, "ref", 15, null), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "children",
    "child",
    "value",
    "disabled",
    "ref"
  ]);
  const c = Kh.create({
    value: z(() => i()),
    disabled: z(() => a() ?? !1),
    id: z(() => n()),
    ref: z(() => l(), (y) => l(y))
  }), f = /* @__PURE__ */ C(() => Ce(u, c.props));
  var p = {
    get id() {
      return n();
    },
    set id(y = me(r)) {
      n(y), m();
    },
    get children() {
      return s();
    },
    set children(y) {
      s(y), m();
    },
    get child() {
      return o();
    },
    set child(y) {
      o(y), m();
    },
    get value() {
      return i();
    },
    set value(y) {
      i(y), m();
    },
    get disabled() {
      return a();
    },
    set disabled(y = !1) {
      a(y), m();
    },
    get ref() {
      return l();
    },
    set ref(y = null) {
      l(y), m();
    }
  }, _ = I(), b = D(_);
  {
    var g = (y) => {
      var S = I(), x = D(S);
      {
        let P = /* @__PURE__ */ C(() => ({ props: d(f), ...c.snippetProps }));
        te(x, o, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = ON();
      ve(S, () => ({ ...d(f) }));
      var x = he(S);
      te(x, () => s() ?? ge, () => c.snippetProps), de(S), A(y, S);
    };
    ue(b, (y) => {
      o() ? y(g) : y(h, !1);
    });
  }
  return A(t, _), W(p);
}
K(
  h1,
  {
    id: {},
    children: {},
    child: {},
    value: {},
    disabled: {},
    ref: {}
  },
  [],
  [],
  { mode: "open" }
);
var CN = /* @__PURE__ */ ne("<div><!></div>");
function g1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "value", 15), l = v(e, "onValueChange", 7, _e), u = v(e, "placeholder", 15), c = v(e, "onPlaceholderChange", 7, _e), f = v(e, "weekdayFormat", 7, "narrow"), p = v(e, "weekStartsOn", 7), _ = v(e, "pagedNavigation", 7, !1), b = v(e, "isDateDisabled", 7, () => !1), g = v(e, "isDateUnavailable", 7, () => !1), h = v(e, "fixedWeeks", 7, !1), y = v(e, "numberOfMonths", 7, 1), S = v(e, "locale", 7), x = v(e, "calendarLabel", 7, "Event"), P = v(e, "disabled", 7, !1), w = v(e, "readonly", 7, !1), O = v(e, "minValue", 7, void 0), k = v(e, "maxValue", 7, void 0), $ = v(e, "preventDeselect", 7, !1), T = v(e, "disableDaysOutsideMonth", 7, !0), E = v(e, "minDays", 7), M = v(e, "maxDays", 7), R = v(e, "onStartValueChange", 7, _e), U = v(e, "onEndValueChange", 7, _e), B = v(e, "excludeDisabled", 7, !1), F = v(e, "monthFormat", 7, "long"), Z = v(e, "yearFormat", 7, "numeric"), Y = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "disableDaysOutsideMonth",
    "minDays",
    "maxDays",
    "onStartValueChange",
    "onEndValueChange",
    "excludeDisabled",
    "monthFormat",
    "yearFormat"
  ]), X = /* @__PURE__ */ xe(Pt(a()?.start)), ae = /* @__PURE__ */ xe(Pt(a()?.end));
  const J = B0({
    defaultValue: a()?.start,
    minValue: O(),
    maxValue: k()
  });
  function j() {
    u() === void 0 && u(J);
  }
  j(), Ne.pre(() => u(), () => {
    j();
  });
  function ee() {
    a() === void 0 && a({ start: void 0, end: void 0 });
  }
  ee(), Ne.pre(() => a(), () => {
    ee();
  });
  const L = Vh.create({
    id: z(() => o()),
    ref: z(() => i(), (le) => i(le)),
    value: z(() => a(), (le) => {
      a(le), l()(le);
    }),
    placeholder: z(() => u(), (le) => {
      u(le), c()(le);
    }),
    disabled: z(() => P()),
    readonly: z(() => w()),
    preventDeselect: z(() => $()),
    minValue: z(() => O()),
    maxValue: z(() => k()),
    isDateUnavailable: z(() => g()),
    isDateDisabled: z(() => b()),
    pagedNavigation: z(() => _()),
    weekStartsOn: z(() => p()),
    weekdayFormat: z(() => f()),
    numberOfMonths: z(() => y()),
    locale: o0(() => S()),
    calendarLabel: z(() => x()),
    fixedWeeks: z(() => h()),
    disableDaysOutsideMonth: z(() => T()),
    minDays: z(() => E()),
    maxDays: z(() => M()),
    excludeDisabled: z(() => B()),
    startValue: z(() => d(X), (le) => {
      q(X, le, !0), R()(le);
    }),
    endValue: z(() => d(ae), (le) => {
      q(ae, le, !0), U()(le);
    }),
    monthFormat: z(() => F()),
    yearFormat: z(() => Z()),
    defaultPlaceholder: J
  }), N = /* @__PURE__ */ C(() => Ce(Y, L.props));
  var V = {
    get children() {
      return n();
    },
    set children(le) {
      n(le), m();
    },
    get child() {
      return s();
    },
    set child(le) {
      s(le), m();
    },
    get id() {
      return o();
    },
    set id(le = me(r)) {
      o(le), m();
    },
    get ref() {
      return i();
    },
    set ref(le = null) {
      i(le), m();
    },
    get value() {
      return a();
    },
    set value(le) {
      a(le), m();
    },
    get onValueChange() {
      return l();
    },
    set onValueChange(le = _e) {
      l(le), m();
    },
    get placeholder() {
      return u();
    },
    set placeholder(le) {
      u(le), m();
    },
    get onPlaceholderChange() {
      return c();
    },
    set onPlaceholderChange(le = _e) {
      c(le), m();
    },
    get weekdayFormat() {
      return f();
    },
    set weekdayFormat(le = "narrow") {
      f(le), m();
    },
    get weekStartsOn() {
      return p();
    },
    set weekStartsOn(le) {
      p(le), m();
    },
    get pagedNavigation() {
      return _();
    },
    set pagedNavigation(le = !1) {
      _(le), m();
    },
    get isDateDisabled() {
      return b();
    },
    set isDateDisabled(le = () => !1) {
      b(le), m();
    },
    get isDateUnavailable() {
      return g();
    },
    set isDateUnavailable(le = () => !1) {
      g(le), m();
    },
    get fixedWeeks() {
      return h();
    },
    set fixedWeeks(le = !1) {
      h(le), m();
    },
    get numberOfMonths() {
      return y();
    },
    set numberOfMonths(le = 1) {
      y(le), m();
    },
    get locale() {
      return S();
    },
    set locale(le) {
      S(le), m();
    },
    get calendarLabel() {
      return x();
    },
    set calendarLabel(le = "Event") {
      x(le), m();
    },
    get disabled() {
      return P();
    },
    set disabled(le = !1) {
      P(le), m();
    },
    get readonly() {
      return w();
    },
    set readonly(le = !1) {
      w(le), m();
    },
    get minValue() {
      return O();
    },
    set minValue(le = void 0) {
      O(le), m();
    },
    get maxValue() {
      return k();
    },
    set maxValue(le = void 0) {
      k(le), m();
    },
    get preventDeselect() {
      return $();
    },
    set preventDeselect(le = !1) {
      $(le), m();
    },
    get disableDaysOutsideMonth() {
      return T();
    },
    set disableDaysOutsideMonth(le = !0) {
      T(le), m();
    },
    get minDays() {
      return E();
    },
    set minDays(le) {
      E(le), m();
    },
    get maxDays() {
      return M();
    },
    set maxDays(le) {
      M(le), m();
    },
    get onStartValueChange() {
      return R();
    },
    set onStartValueChange(le = _e) {
      R(le), m();
    },
    get onEndValueChange() {
      return U();
    },
    set onEndValueChange(le = _e) {
      U(le), m();
    },
    get excludeDisabled() {
      return B();
    },
    set excludeDisabled(le = !1) {
      B(le), m();
    },
    get monthFormat() {
      return F();
    },
    set monthFormat(le = "long") {
      F(le), m();
    },
    get yearFormat() {
      return Z();
    },
    set yearFormat(le = "numeric") {
      Z(le), m();
    }
  }, G = I(), fe = D(G);
  {
    var se = (le) => {
      var re = I(), oe = D(re);
      {
        let pe = /* @__PURE__ */ C(() => ({ props: d(N), ...L.snippetProps }));
        te(oe, s, () => d(pe));
      }
      A(le, re);
    }, we = (le) => {
      var re = CN();
      ve(re, () => ({ ...d(N) }));
      var oe = he(re);
      te(oe, () => n() ?? ge, () => L.snippetProps), de(re), A(le, re);
    };
    ue(fe, (le) => {
      s() ? le(se) : le(we, !1);
    });
  }
  return A(t, G), W(V);
}
K(
  g1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    placeholder: {},
    onPlaceholderChange: {},
    weekdayFormat: {},
    weekStartsOn: {},
    pagedNavigation: {},
    isDateDisabled: {},
    isDateUnavailable: {},
    fixedWeeks: {},
    numberOfMonths: {},
    locale: {},
    calendarLabel: {},
    disabled: {},
    readonly: {},
    minValue: {},
    maxValue: {},
    preventDeselect: {},
    disableDaysOutsideMonth: {},
    minDays: {},
    maxDays: {},
    onStartValueChange: {},
    onEndValueChange: {},
    excludeDisabled: {},
    monthFormat: {},
    yearFormat: {}
  },
  [],
  [],
  { mode: "open" }
);
var kN = /* @__PURE__ */ ne("<!> <!>", 1);
function p1(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "onValueChange", 7, _e), s = v(e, "name", 7, ""), o = v(e, "disabled", 7, !1), i = v(e, "type", 7), a = v(e, "open", 15, !1), l = v(e, "onOpenChange", 7, _e), u = v(e, "onOpenChangeComplete", 7, _e), c = v(e, "loop", 7, !1), f = v(e, "scrollAlignment", 7, "nearest"), p = v(e, "required", 7, !1), _ = v(e, "items", 23, () => []), b = v(e, "allowDeselect", 7, !1), g = v(e, "autocomplete", 7), h = v(e, "children", 7);
  function y() {
    r() === void 0 && r(i() === "single" ? "" : []);
  }
  y(), Ne.pre(() => r(), () => {
    y();
  });
  let S = /* @__PURE__ */ xe("");
  const x = wI.create({
    type: i(),
    value: z(() => r(), (E) => {
      r(E), n()(E);
    }),
    disabled: z(() => o()),
    required: z(() => p()),
    open: z(() => a(), (E) => {
      a(E), l()(E);
    }),
    loop: z(() => c()),
    scrollAlignment: z(() => f()),
    name: z(() => s()),
    isCombobox: !1,
    items: z(() => _()),
    allowDeselect: z(() => b()),
    inputValue: z(() => d(S), (E) => q(S, E, !0)),
    onOpenChangeComplete: z(() => u())
  });
  var P = {
    get value() {
      return r();
    },
    set value(E) {
      r(E), m();
    },
    get onValueChange() {
      return n();
    },
    set onValueChange(E = _e) {
      n(E), m();
    },
    get name() {
      return s();
    },
    set name(E = "") {
      s(E), m();
    },
    get disabled() {
      return o();
    },
    set disabled(E = !1) {
      o(E), m();
    },
    get type() {
      return i();
    },
    set type(E) {
      i(E), m();
    },
    get open() {
      return a();
    },
    set open(E = !1) {
      a(E), m();
    },
    get onOpenChange() {
      return l();
    },
    set onOpenChange(E = _e) {
      l(E), m();
    },
    get onOpenChangeComplete() {
      return u();
    },
    set onOpenChangeComplete(E = _e) {
      u(E), m();
    },
    get loop() {
      return c();
    },
    set loop(E = !1) {
      c(E), m();
    },
    get scrollAlignment() {
      return f();
    },
    set scrollAlignment(E = "nearest") {
      f(E), m();
    },
    get required() {
      return p();
    },
    set required(E = !1) {
      p(E), m();
    },
    get items() {
      return _();
    },
    set items(E = []) {
      _(E), m();
    },
    get allowDeselect() {
      return b();
    },
    set allowDeselect(E = !1) {
      b(E), m();
    },
    get autocomplete() {
      return g();
    },
    set autocomplete(E) {
      g(E), m();
    },
    get children() {
      return h();
    },
    set children(E) {
      h(E), m();
    }
  }, w = kN(), O = D(w);
  uh(O, {
    children: (E, M) => {
      var R = I(), U = D(R);
      te(U, () => h() ?? ge), A(E, R);
    },
    $$slots: { default: !0 }
  });
  var k = be(O, 2);
  {
    var $ = (E) => {
      var M = I(), R = D(M);
      {
        var U = (F) => {
          Xa(F, {
            get autocomplete() {
              return g();
            }
          });
        }, B = (F) => {
          var Z = I(), Y = D(Z);
          st(Y, 16, () => x.opts.value.current, (X) => X, (X, ae) => {
            Xa(X, {
              get value() {
                return ae;
              },
              get autocomplete() {
                return g();
              }
            });
          }), A(F, Z);
        };
        ue(R, (F) => {
          x.opts.value.current.length === 0 ? F(U) : F(B, !1);
        });
      }
      A(E, M);
    }, T = (E) => {
      Xa(E, {
        get autocomplete() {
          return g();
        },
        get value() {
          return x.opts.value.current;
        },
        set value(M) {
          x.opts.value.current = M;
        }
      });
    };
    ue(k, (E) => {
      Array.isArray(x.opts.value.current) ? E($) : E(T, !1);
    });
  }
  return A(t, w), W(P);
}
K(
  p1,
  {
    value: {},
    onValueChange: {},
    name: {},
    disabled: {},
    type: {},
    open: {},
    onOpenChange: {},
    onOpenChangeComplete: {},
    loop: {},
    scrollAlignment: {},
    required: {},
    items: {},
    allowDeselect: {},
    autocomplete: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var $N = /* @__PURE__ */ ne("<button><!></button>");
function m1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "child", 7), i = v(e, "children", 7), a = v(e, "type", 7, "button"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "child",
    "children",
    "type"
  ]);
  const u = ch.create({
    id: z(() => n()),
    ref: z(() => s(), (b) => s(b))
  }), c = /* @__PURE__ */ C(() => Ce(l, u.props, { type: a() }));
  var f = {
    get id() {
      return n();
    },
    set id(b = me(r)) {
      n(b), m();
    },
    get ref() {
      return s();
    },
    set ref(b = null) {
      s(b), m();
    },
    get child() {
      return o();
    },
    set child(b) {
      o(b), m();
    },
    get children() {
      return i();
    },
    set children(b) {
      i(b), m();
    },
    get type() {
      return a();
    },
    set type(b = "button") {
      a(b), m();
    }
  }, p = I(), _ = D(p);
  return Q(_, () => bh, (b, g) => {
    g(b, {
      get id() {
        return n();
      },
      get ref() {
        return u.opts.ref;
      },
      children: (h, y) => {
        var S = I(), x = D(S);
        {
          var P = (O) => {
            var k = I(), $ = D(k);
            te($, o, () => ({ props: d(c) })), A(O, k);
          }, w = (O) => {
            var k = $N();
            ve(k, () => ({ ...d(c) }));
            var $ = he(k);
            te($, () => i() ?? ge), de(k), A(O, k);
          };
          ue(x, (O) => {
            o() ? O(P) : O(w, !1);
          });
        }
        A(h, S);
      },
      $$slots: { default: !0 }
    });
  }), A(t, p), W(f);
}
K(m1, { id: {}, ref: {}, child: {}, children: {}, type: {} }, [], [], { mode: "open" });
function Xm(t, e, r) {
  const n = {
    position: "absolute"
  };
  return t === "lr" ? (n.left = `${e}%`, n.right = `${r}%`) : t === "rl" ? (n.right = `${e}%`, n.left = `${r}%`) : t === "bt" ? (n.bottom = `${e}%`, n.top = `${r}%`) : (n.top = `${e}%`, n.bottom = `${r}%`), n;
}
function v1(t, e) {
  const r = {
    position: "absolute"
  };
  return t === "lr" ? (r.left = `${e}%`, r.translate = "-50% 0") : t === "rl" ? (r.right = `${e}%`, r.translate = "50% 0") : t === "bt" ? (r.bottom = `${e}%`, r.translate = "0 50%") : (r.top = `${e}%`, r.translate = "0 -50%"), r;
}
function y1(t, e, r) {
  const n = {
    position: "absolute"
  };
  return t === "lr" ? (n.left = `${e}%`, n.translate = `${r}% 0`) : t === "rl" ? (n.right = `${e}%`, n.translate = `${-r}% 0`) : t === "bt" ? (n.bottom = `${e}%`, n.translate = `0 ${-r}%`) : (n.top = `${e}%`, n.translate = `0 ${r}%`), n;
}
function AN(t) {
  if (Math.floor(t) === t)
    return 0;
  const e = t.toString();
  if (e.indexOf(".") !== -1 && e.indexOf("e-") === -1)
    return e.split(".")[1].length;
  if (e.indexOf("e-") !== -1) {
    const r = e.split("e-");
    return parseInt(r[1], 10);
  }
  return 0;
}
function EN(t, e) {
  const r = Math.pow(10, e);
  return Math.round(t * r) / r;
}
function Wh(t, e, r) {
  if (typeof t == "number") {
    const n = r - e;
    let s = Math.ceil(n / t);
    const o = AN(t), i = Math.pow(10, o), a = Math.round(n * i), l = Math.round(t * i);
    a % l === 0 && s++;
    const u = [];
    for (let c = 0; c < s; c++) {
      const f = e + c * t, p = EN(f, o);
      u.push(p);
    }
    return u;
  }
  return [...new Set(t)].filter((n) => n >= e && n <= r).sort((n, s) => n - s);
}
function $s(t, e) {
  if (e.length === 0)
    return t;
  let r = e[0], n = Math.abs(t - r);
  for (const s of e) {
    const o = Math.abs(t - s);
    o < n && (n = o, r = s);
  }
  return r;
}
function Ba(t, e, r) {
  const n = e.indexOf(t);
  return n === -1 ? $s(t, e) : r === "next" ? n < e.length - 1 ? e[n + 1] : t : n > 0 ? e[n - 1] : t;
}
function TN(t, e, r = !0) {
  const [n, s] = t, [o, i] = e, a = (i - o) / (s - n);
  return (l) => {
    const u = o + a * (l - n);
    return r ? u > Math.max(o, i) ? Math.max(o, i) : u < Math.min(o, i) ? Math.min(o, i) : u : u;
  };
}
const Yn = rr({
  component: "slider",
  parts: [
    "root",
    "thumb",
    "range",
    "tick",
    "tick-label",
    "thumb-label"
  ]
}), Gh = new ht("Slider.Root");
class b1 {
  opts;
  attachment;
  #e = /* @__PURE__ */ xe(!1);
  get isActive() {
    return d(this.#e);
  }
  set isActive(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ C(() => this.opts.orientation.current === "horizontal" ? this.opts.dir.current === "rtl" ? "rl" : "lr" : this.opts.dir.current === "rtl" ? "tb" : "bt");
  get direction() {
    return d(this.#t);
  }
  set direction(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => Wh(this.opts.step.current, this.opts.min.current, this.opts.max.current));
  get normalizedSteps() {
    return d(this.#r);
  }
  set normalizedSteps(e) {
    q(this.#r, e);
  }
  domContext;
  constructor(e) {
    this.opts = e, this.attachment = Ee(e.ref), this.domContext = new Nn(this.opts.ref);
  }
  isThumbActive(e) {
    return this.isActive;
  }
  #n = /* @__PURE__ */ C(() => {
    if (!this.opts.disabled.current)
      return this.opts.orientation.current === "horizontal" ? "pan-y" : "pan-x";
  });
  getAllThumbs = () => {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Yn.selector("thumb"))) : [];
  };
  getThumbScale = () => {
    const e = this.opts.trackPadding?.current;
    if (e !== void 0 && e > 0)
      return [e, 100 - e];
    if (this.opts.thumbPositioning.current === "exact")
      return [0, 100];
    const r = this.opts.orientation.current === "vertical", n = this.getAllThumbs()[0], s = r ? n?.offsetHeight : n?.offsetWidth;
    if (s === void 0 || Number.isNaN(s) || s === 0) return [0, 100];
    const o = r ? this.opts.ref.current?.offsetHeight : this.opts.ref.current?.offsetWidth;
    if (o === void 0 || Number.isNaN(o) || o === 0) return [0, 100];
    const i = s / 2 / o * 100, a = i, l = 100 - i;
    return [a, l];
  };
  getPositionFromValue = (e) => {
    const r = this.getThumbScale();
    return TN([this.opts.min.current, this.opts.max.current], r)(e);
  };
  #s = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-orientation": this.opts.orientation.current,
    "data-disabled": Fe(this.opts.disabled.current),
    style: { touchAction: d(this.#n) },
    [Yn.root]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#s);
  }
  set props(e) {
    q(this.#s, e);
  }
}
class DN extends b1 {
  opts;
  isMulti = !1;
  constructor(e) {
    super(e), this.opts = e, Zd(() => ks(Ye(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), Ye(this.domContext.getDocument(), "pointerup", this.handlePointerUp), Ye(this.domContext.getDocument(), "pointermove", this.handlePointerMove), Ye(this.domContext.getDocument(), "pointerleave", this.handlePointerUp))), Ne(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([r, n, s, o]) => {
        const i = Wh(r, n, s), a = (u) => i.includes(u), l = (u) => $s(u, i);
        a(o) || (this.opts.value.current = l(o));
      }
    );
  }
  isTickValueSelected = (e) => this.opts.value.current === e;
  applyPosition({ clientXY: e, start: r, end: n }) {
    const s = this.opts.min.current, o = this.opts.max.current, a = (e - r) / (n - r) * (o - s) + s;
    if (a < s)
      this.updateValue(s);
    else if (a > o)
      this.updateValue(o);
    else {
      const l = this.normalizedSteps, u = $s(a, l);
      this.updateValue(u);
    }
  }
  updateValue = (e) => {
    this.opts.value.current = $s(e, this.normalizedSteps);
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault(), e.stopPropagation();
    const r = this.opts.ref.current, n = this.getAllThumbs()[0];
    if (!r || !n) return;
    n.focus();
    const { left: s, right: o, top: i, bottom: a } = r.getBoundingClientRect();
    this.direction === "lr" ? this.applyPosition({ clientXY: e.clientX, start: s, end: o }) : this.direction === "rl" ? this.applyPosition({ clientXY: e.clientX, start: o, end: s }) : this.direction === "bt" ? this.applyPosition({ clientXY: e.clientY, start: a, end: i }) : this.direction === "tb" && this.applyPosition({ clientXY: e.clientY, start: i, end: a });
  };
  handlePointerDown = (e) => {
    if (e.button !== 0 || this.opts.disabled.current) return;
    const r = this.opts.ref.current, n = this.getAllThumbs()[0];
    if (!n || !r) return;
    const s = e.composedPath()[0] ?? e.target;
    !rf(s) || !r.contains(s) || (e.preventDefault(), n.focus(), this.isActive = !0, this.handlePointerMove(e));
  };
  handlePointerUp = () => {
    this.opts.disabled.current || (this.isActive && this.opts.onValueCommit.current(ot(() => this.opts.value.current)), this.isActive = !1);
  };
  #e = /* @__PURE__ */ C(() => {
    const e = this.opts.value.current;
    return Array.from({ length: 1 }, () => {
      const r = e, n = this.getPositionFromValue(r), s = v1(this.direction, n);
      return {
        role: "slider",
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": r,
        "aria-disabled": at(this.opts.disabled.current),
        "aria-orientation": this.opts.orientation.current,
        "data-value": r,
        "data-orientation": this.opts.orientation.current,
        style: s,
        [Yn.thumb]: ""
      };
    });
  });
  get thumbsPropsArr() {
    return d(this.#e);
  }
  set thumbsPropsArr(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => this.thumbsPropsArr.map((e, r) => r));
  get thumbsRenderArr() {
    return d(this.#t);
  }
  set thumbsRenderArr(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => {
    const e = this.normalizedSteps, r = this.opts.value.current;
    return e.map((n, s) => {
      const o = this.getPositionFromValue(n), i = s === 0, a = s === e.length - 1, l = i ? 0 : a ? -100 : -50, u = y1(this.direction, o, l), c = n <= r;
      return {
        "data-disabled": Fe(this.opts.disabled.current),
        "data-orientation": this.opts.orientation.current,
        "data-bounded": c ? "" : void 0,
        "data-value": n,
        "data-selected": this.isTickValueSelected(n) ? "" : void 0,
        style: u,
        [Yn.tick]: ""
      };
    });
  });
  get ticksPropsArr() {
    return d(this.#r);
  }
  set ticksPropsArr(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => this.ticksPropsArr.map((e, r) => r));
  get ticksRenderArr() {
    return d(this.#n);
  }
  set ticksRenderArr(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => this.ticksPropsArr.map((e, r) => ({ value: e["data-value"], index: r })));
  get tickItemsArr() {
    return d(this.#s);
  }
  set tickItemsArr(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ C(() => [{ value: this.opts.value.current, index: 0 }]);
  get thumbItemsArr() {
    return d(this.#o);
  }
  set thumbItemsArr(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => ({
    ticks: this.ticksRenderArr,
    thumbs: this.thumbsRenderArr,
    tickItems: this.tickItemsArr,
    thumbItems: this.thumbItemsArr
  }));
  get snippetProps() {
    return d(this.#i);
  }
  set snippetProps(e) {
    q(this.#i, e);
  }
}
class MN extends b1 {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ xe(null);
  get activeThumb() {
    return d(this.#e);
  }
  set activeThumb(e) {
    q(this.#e, e, !0);
  }
  #t = /* @__PURE__ */ xe(0);
  get currentThumbIdx() {
    return d(this.#t);
  }
  set currentThumbIdx(e) {
    q(this.#t, e, !0);
  }
  constructor(e) {
    super(e), this.opts = e, Zd(() => ks(Ye(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), Ye(this.domContext.getDocument(), "pointerup", this.handlePointerUp), Ye(this.domContext.getDocument(), "pointermove", this.handlePointerMove), Ye(this.domContext.getDocument(), "pointerleave", this.handlePointerUp))), Ne(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([r, n, s, o]) => {
        const i = Wh(r, n, s), a = (u) => i.includes(u), l = (u) => $s(u, i);
        o.some((u) => !a(u)) && (this.opts.value.current = o.map(l));
      }
    );
  }
  isTickValueSelected = (e) => this.opts.value.current.includes(e);
  isThumbActive(e) {
    return this.isActive && this.activeThumb?.idx === e;
  }
  applyPosition({ clientXY: e, activeThumbIdx: r, start: n, end: s }) {
    const o = this.opts.min.current, i = this.opts.max.current, l = (e - n) / (s - n) * (i - o) + o;
    if (l < o)
      this.updateValue(o, r);
    else if (l > i)
      this.updateValue(i, r);
    else {
      const u = this.normalizedSteps, c = $s(l, u);
      this.updateValue(c, r);
    }
  }
  #r = (e) => {
    const r = this.getAllThumbs();
    if (!r.length) return;
    for (const i of r)
      i.blur();
    const n = r.map((i) => {
      if (this.opts.orientation.current === "horizontal") {
        const { left: a, right: l } = i.getBoundingClientRect();
        return Math.abs(e.clientX - (a + l) / 2);
      } else {
        const { top: a, bottom: l } = i.getBoundingClientRect();
        return Math.abs(e.clientY - (a + l) / 2);
      }
    }), s = r[n.indexOf(Math.min(...n))], o = r.indexOf(s);
    return { node: s, idx: o };
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault(), e.stopPropagation();
    const r = this.opts.ref.current, n = this.activeThumb;
    if (!r || !n) return;
    n.node.focus();
    const { left: s, right: o, top: i, bottom: a } = r.getBoundingClientRect(), l = this.direction;
    l === "lr" ? this.applyPosition({
      clientXY: e.clientX,
      activeThumbIdx: n.idx,
      start: s,
      end: o
    }) : l === "rl" ? this.applyPosition({
      clientXY: e.clientX,
      activeThumbIdx: n.idx,
      start: o,
      end: s
    }) : l === "bt" ? this.applyPosition({
      clientXY: e.clientY,
      activeThumbIdx: n.idx,
      start: a,
      end: i
    }) : l === "tb" && this.applyPosition({
      clientXY: e.clientY,
      activeThumbIdx: n.idx,
      start: i,
      end: a
    });
  };
  handlePointerDown = (e) => {
    if (e.button !== 0 || this.opts.disabled.current) return;
    const r = this.opts.ref.current, n = this.#r(e);
    if (!n || !r) return;
    const s = e.composedPath()[0] ?? e.target;
    !rf(s) || !r.contains(s) || (e.preventDefault(), this.activeThumb = n, n.node.focus(), this.isActive = !0, this.handlePointerMove(e));
  };
  handlePointerUp = () => {
    this.opts.disabled.current || (this.isActive && this.opts.onValueCommit.current(ot(() => this.opts.value.current)), this.isActive = !1);
  };
  getAllThumbs = () => {
    const e = this.opts.ref.current;
    return e ? Array.from(e.querySelectorAll(Yn.selector("thumb"))) : [];
  };
  updateValue = (e, r) => {
    const n = this.opts.value.current;
    if (!n.length) {
      this.opts.value.current.push(e);
      return;
    }
    if (n[r] === e) return;
    const o = [...n];
    if (!Wa(r, o)) return;
    const i = o[r] > e ? -1 : 1, a = () => {
      const u = r + i;
      o[r] = o[u], o[u] = e;
      const c = this.getAllThumbs();
      c.length && (c[u]?.focus(), this.activeThumb = { node: c[u], idx: u });
    };
    if (this.opts.autoSort.current && (i === -1 && e < o[r - 1] || i === 1 && e > o[r + 1])) {
      a(), this.opts.value.current = o;
      return;
    }
    const l = this.normalizedSteps;
    o[r] = $s(e, l), this.opts.value.current = o;
  };
  #n = /* @__PURE__ */ C(() => {
    const e = this.opts.value.current;
    return Array.from({ length: e.length || 1 }, (r, n) => {
      const s = ot(() => this.currentThumbIdx);
      s < e.length && ot(() => {
        this.currentThumbIdx = s + 1;
      });
      const o = e[n], i = this.getPositionFromValue(o ?? 0), a = v1(this.direction, i);
      return {
        role: "slider",
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": o,
        "aria-disabled": at(this.opts.disabled.current),
        "aria-orientation": this.opts.orientation.current,
        "data-value": o,
        "data-orientation": this.opts.orientation.current,
        style: a,
        [Yn.thumb]: ""
      };
    });
  });
  get thumbsPropsArr() {
    return d(this.#n);
  }
  set thumbsPropsArr(e) {
    q(this.#n, e);
  }
  #s = /* @__PURE__ */ C(() => this.thumbsPropsArr.map((e, r) => r));
  get thumbsRenderArr() {
    return d(this.#s);
  }
  set thumbsRenderArr(e) {
    q(this.#s, e);
  }
  #o = /* @__PURE__ */ C(() => {
    const e = this.normalizedSteps, r = this.opts.value.current;
    return e.map((n, s) => {
      const o = this.getPositionFromValue(n), i = s === 0, a = s === e.length - 1, l = i ? 0 : a ? -100 : -50, u = y1(this.direction, o, l), c = r.length === 1 ? n <= r[0] : r[0] <= n && n <= r[r.length - 1];
      return {
        "data-disabled": Fe(this.opts.disabled.current),
        "data-orientation": this.opts.orientation.current,
        "data-bounded": c ? "" : void 0,
        "data-value": n,
        style: u,
        [Yn.tick]: ""
      };
    });
  });
  get ticksPropsArr() {
    return d(this.#o);
  }
  set ticksPropsArr(e) {
    q(this.#o, e);
  }
  #i = /* @__PURE__ */ C(() => this.ticksPropsArr.map((e, r) => r));
  get ticksRenderArr() {
    return d(this.#i);
  }
  set ticksRenderArr(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ C(() => this.ticksPropsArr.map((e, r) => ({ value: e["data-value"], index: r })));
  get tickItemsArr() {
    return d(this.#a);
  }
  set tickItemsArr(e) {
    q(this.#a, e);
  }
  #u = /* @__PURE__ */ C(() => this.opts.value.current.map((r, n) => ({ value: r, index: n })));
  get thumbItemsArr() {
    return d(this.#u);
  }
  set thumbItemsArr(e) {
    q(this.#u, e);
  }
  #l = /* @__PURE__ */ C(() => ({
    ticks: this.ticksRenderArr,
    thumbs: this.thumbsRenderArr,
    tickItems: this.tickItemsArr,
    thumbItems: this.thumbItemsArr
  }));
  get snippetProps() {
    return d(this.#l);
  }
  set snippetProps(e) {
    q(this.#l, e);
  }
}
class IN {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new DN(n) : new MN(n);
    return Gh.set(s);
  }
}
const NN = [
  ls,
  us,
  Qt,
  cr,
  Vo,
  Ro
];
class Yh {
  static create(e) {
    return new Yh(e, Gh.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref);
  }
  #e = /* @__PURE__ */ C(() => {
    if (Array.isArray(this.root.opts.value.current)) {
      const e = this.root.opts.value.current.length > 1 ? this.root.getPositionFromValue(Math.min(...this.root.opts.value.current) ?? 0) : 0, r = 100 - this.root.getPositionFromValue(Math.max(...this.root.opts.value.current) ?? 0);
      return {
        position: "absolute",
        ...Xm(this.root.direction, e, r)
      };
    } else {
      const e = this.root.opts.trackPadding?.current, r = this.root.opts.value.current, n = this.root.opts.max.current, s = 0, o = e !== void 0 && e > 0 && r === n ? 0 : (
        // 100% - 0% = full width
        100 - this.root.getPositionFromValue(r)
      );
      return {
        position: "absolute",
        ...Xm(this.root.direction, s, o)
      };
    }
  });
  get rangeStyles() {
    return d(this.#e);
  }
  set rangeStyles(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Fe(this.root.opts.disabled.current),
    style: this.rangeStyles,
    [Yn.range]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class Xh {
  static create(e) {
    return new Xh(e, Gh.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => this.root.opts.disabled.current || this.opts.disabled.current);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref), this.onkeydown = this.onkeydown.bind(this);
  }
  #t(e) {
    this.root.isMulti ? this.root.updateValue(e, this.opts.index.current) : this.root.updateValue(e);
  }
  onkeydown(e) {
    if (d(this.#e)) return;
    const r = this.opts.ref.current;
    if (!r) return;
    const n = this.root.getAllThumbs();
    if (!n.length) return;
    const s = n.indexOf(r);
    if (this.root.isMulti && (this.root.currentThumbIdx = s), !NN.includes(e.key)) return;
    e.preventDefault();
    const o = this.root.opts.min.current, i = this.root.opts.max.current, a = this.root.opts.value.current, l = Array.isArray(a) ? a[s] : a, u = this.root.opts.orientation.current, c = this.root.direction, f = this.root.normalizedSteps;
    switch (e.key) {
      case Vo:
        this.#t(o);
        break;
      case Ro:
        this.#t(i);
        break;
      case ls:
        if (u !== "horizontal") break;
        if (e.metaKey) {
          const p = c === "rl" ? i : o;
          this.#t(p);
        } else {
          const _ = Ba(l, f, c === "rl" ? "next" : "prev");
          this.#t(_);
        }
        break;
      case us:
        if (u !== "horizontal") break;
        if (e.metaKey) {
          const p = c === "rl" ? o : i;
          this.#t(p);
        } else {
          const _ = Ba(l, f, c === "rl" ? "prev" : "next");
          this.#t(_);
        }
        break;
      case Qt:
        if (e.metaKey) {
          const p = c === "tb" ? o : i;
          this.#t(p);
        } else {
          const _ = Ba(l, f, c === "tb" ? "prev" : "next");
          this.#t(_);
        }
        break;
      case cr:
        if (e.metaKey) {
          const p = c === "tb" ? i : o;
          this.#t(p);
        } else {
          const _ = Ba(l, f, c === "tb" ? "next" : "prev");
          this.#t(_);
        }
        break;
    }
    this.root.opts.onValueCommit.current(this.root.opts.value.current);
  }
  #r = /* @__PURE__ */ C(() => ({
    ...this.root.thumbsPropsArr[this.opts.index.current],
    id: this.opts.id.current,
    onkeydown: this.onkeydown,
    "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
    "data-disabled": Fe(this.opts.disabled.current || this.root.opts.disabled.current),
    tabindex: this.opts.disabled.current || this.root.opts.disabled.current ? -1 : 0,
    ...this.attachment
  }));
  get props() {
    return d(this.#r);
  }
  set props(e) {
    q(this.#r, e);
  }
}
var FN = /* @__PURE__ */ ne("<span><!></span>");
function _1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "id", 23, () => me(r)), i = v(e, "ref", 15, null), a = v(e, "value", 15), l = v(e, "type", 7), u = v(e, "onValueChange", 7, _e), c = v(e, "onValueCommit", 7, _e), f = v(e, "disabled", 7, !1), p = v(e, "min", 7), _ = v(e, "max", 7), b = v(e, "step", 7, 1), g = v(e, "dir", 7, "ltr"), h = v(e, "autoSort", 7, !0), y = v(e, "orientation", 7, "horizontal"), S = v(e, "thumbPositioning", 7, "contain"), x = v(e, "trackPadding", 7), P = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "type",
    "onValueChange",
    "onValueCommit",
    "disabled",
    "min",
    "max",
    "step",
    "dir",
    "autoSort",
    "orientation",
    "thumbPositioning",
    "trackPadding"
  ]);
  const w = /* @__PURE__ */ C(() => p() !== void 0 ? p() : Array.isArray(b()) ? Math.min(...b()) : 0), O = /* @__PURE__ */ C(() => _() !== void 0 ? _() : Array.isArray(b()) ? Math.max(...b()) : 100);
  function k() {
    if (a() === void 0)
      return l() === "single" ? d(w) : [];
  }
  k(), Ne.pre(() => a(), () => {
    k();
  });
  const $ = IN.create({
    id: z(() => o()),
    ref: z(() => i(), (F) => i(F)),
    value: z(() => a(), (F) => {
      a(F), u()(F);
    }),
    // @ts-expect-error - we know
    onValueCommit: z(() => c()),
    disabled: z(() => f()),
    min: z(() => d(w)),
    max: z(() => d(O)),
    step: z(() => b()),
    dir: z(() => g()),
    autoSort: z(() => h()),
    orientation: z(() => y()),
    thumbPositioning: z(() => S()),
    type: l(),
    trackPadding: z(() => x())
  }), T = /* @__PURE__ */ C(() => Ce(P, $.props));
  var E = {
    get children() {
      return n();
    },
    set children(F) {
      n(F), m();
    },
    get child() {
      return s();
    },
    set child(F) {
      s(F), m();
    },
    get id() {
      return o();
    },
    set id(F = me(r)) {
      o(F), m();
    },
    get ref() {
      return i();
    },
    set ref(F = null) {
      i(F), m();
    },
    get value() {
      return a();
    },
    set value(F) {
      a(F), m();
    },
    get type() {
      return l();
    },
    set type(F) {
      l(F), m();
    },
    get onValueChange() {
      return u();
    },
    set onValueChange(F = _e) {
      u(F), m();
    },
    get onValueCommit() {
      return c();
    },
    set onValueCommit(F = _e) {
      c(F), m();
    },
    get disabled() {
      return f();
    },
    set disabled(F = !1) {
      f(F), m();
    },
    get min() {
      return p();
    },
    set min(F) {
      p(F), m();
    },
    get max() {
      return _();
    },
    set max(F) {
      _(F), m();
    },
    get step() {
      return b();
    },
    set step(F = 1) {
      b(F), m();
    },
    get dir() {
      return g();
    },
    set dir(F = "ltr") {
      g(F), m();
    },
    get autoSort() {
      return h();
    },
    set autoSort(F = !0) {
      h(F), m();
    },
    get orientation() {
      return y();
    },
    set orientation(F = "horizontal") {
      y(F), m();
    },
    get thumbPositioning() {
      return S();
    },
    set thumbPositioning(F = "contain") {
      S(F), m();
    },
    get trackPadding() {
      return x();
    },
    set trackPadding(F) {
      x(F), m();
    }
  }, M = I(), R = D(M);
  {
    var U = (F) => {
      var Z = I(), Y = D(Z);
      {
        let X = /* @__PURE__ */ C(() => ({ props: d(T), ...$.snippetProps }));
        te(Y, s, () => d(X));
      }
      A(F, Z);
    }, B = (F) => {
      var Z = FN();
      ve(Z, () => ({ ...d(T) }));
      var Y = he(Z);
      te(Y, () => n() ?? ge, () => $.snippetProps), de(Z), A(F, Z);
    };
    ue(R, (F) => {
      s() ? F(U) : F(B, !1);
    });
  }
  return A(t, M), W(E);
}
K(
  _1,
  {
    children: {},
    child: {},
    id: {},
    ref: {},
    value: {},
    type: {},
    onValueChange: {},
    onValueCommit: {},
    disabled: {},
    min: {},
    max: {},
    step: {},
    dir: {},
    autoSort: {},
    orientation: {},
    thumbPositioning: {},
    trackPadding: {}
  },
  [],
  [],
  { mode: "open" }
);
var RN = /* @__PURE__ */ ne("<span><!></span>");
function w1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const l = Yh.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get children() {
      return n();
    },
    set children(g) {
      n(g), m();
    },
    get child() {
      return s();
    },
    set child(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      te(y, s, () => ({ props: d(u) })), A(g, h);
    }, b = (g) => {
      var h = RN();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => n() ?? ge), de(h), A(g, h);
    };
    ue(p, (g) => {
      s() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(w1, { children: {}, child: {}, ref: {}, id: {} }, [], [], { mode: "open" });
var VN = /* @__PURE__ */ ne("<span><!></span>");
function S1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "index", 7), l = v(e, "disabled", 7, !1), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "id",
    "index",
    "disabled"
  ]);
  const c = Xh.create({
    id: z(() => i()),
    ref: z(() => o(), (y) => o(y)),
    index: z(() => a()),
    disabled: z(() => l())
  }), f = /* @__PURE__ */ C(() => Ce(u, c.props));
  var p = {
    get children() {
      return n();
    },
    set children(y) {
      n(y), m();
    },
    get child() {
      return s();
    },
    set child(y) {
      s(y), m();
    },
    get ref() {
      return o();
    },
    set ref(y = null) {
      o(y), m();
    },
    get id() {
      return i();
    },
    set id(y = me(r)) {
      i(y), m();
    },
    get index() {
      return a();
    },
    set index(y) {
      a(y), m();
    },
    get disabled() {
      return l();
    },
    set disabled(y = !1) {
      l(y), m();
    }
  }, _ = I(), b = D(_);
  {
    var g = (y) => {
      var S = I(), x = D(S);
      {
        let P = /* @__PURE__ */ C(() => ({
          active: c.root.isThumbActive(c.opts.index.current),
          props: d(f)
        }));
        te(x, s, () => d(P));
      }
      A(y, S);
    }, h = (y) => {
      var S = VN();
      ve(S, () => ({ ...d(f) }));
      var x = he(S);
      {
        let P = /* @__PURE__ */ C(() => ({
          active: c.root.isThumbActive(c.opts.index.current)
        }));
        te(x, () => n() ?? ge, () => d(P));
      }
      de(S), A(y, S);
    };
    ue(b, (y) => {
      s() ? y(g) : y(h, !1);
    });
  }
  return A(t, _), W(p);
}
K(
  S1,
  {
    children: {},
    child: {},
    ref: {},
    id: {},
    index: {},
    disabled: {}
  },
  [],
  [],
  { mode: "open" }
);
const x1 = rr({ component: "switch", parts: ["root", "thumb"] }), Jh = new ht("Switch.Root");
class Zh {
  static create(e) {
    return Jh.set(new Zh(e));
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(e.ref), this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this);
  }
  #e() {
    this.opts.checked.current = !this.opts.checked.current;
  }
  onkeydown(e) {
    !(e.key === Vr || e.key === wr) || this.opts.disabled.current || (e.preventDefault(), this.#e());
  }
  onclick(e) {
    this.opts.disabled.current || this.#e();
  }
  #t = /* @__PURE__ */ C(() => ({
    "data-disabled": Fe(this.opts.disabled.current),
    "data-state": M2(this.opts.checked.current),
    "data-required": Fe(this.opts.required.current)
  }));
  get sharedProps() {
    return d(this.#t);
  }
  set sharedProps(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => ({ checked: this.opts.checked.current }));
  get snippetProps() {
    return d(this.#r);
  }
  set snippetProps(e) {
    q(this.#r, e);
  }
  #n = /* @__PURE__ */ C(() => ({
    ...this.sharedProps,
    id: this.opts.id.current,
    role: "switch",
    disabled: _i(this.opts.disabled.current),
    "aria-checked": ou(this.opts.checked.current, !1),
    "aria-required": at(this.opts.required.current),
    [x1.root]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#n);
  }
  set props(e) {
    q(this.#n, e);
  }
}
class Qh {
  static create() {
    return new Qh(Jh.get());
  }
  root;
  #e = /* @__PURE__ */ C(() => this.root.opts.name.current !== void 0);
  get shouldRender() {
    return d(this.#e);
  }
  set shouldRender(e) {
    q(this.#e, e);
  }
  constructor(e) {
    this.root = e;
  }
  #t = /* @__PURE__ */ C(() => ({
    type: "checkbox",
    name: this.root.opts.name.current,
    value: this.root.opts.value.current,
    checked: this.root.opts.checked.current,
    disabled: this.root.opts.disabled.current,
    required: this.root.opts.required.current
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
class eg {
  static create(e) {
    return new eg(e, Jh.get());
  }
  opts;
  root;
  attachment;
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(e.ref);
  }
  #e = /* @__PURE__ */ C(() => ({ checked: this.root.opts.checked.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => ({
    ...this.root.sharedProps,
    id: this.opts.id.current,
    [x1.thumb]: "",
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function P1(t, e) {
  H(e, !1);
  const r = Qh.create();
  vd();
  var n = I(), s = D(n);
  {
    var o = (i) => {
      zi(i, ce(() => r.props));
    };
    ue(s, (i) => {
      r.shouldRender && i(o);
    });
  }
  A(t, n), W();
}
K(P1, {}, [], [], { mode: "open" });
var LN = /* @__PURE__ */ ne("<button><!></button>"), jN = /* @__PURE__ */ ne("<!> <!>", 1);
function O1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = v(e, "disabled", 7, !1), l = v(e, "required", 7, !1), u = v(e, "checked", 15, !1), c = v(e, "value", 7, "on"), f = v(e, "name", 7, void 0), p = v(e, "type", 7, "button"), _ = v(e, "onCheckedChange", 7, _e), b = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id",
    "disabled",
    "required",
    "checked",
    "value",
    "name",
    "type",
    "onCheckedChange"
  ]);
  const g = Zh.create({
    checked: z(() => u(), (k) => {
      u(k), _()?.(k);
    }),
    disabled: z(() => a() ?? !1),
    required: z(() => l()),
    value: z(() => c()),
    name: z(() => f()),
    id: z(() => i()),
    ref: z(() => o(), (k) => o(k))
  }), h = /* @__PURE__ */ C(() => Ce(b, g.props, { type: p() }));
  var y = {
    get child() {
      return n();
    },
    set child(k) {
      n(k), m();
    },
    get children() {
      return s();
    },
    set children(k) {
      s(k), m();
    },
    get ref() {
      return o();
    },
    set ref(k = null) {
      o(k), m();
    },
    get id() {
      return i();
    },
    set id(k = me(r)) {
      i(k), m();
    },
    get disabled() {
      return a();
    },
    set disabled(k = !1) {
      a(k), m();
    },
    get required() {
      return l();
    },
    set required(k = !1) {
      l(k), m();
    },
    get checked() {
      return u();
    },
    set checked(k = !1) {
      u(k), m();
    },
    get value() {
      return c();
    },
    set value(k = "on") {
      c(k), m();
    },
    get name() {
      return f();
    },
    set name(k = void 0) {
      f(k), m();
    },
    get type() {
      return p();
    },
    set type(k = "button") {
      p(k), m();
    },
    get onCheckedChange() {
      return _();
    },
    set onCheckedChange(k = _e) {
      _(k), m();
    }
  }, S = jN(), x = D(S);
  {
    var P = (k) => {
      var $ = I(), T = D($);
      {
        let E = /* @__PURE__ */ C(() => ({ props: d(h), ...g.snippetProps }));
        te(T, n, () => d(E));
      }
      A(k, $);
    }, w = (k) => {
      var $ = LN();
      ve($, () => ({ ...d(h) }));
      var T = he($);
      te(T, () => s() ?? ge, () => g.snippetProps), de($), A(k, $);
    };
    ue(x, (k) => {
      n() ? k(P) : k(w, !1);
    });
  }
  var O = be(x, 2);
  return P1(O, {}), A(t, S), W(y);
}
K(
  O1,
  {
    child: {},
    children: {},
    ref: {},
    id: {},
    disabled: {},
    required: {},
    checked: {},
    value: {},
    name: {},
    type: {},
    onCheckedChange: {}
  },
  [],
  [],
  { mode: "open" }
);
var BN = /* @__PURE__ */ ne("<span><!></span>");
function C1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "child", 7), s = v(e, "children", 7), o = v(e, "ref", 15, null), i = v(e, "id", 23, () => me(r)), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "child",
    "children",
    "ref",
    "id"
  ]);
  const l = eg.create({
    id: z(() => i()),
    ref: z(() => o(), (g) => o(g))
  }), u = /* @__PURE__ */ C(() => Ce(a, l.props));
  var c = {
    get child() {
      return n();
    },
    set child(g) {
      n(g), m();
    },
    get children() {
      return s();
    },
    set children(g) {
      s(g), m();
    },
    get ref() {
      return o();
    },
    set ref(g = null) {
      o(g), m();
    },
    get id() {
      return i();
    },
    set id(g = me(r)) {
      i(g), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (g) => {
      var h = I(), y = D(h);
      {
        let S = /* @__PURE__ */ C(() => ({ props: d(u), ...l.snippetProps }));
        te(y, n, () => d(S));
      }
      A(g, h);
    }, b = (g) => {
      var h = BN();
      ve(h, () => ({ ...d(u) }));
      var y = he(h);
      te(y, () => s() ?? ge, () => l.snippetProps), de(h), A(g, h);
    };
    ue(p, (g) => {
      n() ? g(_) : g(b, !1);
    });
  }
  return A(t, f), W(c);
}
K(C1, { child: {}, children: {}, ref: {}, id: {} }, [], [], { mode: "open" });
const zN = rr({ component: "toggle", parts: ["root"] });
class tg {
  static create(e) {
    return new tg(e);
  }
  opts;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref), this.onclick = this.onclick.bind(this);
  }
  onclick(e) {
    this.opts.disabled.current || (this.opts.pressed.current = !this.opts.pressed.current);
  }
  #e = /* @__PURE__ */ C(() => ({ pressed: this.opts.pressed.current }));
  get snippetProps() {
    return d(this.#e);
  }
  set snippetProps(e) {
    q(this.#e, e);
  }
  #t = /* @__PURE__ */ C(() => ({
    [zN.root]: "",
    id: this.opts.id.current,
    "data-disabled": Fe(this.opts.disabled.current),
    "aria-pressed": at(this.opts.pressed.current),
    "data-state": qN(this.opts.pressed.current),
    disabled: _i(this.opts.disabled.current),
    onclick: this.onclick,
    ...this.attachment
  }));
  get props() {
    return d(this.#t);
  }
  set props(e) {
    q(this.#t, e);
  }
}
function qN(t) {
  return t ? "on" : "off";
}
var UN = /* @__PURE__ */ ne("<button><!></button>");
function k1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "ref", 15, null), s = v(e, "id", 23, () => me(r)), o = v(e, "pressed", 15, !1), i = v(e, "onPressedChange", 7, _e), a = v(e, "disabled", 7, !1), l = v(e, "type", 7, "button"), u = v(e, "children", 7), c = v(e, "child", 7), f = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "id",
    "pressed",
    "onPressedChange",
    "disabled",
    "type",
    "children",
    "child"
  ]);
  const p = tg.create({
    pressed: z(() => o(), (x) => {
      o(x), i()(x);
    }),
    disabled: z(() => a() ?? !1),
    id: z(() => s()),
    ref: z(() => n(), (x) => n(x))
  }), _ = /* @__PURE__ */ C(() => Ce(f, p.props, { type: l() }));
  var b = {
    get ref() {
      return n();
    },
    set ref(x = null) {
      n(x), m();
    },
    get id() {
      return s();
    },
    set id(x = me(r)) {
      s(x), m();
    },
    get pressed() {
      return o();
    },
    set pressed(x = !1) {
      o(x), m();
    },
    get onPressedChange() {
      return i();
    },
    set onPressedChange(x = _e) {
      i(x), m();
    },
    get disabled() {
      return a();
    },
    set disabled(x = !1) {
      a(x), m();
    },
    get type() {
      return l();
    },
    set type(x = "button") {
      l(x), m();
    },
    get children() {
      return u();
    },
    set children(x) {
      u(x), m();
    },
    get child() {
      return c();
    },
    set child(x) {
      c(x), m();
    }
  }, g = I(), h = D(g);
  {
    var y = (x) => {
      var P = I(), w = D(P);
      {
        let O = /* @__PURE__ */ C(() => ({ props: d(_), ...p.snippetProps }));
        te(w, c, () => d(O));
      }
      A(x, P);
    }, S = (x) => {
      var P = UN();
      ve(P, () => ({ ...d(_) }));
      var w = he(P);
      te(w, () => u() ?? ge, () => p.snippetProps), de(P), A(x, P);
    };
    ue(h, (x) => {
      c() ? x(y) : x(S, !1);
    });
  }
  return A(t, g), W(b);
}
K(
  k1,
  {
    ref: {},
    id: {},
    pressed: {},
    onPressedChange: {},
    disabled: {},
    type: {},
    children: {},
    child: {}
  },
  [],
  [],
  { mode: "open" }
);
const Jc = rr({ component: "toggle-group", parts: ["root", "item"] }), $1 = new ht("ToggleGroup.Root");
class A1 {
  opts;
  rovingFocusGroup;
  attachment;
  constructor(e) {
    this.opts = e, this.attachment = Ee(this.opts.ref), this.rovingFocusGroup = new t0({
      candidateAttr: Jc.item,
      rootNode: e.ref,
      loop: e.loop,
      orientation: e.orientation
    });
  }
  #e = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    [Jc.root]: "",
    role: "group",
    "data-orientation": this.opts.orientation.current,
    "data-disabled": Fe(this.opts.disabled.current),
    ...this.attachment
  }));
  get props() {
    return d(this.#e);
  }
  set props(e) {
    q(this.#e, e);
  }
}
class KN extends A1 {
  opts;
  isMulti = !1;
  #e = /* @__PURE__ */ C(() => this.opts.value.current !== "");
  get anyPressed() {
    return d(this.#e);
  }
  set anyPressed(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e;
  }
  includesItem(e) {
    return this.opts.value.current === e;
  }
  toggleItem(e, r) {
    this.includesItem(e) ? this.opts.value.current = "" : (this.opts.value.current = e, this.rovingFocusGroup.setCurrentTabStopId(r));
  }
}
class HN extends A1 {
  opts;
  isMulti = !0;
  #e = /* @__PURE__ */ C(() => this.opts.value.current.length > 0);
  get anyPressed() {
    return d(this.#e);
  }
  set anyPressed(e) {
    q(this.#e, e);
  }
  constructor(e) {
    super(e), this.opts = e;
  }
  includesItem(e) {
    return this.opts.value.current.includes(e);
  }
  toggleItem(e, r) {
    this.includesItem(e) ? this.opts.value.current = this.opts.value.current.filter((n) => n !== e) : (this.opts.value.current = [...this.opts.value.current, e], this.rovingFocusGroup.setCurrentTabStopId(r));
  }
}
class WN {
  static create(e) {
    const { type: r, ...n } = e, s = r === "single" ? new KN(n) : new HN(n);
    return $1.set(s);
  }
}
class rg {
  static create(e) {
    return new rg(e, $1.get());
  }
  opts;
  root;
  attachment;
  #e = /* @__PURE__ */ C(() => this.opts.disabled.current || this.root.opts.disabled.current);
  #t = /* @__PURE__ */ C(() => this.root.includesItem(this.opts.value.current));
  get isPressed() {
    return d(this.#t);
  }
  set isPressed(e) {
    q(this.#t, e);
  }
  #r = /* @__PURE__ */ C(() => this.root.isMulti ? void 0 : ou(this.isPressed, !1));
  #n = /* @__PURE__ */ C(() => this.root.isMulti ? at(this.isPressed) : void 0);
  constructor(e, r) {
    this.opts = e, this.root = r, this.attachment = Ee(this.opts.ref), Ze(() => {
      this.root.opts.rovingFocus.current ? q(this.#o, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), !0) : q(this.#o, 0);
    }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
  }
  #s() {
    d(this.#e) || this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onclick(e) {
    d(this.#e) || this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onkeydown(e) {
    if (!d(this.#e)) {
      if (e.key === Vr || e.key === wr) {
        e.preventDefault(), this.#s();
        return;
      }
      this.root.opts.rovingFocus.current && this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    }
  }
  #o = /* @__PURE__ */ xe(0);
  #i = /* @__PURE__ */ C(() => ({ pressed: this.isPressed }));
  get snippetProps() {
    return d(this.#i);
  }
  set snippetProps(e) {
    q(this.#i, e);
  }
  #a = /* @__PURE__ */ C(() => ({
    id: this.opts.id.current,
    role: this.root.isMulti ? void 0 : "radio",
    tabindex: d(this.#o),
    "data-orientation": this.root.opts.orientation.current,
    "data-disabled": Fe(d(this.#e)),
    "data-state": GN(this.isPressed),
    "data-value": this.opts.value.current,
    "aria-pressed": d(this.#n),
    "aria-checked": d(this.#r),
    disabled: _i(d(this.#e)),
    [Jc.item]: "",
    onclick: this.onclick,
    onkeydown: this.onkeydown,
    ...this.attachment
  }));
  get props() {
    return d(this.#a);
  }
  set props(e) {
    q(this.#a, e);
  }
}
function GN(t) {
  return t ? "on" : "off";
}
var YN = /* @__PURE__ */ ne("<div><!></div>");
function E1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "id", 23, () => me(r)), s = v(e, "ref", 15, null), o = v(e, "value", 15), i = v(e, "onValueChange", 7, _e), a = v(e, "type", 7), l = v(e, "disabled", 7, !1), u = v(e, "loop", 7, !0), c = v(e, "orientation", 7, "horizontal"), f = v(e, "rovingFocus", 7, !0), p = v(e, "child", 7), _ = v(e, "children", 7), b = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "id",
    "ref",
    "value",
    "onValueChange",
    "type",
    "disabled",
    "loop",
    "orientation",
    "rovingFocus",
    "child",
    "children"
  ]);
  function g() {
    o() === void 0 && o(a() === "single" ? "" : []);
  }
  g(), Ne.pre(() => o(), () => {
    g();
  });
  const h = WN.create({
    id: z(() => n()),
    value: z(() => o(), (k) => {
      o(k), i()(k);
    }),
    disabled: z(() => l()),
    loop: z(() => u()),
    orientation: z(() => c()),
    rovingFocus: z(() => f()),
    type: a(),
    ref: z(() => s(), (k) => s(k))
  }), y = /* @__PURE__ */ C(() => Ce(b, h.props));
  var S = {
    get id() {
      return n();
    },
    set id(k = me(r)) {
      n(k), m();
    },
    get ref() {
      return s();
    },
    set ref(k = null) {
      s(k), m();
    },
    get value() {
      return o();
    },
    set value(k) {
      o(k), m();
    },
    get onValueChange() {
      return i();
    },
    set onValueChange(k = _e) {
      i(k), m();
    },
    get type() {
      return a();
    },
    set type(k) {
      a(k), m();
    },
    get disabled() {
      return l();
    },
    set disabled(k = !1) {
      l(k), m();
    },
    get loop() {
      return u();
    },
    set loop(k = !0) {
      u(k), m();
    },
    get orientation() {
      return c();
    },
    set orientation(k = "horizontal") {
      c(k), m();
    },
    get rovingFocus() {
      return f();
    },
    set rovingFocus(k = !0) {
      f(k), m();
    },
    get child() {
      return p();
    },
    set child(k) {
      p(k), m();
    },
    get children() {
      return _();
    },
    set children(k) {
      _(k), m();
    }
  }, x = I(), P = D(x);
  {
    var w = (k) => {
      var $ = I(), T = D($);
      te(T, p, () => ({ props: d(y) })), A(k, $);
    }, O = (k) => {
      var $ = YN();
      ve($, () => ({ ...d(y) }));
      var T = he($);
      te(T, () => _() ?? ge), de($), A(k, $);
    };
    ue(P, (k) => {
      p() ? k(w) : k(O, !1);
    });
  }
  return A(t, x), W(S);
}
K(
  E1,
  {
    id: {},
    ref: {},
    value: {},
    onValueChange: {},
    type: {},
    disabled: {},
    loop: {},
    orientation: {},
    rovingFocus: {},
    child: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var XN = /* @__PURE__ */ ne("<button><!></button>");
function T1(t, e) {
  const r = Te();
  H(e, !0);
  let n = v(e, "children", 7), s = v(e, "child", 7), o = v(e, "ref", 15, null), i = v(e, "value", 7), a = v(e, "disabled", 7, !1), l = v(e, "id", 23, () => me(r)), u = v(e, "type", 7, "button"), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "children",
    "child",
    "ref",
    "value",
    "disabled",
    "id",
    "type"
  ]);
  const f = rg.create({
    id: z(() => l()),
    value: z(() => i()),
    disabled: z(() => a() ?? !1),
    ref: z(() => o(), (S) => o(S))
  }), p = /* @__PURE__ */ C(() => Ce(c, f.props, { type: u() }));
  var _ = {
    get children() {
      return n();
    },
    set children(S) {
      n(S), m();
    },
    get child() {
      return s();
    },
    set child(S) {
      s(S), m();
    },
    get ref() {
      return o();
    },
    set ref(S = null) {
      o(S), m();
    },
    get value() {
      return i();
    },
    set value(S) {
      i(S), m();
    },
    get disabled() {
      return a();
    },
    set disabled(S = !1) {
      a(S), m();
    },
    get id() {
      return l();
    },
    set id(S = me(r)) {
      l(S), m();
    },
    get type() {
      return u();
    },
    set type(S = "button") {
      u(S), m();
    }
  }, b = I(), g = D(b);
  {
    var h = (S) => {
      var x = I(), P = D(x);
      {
        let w = /* @__PURE__ */ C(() => ({ props: d(p), ...f.snippetProps }));
        te(P, s, () => d(w));
      }
      A(S, x);
    }, y = (S) => {
      var x = XN();
      ve(x, () => ({ ...d(p) }));
      var P = he(x);
      te(P, () => n() ?? ge, () => f.snippetProps), de(x), A(S, x);
    };
    ue(g, (S) => {
      s() ? S(h) : S(y, !1);
    });
  }
  return A(t, b), W(_);
}
K(
  T1,
  {
    children: {},
    child: {},
    ref: {},
    value: {},
    disabled: {},
    id: {},
    type: {}
  },
  [],
  [],
  { mode: "open" }
);
function mu(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "data-slot", 7, "separator"), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "data-slot"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get "data-slot"() {
      return s();
    },
    set "data-slot"(u = "separator") {
      s(u), m();
    }
  }, a = I(), l = D(a);
  {
    let u = /* @__PURE__ */ C(() => Se("bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:min-h-full data-[orientation=vertical]:w-px", n()));
    Q(l, () => Tw, (c, f) => {
      f(c, ce(
        {
          get "data-slot"() {
            return s();
          },
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          }
        }
      ));
    });
  }
  return A(t, a), W(i);
}
K(mu, { ref: {}, class: {}, "data-slot": {} }, [], [], { mode: "open" });
function JN(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "orientation", 7, "vertical"), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "orientation"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    },
    get class() {
      return n();
    },
    set class(a) {
      n(a), m();
    },
    get orientation() {
      return s();
    },
    set orientation(a = "vertical") {
      s(a), m();
    }
  };
  {
    let a = /* @__PURE__ */ C(() => Se("bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto", n()));
    mu(t, ce(
      {
        "data-slot": "button-group-separator",
        get orientation() {
          return s();
        },
        get class() {
          return d(a);
        }
      },
      () => o,
      {
        get ref() {
          return r();
        },
        set ref(l) {
          r(l);
        }
      }
    ));
  }
  return W(i);
}
K(JN, { ref: {}, class: {}, orientation: {} }, [], [], { mode: "open" });
const ss = Ri({
  base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-xs",
      destructive: "bg-destructive hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white shadow-xs",
      outline: "bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80 shadow-xs",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
var ZN = /* @__PURE__ */ ne("<a><!></a>"), QN = /* @__PURE__ */ ne("<button><!></button>");
function D1(t, e) {
  H(e, !0);
  let r = v(e, "class", 7), n = v(e, "variant", 7, "default"), s = v(e, "size", 7, "default"), o = v(e, "ref", 15, null), i = v(e, "href", 7, void 0), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7), u = v(e, "children", 7), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "class",
    "variant",
    "size",
    "ref",
    "href",
    "type",
    "disabled",
    "children"
  ]);
  var f = {
    get class() {
      return r();
    },
    set class(h) {
      r(h), m();
    },
    get variant() {
      return n();
    },
    set variant(h = "default") {
      n(h), m();
    },
    get size() {
      return s();
    },
    set size(h = "default") {
      s(h), m();
    },
    get ref() {
      return o();
    },
    set ref(h = null) {
      o(h), m();
    },
    get href() {
      return i();
    },
    set href(h = void 0) {
      i(h), m();
    },
    get type() {
      return a();
    },
    set type(h = "button") {
      a(h), m();
    },
    get disabled() {
      return l();
    },
    set disabled(h) {
      l(h), m();
    },
    get children() {
      return u();
    },
    set children(h) {
      u(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = ZN();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          href: l() ? void 0 : i(),
          "aria-disabled": l(),
          role: l() ? "link" : void 0,
          tabindex: l() ? -1 : void 0,
          ...c
        }),
        [
          () => Se(ss({ variant: n(), size: s() }), r())
        ]
      );
      var S = he(y);
      te(S, () => u() ?? ge), de(y), et(y, (x) => o(x), () => o()), A(h, y);
    }, g = (h) => {
      var y = QN();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          type: a(),
          disabled: l(),
          ...c
        }),
        [
          () => Se(ss({ variant: n(), size: s() }), r())
        ]
      );
      var S = he(y);
      te(S, () => u() ?? ge), de(y), et(y, (x) => o(x), () => o()), A(h, y);
    };
    ue(_, (h) => {
      i() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(
  D1,
  {
    class: {},
    variant: {},
    size: {},
    ref: {},
    href: {},
    type: {},
    disabled: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var eF = /* @__PURE__ */ ne("<!> <!>", 1), tF = /* @__PURE__ */ ne("<!> <!>", 1), rF = /* @__PURE__ */ ne("<!> <!>", 1), nF = /* @__PURE__ */ ne("<!> <!>", 1);
function M1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "placeholder", 15), o = v(e, "class", 7), i = v(e, "weekdayFormat", 7, "short"), a = v(e, "buttonVariant", 7, "ghost"), l = v(e, "captionLayout", 7, "label"), u = v(e, "locale", 7, "en-US"), c = v(e, "months", 7), f = v(e, "years", 7), p = v(e, "monthFormat", 7), _ = v(e, "yearFormat", 7, "numeric"), b = v(e, "day", 7), g = v(e, "disableDaysOutsideMonth", 7, !1), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "placeholder",
    "class",
    "weekdayFormat",
    "buttonVariant",
    "captionLayout",
    "locale",
    "months",
    "years",
    "monthFormat",
    "yearFormat",
    "day",
    "disableDaysOutsideMonth"
  ]);
  const y = /* @__PURE__ */ C(() => p() ? p() : l().startsWith("dropdown") ? "short" : "long");
  var S = {
    get ref() {
      return r();
    },
    set ref(w = null) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get placeholder() {
      return s();
    },
    set placeholder(w) {
      s(w), m();
    },
    get class() {
      return o();
    },
    set class(w) {
      o(w), m();
    },
    get weekdayFormat() {
      return i();
    },
    set weekdayFormat(w = "short") {
      i(w), m();
    },
    get buttonVariant() {
      return a();
    },
    set buttonVariant(w = "ghost") {
      a(w), m();
    },
    get captionLayout() {
      return l();
    },
    set captionLayout(w = "label") {
      l(w), m();
    },
    get locale() {
      return u();
    },
    set locale(w = "en-US") {
      u(w), m();
    },
    get months() {
      return c();
    },
    set months(w) {
      c(w), m();
    },
    get years() {
      return f();
    },
    set years(w) {
      f(w), m();
    },
    get monthFormat() {
      return p();
    },
    set monthFormat(w) {
      p(w), m();
    },
    get yearFormat() {
      return _();
    },
    set yearFormat(w = "numeric") {
      _(w), m();
    },
    get day() {
      return b();
    },
    set day(w) {
      b(w), m();
    },
    get disableDaysOutsideMonth() {
      return g();
    },
    set disableDaysOutsideMonth(w = !1) {
      g(w), m();
    }
  }, x = I(), P = D(x);
  {
    const w = (k, $) => {
      let T = () => $?.().months, E = () => $?.().weekdays;
      var M = I(), R = D(M);
      Q(R, () => V1, (U, B) => {
        B(U, {
          children: (F, Z) => {
            var Y = nF(), X = D(Y);
            Q(X, () => W1, (J, j) => {
              j(J, {
                children: (ee, L) => {
                  var N = eF(), V = D(N);
                  Q(V, () => q1, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  });
                  var G = be(V, 2);
                  Q(G, () => z1, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  }), A(ee, N);
                },
                $$slots: { default: !0 }
              });
            });
            var ae = be(X, 2);
            st(ae, 18, T, (J) => J, (J, j, ee) => {
              var L = I(), N = D(L);
              Q(N, () => H1, (V, G) => {
                G(V, {
                  children: (fe, se) => {
                    var we = rF(), le = D(we);
                    Q(le, () => R1, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = I(), Re = D(Oe);
                          Q(Re, () => G1, (Ke, Ve) => {
                            Ve(Ke, {
                              get captionLayout() {
                                return l();
                              },
                              get months() {
                                return c();
                              },
                              get monthFormat() {
                                return d(y);
                              },
                              get years() {
                                return f();
                              },
                              get yearFormat() {
                                return _();
                              },
                              get month() {
                                return j.value;
                              },
                              get locale() {
                                return u();
                              },
                              get monthIndex() {
                                return d(ee);
                              },
                              get placeholder() {
                                return s();
                              },
                              set placeholder(je) {
                                s(je);
                              }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    });
                    var re = be(le, 2);
                    Q(re, () => F1, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = tF(), Re = D(Oe);
                          Q(Re, () => j1, (Ve, je) => {
                            je(Ve, {
                              children: (He, gt) => {
                                var Je = I(), kt = D(Je);
                                Q(kt, () => Zc, (lt, ct) => {
                                  ct(lt, {
                                    class: "select-none",
                                    children: (pt, Kt) => {
                                      var yt = I(), Rt = D(yt);
                                      st(Rt, 16, E, (Dt) => Dt, (Dt, Ht) => {
                                        var Wt = I(), un = D(Wt);
                                        Q(un, () => B1, (nr, sr) => {
                                          sr(nr, {
                                            children: (Pr, Gs) => {
                                              vt();
                                              var mr = tt();
                                              ke((qr) => Me(mr, qr), [() => Ht.slice(0, 2)]), A(Pr, mr);
                                            },
                                            $$slots: { default: !0 }
                                          });
                                        }), A(Dt, Wt);
                                      }), A(pt, yt);
                                    },
                                    $$slots: { default: !0 }
                                  });
                                }), A(He, Je);
                              },
                              $$slots: { default: !0 }
                            });
                          });
                          var Ke = be(Re, 2);
                          Q(Ke, () => L1, (Ve, je) => {
                            je(Ve, {
                              children: (He, gt) => {
                                var Je = I(), kt = D(Je);
                                st(kt, 16, () => j.weeks, (lt) => lt, (lt, ct) => {
                                  var pt = I(), Kt = D(pt);
                                  Q(Kt, () => Zc, (yt, Rt) => {
                                    Rt(yt, {
                                      class: "mt-2 w-full",
                                      children: (Dt, Ht) => {
                                        var Wt = I(), un = D(Wt);
                                        st(un, 16, () => ct, (nr) => nr, (nr, sr) => {
                                          var Pr = I(), Gs = D(Pr);
                                          Q(Gs, () => I1, (mr, qr) => {
                                            qr(mr, {
                                              get date() {
                                                return sr;
                                              },
                                              get month() {
                                                return j.value;
                                              },
                                              children: (Uo, vu) => {
                                                var Ko = I(), yu = D(Ko);
                                                {
                                                  var bu = (or) => {
                                                    var Or = I(), ds = D(Or);
                                                    {
                                                      let fs = /* @__PURE__ */ C(() => ({ day: sr, outsideMonth: !w0(sr, j.value) }));
                                                      te(ds, b, () => d(fs));
                                                    }
                                                    A(or, Or);
                                                  }, _u = (or) => {
                                                    var Or = I(), ds = D(Or);
                                                    Q(ds, () => N1, (fs, wu) => {
                                                      wu(fs, {});
                                                    }), A(or, Or);
                                                  };
                                                  ue(yu, (or) => {
                                                    b() ? or(bu) : or(_u, !1);
                                                  });
                                                }
                                                A(Uo, Ko);
                                              },
                                              $$slots: { default: !0 }
                                            });
                                          }), A(nr, Pr);
                                        }), A(Dt, Wt);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(lt, pt);
                                }), A(He, Je);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(fe, we);
                  },
                  $$slots: { default: !0 }
                });
              }), A(J, L);
            }), A(F, Y);
          },
          $$slots: { default: !0 }
        });
      }), A(k, M);
    };
    let O = /* @__PURE__ */ C(() => Se("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", o()));
    Q(P, () => uw, (k, $) => {
      $(k, ce(
        {
          get weekdayFormat() {
            return i();
          },
          get disableDaysOutsideMonth() {
            return g();
          },
          get class() {
            return d(O);
          },
          get locale() {
            return u();
          },
          get monthFormat() {
            return d(y);
          },
          get yearFormat() {
            return _();
          }
        },
        () => h,
        {
          get value() {
            return n();
          },
          set value(T) {
            n(T);
          },
          get ref() {
            return r();
          },
          set ref(T) {
            r(T);
          },
          get placeholder() {
            return s();
          },
          set placeholder(T) {
            s(T);
          },
          children: w,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, x), W(S);
}
K(
  M1,
  {
    ref: {},
    value: {},
    placeholder: {},
    class: {},
    weekdayFormat: {},
    buttonVariant: {},
    captionLayout: {},
    locale: {},
    months: {},
    years: {},
    monthFormat: {},
    yearFormat: {},
    day: {},
    disableDaysOutsideMonth: {}
  },
  [],
  [],
  { mode: "open" }
);
function I1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("relative size-(--cell-size) p-0 text-center text-sm focus-within:z-20 [&:first-child[data-selected]_[data-bits-day]]:rounded-s-md [&:last-child[data-selected]_[data-bits-day]]:rounded-e-md", n()));
    Q(a, () => dw, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(I1, { ref: {}, class: {} }, [], [], { mode: "open" });
function N1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se(ss({ variant: "ghost" }), "flex size-(--cell-size) flex-col items-center justify-center gap-1 p-0 leading-none font-normal whitespace-nowrap select-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground", "data-[selected]:bg-primary dark:data-[selected]:hover:bg-accent/50 data-[selected]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:text-muted-foreground data-[unavailable]:line-through", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", n()));
    Q(a, () => cw, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(N1, { ref: {}, class: {} }, [], [], { mode: "open" });
function F1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("mt-4 flex w-full border-collapse flex-col gap-1", n()));
    Q(a, () => Bf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(F1, { ref: {}, class: {} }, [], [], { mode: "open" });
function R1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex h-(--cell-size) w-full items-center justify-center gap-1.5 text-sm font-medium", n()));
    Q(a, () => Hf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(R1, { ref: {}, class: {} }, [], [], { mode: "open" });
var sF = /* @__PURE__ */ ne("<div><!></div>");
function V1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = sF();
  ve(a, (u) => ({ class: u, ...o }), [
    () => Se("relative flex flex-col gap-4 md:flex-row", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(V1, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function Zc(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex", n()));
    Q(a, () => Kf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(Zc, { ref: {}, class: {} }, [], [], { mode: "open" });
function oF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("px-(--cell-size) text-sm font-medium", n()));
    Q(a, () => Wf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(oF, { ref: {}, class: {} }, [], [], { mode: "open" });
function L1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se(n()));
    Q(a, () => zf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(L1, { ref: {}, class: {} }, [], [], { mode: "open" });
function j1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se(n()));
    Q(a, () => qf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(j1, { ref: {}, class: {} }, [], [], { mode: "open" });
function B1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", n()));
    Q(a, () => Uf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(B1, { ref: {}, class: {} }, [], [], { mode: "open" });
const iF = (t) => {
  Gd(t, { class: "size-4" });
};
function z1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    let c = /* @__PURE__ */ C(() => Se(ss({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ C(() => s() || iF);
    Q(u, () => Yf, (p, _) => {
      _(p, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(z1, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
const aF = (t) => {
  Wd(t, { class: "size-4" });
};
function q1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    let c = /* @__PURE__ */ C(() => Se(ss({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ C(() => s() || aF);
    Q(u, () => Xf, (p, _) => {
      _(p, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(q1, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
var lF = /* @__PURE__ */ ne("<option> </option>"), uF = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), cF = /* @__PURE__ */ ne("<span><!></span>");
function U1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "onchange", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "onchange"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c) {
      s(c), m();
    },
    get onchange() {
      return o();
    },
    set onchange(c) {
      o(c), m();
    }
  }, l = cF(), u = he(l);
  {
    const c = (f, p) => {
      let _ = () => p?.().props, b = () => p?.().monthItems, g = () => p?.().selectedMonthItem;
      var h = uF(), y = D(h);
      ve(y, () => ({ ..._(), value: s(), onchange: o() })), st(y, 21, b, (w) => w.value, (w, O) => {
        var k = lF(), $ = he(k, !0);
        de(k);
        var T = {};
        ke(() => {
          zs(k, s() !== void 0 ? d(O).value === s() : d(O).value === g().value), Me($, d(O).label), T !== (T = d(O).value) && (k.value = (k.__value = d(O).value) ?? "");
        }), A(w, k);
      }), de(y);
      var S = be(y, 2), x = he(S), P = be(x);
      Ks(P, { class: "size-4" }), de(S), ke((w) => Me(x, `${w ?? ""} `), [
        () => b().find((w) => w.value === s())?.label || g().label
      ]), A(f, h);
    };
    Q(u, () => Gf, (f, p) => {
      p(f, ce(
        {
          class: "dark:bg-popover dark:text-popover-foreground absolute inset-0 opacity-0"
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          child: c,
          $$slots: { child: !0 }
        }
      ));
    });
  }
  return de(l), ke((c) => Bs(l, 1, c), [
    () => js(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, l), W(a);
}
K(U1, { ref: {}, class: {}, value: {}, onchange: {} }, [], [], { mode: "open" });
var dF = /* @__PURE__ */ ne("<option> </option>"), fF = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), hF = /* @__PURE__ */ ne("<span><!></span>");
function K1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u) {
      s(u), m();
    }
  }, a = hF(), l = he(a);
  {
    const u = (c, f) => {
      let p = () => f?.().props, _ = () => f?.().yearItems, b = () => f?.().selectedYearItem;
      var g = fF(), h = D(g);
      ve(h, () => ({ ...p(), value: s() })), st(h, 21, _, (P) => P.value, (P, w) => {
        var O = dF(), k = he(O, !0);
        de(O);
        var $ = {};
        ke(() => {
          zs(O, s() !== void 0 ? d(w).value === s() : d(w).value === b().value), Me(k, d(w).label), $ !== ($ = d(w).value) && (O.value = (O.__value = d(w).value) ?? "");
        }), A(P, O);
      }), de(h);
      var y = be(h, 2), S = he(y), x = be(S);
      Ks(x, { class: "size-4" }), de(y), ke((P) => Me(S, `${P ?? ""} `), [
        () => _().find((P) => P.value === s())?.label || b().label
      ]), A(c, g);
    };
    Q(l, () => Jf, (c, f) => {
      f(c, ce(
        {
          class: "dark:bg-popover dark:text-popover-foreground absolute inset-0 opacity-0"
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          child: u,
          $$slots: { child: !0 }
        }
      ));
    });
  }
  return de(a), ke((u) => Bs(a, 1, u), [
    () => js(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, a), W(i);
}
K(K1, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var gF = /* @__PURE__ */ ne("<div><!></div>");
function H1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = gF();
  ve(a, (u) => ({ ...o, class: u }), [() => Se("flex flex-col", n())]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(H1, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var pF = /* @__PURE__ */ ne("<nav><!></nav>");
function W1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = pF();
  ve(a, (u) => ({ ...o, class: u }), [
    () => Se("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(W1, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var mF = /* @__PURE__ */ ne("<!> <!>", 1), vF = /* @__PURE__ */ ne("<!> <!>", 1), yF = /* @__PURE__ */ ne("<!> <!>", 1);
function G1(t, e) {
  H(e, !0);
  const r = (P) => {
    U1(P, {
      get months() {
        return o();
      },
      get monthFormat() {
        return i();
      },
      get value() {
        return u().month;
      },
      onchange: (w) => {
        if (!f()) return;
        const O = Number.parseInt(w.currentTarget.value), k = f().set({ month: O });
        f(k.subtract({ months: p() }));
      }
    });
  }, n = (P) => {
    K1(P, {
      get years() {
        return a();
      },
      get yearFormat() {
        return l();
      },
      get value() {
        return u().year;
      }
    });
  };
  let s = v(e, "captionLayout", 7), o = v(e, "months", 7), i = v(e, "monthFormat", 7), a = v(e, "years", 7), l = v(e, "yearFormat", 7), u = v(e, "month", 7), c = v(e, "locale", 7), f = v(e, "placeholder", 15), p = v(e, "monthIndex", 7, 0);
  function _(P) {
    const w = P.toDate(ft());
    return typeof l() == "function" ? l()(w.getFullYear()) : new Lt(c(), { year: l() }).format(w);
  }
  function b(P) {
    const w = P.toDate(ft());
    return typeof i() == "function" ? i()(w.getMonth() + 1) : new Lt(c(), { month: i() }).format(w);
  }
  var g = {
    get captionLayout() {
      return s();
    },
    set captionLayout(P) {
      s(P), m();
    },
    get months() {
      return o();
    },
    set months(P) {
      o(P), m();
    },
    get monthFormat() {
      return i();
    },
    set monthFormat(P) {
      i(P), m();
    },
    get years() {
      return a();
    },
    set years(P) {
      a(P), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(P) {
      l(P), m();
    },
    get month() {
      return u();
    },
    set month(P) {
      u(P), m();
    },
    get locale() {
      return c();
    },
    set locale(P) {
      c(P), m();
    },
    get placeholder() {
      return f();
    },
    set placeholder(P) {
      f(P), m();
    },
    get monthIndex() {
      return p();
    },
    set monthIndex(P = 0) {
      p(P), m();
    }
  }, h = I(), y = D(h);
  {
    var S = (P) => {
      var w = mF(), O = D(w);
      r(O);
      var k = be(O, 2);
      n(k), A(P, w);
    }, x = (P) => {
      var w = I(), O = D(w);
      {
        var k = (T) => {
          var E = vF(), M = D(E);
          r(M);
          var R = be(M, 2);
          {
            var U = (B) => {
              var F = tt();
              ke((Z) => Me(F, Z), [() => _(f())]), A(B, F);
            };
            ue(R, (B) => {
              f() && B(U);
            });
          }
          A(T, E);
        }, $ = (T) => {
          var E = I(), M = D(E);
          {
            var R = (B) => {
              var F = yF(), Z = D(F);
              {
                var Y = (ae) => {
                  var J = tt();
                  ke((j) => Me(J, j), [() => b(f())]), A(ae, J);
                };
                ue(Z, (ae) => {
                  f() && ae(Y);
                });
              }
              var X = be(Z, 2);
              n(X), A(B, F);
            }, U = (B) => {
              var F = tt();
              ke((Z, Y) => Me(F, `${Z ?? ""} ${Y ?? ""}`), [() => b(u()), () => _(u())]), A(B, F);
            };
            ue(
              M,
              (B) => {
                s() === "dropdown-years" ? B(R) : B(U, !1);
              },
              !0
            );
          }
          A(T, E);
        };
        ue(
          O,
          (T) => {
            s() === "dropdown-months" ? T(k) : T($, !1);
          },
          !0
        );
      }
      A(P, w);
    };
    ue(y, (P) => {
      s() === "dropdown" ? P(S) : P(x, !1);
    });
  }
  return A(t, h), W(g);
}
K(
  G1,
  {
    captionLayout: {},
    months: {},
    monthFormat: {},
    years: {},
    yearFormat: {},
    month: {},
    locale: {},
    placeholder: {},
    monthIndex: {}
  },
  [],
  [],
  { mode: "open" }
);
var bF = /* @__PURE__ */ ne('<div data-slot="checkbox-indicator" class="text-current transition-none"><!></div>');
function Y1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "checked", 15, !1), s = v(e, "indeterminate", 15, !1), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "checked",
    "indeterminate",
    "class"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get checked() {
      return n();
    },
    set checked(c = !1) {
      n(c), m();
    },
    get indeterminate() {
      return s();
    },
    set indeterminate(c = !1) {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    const c = (p, _) => {
      let b = () => _?.().checked, g = () => _?.().indeterminate;
      var h = bF(), y = he(h);
      {
        var S = (P) => {
          ru(P, { class: "size-3.5" });
        }, x = (P) => {
          var w = I(), O = D(w);
          {
            var k = ($) => {
              __($, { class: "size-3.5" });
            };
            ue(
              O,
              ($) => {
                g() && $(k);
              },
              !0
            );
          }
          A(P, w);
        };
        ue(y, (P) => {
          b() ? P(S) : P(x, !1);
        });
      }
      de(h), A(p, h);
    };
    let f = /* @__PURE__ */ C(() => Se("border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive peer flex size-4 shrink-0 items-center justify-center rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", o()));
    Q(u, () => gw, (p, _) => {
      _(p, ce(
        {
          "data-slot": "checkbox",
          get class() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get checked() {
            return n();
          },
          set checked(b) {
            n(b);
          },
          get indeterminate() {
            return s();
          },
          set indeterminate(b) {
            s(b);
          },
          children: c,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(Y1, { ref: {}, checked: {}, indeterminate: {}, class: {} }, [], [], { mode: "open" });
function ng(t, e) {
  H(e, !0);
  let r = v(e, "api", 15, null), n = v(e, "ref", 15, null), s = v(e, "value", 15, ""), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "api",
    "ref",
    "value",
    "class"
  ]);
  var a = {
    get api() {
      return r();
    },
    set api(c = null) {
      r(c), m();
    },
    get ref() {
      return n();
    },
    set ref(c = null) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c = "") {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    let c = /* @__PURE__ */ C(() => Se("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", o()));
    Q(u, () => qw, (f, p) => {
      et(
        p(f, ce(
          {
            "data-slot": "command",
            get class() {
              return d(c);
            }
          },
          () => i,
          {
            get value() {
              return s();
            },
            set value(_) {
              s(_);
            },
            get ref() {
              return n();
            },
            set ref(_) {
              n(_);
            }
          }
        )),
        (_) => r(_),
        () => r()
      );
    });
  }
  return A(t, l), W(a);
}
K(ng, { api: {}, ref: {}, value: {}, class: {} }, [], [], { mode: "open" });
function _F(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => Zw, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(_F, { ref: {} }, [], [], { mode: "open" });
function X1(t, e) {
  H(e, !0);
  let r = v(e, "open", 15, !1), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open"]);
  var s = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => a1, (a, l) => {
    l(a, ce(() => n, {
      get open() {
        return r();
      },
      set open(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(X1, { open: {} }, [], [], { mode: "open" });
function J1(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = I(), s = D(n);
  Q(s, () => iu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(J1, {}, [], [], { mode: "open" });
function Z1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("text-lg leading-none font-semibold", n()));
    Q(a, () => r0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-title",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(Z1, { ref: {}, class: {} }, [], [], { mode: "open" });
var wF = /* @__PURE__ */ ne("<div><!></div>");
function SF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = wF();
  ve(a, (u) => ({ "data-slot": "dialog-footer", class: u, ...o }), [
    () => Se("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(SF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var xF = /* @__PURE__ */ ne("<div><!></div>");
function Q1(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = xF();
  ve(a, (u) => ({ "data-slot": "dialog-header", class: u, ...o }), [
    () => Se("flex flex-col gap-2 text-center sm:text-start", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(Q1, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function eS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", n()));
    Q(a, () => v0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-overlay",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(eS, { ref: {}, class: {} }, [], [], { mode: "open" });
var PF = /* @__PURE__ */ ne('<!> <span class="sr-only">Close</span>', 1), OF = /* @__PURE__ */ ne("<!> <!>", 1), CF = /* @__PURE__ */ ne("<!> <!>", 1);
function tS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "portalProps", 7), o = v(e, "children", 7), i = v(e, "showCloseButton", 7, !0), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "portalProps",
    "children",
    "showCloseButton"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get portalProps() {
      return s();
    },
    set portalProps(u) {
      s(u), m();
    },
    get children() {
      return o();
    },
    set children(u) {
      o(u), m();
    },
    get showCloseButton() {
      return i();
    },
    set showCloseButton(u = !0) {
      i(u), m();
    }
  };
  return J1(t, ce(s, {
    children: (u, c) => {
      var f = CF(), p = D(f);
      Q(p, () => eS, (b, g) => {
        g(b, {});
      });
      var _ = be(p, 2);
      {
        let b = /* @__PURE__ */ C(() => Se("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", n()));
        Q(_, () => l1, (g, h) => {
          h(g, ce(
            {
              "data-slot": "dialog-content",
              get class() {
                return d(b);
              }
            },
            () => a,
            {
              get ref() {
                return r();
              },
              set ref(y) {
                r(y);
              },
              children: (y, S) => {
                var x = OF(), P = D(x);
                te(P, () => o() ?? ge);
                var w = be(P, 2);
                {
                  var O = (k) => {
                    var $ = I(), T = D($);
                    Q(T, () => Bh, (E, M) => {
                      M(E, {
                        class: "ring-offset-background focus:ring-ring absolute end-4 top-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
                        children: (R, U) => {
                          var B = PF(), F = D(B);
                          P_(F, {}), vt(2), A(R, B);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(k, $);
                  };
                  ue(w, (k) => {
                    i() && k(O);
                  });
                }
                A(y, x);
              },
              $$slots: { default: !0 }
            }
          ));
        });
      }
      A(u, f);
    },
    $$slots: { default: !0 }
  })), W(l);
}
K(
  tS,
  {
    ref: {},
    class: {},
    portalProps: {},
    children: {},
    showCloseButton: {}
  },
  [],
  [],
  { mode: "open" }
);
function rS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("text-muted-foreground text-sm", n()));
    Q(a, () => b0, (u, c) => {
      c(u, ce(
        {
          "data-slot": "dialog-description",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(rS, { ref: {}, class: {} }, [], [], { mode: "open" });
function kF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => y0, (a, l) => {
    l(a, ce({ "data-slot": "dialog-trigger" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(kF, { ref: {} }, [], [], { mode: "open" });
function $F(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => Bh, (a, l) => {
    l(a, ce({ "data-slot": "dialog-close" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K($F, { ref: {} }, [], [], { mode: "open" });
var AF = /* @__PURE__ */ ne("<!> <!>", 1), EF = /* @__PURE__ */ ne("<!> <!>", 1);
function TF(t, e) {
  H(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "ref", 15, null), s = v(e, "value", 15, ""), o = v(e, "title", 7, "Command Palette"), i = v(e, "description", 7, "Search for a command to run"), a = v(e, "portalProps", 7), l = v(e, "children", 7), u = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "open",
    "ref",
    "value",
    "title",
    "description",
    "portalProps",
    "children"
  ]);
  var c = {
    get open() {
      return r();
    },
    set open(_ = !1) {
      r(_), m();
    },
    get ref() {
      return n();
    },
    set ref(_ = null) {
      n(_), m();
    },
    get value() {
      return s();
    },
    set value(_ = "") {
      s(_), m();
    },
    get title() {
      return o();
    },
    set title(_ = "Command Palette") {
      o(_), m();
    },
    get description() {
      return i();
    },
    set description(_ = "Search for a command to run") {
      i(_), m();
    },
    get portalProps() {
      return a();
    },
    set portalProps(_) {
      a(_), m();
    },
    get children() {
      return l();
    },
    set children(_) {
      l(_), m();
    }
  }, f = I(), p = D(f);
  return Q(p, () => X1, (_, b) => {
    b(_, ce(() => u, {
      get open() {
        return r();
      },
      set open(g) {
        r(g);
      },
      children: (g, h) => {
        var y = EF(), S = D(y);
        Q(S, () => Q1, (P, w) => {
          w(P, {
            class: "sr-only",
            children: (O, k) => {
              var $ = AF(), T = D($);
              Q(T, () => Z1, (M, R) => {
                R(M, {
                  children: (U, B) => {
                    vt();
                    var F = tt();
                    ke(() => Me(F, o())), A(U, F);
                  },
                  $$slots: { default: !0 }
                });
              });
              var E = be(T, 2);
              Q(E, () => rS, (M, R) => {
                R(M, {
                  children: (U, B) => {
                    vt();
                    var F = tt();
                    ke(() => Me(F, i())), A(U, F);
                  },
                  $$slots: { default: !0 }
                });
              }), A(O, $);
            },
            $$slots: { default: !0 }
          });
        });
        var x = be(S, 2);
        Q(x, () => tS, (P, w) => {
          w(P, {
            class: "overflow-hidden p-0",
            get portalProps() {
              return a();
            },
            children: (O, k) => {
              ng(O, ce(
                {
                  class: "**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]]:px-2 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5"
                },
                () => u,
                {
                  get children() {
                    return l();
                  },
                  get value() {
                    return s();
                  },
                  set value($) {
                    s($);
                  },
                  get ref() {
                    return n();
                  },
                  set ref($) {
                    n($);
                  }
                }
              ));
            },
            $$slots: { default: !0 }
          });
        }), A(g, y);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, f), W(c);
}
K(
  TF,
  {
    open: {},
    ref: {},
    value: {},
    title: {},
    description: {},
    portalProps: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
function nS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("py-6 text-center text-sm", n()));
    Q(a, () => Uw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-empty",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(nS, { ref: {}, class: {} }, [], [], { mode: "open" });
var DF = /* @__PURE__ */ ne("<!> <!>", 1);
function sS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "heading", 7), i = v(e, "value", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "heading",
    "value"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get class() {
      return n();
    },
    set class(f) {
      n(f), m();
    },
    get children() {
      return s();
    },
    set children(f) {
      s(f), m();
    },
    get heading() {
      return o();
    },
    set heading(f) {
      o(f), m();
    },
    get value() {
      return i();
    },
    set value(f) {
      i(f), m();
    }
  }, u = I(), c = D(u);
  {
    let f = /* @__PURE__ */ C(() => Se("text-foreground overflow-hidden p-1", n())), p = /* @__PURE__ */ C(() => i() ?? o() ?? `----${kn()}`);
    Q(c, () => Kw, (_, b) => {
      b(_, ce(
        {
          "data-slot": "command-group",
          get class() {
            return d(f);
          },
          get value() {
            return d(p);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          children: (g, h) => {
            var y = DF(), S = D(y);
            {
              var x = (w) => {
                var O = I(), k = D(O);
                Q(k, () => Hw, ($, T) => {
                  T($, {
                    class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                    children: (E, M) => {
                      vt();
                      var R = tt();
                      ke(() => Me(R, o())), A(E, R);
                    },
                    $$slots: { default: !0 }
                  });
                }), A(w, O);
              };
              ue(S, (w) => {
                o() && w(x);
              });
            }
            var P = be(S, 2);
            Q(P, () => Ww, (w, O) => {
              O(w, {
                get children() {
                  return s();
                }
              });
            }), A(g, y);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, u), W(l);
}
K(sS, { ref: {}, class: {}, children: {}, heading: {}, value: {} }, [], [], { mode: "open" });
function oS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(a, () => Yw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-item",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(oS, { ref: {}, class: {} }, [], [], { mode: "open" });
var MF = /* @__PURE__ */ ne('<div class="flex h-9 items-center gap-2 border-b ps-3 pe-8" data-slot="command-input-wrapper"><!> <!></div>');
function iS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 15, ""), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c = "") {
      s(c), m();
    }
  }, a = MF(), l = he(a);
  w_(l, { class: "size-4 shrink-0 opacity-50" });
  var u = be(l, 2);
  {
    let c = /* @__PURE__ */ C(() => Se("placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(u, () => Gw, (f, p) => {
      p(f, ce(
        {
          "data-slot": "command-input",
          get class() {
            return d(c);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          get value() {
            return s();
          },
          set value(_) {
            s(_);
          }
        }
      ));
    });
  }
  return de(a), A(t, a), W(i);
}
K(iS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
function aS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto", n()));
    Q(a, () => Jw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-list",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(aS, { ref: {}, class: {} }, [], [], { mode: "open" });
function IF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("bg-border -mx-1 h-px", n()));
    Q(a, () => Qw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-separator",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(IF, { ref: {}, class: {} }, [], [], { mode: "open" });
var NF = /* @__PURE__ */ ne("<span><!></span>");
function FF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = NF();
  ve(a, (u) => ({ "data-slot": "command-shortcut", class: u, ...o }), [
    () => Se("text-muted-foreground ms-auto text-xs tracking-widest", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(FF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function RF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(a, () => Xw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "command-item",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(RF, { ref: {}, class: {} }, [], [], { mode: "open" });
const VF = Ri({
  base: "group/field data-[invalid=true]:text-destructive flex w-full gap-3",
  variants: {
    orientation: {
      vertical: "flex-col [&>*]:w-full [&>.sr-only]:w-auto",
      horizontal: [
        "flex-row items-center",
        "[&>[data-slot=field-label]]:flex-auto",
        "has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ],
      responsive: [
        "flex-col @md/field-group:flex-row @md/field-group:items-center [&>*]:w-full @md/field-group:[&>*]:w-auto [&>.sr-only]:w-auto",
        "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
        "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ]
    }
  },
  defaultVariants: { orientation: "vertical" }
});
var LF = /* @__PURE__ */ ne("<div><!></div>");
function lS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "orientation", 7, "vertical"), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "orientation",
    "children"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get orientation() {
      return s();
    },
    set orientation(c = "vertical") {
      s(c), m();
    },
    get children() {
      return o();
    },
    set children(c) {
      o(c), m();
    }
  }, l = LF();
  ve(
    l,
    (c) => ({
      role: "group",
      "data-slot": "field",
      "data-orientation": s(),
      class: c,
      ...i
    }),
    [
      () => Se(VF({ orientation: s() }), n())
    ]
  );
  var u = he(l);
  return te(u, () => o() ?? ge), de(l), et(l, (c) => r(c), () => r()), A(t, l), W(a);
}
K(lS, { ref: {}, class: {}, orientation: {}, children: {} }, [], [], { mode: "open" });
var jF = /* @__PURE__ */ ne("<fieldset><!></fieldset>");
function uS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = jF();
  ve(a, (u) => ({ "data-slot": "field-set", class: u, ...o }), [
    () => Se("flex flex-col gap-6", "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(uS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var BF = /* @__PURE__ */ ne("<legend><!></legend>");
function cS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "variant", 7, "legend"), o = v(e, "children", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "variant",
    "children"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get variant() {
      return s();
    },
    set variant(c = "legend") {
      s(c), m();
    },
    get children() {
      return o();
    },
    set children(c) {
      o(c), m();
    }
  }, l = BF();
  ve(
    l,
    (c) => ({
      "data-slot": "field-legend",
      "data-variant": s(),
      class: c,
      ...i
    }),
    [
      () => Se("mb-3 font-medium", "data-[variant=legend]:text-base", "data-[variant=label]:text-sm", n())
    ]
  );
  var u = he(l);
  return te(u, () => o() ?? ge), de(l), et(l, (c) => r(c), () => r()), A(t, l), W(a);
}
K(cS, { ref: {}, class: {}, variant: {}, children: {} }, [], [], { mode: "open" });
var zF = /* @__PURE__ */ ne("<div><!></div>");
function dS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = zF();
  ve(a, (u) => ({ "data-slot": "field-group", class: u, ...o }), [
    () => Se("group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(dS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var qF = /* @__PURE__ */ ne("<div><!></div>");
function UF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = qF();
  ve(a, (u) => ({ "data-slot": "field-content", class: u, ...o }), [
    () => Se("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(UF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function fS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", n()));
    Q(a, () => u1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "label",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(fS, { ref: {}, class: {} }, [], [], { mode: "open" });
function hS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    },
    get class() {
      return n();
    },
    set class(a) {
      n(a), m();
    },
    get children() {
      return s();
    },
    set children(a) {
      s(a), m();
    }
  };
  {
    let a = /* @__PURE__ */ C(() => Se("group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50", "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4", "has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10", n()));
    fS(t, ce(
      {
        "data-slot": "field-label",
        get class() {
          return d(a);
        }
      },
      () => o,
      {
        get ref() {
          return r();
        },
        set ref(l) {
          r(l);
        },
        children: (l, u) => {
          var c = I(), f = D(c);
          te(f, () => s() ?? ge), A(l, c);
        },
        $$slots: { default: !0 }
      }
    ));
  }
  return W(i);
}
K(hS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var KF = /* @__PURE__ */ ne("<div><!></div>");
function gS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = KF();
  ve(a, (u) => ({ "data-slot": "field-title", class: u, ...o }), [
    () => Se("flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(gS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var HF = /* @__PURE__ */ ne("<p><!></p>");
function pS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = HF();
  ve(a, (u) => ({ "data-slot": "field-description", class: u, ...o }), [
    () => Se("text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance", "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5", "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(pS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var WF = /* @__PURE__ */ ne('<span class="bg-background text-muted-foreground relative mx-auto block w-fit px-2" data-slot="field-separator-content"><!></span>'), GF = /* @__PURE__ */ ne("<div><!> <!></div>");
function YF(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  const i = /* @__PURE__ */ C(() => !!s());
  var a = {
    get ref() {
      return r();
    },
    set ref(p = null) {
      r(p), m();
    },
    get class() {
      return n();
    },
    set class(p) {
      n(p), m();
    },
    get children() {
      return s();
    },
    set children(p) {
      s(p), m();
    }
  }, l = GF();
  ve(
    l,
    (p) => ({
      "data-slot": "field-separator",
      "data-content": d(i),
      class: p,
      ...o
    }),
    [
      () => Se("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", n())
    ]
  );
  var u = he(l);
  mu(u, { class: "absolute inset-0 top-1/2" });
  var c = be(u, 2);
  {
    var f = (p) => {
      var _ = WF(), b = he(_);
      te(b, s), de(_), A(p, _);
    };
    ue(c, (p) => {
      s() && p(f);
    });
  }
  return de(l), et(l, (p) => r(p), () => r()), A(t, l), W(a);
}
K(YF, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var XF = /* @__PURE__ */ ne("<li> </li>"), JF = /* @__PURE__ */ ne('<ul class="ms-4 flex list-disc flex-col gap-1"></ul>'), ZF = /* @__PURE__ */ ne("<div><!></div>");
function mS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "errors", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "errors"
  ]);
  const a = /* @__PURE__ */ C(() => s() ? !0 : !(!o() || o().length === 0 || o().length === 1 && !o()[0]?.message)), l = /* @__PURE__ */ C(() => o() && o().length > 1), u = /* @__PURE__ */ C(() => o() && o().length === 1 && o()[0]?.message);
  var c = {
    get ref() {
      return r();
    },
    set ref(b = null) {
      r(b), m();
    },
    get class() {
      return n();
    },
    set class(b) {
      n(b), m();
    },
    get children() {
      return s();
    },
    set children(b) {
      s(b), m();
    },
    get errors() {
      return o();
    },
    set errors(b) {
      o(b), m();
    }
  }, f = I(), p = D(f);
  {
    var _ = (b) => {
      var g = ZF();
      ve(
        g,
        (x) => ({
          role: "alert",
          "data-slot": "field-error",
          class: x,
          ...i
        }),
        [
          () => Se("text-destructive text-sm font-normal", n())
        ]
      );
      var h = he(g);
      {
        var y = (x) => {
          var P = I(), w = D(P);
          te(w, s), A(x, P);
        }, S = (x) => {
          var P = I(), w = D(P);
          {
            var O = ($) => {
              var T = tt();
              ke(() => Me(T, d(u))), A($, T);
            }, k = ($) => {
              var T = I(), E = D(T);
              {
                var M = (R) => {
                  var U = JF();
                  st(U, 21, () => o() ?? [], Ll, (B, F) => {
                    var Z = I(), Y = D(Z);
                    {
                      var X = (ae) => {
                        var J = XF(), j = he(J, !0);
                        de(J), ke(() => Me(j, d(F).message)), A(ae, J);
                      };
                      ue(Y, (ae) => {
                        d(F)?.message && ae(X);
                      });
                    }
                    A(B, Z);
                  }), de(U), A(R, U);
                };
                ue(
                  E,
                  (R) => {
                    d(l) && R(M);
                  },
                  !0
                );
              }
              A($, T);
            };
            ue(
              w,
              ($) => {
                d(u) ? $(O) : $(k, !1);
              },
              !0
            );
          }
          A(x, P);
        };
        ue(h, (x) => {
          s() ? x(y) : x(S, !1);
        });
      }
      de(g), et(g, (x) => r(x), () => r()), A(b, g);
    };
    ue(p, (b) => {
      d(a) && b(_);
    });
  }
  return A(t, f), W(c);
}
K(mS, { ref: {}, class: {}, children: {}, errors: {} }, [], [], { mode: "open" });
var QF = /* @__PURE__ */ ne("<input/>"), eR = /* @__PURE__ */ ne("<input/>");
function vS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "type", 7), o = v(e, "files", 15), i = v(e, "class", 7), a = v(e, "data-slot", 7, "input"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "type",
    "files",
    "class",
    "data-slot"
  ]);
  var u = {
    get ref() {
      return r();
    },
    set ref(b = null) {
      r(b), m();
    },
    get value() {
      return n();
    },
    set value(b) {
      n(b), m();
    },
    get type() {
      return s();
    },
    set type(b) {
      s(b), m();
    },
    get files() {
      return o();
    },
    set files(b) {
      o(b), m();
    },
    get class() {
      return i();
    },
    set class(b) {
      i(b), m();
    },
    get "data-slot"() {
      return a();
    },
    set "data-slot"(b = "input") {
      a(b), m();
    }
  }, c = I(), f = D(c);
  {
    var p = (b) => {
      var g = QF();
      ve(
        g,
        (h) => ({
          "data-slot": a(),
          class: h,
          type: "file",
          ...l
        }),
        [
          () => Se("selection:bg-primary dark:bg-input/30 selection:text-primary-foreground border-input ring-offset-background placeholder:text-muted-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 pt-1.5 text-sm font-medium shadow-xs transition-[color,box-shadow] outline-none disabled:cursor-not-allowed disabled:opacity-50", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", i())
        ],
        void 0,
        void 0,
        void 0,
        !0
      ), et(g, (h) => r(h), () => r()), sy(g, o), fo(g, n), A(b, g);
    }, _ = (b) => {
      var g = eR();
      ve(
        g,
        (h) => ({
          "data-slot": a(),
          class: h,
          type: s(),
          ...l
        }),
        [
          () => Se("border-input bg-background selection:bg-primary dark:bg-input/30 selection:text-primary-foreground ring-offset-background placeholder:text-muted-foreground flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", i())
        ],
        void 0,
        void 0,
        void 0,
        !0
      ), et(g, (h) => r(h), () => r()), fo(g, n), A(b, g);
    };
    ue(f, (b) => {
      s() === "file" ? b(p) : b(_, !1);
    });
  }
  return A(t, c), W(u);
}
K(
  vS,
  {
    ref: {},
    value: {},
    type: {},
    files: {},
    class: {},
    "data-slot": {}
  },
  [],
  [],
  { mode: "open" }
);
function yS(t, e) {
  H(e, !0);
  let r = v(e, "open", 15, !1), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open"]);
  var s = {
    get open() {
      return r();
    },
    set open(a = !1) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => c1, (a, l) => {
    l(a, ce(() => n, {
      get open() {
        return r();
      },
      set open(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(yS, { open: {} }, [], [], { mode: "open" });
function tR(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => n1, (a, l) => {
    l(a, ce({ "data-slot": "popover-close" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(tR, { ref: {} }, [], [], { mode: "open" });
function bS(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = I(), s = D(n);
  Q(s, () => iu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(bS, {}, [], [], { mode: "open" });
function _S(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "sideOffset", 7, 4), o = v(e, "align", 7, "center"), i = v(e, "portalProps", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "sideOffset",
    "align",
    "portalProps"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(u = 4) {
      s(u), m();
    },
    get align() {
      return o();
    },
    set align(u = "center") {
      o(u), m();
    },
    get portalProps() {
      return i();
    },
    set portalProps(u) {
      i(u), m();
    }
  };
  return bS(t, ce(i, {
    children: (u, c) => {
      var f = I(), p = D(f);
      {
        let _ = /* @__PURE__ */ C(() => Se("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-end-2 data-[side=right]:slide-in-from-start-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--bits-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden", n()));
        Q(p, () => t1, (b, g) => {
          g(b, ce(
            {
              "data-slot": "popover-content",
              get sideOffset() {
                return s();
              },
              get align() {
                return o();
              },
              get class() {
                return d(_);
              }
            },
            () => a,
            {
              get ref() {
                return r();
              },
              set ref(h) {
                r(h);
              }
            }
          ));
        });
      }
      A(u, f);
    },
    $$slots: { default: !0 }
  })), W(l);
}
K(
  _S,
  {
    ref: {},
    class: {},
    sideOffset: {},
    align: {},
    portalProps: {}
  },
  [],
  [],
  { mode: "open" }
);
function wS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("", n()));
    Q(a, () => r1, (u, c) => {
      c(u, ce(
        {
          "data-slot": "popover-trigger",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(wS, { ref: {}, class: {} }, [], [], { mode: "open" });
function SS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 15, ""), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u = "") {
      s(u), m();
    }
  }, a = I(), l = D(a);
  {
    let u = /* @__PURE__ */ C(() => Se("grid gap-3", n()));
    Q(l, () => f1, (c, f) => {
      f(c, ce(
        {
          "data-slot": "radio-group",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          get value() {
            return s();
          },
          set value(p) {
            s(p);
          }
        }
      ));
    });
  }
  return A(t, a), W(i);
}
K(SS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var rR = /* @__PURE__ */ ne('<div data-slot="radio-group-indicator" class="relative flex items-center justify-center"><!></div>');
function xS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    const l = (c, f) => {
      let p = () => f?.().checked;
      var _ = rR(), b = he(_);
      {
        var g = (h) => {
          y_(h, {
            class: "fill-primary absolute start-1/2 top-1/2 size-2 -translate-x-1/2 -translate-y-1/2"
          });
        };
        ue(b, (h) => {
          p() && h(g);
        });
      }
      de(_), A(c, _);
    };
    let u = /* @__PURE__ */ C(() => Se("border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(a, () => h1, (c, f) => {
      f(c, ce(
        {
          "data-slot": "radio-group-item",
          get class() {
            return d(u);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          children: l,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(xS, { ref: {}, class: {} }, [], [], { mode: "open" });
var nR = /* @__PURE__ */ ne("<!> <!>", 1), sR = /* @__PURE__ */ ne("<!> <!>", 1), oR = /* @__PURE__ */ ne("<!> <!>", 1), iR = /* @__PURE__ */ ne("<!> <!>", 1);
function PS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "placeholder", 15), o = v(e, "weekdayFormat", 7, "short"), i = v(e, "class", 7), a = v(e, "buttonVariant", 7, "ghost"), l = v(e, "captionLayout", 7, "label"), u = v(e, "locale", 7, "en-US"), c = v(e, "months", 7), f = v(e, "years", 7), p = v(e, "monthFormat", 7), _ = v(e, "yearFormat", 7, "numeric"), b = v(e, "day", 7), g = v(e, "disableDaysOutsideMonth", 7, !1), h = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "placeholder",
    "weekdayFormat",
    "class",
    "buttonVariant",
    "captionLayout",
    "locale",
    "months",
    "years",
    "monthFormat",
    "yearFormat",
    "day",
    "disableDaysOutsideMonth"
  ]);
  const y = /* @__PURE__ */ C(() => p() ? p() : l().startsWith("dropdown") ? "short" : "long");
  var S = {
    get ref() {
      return r();
    },
    set ref(w = null) {
      r(w), m();
    },
    get value() {
      return n();
    },
    set value(w) {
      n(w), m();
    },
    get placeholder() {
      return s();
    },
    set placeholder(w) {
      s(w), m();
    },
    get weekdayFormat() {
      return o();
    },
    set weekdayFormat(w = "short") {
      o(w), m();
    },
    get class() {
      return i();
    },
    set class(w) {
      i(w), m();
    },
    get buttonVariant() {
      return a();
    },
    set buttonVariant(w = "ghost") {
      a(w), m();
    },
    get captionLayout() {
      return l();
    },
    set captionLayout(w = "label") {
      l(w), m();
    },
    get locale() {
      return u();
    },
    set locale(w = "en-US") {
      u(w), m();
    },
    get months() {
      return c();
    },
    set months(w) {
      c(w), m();
    },
    get years() {
      return f();
    },
    set years(w) {
      f(w), m();
    },
    get monthFormat() {
      return p();
    },
    set monthFormat(w) {
      p(w), m();
    },
    get yearFormat() {
      return _();
    },
    set yearFormat(w = "numeric") {
      _(w), m();
    },
    get day() {
      return b();
    },
    set day(w) {
      b(w), m();
    },
    get disableDaysOutsideMonth() {
      return g();
    },
    set disableDaysOutsideMonth(w = !1) {
      g(w), m();
    }
  }, x = I(), P = D(x);
  {
    const w = (k, $) => {
      let T = () => $?.().months, E = () => $?.().weekdays;
      var M = I(), R = D(M);
      Q(R, () => AS, (U, B) => {
        B(U, {
          children: (F, Z) => {
            var Y = iR(), X = D(Y);
            Q(X, () => FS, (J, j) => {
              j(J, {
                children: (ee, L) => {
                  var N = nR(), V = D(N);
                  Q(V, () => DS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  });
                  var G = be(V, 2);
                  Q(G, () => TS, (fe, se) => {
                    se(fe, {
                      get variant() {
                        return a();
                      }
                    });
                  }), A(ee, N);
                },
                $$slots: { default: !0 }
              });
            });
            var ae = be(X, 2);
            st(ae, 18, T, (J) => J, (J, j, ee) => {
              var L = I(), N = D(L);
              Q(N, () => RS, (V, G) => {
                G(V, {
                  children: (fe, se) => {
                    var we = oR(), le = D(we);
                    Q(le, () => $S, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = I(), Re = D(Oe);
                          Q(Re, () => NS, (Ke, Ve) => {
                            Ve(Ke, {
                              get captionLayout() {
                                return l();
                              },
                              get months() {
                                return c();
                              },
                              get monthFormat() {
                                return d(y);
                              },
                              get years() {
                                return f();
                              },
                              get yearFormat() {
                                return _();
                              },
                              get month() {
                                return j.value;
                              },
                              get locale() {
                                return u();
                              },
                              get monthIndex() {
                                return d(ee);
                              },
                              get placeholder() {
                                return s();
                              },
                              set placeholder(je) {
                                s(je);
                              }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    });
                    var re = be(le, 2);
                    Q(re, () => kS, (oe, pe) => {
                      pe(oe, {
                        children: (ye, Pe) => {
                          var Oe = sR(), Re = D(Oe);
                          Q(Re, () => LS, (Ve, je) => {
                            je(Ve, {
                              children: (He, gt) => {
                                var Je = I(), kt = D(Je);
                                Q(kt, () => Qc, (lt, ct) => {
                                  ct(lt, {
                                    class: "select-none",
                                    children: (pt, Kt) => {
                                      var yt = I(), Rt = D(yt);
                                      st(Rt, 16, E, (Dt) => Dt, (Dt, Ht) => {
                                        var Wt = I(), un = D(Wt);
                                        Q(un, () => ES, (nr, sr) => {
                                          sr(nr, {
                                            children: (Pr, Gs) => {
                                              vt();
                                              var mr = tt();
                                              ke((qr) => Me(mr, qr), [() => Ht.slice(0, 2)]), A(Pr, mr);
                                            },
                                            $$slots: { default: !0 }
                                          });
                                        }), A(Dt, Wt);
                                      }), A(pt, yt);
                                    },
                                    $$slots: { default: !0 }
                                  });
                                }), A(He, Je);
                              },
                              $$slots: { default: !0 }
                            });
                          });
                          var Ke = be(Re, 2);
                          Q(Ke, () => VS, (Ve, je) => {
                            je(Ve, {
                              children: (He, gt) => {
                                var Je = I(), kt = D(Je);
                                st(kt, 16, () => j.weeks, (lt) => lt, (lt, ct) => {
                                  var pt = I(), Kt = D(pt);
                                  Q(Kt, () => Qc, (yt, Rt) => {
                                    Rt(yt, {
                                      class: "mt-2 w-full",
                                      children: (Dt, Ht) => {
                                        var Wt = I(), un = D(Wt);
                                        st(un, 16, () => ct, (nr) => nr, (nr, sr) => {
                                          var Pr = I(), Gs = D(Pr);
                                          Q(Gs, () => OS, (mr, qr) => {
                                            qr(mr, {
                                              get date() {
                                                return sr;
                                              },
                                              get month() {
                                                return j.value;
                                              },
                                              children: (Uo, vu) => {
                                                var Ko = I(), yu = D(Ko);
                                                {
                                                  var bu = (or) => {
                                                    var Or = I(), ds = D(Or);
                                                    {
                                                      let fs = /* @__PURE__ */ C(() => ({ day: sr, outsideMonth: !w0(sr, j.value) }));
                                                      te(ds, b, () => d(fs));
                                                    }
                                                    A(or, Or);
                                                  }, _u = (or) => {
                                                    var Or = I(), ds = D(Or);
                                                    Q(ds, () => CS, (fs, wu) => {
                                                      wu(fs, {});
                                                    }), A(or, Or);
                                                  };
                                                  ue(yu, (or) => {
                                                    b() ? or(bu) : or(_u, !1);
                                                  });
                                                }
                                                A(Uo, Ko);
                                              },
                                              $$slots: { default: !0 }
                                            });
                                          }), A(nr, Pr);
                                        }), A(Dt, Wt);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(lt, pt);
                                }), A(He, Je);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(ye, Oe);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(fe, we);
                  },
                  $$slots: { default: !0 }
                });
              }), A(J, L);
            }), A(F, Y);
          },
          $$slots: { default: !0 }
        });
      }), A(k, M);
    };
    let O = /* @__PURE__ */ C(() => Se("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", i()));
    Q(P, () => g1, (k, $) => {
      $(k, ce(
        {
          get weekdayFormat() {
            return o();
          },
          get disableDaysOutsideMonth() {
            return g();
          },
          get class() {
            return d(O);
          },
          get locale() {
            return u();
          },
          get monthFormat() {
            return d(y);
          },
          get yearFormat() {
            return _();
          }
        },
        () => h,
        {
          get ref() {
            return r();
          },
          set ref(T) {
            r(T);
          },
          get value() {
            return n();
          },
          set value(T) {
            n(T);
          },
          get placeholder() {
            return s();
          },
          set placeholder(T) {
            s(T);
          },
          children: w,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, x), W(S);
}
K(
  PS,
  {
    ref: {},
    value: {},
    placeholder: {},
    weekdayFormat: {},
    class: {},
    buttonVariant: {},
    captionLayout: {},
    locale: {},
    months: {},
    years: {},
    monthFormat: {},
    yearFormat: {},
    day: {},
    disableDaysOutsideMonth: {}
  },
  [],
  [],
  { mode: "open" }
);
function OS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("dark:[&:has([data-range-start])]:hover:bg-accent dark:[&:has([data-range-end])]:hover:bg-accent [&:has([data-range-middle])]:bg-accent dark:[&:has([data-range-middle])]:hover:bg-accent/50 [&:has([data-selected])]:bg-accent relative size-(--cell-size) p-0 text-center text-sm focus-within:z-20 data-[range-middle]:rounded-e-md [&:first-child[data-selected]_[data-bits-day]]:rounded-s-md [&:has([data-range-end])]:rounded-e-md [&:has([data-range-middle])]:rounded-none first:[&:has([data-range-middle])]:rounded-s-md last:[&:has([data-range-middle])]:rounded-e-md [&:has([data-range-start])]:rounded-s-md [&:last-child[data-selected]_[data-bits-day]]:rounded-e-md", n()));
    Q(a, () => o1, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(OS, { ref: {}, class: {} }, [], [], { mode: "open" });
function CS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se(ss({ variant: "ghost" }), "flex size-(--cell-size) flex-col items-center justify-center gap-1 p-0 leading-none font-normal whitespace-nowrap select-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground data-[range-middle]:rounded-none", "data-[range-start]:bg-primary dark:data-[range-start]:hover:bg-accent data-[range-start]:text-primary-foreground", "data-[range-end]:bg-primary dark:data-[range-end]:hover:bg-accent data-[range-end]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:line-through", "dark:data-[range-middle]:hover:bg-accent/0", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", n()));
    Q(a, () => i1, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(CS, { ref: {}, class: {} }, [], [], { mode: "open" });
function kS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("mt-4 flex w-full border-collapse flex-col gap-1", n()));
    Q(a, () => Bf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(kS, { ref: {}, class: {} }, [], [], { mode: "open" });
function $S(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex h-(--cell-size) w-full items-center justify-center gap-1.5 text-sm font-medium", n()));
    Q(a, () => Hf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K($S, { ref: {}, class: {} }, [], [], { mode: "open" });
var aR = /* @__PURE__ */ ne("<div><!></div>");
function AS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = aR();
  ve(a, (u) => ({ class: u, ...o }), [
    () => Se("relative flex flex-col gap-4 md:flex-row", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(AS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function Qc(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex", n()));
    Q(a, () => Kf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(Qc, { ref: {}, class: {} }, [], [], { mode: "open" });
function lR(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("px-(--cell-size) text-sm font-medium", n()));
    Q(a, () => Wf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(lR, { ref: {}, class: {} }, [], [], { mode: "open" });
function ES(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", n()));
    Q(a, () => Uf, (u, c) => {
      c(u, ce(
        {
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(ES, { ref: {}, class: {} }, [], [], { mode: "open" });
const uR = (t) => {
  Gd(t, { class: "size-4" });
};
function TS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    let c = /* @__PURE__ */ C(() => Se(ss({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ C(() => s() || uR);
    Q(u, () => Yf, (p, _) => {
      _(p, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(TS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
const cR = (t) => {
  Wd(t, { class: "size-4" });
};
function DS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "variant", 7, "ghost"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "variant"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get variant() {
      return o();
    },
    set variant(c = "ghost") {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    let c = /* @__PURE__ */ C(() => Se(ss({ variant: o() }), "size-(--cell-size) bg-transparent p-0 select-none disabled:opacity-50 rtl:rotate-180", n())), f = /* @__PURE__ */ C(() => s() || cR);
    Q(u, () => Xf, (p, _) => {
      _(p, ce(
        {
          get class() {
            return d(c);
          },
          get children() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(DS, { ref: {}, class: {}, children: {}, variant: {} }, [], [], { mode: "open" });
var dR = /* @__PURE__ */ ne("<option> </option>"), fR = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), hR = /* @__PURE__ */ ne("<span><!></span>");
function MS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "onchange", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "onchange"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get value() {
      return s();
    },
    set value(c) {
      s(c), m();
    },
    get onchange() {
      return o();
    },
    set onchange(c) {
      o(c), m();
    }
  }, l = hR(), u = he(l);
  {
    const c = (f, p) => {
      let _ = () => p?.().props, b = () => p?.().monthItems, g = () => p?.().selectedMonthItem;
      var h = fR(), y = D(h);
      ve(y, () => ({ ..._(), value: s(), onchange: o() })), st(y, 21, b, (w) => w.value, (w, O) => {
        var k = dR(), $ = he(k, !0);
        de(k);
        var T = {};
        ke(() => {
          zs(k, s() !== void 0 ? d(O).value === s() : d(O).value === g().value), Me($, d(O).label), T !== (T = d(O).value) && (k.value = (k.__value = d(O).value) ?? "");
        }), A(w, k);
      }), de(y);
      var S = be(y, 2), x = he(S), P = be(x);
      Ks(P, { class: "size-4" }), de(S), ke((w) => Me(x, `${w ?? ""} `), [
        () => b().find((w) => w.value === s())?.label || g().label
      ]), A(f, h);
    };
    Q(u, () => Gf, (f, p) => {
      p(f, ce({ class: "absolute inset-0 opacity-0" }, () => i, {
        get ref() {
          return r();
        },
        set ref(_) {
          r(_);
        },
        child: c,
        $$slots: { child: !0 }
      }));
    });
  }
  return de(l), ke((c) => Bs(l, 1, c), [
    () => js(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, l), W(a);
}
K(MS, { ref: {}, class: {}, value: {}, onchange: {} }, [], [], { mode: "open" });
var gR = /* @__PURE__ */ ne("<option> </option>"), pR = /* @__PURE__ */ ne('<select></select> <span class="[&amp;>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md ps-2 pe-1 text-sm font-medium select-none [&amp;>svg]:size-3.5" aria-hidden="true"> <!></span>', 1), mR = /* @__PURE__ */ ne("<span><!></span>");
function IS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get value() {
      return s();
    },
    set value(u) {
      s(u), m();
    }
  }, a = mR(), l = he(a);
  {
    const u = (c, f) => {
      let p = () => f?.().props, _ = () => f?.().yearItems, b = () => f?.().selectedYearItem;
      var g = pR(), h = D(g);
      ve(h, () => ({ ...p(), value: s() })), st(h, 21, _, (P) => P.value, (P, w) => {
        var O = gR(), k = he(O, !0);
        de(O);
        var $ = {};
        ke(() => {
          zs(O, s() !== void 0 ? d(w).value === s() : d(w).value === b().value), Me(k, d(w).label), $ !== ($ = d(w).value) && (O.value = (O.__value = d(w).value) ?? "");
        }), A(P, O);
      }), de(h);
      var y = be(h, 2), S = he(y), x = be(S);
      Ks(x, { class: "size-4" }), de(y), ke((P) => Me(S, `${P ?? ""} `), [
        () => _().find((P) => P.value === s())?.label || b().label
      ]), A(c, g);
    };
    Q(l, () => Jf, (c, f) => {
      f(c, ce({ class: "absolute inset-0 opacity-0" }, () => o, {
        get ref() {
          return r();
        },
        set ref(p) {
          r(p);
        },
        child: u,
        $$slots: { child: !0 }
      }));
    });
  }
  return de(a), ke((u) => Bs(a, 1, u), [
    () => js(Se("has-focus:border-ring border-input has-focus:ring-ring/50 relative flex rounded-md border shadow-xs has-focus:ring-[3px]", n()))
  ]), A(t, a), W(i);
}
K(IS, { ref: {}, class: {}, value: {} }, [], [], { mode: "open" });
var vR = /* @__PURE__ */ ne("<!> <!>", 1), yR = /* @__PURE__ */ ne("<!> <!>", 1), bR = /* @__PURE__ */ ne("<!> <!>", 1);
function NS(t, e) {
  H(e, !0);
  const r = (P) => {
    MS(P, {
      get months() {
        return o();
      },
      get monthFormat() {
        return i();
      },
      get value() {
        return u().month;
      },
      onchange: (w) => {
        if (!f()) return;
        const O = Number.parseInt(w.currentTarget.value), k = f().set({ month: O });
        f(k.subtract({ months: p() }));
      }
    });
  }, n = (P) => {
    IS(P, {
      get years() {
        return a();
      },
      get yearFormat() {
        return l();
      },
      get value() {
        return u().year;
      }
    });
  };
  let s = v(e, "captionLayout", 7), o = v(e, "months", 7), i = v(e, "monthFormat", 7), a = v(e, "years", 7), l = v(e, "yearFormat", 7), u = v(e, "month", 7), c = v(e, "locale", 7), f = v(e, "placeholder", 15), p = v(e, "monthIndex", 7, 0);
  function _(P) {
    const w = P.toDate(ft());
    return typeof l() == "function" ? l()(w.getFullYear()) : new Lt(c(), { year: l() }).format(w);
  }
  function b(P) {
    const w = P.toDate(ft());
    return typeof i() == "function" ? i()(w.getMonth() + 1) : new Lt(c(), { month: i() }).format(w);
  }
  var g = {
    get captionLayout() {
      return s();
    },
    set captionLayout(P) {
      s(P), m();
    },
    get months() {
      return o();
    },
    set months(P) {
      o(P), m();
    },
    get monthFormat() {
      return i();
    },
    set monthFormat(P) {
      i(P), m();
    },
    get years() {
      return a();
    },
    set years(P) {
      a(P), m();
    },
    get yearFormat() {
      return l();
    },
    set yearFormat(P) {
      l(P), m();
    },
    get month() {
      return u();
    },
    set month(P) {
      u(P), m();
    },
    get locale() {
      return c();
    },
    set locale(P) {
      c(P), m();
    },
    get placeholder() {
      return f();
    },
    set placeholder(P) {
      f(P), m();
    },
    get monthIndex() {
      return p();
    },
    set monthIndex(P = 0) {
      p(P), m();
    }
  }, h = I(), y = D(h);
  {
    var S = (P) => {
      var w = vR(), O = D(w);
      r(O);
      var k = be(O, 2);
      n(k), A(P, w);
    }, x = (P) => {
      var w = I(), O = D(w);
      {
        var k = (T) => {
          var E = yR(), M = D(E);
          r(M);
          var R = be(M, 2);
          {
            var U = (B) => {
              var F = tt();
              ke((Z) => Me(F, Z), [() => _(f())]), A(B, F);
            };
            ue(R, (B) => {
              f() && B(U);
            });
          }
          A(T, E);
        }, $ = (T) => {
          var E = I(), M = D(E);
          {
            var R = (B) => {
              var F = bR(), Z = D(F);
              {
                var Y = (ae) => {
                  var J = tt();
                  ke((j) => Me(J, j), [() => b(f())]), A(ae, J);
                };
                ue(Z, (ae) => {
                  f() && ae(Y);
                });
              }
              var X = be(Z, 2);
              n(X), A(B, F);
            }, U = (B) => {
              var F = tt();
              ke((Z, Y) => Me(F, `${Z ?? ""} ${Y ?? ""}`), [() => b(u()), () => _(u())]), A(B, F);
            };
            ue(
              M,
              (B) => {
                s() === "dropdown-years" ? B(R) : B(U, !1);
              },
              !0
            );
          }
          A(T, E);
        };
        ue(
          O,
          (T) => {
            s() === "dropdown-months" ? T(k) : T($, !1);
          },
          !0
        );
      }
      A(P, w);
    };
    ue(y, (P) => {
      s() === "dropdown" ? P(S) : P(x, !1);
    });
  }
  return A(t, h), W(g);
}
K(
  NS,
  {
    captionLayout: {},
    months: {},
    monthFormat: {},
    years: {},
    yearFormat: {},
    month: {},
    locale: {},
    placeholder: {},
    monthIndex: {}
  },
  [],
  [],
  { mode: "open" }
);
var _R = /* @__PURE__ */ ne("<nav><!></nav>");
function FS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = _R();
  ve(a, (u) => ({ ...o, class: u }), [
    () => Se("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(FS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var wR = /* @__PURE__ */ ne("<div><!></div>");
function RS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = wR();
  ve(a, (u) => ({ ...o, class: u }), [() => Se("flex flex-col", n())]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(RS, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
function VS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => zf, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(VS, { ref: {} }, [], [], { mode: "open" });
function LS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => qf, (a, l) => {
    l(a, ce(() => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(LS, { ref: {} }, [], [], { mode: "open" });
function jS(t, e) {
  H(e, !0);
  let r = v(e, "open", 15, !1), n = v(e, "value", 15), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "open", "value"]);
  var o = {
    get open() {
      return r();
    },
    set open(l = !1) {
      r(l), m();
    },
    get value() {
      return n();
    },
    set value(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  return Q(a, () => p1, (l, u) => {
    u(l, ce(() => s, {
      get open() {
        return r();
      },
      set open(c) {
        r(c);
      },
      get value() {
        return n();
      },
      set value(c) {
        n(c);
      }
    }));
  }), A(t, i), W(o);
}
K(jS, { open: {}, value: {} }, [], [], { mode: "open" });
function SR(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref"]);
  var s = {
    get ref() {
      return r();
    },
    set ref(a = null) {
      r(a), m();
    }
  }, o = I(), i = D(o);
  return Q(i, () => Nw, (a, l) => {
    l(a, ce({ "data-slot": "select-group" }, () => n, {
      get ref() {
        return r();
      },
      set ref(u) {
        r(u);
      }
    }));
  }), A(t, o), W(s);
}
K(SR, { ref: {} }, [], [], { mode: "open" });
var xR = /* @__PURE__ */ ne("<div><!></div>");
function PR(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = xR();
  ve(a, (u) => ({ "data-slot": "select-label", class: u, ...o }), [
    () => Se("text-muted-foreground px-2 py-1.5 text-xs", n())
  ]);
  var l = he(a);
  return te(l, () => s() ?? ge), de(a), et(a, (u) => r(u), () => r()), A(t, a), W(i);
}
K(PR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var OR = /* @__PURE__ */ ne('<span class="absolute end-2 flex size-3.5 items-center justify-center"><!></span> <!>', 1);
function BS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "value", 7), o = v(e, "label", 7), i = v(e, "children", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "value",
    "label",
    "children"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get class() {
      return n();
    },
    set class(f) {
      n(f), m();
    },
    get value() {
      return s();
    },
    set value(f) {
      s(f), m();
    },
    get label() {
      return o();
    },
    set label(f) {
      o(f), m();
    },
    get children() {
      return i();
    },
    set children(f) {
      i(f), m();
    }
  }, u = I(), c = D(u);
  {
    const f = (_, b) => {
      let g = () => b?.().selected, h = () => b?.().highlighted;
      var y = OR(), S = D(y), x = he(S);
      {
        var P = ($) => {
          ru($, { class: "size-4" });
        };
        ue(x, ($) => {
          g() && $(P);
        });
      }
      de(S);
      var w = be(S, 2);
      {
        var O = ($) => {
          var T = I(), E = D(T);
          te(E, i, () => ({ selected: g(), highlighted: h() })), A($, T);
        }, k = ($) => {
          var T = tt();
          ke(() => Me(T, o() || s())), A($, T);
        };
        ue(w, ($) => {
          i() ? $(O) : $(k, !1);
        });
      }
      A(_, y);
    };
    let p = /* @__PURE__ */ C(() => Se("data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 ps-2 pe-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", n()));
    Q(c, () => Iw, (_, b) => {
      b(_, ce(
        {
          get value() {
            return s();
          },
          "data-slot": "select-item",
          get class() {
            return d(p);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(g) {
            r(g);
          },
          children: f,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, u), W(l);
}
K(BS, { ref: {}, class: {}, value: {}, label: {}, children: {} }, [], [], { mode: "open" });
function zS(t, e) {
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  var n = I(), s = D(n);
  Q(s, () => iu, (o, i) => {
    i(o, ce(() => r));
  }), A(t, n);
}
K(zS, {}, [], [], { mode: "open" });
function qS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex cursor-default items-center justify-center py-1", n()));
    Q(a, () => Lw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "select-scroll-up-button",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          },
          children: (f, p) => {
            m_(f, { class: "size-4" });
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(qS, { ref: {}, class: {} }, [], [], { mode: "open" });
function US(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(l = null) {
      r(l), m();
    },
    get class() {
      return n();
    },
    set class(l) {
      n(l), m();
    }
  }, i = I(), a = D(i);
  {
    let l = /* @__PURE__ */ C(() => Se("flex cursor-default items-center justify-center py-1", n()));
    Q(a, () => Vw, (u, c) => {
      c(u, ce(
        {
          "data-slot": "select-scroll-down-button",
          get class() {
            return d(l);
          }
        },
        () => s,
        {
          get ref() {
            return r();
          },
          set ref(f) {
            r(f);
          },
          children: (f, p) => {
            Ks(f, { class: "size-4" });
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, i), W(o);
}
K(US, { ref: {}, class: {} }, [], [], { mode: "open" });
var CR = /* @__PURE__ */ ne("<!> <!> <!>", 1);
function KS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "sideOffset", 7, 4), o = v(e, "portalProps", 7), i = v(e, "children", 7), a = v(e, "preventScroll", 7, !0), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "sideOffset",
    "portalProps",
    "children",
    "preventScroll"
  ]);
  var u = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get sideOffset() {
      return s();
    },
    set sideOffset(c = 4) {
      s(c), m();
    },
    get portalProps() {
      return o();
    },
    set portalProps(c) {
      o(c), m();
    },
    get children() {
      return i();
    },
    set children(c) {
      i(c), m();
    },
    get preventScroll() {
      return a();
    },
    set preventScroll(c = !0) {
      a(c), m();
    }
  };
  return zS(t, ce(o, {
    children: (c, f) => {
      var p = I(), _ = D(p);
      {
        let b = /* @__PURE__ */ C(() => Se("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-end-2 data-[side=right]:slide-in-from-start-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--bits-select-content-available-height) min-w-[8rem] origin-(--bits-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", n()));
        Q(_, () => Mw, (g, h) => {
          h(g, ce(
            {
              get sideOffset() {
                return s();
              },
              get preventScroll() {
                return a();
              },
              "data-slot": "select-content",
              get class() {
                return d(b);
              }
            },
            () => l,
            {
              get ref() {
                return r();
              },
              set ref(y) {
                r(y);
              },
              children: (y, S) => {
                var x = CR(), P = D(x);
                qS(P, {});
                var w = be(P, 2);
                {
                  let k = /* @__PURE__ */ C(() => Se("h-(--bits-select-anchor-height) w-full min-w-(--bits-select-anchor-width) scroll-my-1 p-1"));
                  Q(w, () => Rw, ($, T) => {
                    T($, {
                      get class() {
                        return d(k);
                      },
                      children: (E, M) => {
                        var R = I(), U = D(R);
                        te(U, () => i() ?? ge), A(E, R);
                      },
                      $$slots: { default: !0 }
                    });
                  });
                }
                var O = be(w, 2);
                US(O, {}), A(y, x);
              },
              $$slots: { default: !0 }
            }
          ));
        });
      }
      A(c, p);
    },
    $$slots: { default: !0 }
  })), W(u);
}
K(
  KS,
  {
    ref: {},
    class: {},
    sideOffset: {},
    portalProps: {},
    children: {},
    preventScroll: {}
  },
  [],
  [],
  { mode: "open" }
);
var kR = /* @__PURE__ */ ne("<!> <!>", 1);
function HS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = v(e, "size", 7, "default"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children",
    "size"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get class() {
      return n();
    },
    set class(c) {
      n(c), m();
    },
    get children() {
      return s();
    },
    set children(c) {
      s(c), m();
    },
    get size() {
      return o();
    },
    set size(c = "default") {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    let c = /* @__PURE__ */ C(() => Se("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none select-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n()));
    Q(u, () => m1, (f, p) => {
      p(f, ce(
        {
          "data-slot": "select-trigger",
          get "data-size"() {
            return o();
          },
          get class() {
            return d(c);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(_) {
            r(_);
          },
          children: (_, b) => {
            var g = kR(), h = D(g);
            te(h, () => s() ?? ge);
            var y = be(h, 2);
            Ks(y, { class: "size-4 opacity-50" }), A(_, g);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(HS, { ref: {}, class: {}, children: {}, size: {} }, [], [], { mode: "open" });
function $R(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host", "ref", "class"]);
  var o = {
    get ref() {
      return r();
    },
    set ref(i = null) {
      r(i), m();
    },
    get class() {
      return n();
    },
    set class(i) {
      n(i), m();
    }
  };
  {
    let i = /* @__PURE__ */ C(() => Se("bg-border pointer-events-none -mx-1 my-1 h-px", n()));
    mu(t, ce(
      {
        "data-slot": "select-separator",
        get class() {
          return d(i);
        }
      },
      () => s,
      {
        get ref() {
          return r();
        },
        set ref(a) {
          r(a);
        }
      }
    ));
  }
  return W(o);
}
K($R, { ref: {}, class: {} }, [], [], { mode: "open" });
function AR(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "children", 7), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "children"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get children() {
      return s();
    },
    set children(u) {
      s(u), m();
    }
  }, a = I(), l = D(a);
  {
    let u = /* @__PURE__ */ C(() => Se("text-muted-foreground px-2 py-1.5 text-xs", n()));
    Q(l, () => Fw, (c, f) => {
      f(c, ce(
        {
          "data-slot": "select-group-heading",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          children: (p, _) => {
            var b = I(), g = D(b);
            te(g, () => s() ?? ge), A(p, b);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, a), W(i);
}
K(AR, { ref: {}, class: {}, children: {} }, [], [], { mode: "open" });
var ER = /* @__PURE__ */ ne('<span data-slot="slider-track"><!></span> <!>', 1);
function WS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "orientation", 7, "horizontal"), o = v(e, "class", 7), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "orientation",
    "class"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(c = null) {
      r(c), m();
    },
    get value() {
      return n();
    },
    set value(c) {
      n(c), m();
    },
    get orientation() {
      return s();
    },
    set orientation(c = "horizontal") {
      s(c), m();
    },
    get class() {
      return o();
    },
    set class(c) {
      o(c), m();
    }
  }, l = I(), u = D(l);
  {
    const c = (p, _) => {
      let b = () => _?.().thumbs;
      var g = ER(), h = D(g), y = he(h);
      {
        let x = /* @__PURE__ */ C(() => Se("bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"));
        Q(y, () => w1, (P, w) => {
          w(P, {
            "data-slot": "slider-range",
            get class() {
              return d(x);
            }
          });
        });
      }
      de(h);
      var S = be(h, 2);
      st(S, 16, b, (x) => x, (x, P) => {
        var w = I(), O = D(w);
        Q(O, () => S1, (k, $) => {
          $(k, {
            "data-slot": "slider-thumb",
            get index() {
              return P;
            },
            class: "border-primary ring-ring/50 block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
          });
        }), A(x, w);
      }), ke(
        (x) => {
          Cn(h, "data-orientation", s()), Bs(h, 1, x);
        },
        [
          () => js(Se("bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"))
        ]
      ), A(p, g);
    };
    let f = /* @__PURE__ */ C(() => Se("relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col", o()));
    Q(u, () => _1, (p, _) => {
      _(p, ce(
        {
          "data-slot": "slider",
          get orientation() {
            return s();
          },
          get class() {
            return d(f);
          }
        },
        () => i,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get value() {
            return n();
          },
          set value(b) {
            n(b);
          },
          children: c,
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, l), W(a);
}
K(WS, { ref: {}, value: {}, orientation: {}, class: {} }, [], [], { mode: "open" });
function GS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "class", 7), s = v(e, "checked", 15, !1), o = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "class",
    "checked"
  ]);
  var i = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get class() {
      return n();
    },
    set class(u) {
      n(u), m();
    },
    get checked() {
      return s();
    },
    set checked(u = !1) {
      s(u), m();
    }
  }, a = I(), l = D(a);
  {
    let u = /* @__PURE__ */ C(() => Se("data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", n()));
    Q(l, () => O1, (c, f) => {
      f(c, ce(
        {
          "data-slot": "switch",
          get class() {
            return d(u);
          }
        },
        () => o,
        {
          get ref() {
            return r();
          },
          set ref(p) {
            r(p);
          },
          get checked() {
            return s();
          },
          set checked(p) {
            s(p);
          },
          children: (p, _) => {
            var b = I(), g = D(b);
            {
              let h = /* @__PURE__ */ C(() => Se("bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"));
              Q(g, () => C1, (y, S) => {
                S(y, {
                  "data-slot": "switch-thumb",
                  get class() {
                    return d(h);
                  }
                });
              });
            }
            A(p, b);
          },
          $$slots: { default: !0 }
        }
      ));
    });
  }
  return A(t, a), W(i);
}
K(GS, { ref: {}, class: {}, checked: {} }, [], [], { mode: "open" });
var TR = /* @__PURE__ */ ne("<textarea></textarea>");
function YS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "data-slot", 7, "textarea"), i = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "data-slot"
  ]);
  var a = {
    get ref() {
      return r();
    },
    set ref(u = null) {
      r(u), m();
    },
    get value() {
      return n();
    },
    set value(u) {
      n(u), m();
    },
    get class() {
      return s();
    },
    set class(u) {
      s(u), m();
    },
    get "data-slot"() {
      return o();
    },
    set "data-slot"(u = "textarea") {
      o(u), m();
    }
  }, l = TR();
  return Cv(l), ve(l, (u) => ({ "data-slot": o(), class: u, ...i }), [
    () => Se("border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", s())
  ]), et(l, (u) => r(u), () => r()), fo(l, n), A(t, l), W(a);
}
K(YS, { ref: {}, value: {}, class: {}, "data-slot": {} }, [], [], { mode: "open" });
const XS = Ri({
  base: "hover:bg-muted hover:text-muted-foreground data-[state=on]:bg-accent data-[state=on]:text-accent-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  variants: {
    variant: {
      default: "bg-transparent",
      outline: "border-input hover:bg-accent hover:text-accent-foreground border bg-transparent shadow-xs"
    },
    size: {
      default: "h-9 min-w-9 px-2",
      sm: "h-8 min-w-8 px-1.5",
      lg: "h-10 min-w-10 px-2.5"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
function DR(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "pressed", 15, !1), s = v(e, "class", 7), o = v(e, "size", 7, "default"), i = v(e, "variant", 7, "default"), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "pressed",
    "class",
    "size",
    "variant"
  ]);
  var l = {
    get ref() {
      return r();
    },
    set ref(f = null) {
      r(f), m();
    },
    get pressed() {
      return n();
    },
    set pressed(f = !1) {
      n(f), m();
    },
    get class() {
      return s();
    },
    set class(f) {
      s(f), m();
    },
    get size() {
      return o();
    },
    set size(f = "default") {
      o(f), m();
    },
    get variant() {
      return i();
    },
    set variant(f = "default") {
      i(f), m();
    }
  }, u = I(), c = D(u);
  {
    let f = /* @__PURE__ */ C(() => Se(XS({ variant: i(), size: o() }), s()));
    Q(c, () => k1, (p, _) => {
      _(p, ce(
        {
          "data-slot": "toggle",
          get class() {
            return d(f);
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(b) {
            r(b);
          },
          get pressed() {
            return n();
          },
          set pressed(b) {
            n(b);
          }
        }
      ));
    });
  }
  return A(t, u), W(l);
}
K(DR, { ref: {}, pressed: {}, class: {}, size: {}, variant: {} }, [], [], { mode: "open" });
function MR(t) {
  Po("toggleGroup", t);
}
function IR() {
  return Es("toggleGroup");
}
function JS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "size", 7, "default"), i = v(e, "spacing", 7, 0), a = v(e, "variant", 7, "default"), l = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "size",
    "spacing",
    "variant"
  ]);
  MR({ variant: a(), size: o(), spacing: i() });
  var u = {
    get ref() {
      return r();
    },
    set ref(p = null) {
      r(p), m();
    },
    get value() {
      return n();
    },
    set value(p) {
      n(p), m();
    },
    get class() {
      return s();
    },
    set class(p) {
      s(p), m();
    },
    get size() {
      return o();
    },
    set size(p = "default") {
      o(p), m();
    },
    get spacing() {
      return i();
    },
    set spacing(p = 0) {
      i(p), m();
    },
    get variant() {
      return a();
    },
    set variant(p = "default") {
      a(p), m();
    }
  }, c = I(), f = D(c);
  {
    let p = /* @__PURE__ */ C(() => `--gap: ${i()}`), _ = /* @__PURE__ */ C(() => Se("group/toggle-group flex w-fit items-center gap-[--spacing(var(--gap))] rounded-md data-[spacing=default]:data-[variant=outline]:shadow-xs", s()));
    Q(f, () => E1, (b, g) => {
      g(b, ce(
        {
          "data-slot": "toggle-group",
          get "data-variant"() {
            return a();
          },
          get "data-size"() {
            return o();
          },
          get "data-spacing"() {
            return i();
          },
          get style() {
            return d(p);
          },
          get class() {
            return d(_);
          }
        },
        () => l,
        {
          get value() {
            return n();
          },
          set value(h) {
            n(h);
          },
          get ref() {
            return r();
          },
          set ref(h) {
            r(h);
          }
        }
      ));
    });
  }
  return A(t, c), W(u);
}
K(
  JS,
  {
    ref: {},
    value: {},
    class: {},
    size: {},
    spacing: {},
    variant: {}
  },
  [],
  [],
  { mode: "open" }
);
function ZS(t, e) {
  H(e, !0);
  let r = v(e, "ref", 15, null), n = v(e, "value", 15), s = v(e, "class", 7), o = v(e, "size", 7), i = v(e, "variant", 7), a = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "ref",
    "value",
    "class",
    "size",
    "variant"
  ]);
  const l = IR();
  var u = {
    get ref() {
      return r();
    },
    set ref(p = null) {
      r(p), m();
    },
    get value() {
      return n();
    },
    set value(p) {
      n(p), m();
    },
    get class() {
      return s();
    },
    set class(p) {
      s(p), m();
    },
    get size() {
      return o();
    },
    set size(p) {
      o(p), m();
    },
    get variant() {
      return i();
    },
    set variant(p) {
      i(p), m();
    }
  }, c = I(), f = D(c);
  {
    let p = /* @__PURE__ */ C(() => l.variant || i()), _ = /* @__PURE__ */ C(() => l.size || o()), b = /* @__PURE__ */ C(() => Se(XS({ variant: l.variant || i(), size: l.size || o() }), "w-auto min-w-0 shrink-0 px-3 focus:z-10 focus-visible:z-10 data-[spacing=0]:rounded-none data-[spacing=0]:shadow-none data-[spacing=0]:first:rounded-l-md data-[spacing=0]:last:rounded-r-md data-[spacing=0]:data-[variant=outline]:border-l-0 data-[spacing=0]:data-[variant=outline]:first:border-l", s()));
    Q(f, () => T1, (g, h) => {
      h(g, ce(
        {
          "data-slot": "toggle-group-item",
          get "data-variant"() {
            return d(p);
          },
          get "data-size"() {
            return d(_);
          },
          get "data-spacing"() {
            return l.spacing;
          },
          get class() {
            return d(b);
          },
          get value() {
            return n();
          }
        },
        () => a,
        {
          get ref() {
            return r();
          },
          set ref(y) {
            r(y);
          }
        }
      ));
    });
  }
  return A(t, c), W(u);
}
K(ZS, { ref: {}, value: {}, class: {}, size: {}, variant: {} }, [], [], { mode: "open" });
var NR = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function QS(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Checkbox), i = /* @__PURE__ */ C(() => d(s).FieldLabel);
  let a = v(e, "value", 15), l = v(e, "options", 7), u = v(e, "config", 7), c = v(e, "handlers", 7);
  const f = c_({
    mapper: () => Mo(l()),
    value: () => a(),
    update: (w) => a(w)
  }), p = /* @__PURE__ */ C(() => new Set(f.current)), _ = /* @__PURE__ */ C(() => c().oninput), b = /* @__PURE__ */ C(() => c().onchange), g = /* @__PURE__ */ C(() => Dn(c(), ["oninput", "onchange"])), h = /* @__PURE__ */ C(() => pr(r, u().path)), y = /* @__PURE__ */ C(() => gr(r, u(), "shadcn4Checkboxes", an(d(g))({ ...c(), name: d(h), required: u().required })));
  var S = {
    get value() {
      return a();
    },
    set value(w) {
      a(w), m();
    },
    get options() {
      return l();
    },
    set options(w) {
      l(w), m();
    },
    get config() {
      return u();
    },
    set config(w) {
      u(w), m();
    },
    get handlers() {
      return c();
    },
    set handlers(w) {
      c(w), m();
    }
  }, x = I(), P = D(x);
  return st(P, 17, l, (w) => w.id, (w, O) => {
    var k = NR(), $ = he(k);
    {
      let E = /* @__PURE__ */ C(() => d(p).has(d(O).id)), M = /* @__PURE__ */ C(() => d(O).disabled || d(y).disabled);
      Q($, () => d(o), (R, U) => {
        U(R, ce(
          {
            get checked() {
              return d(E);
            },
            get value() {
              return d(O).id;
            },
            onCheckedChange: (B) => {
              f.current = B ? f.current.concat(d(O).id) : f.current.filter((F) => F !== d(O).id), d(_)?.(), d(b)?.();
            }
          },
          () => d(y),
          {
            get id() {
              return d(O).id;
            },
            get disabled() {
              return d(M);
            }
          }
        ));
      });
    }
    var T = be($, 2);
    Q(T, () => d(i), (E, M) => {
      M(E, {
        get for() {
          return d(O).id;
        },
        children: (R, U) => {
          vt();
          var B = tt();
          ke(() => Me(B, d(O).label)), A(R, B);
        },
        $$slots: { default: !0 }
      });
    }), de(k), A(w, k);
  }), A(t, x), W(S);
}
K(QS, { value: {}, options: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.checkboxesWidget = QS;
function Ol(...t) {
  return Xd(so(t));
}
var FR = /* @__PURE__ */ ne("<span> </span> <!>", 1), RR = /* @__PURE__ */ ne("<!> ", 1), VR = /* @__PURE__ */ ne("<!> <!>", 1), LR = /* @__PURE__ */ ne("<!> <!>", 1), jR = /* @__PURE__ */ ne("<!> <!>", 1);
function ex(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Popover), i = /* @__PURE__ */ C(() => d(s).PopoverContent), a = /* @__PURE__ */ C(() => d(s).PopoverTrigger), l = /* @__PURE__ */ C(() => d(s).Button), u = /* @__PURE__ */ C(() => d(s).CommandInput), c = /* @__PURE__ */ C(() => d(s).Command), f = /* @__PURE__ */ C(() => d(s).CommandList), p = /* @__PURE__ */ C(() => d(s).CommandEmpty), _ = /* @__PURE__ */ C(() => d(s).CommandGroup), b = /* @__PURE__ */ C(() => d(s).CommandItem);
  let g = v(e, "value", 15), h = v(e, "config", 7), y = v(e, "handlers", 7), S = v(e, "options", 7);
  const x = /* @__PURE__ */ C(() => new Map(S().map((Y) => [Y.id, Y.label]))), P = tu({
    mapper: () => Mo(S()),
    value: () => g(),
    update: (Y) => g(Y)
  });
  let w = /* @__PURE__ */ xe(!1), O = /* @__PURE__ */ xe(null);
  function k() {
    q(w, !1), Rl().then(() => {
      d(O).focus();
    });
  }
  const $ = /* @__PURE__ */ C(() => Ni(r, h(), "shadcn4ComboboxInput", y(), {})), T = /* @__PURE__ */ C(() => d(x).get(P.current) ?? d($).placeholder), E = /* @__PURE__ */ C(() => It(r, h(), "shadcn4ComboboxEmptyText")), M = /* @__PURE__ */ C(() => y().oninput), R = /* @__PURE__ */ C(() => y().onchange), U = /* @__PURE__ */ C(() => Dn(y(), ["oninput", "onchange"]));
  var B = {
    get value() {
      return g();
    },
    set value(Y) {
      g(Y), m();
    },
    get config() {
      return h();
    },
    set config(Y) {
      h(Y), m();
    },
    get handlers() {
      return y();
    },
    set handlers(Y) {
      y(Y), m();
    },
    get options() {
      return S();
    },
    set options(Y) {
      S(Y), m();
    }
  }, F = I(), Z = D(F);
  return Q(Z, () => d(o), (Y, X) => {
    X(Y, {
      get open() {
        return d(w);
      },
      set open(ae) {
        q(w, ae, !0);
      },
      children: (ae, J) => {
        var j = jR(), ee = D(j);
        {
          const N = (G, fe) => {
            let se = () => fe?.().props;
            var we = I(), le = D(we);
            {
              let re = /* @__PURE__ */ C(() => Nt(
                r,
                h(),
                {
                  variant: "outline",
                  ...se(),
                  role: "combobox",
                  "aria-expanded": d(w)
                },
                St("shadcn4ComboboxTrigger"),
                an(d(U)),
                Us
              ));
              Q(le, () => d(l), (oe, pe) => {
                pe(oe, ce(() => d(re), {
                  children: (ye, Pe) => {
                    var Oe = FR(), Re = D(Oe), Ke = he(Re, !0);
                    de(Re);
                    var Ve = be(Re, 2);
                    v_(Ve, { class: "ml-2 size-4 shrink-0 opacity-50" }), ke(() => Me(Ke, d(T))), A(ye, Oe);
                  },
                  $$slots: { default: !0 }
                }));
              });
            }
            A(G, we);
          };
          let V = /* @__PURE__ */ C(() => Do({}, h(), r));
          Q(ee, () => d(a), (G, fe) => {
            fe(G, ce({ class: "w-full justify-between" }, () => d(V), {
              get ref() {
                return d(O);
              },
              set ref(se) {
                q(O, se, !0);
              },
              child: N,
              $$slots: { child: !0 }
            }));
          });
        }
        var L = be(ee, 2);
        Q(L, () => d(i), (N, V) => {
          V(N, {
            class: "w-[200px] p-0",
            children: (G, fe) => {
              var se = I(), we = D(se);
              Q(we, () => d(c), (le, re) => {
                re(le, {
                  children: (oe, pe) => {
                    var ye = LR(), Pe = D(ye);
                    Q(Pe, () => d(u), (Re, Ke) => {
                      Ke(Re, ce(() => d($)));
                    });
                    var Oe = be(Pe, 2);
                    Q(Oe, () => d(f), (Re, Ke) => {
                      Ke(Re, {
                        children: (Ve, je) => {
                          var He = VR(), gt = D(He);
                          {
                            var Je = (lt) => {
                              var ct = I(), pt = D(ct);
                              Q(pt, () => d(p), (Kt, yt) => {
                                yt(Kt, {
                                  children: (Rt, Dt) => {
                                    vt();
                                    var Ht = tt();
                                    ke(() => Me(Ht, d(E))), A(Rt, Ht);
                                  },
                                  $$slots: { default: !0 }
                                });
                              }), A(lt, ct);
                            };
                            ue(gt, (lt) => {
                              d(E) && lt(Je);
                            });
                          }
                          var kt = be(gt, 2);
                          Q(kt, () => d(_), (lt, ct) => {
                            ct(lt, {
                              children: (pt, Kt) => {
                                var yt = I(), Rt = D(yt);
                                st(Rt, 17, S, (Dt) => Dt.id, (Dt, Ht) => {
                                  var Wt = I(), un = D(Wt);
                                  Q(un, () => d(b), (nr, sr) => {
                                    sr(nr, {
                                      get value() {
                                        return d(Ht).label;
                                      },
                                      onSelect: () => {
                                        P.current = d(Ht).id, d(M)?.(), d(R)?.(), k();
                                      },
                                      get disabled() {
                                        return d(Ht).disabled;
                                      },
                                      children: (Pr, Gs) => {
                                        var mr = RR(), qr = D(mr);
                                        {
                                          let vu = /* @__PURE__ */ C(() => Ol("mr-2 size-4", P.current !== d(Ht).id && "text-transparent"));
                                          ru(qr, {
                                            get class() {
                                              return d(vu);
                                            }
                                          });
                                        }
                                        var Uo = be(qr);
                                        ke(() => Me(Uo, ` ${d(Ht).label ?? ""}`)), A(Pr, mr);
                                      },
                                      $$slots: { default: !0 }
                                    });
                                  }), A(Dt, Wt);
                                }), A(pt, yt);
                              },
                              $$slots: { default: !0 }
                            });
                          }), A(Ve, He);
                        },
                        $$slots: { default: !0 }
                      });
                    }), A(oe, ye);
                  },
                  $$slots: { default: !0 }
                });
              }), A(G, se);
            },
            $$slots: { default: !0 }
          });
        }), A(ae, j);
      },
      $$slots: { default: !0 }
    });
  }), A(t, F), W(B);
}
K(ex, { value: {}, config: {}, handlers: {}, options: {} }, [], [], { mode: "open" });
tr.comboboxWidget = ex;
var BR = /* @__PURE__ */ ne("<!> <!>", 1);
function tx(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Popover), i = /* @__PURE__ */ C(() => d(s).PopoverTrigger), a = /* @__PURE__ */ C(() => d(s).Button), l = /* @__PURE__ */ C(() => d(s).PopoverContent), u = /* @__PURE__ */ C(() => d(s).Calendar);
  let c = v(e, "value", 15), f = v(e, "config", 7), p = v(e, "handlers", 7);
  const _ = /* @__PURE__ */ C(() => p().oninput), b = /* @__PURE__ */ C(() => p().onchange), g = /* @__PURE__ */ C(() => Dn(p(), ["oninput", "onchange"])), h = /* @__PURE__ */ C(() => gr(r, f(), "shadcn4DatePicker", {
    initialFocus: !0,
    onValueChange: () => {
      d(_)?.(), d(b)?.();
    }
  })), y = /* @__PURE__ */ C(() => c() !== void 0 ? Pi(c()) : void 0), S = /* @__PURE__ */ C(() => {
    const k = It(r, f(), "shadcn4DateFormatter");
    if (k !== void 0)
      return k;
    const $ = new Intl.DateTimeFormat(void 0, { year: "numeric", month: "2-digit", day: "numeric" });
    return (T) => $.format(T);
  }), x = /* @__PURE__ */ C(() => {
    const k = d(y);
    return k === void 0 ? d(h).placeholder : d(S)(k.toDate(ft()));
  });
  var P = {
    get value() {
      return c();
    },
    set value(k) {
      c(k), m();
    },
    get config() {
      return f();
    },
    set config(k) {
      f(k), m();
    },
    get handlers() {
      return p();
    },
    set handlers(k) {
      p(k), m();
    }
  }, w = I(), O = D(w);
  return Q(O, () => d(o), (k, $) => {
    $(k, {
      children: (T, E) => {
        var M = BR(), R = D(M);
        {
          const B = (F, Z) => {
            let Y = () => Z?.().props;
            var X = I(), ae = D(X);
            {
              let J = /* @__PURE__ */ C(() => [
                "w-full",
                d(y) === void 0 && "text-muted-foreground"
              ]), j = /* @__PURE__ */ C(() => Nt(r, f(), {}, St("shadcn4DatePickerTrigger"), an(d(g)), Us));
              Q(ae, () => d(a), (ee, L) => {
                L(ee, ce(
                  Y,
                  {
                    get class() {
                      return d(J);
                    }
                  },
                  () => d(j),
                  {
                    children: (N, V) => {
                      vt();
                      var G = tt();
                      ke(() => Me(G, d(x))), A(N, G);
                    },
                    $$slots: { default: !0 }
                  }
                ));
              });
            }
            A(F, X);
          };
          Q(R, () => d(i), (F, Z) => {
            Z(F, { child: B, $$slots: { child: !0 } });
          });
        }
        var U = be(R, 2);
        Q(U, () => d(l), (B, F) => {
          F(B, {
            children: (Z, Y) => {
              var X = I(), ae = D(X), J = () => d(y), j = (ee) => {
                c(ee?.toDate(ft()).toLocaleDateString("en-CA"));
              };
              Q(ae, () => d(u), (ee, L) => {
                L(ee, ce(
                  {
                    get value() {
                      return J();
                    },
                    set value(N) {
                      j(N);
                    }
                  },
                  () => d(h),
                  { type: "single" }
                ));
              }), A(Z, X);
            },
            $$slots: { default: !0 }
          });
        }), A(T, M);
      },
      $$slots: { default: !0 }
    });
  }), A(t, w), W(P);
}
K(tx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.datePickerWidget = tx;
const ed = Ri({
  base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
      destructive: "bg-destructive shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white",
      outline: "bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border",
      secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: { variant: "default", size: "default" }
});
var zR = /* @__PURE__ */ ne("<a><!></a>"), qR = /* @__PURE__ */ ne("<button><!></button>");
function UR(t, e) {
  H(e, !0);
  let r = v(e, "class", 7), n = v(e, "variant", 7, "default"), s = v(e, "size", 7, "default"), o = v(e, "ref", 15, null), i = v(e, "href", 7, void 0), a = v(e, "type", 7, "button"), l = v(e, "disabled", 7), u = v(e, "children", 7), c = /* @__PURE__ */ ie(e, [
    "$$slots",
    "$$events",
    "$$legacy",
    "$$host",
    "class",
    "variant",
    "size",
    "ref",
    "href",
    "type",
    "disabled",
    "children"
  ]);
  var f = {
    get class() {
      return r();
    },
    set class(h) {
      r(h), m();
    },
    get variant() {
      return n();
    },
    set variant(h = "default") {
      n(h), m();
    },
    get size() {
      return s();
    },
    set size(h = "default") {
      s(h), m();
    },
    get ref() {
      return o();
    },
    set ref(h = null) {
      o(h), m();
    },
    get href() {
      return i();
    },
    set href(h = void 0) {
      i(h), m();
    },
    get type() {
      return a();
    },
    set type(h = "button") {
      a(h), m();
    },
    get disabled() {
      return l();
    },
    set disabled(h) {
      l(h), m();
    },
    get children() {
      return u();
    },
    set children(h) {
      u(h), m();
    }
  }, p = I(), _ = D(p);
  {
    var b = (h) => {
      var y = zR();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          href: l() ? void 0 : i(),
          "aria-disabled": l(),
          role: l() ? "link" : void 0,
          tabindex: l() ? -1 : void 0,
          ...c
        }),
        [
          () => Ol(ed({ variant: n(), size: s() }), r())
        ]
      );
      var S = he(y);
      te(S, () => u() ?? ge), de(y), et(y, (x) => o(x), () => o()), A(h, y);
    }, g = (h) => {
      var y = qR();
      ve(
        y,
        (x) => ({
          "data-slot": "button",
          class: x,
          type: a(),
          disabled: l(),
          ...c
        }),
        [
          () => Ol(ed({ variant: n(), size: s() }), r())
        ]
      );
      var S = he(y);
      te(S, () => u() ?? ge), de(y), et(y, (x) => o(x), () => o()), A(h, y);
    };
    ue(_, (h) => {
      i() ? h(b) : h(g, !1);
    });
  }
  return A(t, p), W(f);
}
K(
  UR,
  {
    class: {},
    variant: {},
    size: {},
    ref: {},
    href: {},
    type: {},
    disabled: {},
    children: {}
  },
  [],
  [],
  { mode: "open" }
);
var KR = /* @__PURE__ */ ne("<!> ", 1), HR = /* @__PURE__ */ ne("<!> <!>", 1);
function sg(t, e) {
  H(e, !0);
  const r = De(), n = ut();
  let s = v(e, "value", 15), o = v(e, "config", 7), i = v(e, "handlers", 7);
  const a = /* @__PURE__ */ C(() => i().oninput), l = /* @__PURE__ */ C(() => i().onchange), u = /* @__PURE__ */ C(() => Dn(i(), ["oninput", "onchange"])), c = /* @__PURE__ */ C(() => n.components), f = /* @__PURE__ */ C(() => d(c).Popover), p = /* @__PURE__ */ C(() => d(c).PopoverTrigger), _ = /* @__PURE__ */ C(() => d(c).PopoverContent), b = /* @__PURE__ */ C(() => d(c).RangeCalendar), g = /* @__PURE__ */ C(() => gr(r, o(), "shadcn4DateRangePicker", {
    numberOfMonths: 2,
    onValueChange: () => {
      d(a)?.(), d(l)?.();
    }
  })), h = /* @__PURE__ */ C(() => {
    const w = It(r, o(), "shadcn4DateRangeFormatter");
    if (w !== void 0)
      return w;
    const O = It(r, o(), "shadcn4DateRangePickerPlaceholder"), k = new Lt("en-US", { dateStyle: "medium" });
    return ({ start: $, end: T }) => $ && T ? `${k.format($.toDate(ft()))} - ${k.format(T.toDate(ft()))}` : $ ? k.format($.toDate(ft())) : O;
  }), y = /* @__PURE__ */ C(() => ({
    start: typeof s()?.start == "string" ? Pi(s().start) : void 0,
    end: typeof s()?.end == "string" ? Pi(s().end) : void 0
  }));
  var S = {
    get value() {
      return s();
    },
    set value(w) {
      s(w), m();
    },
    get config() {
      return o();
    },
    set config(w) {
      o(w), m();
    },
    get handlers() {
      return i();
    },
    set handlers(w) {
      i(w), m();
    }
  }, x = I(), P = D(x);
  return Q(P, () => d(f), (w, O) => {
    O(w, {
      children: (k, $) => {
        var T = HR(), E = D(T);
        {
          let R = /* @__PURE__ */ C(() => Ol(
            ed({
              variant: "outline",
              class: "justify-start text-start font-normal"
            }),
            !s() && "text-muted-foreground"
          ));
          Q(E, () => d(p), (U, B) => {
            B(U, ce(() => d(u), {
              get class() {
                return d(R);
              },
              children: (F, Z) => {
                var Y = KR(), X = D(Y);
                p_(X, { class: "me-2 size-4" });
                var ae = be(X);
                ke((J) => Me(ae, ` ${J ?? ""}`), [() => d(h)(d(y))]), A(F, Y);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var M = be(E, 2);
        Q(M, () => d(_), (R, U) => {
          U(R, {
            class: "w-auto p-0",
            align: "start",
            children: (B, F) => {
              var Z = I(), Y = D(Z), X = () => d(y), ae = (J) => {
                const j = ft();
                s({
                  start: J?.start?.toDate(j).toLocaleDateString("en-CA"),
                  end: J?.end?.toDate(j).toLocaleDateString("en-CA")
                });
              };
              Q(Y, () => d(b), (J, j) => {
                j(J, ce(() => d(g), {
                  get value() {
                    return X();
                  },
                  set value(ee) {
                    ae(ee);
                  }
                }));
              }), A(B, Z);
            },
            $$slots: { default: !0 }
          });
        }), A(k, T);
      },
      $$slots: { default: !0 }
    });
  }), A(t, x), W(S);
}
K(sg, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.dateRangePickerWidget = sg;
tr.shadcn4DateRangePickerWidget = sg;
var WR = /* @__PURE__ */ ne("<input/>");
function GR(t, e) {
  H(e, !0);
  let r = v(e, "handlers", 7), n = v(e, "multiple", 7), s = v(e, "loading", 7), o = v(e, "processing", 7), i = v(e, "config", 7), a = v(e, "value", 15);
  const l = De(), u = /* @__PURE__ */ C(() => Ni(l, i(), "file", r(), {
    multiple: n(),
    class: "sjsf-file",
    "data-loading": s(),
    "data-processing": o()
  }));
  var c = {
    get handlers() {
      return r();
    },
    set handlers(p) {
      r(p), m();
    },
    get multiple() {
      return n();
    },
    set multiple(p) {
      n(p), m();
    },
    get loading() {
      return s();
    },
    set loading(p) {
      s(p), m();
    },
    get processing() {
      return o();
    },
    set processing(p) {
      o(p), m();
    },
    get config() {
      return i();
    },
    set config(p) {
      i(p), m();
    },
    get value() {
      return a();
    },
    set value(p) {
      a(p), m();
    }
  }, f = WR();
  return ve(f, () => ({ type: "file", ...d(u) }), void 0, void 0, void 0, void 0, !0), sy(f, a), A(t, f), W(c);
}
K(
  GR,
  {
    handlers: {},
    multiple: {},
    loading: {},
    processing: {},
    config: {},
    value: {}
  },
  [],
  [],
  { mode: "open" }
);
function rx(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Input);
  let i = v(e, "config", 7), a = v(e, "handlers", 7), l = v(e, "multiple", 7), u = v(e, "loading", 7), c = v(e, "processing", 7), f = v(e, "value", 15);
  var p = {
    get config() {
      return i();
    },
    set config(g) {
      i(g), m();
    },
    get handlers() {
      return a();
    },
    set handlers(g) {
      a(g), m();
    },
    get multiple() {
      return l();
    },
    set multiple(g) {
      l(g), m();
    },
    get loading() {
      return u();
    },
    set loading(g) {
      u(g), m();
    },
    get processing() {
      return c();
    },
    set processing(g) {
      c(g), m();
    },
    get value() {
      return f();
    },
    set value(g) {
      f(g), m();
    }
  }, _ = I(), b = D(_);
  {
    let g = /* @__PURE__ */ C(() => Ni(r, i(), "file", a(), { multiple: l() }));
    Q(b, () => d(o), (h, y) => {
      y(h, ce(() => d(g), {
        type: "file",
        get "data-loading"() {
          return u();
        },
        get "data-processing"() {
          return c();
        },
        get files() {
          return f();
        },
        set files(S) {
          f(S);
        }
      }));
    });
  }
  return A(t, _), W(p);
}
K(
  rx,
  {
    config: {},
    handlers: {},
    multiple: {},
    loading: {},
    processing: {},
    value: {}
  },
  [],
  [],
  { mode: "open" }
);
tr.fileWidget = rx;
var YR = /* @__PURE__ */ ne("<span> </span>"), XR = /* @__PURE__ */ ne("<!> <!>", 1);
function nx(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Select), i = /* @__PURE__ */ C(() => d(s).SelectTrigger), a = /* @__PURE__ */ C(() => d(s).SelectContent), l = /* @__PURE__ */ C(() => d(s).SelectItem);
  let u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7), p = v(e, "config", 7);
  const _ = /* @__PURE__ */ C(() => new Map(f().map(($) => [$.id, $.label]))), b = c_({
    mapper: () => Mo(f()),
    value: () => c(),
    update: ($) => c($)
  }), g = /* @__PURE__ */ C(() => u().oninput), h = /* @__PURE__ */ C(() => u().onchange), y = /* @__PURE__ */ C(() => Dn(u(), ["oninput", "onchange"])), S = /* @__PURE__ */ C(() => gr(r, p(), "shadcn4MultiSelect", {
    onValueChange: () => {
      d(g)?.(), d(h)?.();
    },
    required: p().required
  })), x = /* @__PURE__ */ C(() => b.current.map(($) => d(_).get($)).join(", ") || d(S).placeholder), P = /* @__PURE__ */ C(() => pr(r, p().path));
  var w = {
    get handlers() {
      return u();
    },
    set handlers($) {
      u($), m();
    },
    get value() {
      return c();
    },
    set value($) {
      c($), m();
    },
    get options() {
      return f();
    },
    set options($) {
      f($), m();
    },
    get config() {
      return p();
    },
    set config($) {
      p($), m();
    }
  }, O = I(), k = D(O);
  return Q(k, () => d(o), ($, T) => {
    T($, ce(() => d(S), {
      type: "multiple",
      get value() {
        return b.current;
      },
      set value(E) {
        b.current = E;
      },
      children: (E, M) => {
        var R = XR(), U = D(R);
        {
          let F = /* @__PURE__ */ C(() => gr(r, p(), "shadcn4MultiSelectTrigger", an(d(y))({ id: d(P), name: d(P) })));
          Q(U, () => d(i), (Z, Y) => {
            Y(Z, ce({ class: "w-full" }, () => d(F), {
              children: (X, ae) => {
                var J = YR(), j = he(J, !0);
                de(J), ke(() => Me(j, d(x))), A(X, J);
              },
              $$slots: { default: !0 }
            }));
          });
        }
        var B = be(U, 2);
        Q(B, () => d(a), (F, Z) => {
          Z(F, {
            children: (Y, X) => {
              var ae = I(), J = D(ae);
              st(J, 17, f, (j) => j.id, (j, ee) => {
                var L = I(), N = D(L);
                Q(N, () => d(l), (V, G) => {
                  G(V, {
                    get value() {
                      return d(ee).id;
                    },
                    get label() {
                      return d(ee).label;
                    },
                    get disabled() {
                      return d(ee).disabled;
                    }
                  });
                }), A(j, L);
              }), A(Y, ae);
            },
            $$slots: { default: !0 }
          });
        }), A(E, R);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, O), W(w);
}
K(nx, { handlers: {}, value: {}, options: {}, config: {} }, [], [], { mode: "open" });
tr.multiSelectWidget = nx;
function sx(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).ToggleGroup), i = /* @__PURE__ */ C(() => d(s).ToggleGroupItem);
  let a = v(e, "value", 15), l = v(e, "config", 7), u = v(e, "handlers", 7), c = v(e, "options", 7);
  const f = tu({
    mapper: () => Mo(c()),
    value: () => a(),
    update: (x) => a(x)
  }), p = /* @__PURE__ */ C(() => u().oninput), _ = /* @__PURE__ */ C(() => u().onchange), b = /* @__PURE__ */ C(() => Dn(u(), ["oninput", "onchange"])), g = /* @__PURE__ */ C(() => gr(r, l(), "shadcn4RadioButtons", {
    type: "single",
    id: pr(r, l().path),
    variant: "outline",
    onValueChange: () => {
      d(p)?.(), d(_)?.();
    }
  }));
  var h = {
    get value() {
      return a();
    },
    set value(x) {
      a(x), m();
    },
    get config() {
      return l();
    },
    set config(x) {
      l(x), m();
    },
    get handlers() {
      return u();
    },
    set handlers(x) {
      u(x), m();
    },
    get options() {
      return c();
    },
    set options(x) {
      c(x), m();
    }
  }, y = I(), S = D(y);
  return Q(S, () => d(o), (x, P) => {
    P(x, ce(() => d(g), {
      get value() {
        return f.current;
      },
      set value(w) {
        f.current = w;
      },
      children: (w, O) => {
        var k = I(), $ = D(k);
        st($, 17, c, (T) => T.id, (T, E) => {
          var M = I(), R = D(M);
          {
            let U = /* @__PURE__ */ C(() => Nt(r, l(), { value: d(E).id }, St("shadcn4RadioButtonsItem"), an(d(b)), Us));
            Q(R, () => d(i), (B, F) => {
              F(B, ce(() => d(U), {
                children: (Z, Y) => {
                  vt();
                  var X = tt();
                  ke(() => Me(X, d(E).label)), A(Z, X);
                },
                $$slots: { default: !0 }
              }));
            });
          }
          A(T, M);
        }), A(w, k);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, y), W(h);
}
K(sx, { value: {}, config: {}, handlers: {}, options: {} }, [], [], { mode: "open" });
tr.radioButtonsWidget = sx;
var JR = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function ox(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).RadioGroup), i = /* @__PURE__ */ C(() => d(s).RadioGroupItem), a = /* @__PURE__ */ C(() => d(s).FieldLabel);
  let l = v(e, "config", 7), u = v(e, "handlers", 7), c = v(e, "value", 15), f = v(e, "options", 7);
  const p = tu({
    mapper: () => Mo(f()),
    value: () => c(),
    update: (S) => c(S)
  }), _ = /* @__PURE__ */ C(() => gr(r, l(), "shadcn4RadioGroup", { onValueChange: u().onchange })), b = /* @__PURE__ */ C(() => Nt(r, l(), { onclick: u().oninput, onblur: u().onblur }, St("shadcn4RadioItem"), Us));
  var g = {
    get config() {
      return l();
    },
    set config(S) {
      l(S), m();
    },
    get handlers() {
      return u();
    },
    set handlers(S) {
      u(S), m();
    },
    get value() {
      return c();
    },
    set value(S) {
      c(S), m();
    },
    get options() {
      return f();
    },
    set options(S) {
      f(S), m();
    }
  }, h = I(), y = D(h);
  return Q(y, () => d(o), (S, x) => {
    x(S, ce(() => d(_), {
      get value() {
        return p.current;
      },
      set value(P) {
        p.current = P;
      },
      children: (P, w) => {
        var O = I(), k = D(O);
        st(k, 17, f, ($) => $.id, ($, T) => {
          var E = JR(), M = he(E);
          Q(M, () => d(i), (U, B) => {
            B(U, ce(() => d(b), {
              get value() {
                return d(T).id;
              },
              get id() {
                return d(T).id;
              },
              get disabled() {
                return d(T).disabled;
              }
            }));
          });
          var R = be(M, 2);
          Q(R, () => d(a), (U, B) => {
            B(U, {
              get for() {
                return d(T).id;
              },
              children: (F, Z) => {
                vt();
                var Y = tt();
                ke(() => Me(Y, d(T).label)), A(F, Y);
              },
              $$slots: { default: !0 }
            });
          }), de(E), A($, E);
        }), A(P, O);
      },
      $$slots: { default: !0 }
    }));
  }), A(t, h), W(g);
}
K(ox, { config: {}, handlers: {}, value: {}, options: {} }, [], [], { mode: "open" });
tr.radioWidget = ox;
function ix(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Slider);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  const u = /* @__PURE__ */ C(() => pr(r, a().path));
  var c = {
    get value() {
      return i();
    },
    set value(g) {
      i(g), m();
    },
    get config() {
      return a();
    },
    set config(g) {
      a(g), m();
    },
    get handlers() {
      return l();
    },
    set handlers(g) {
      l(g), m();
    }
  }, f = I(), p = D(f), _ = () => i() ?? 0, b = (g) => i(g);
  {
    let g = /* @__PURE__ */ C(() => gr(r, a(), "shadcn4Range", {
      id: d(u),
      min: a().schema.minimum,
      max: a().schema.maximum,
      step: a().schema.multipleOf,
      onValueChange: l().oninput,
      onValueCommit: l().onchange
    }));
    Q(p, () => d(o), (h, y) => {
      y(h, ce(
        {
          get value() {
            return _();
          },
          set value(S) {
            b(S);
          }
        },
        () => d(g),
        { type: "single" }
      ));
    });
  }
  return A(t, f), W(c);
}
K(ix, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.rangeWidget = ix;
function ax(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "handlers", 7);
  const o = De(), i = ut(), a = /* @__PURE__ */ C(() => i.components), l = /* @__PURE__ */ C(() => d(a).Slider), u = /* @__PURE__ */ C(() => pr(o, n().path));
  var c = {
    get value() {
      return r();
    },
    set value(g) {
      r(g), m();
    },
    get config() {
      return n();
    },
    set config(g) {
      n(g), m();
    },
    get handlers() {
      return s();
    },
    set handlers(g) {
      s(g), m();
    }
  }, f = I(), p = D(f), _ = () => [r()?.start ?? 0, r()?.end ?? 0], b = (g) => {
    r({ start: g[0], end: g[1] });
  };
  {
    let g = /* @__PURE__ */ C(() => gr(o, n(), "shadcn4RangeSlider", {
      id: d(u),
      min: n().schema.minimum,
      max: n().schema.maximum,
      step: n().schema.multipleOf,
      onValueChange: s().oninput,
      onValueCommit: s().onchange
    }));
    Q(p, () => d(l), (h, y) => {
      y(h, ce(
        {
          get value() {
            return _();
          },
          set value(S) {
            b(S);
          }
        },
        () => d(g),
        { type: "multiple" }
      ));
    });
  }
  return A(t, f), W(c);
}
K(ax, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.rangeSliderWidget = ax;
var ZR = /* @__PURE__ */ ne('<div class="flex items-center space-x-3"><!> <!></div>');
function lx(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Switch), i = /* @__PURE__ */ C(() => d(s).FieldLabel);
  let a = v(e, "value", 15), l = v(e, "config", 7), u = v(e, "handlers", 7);
  const c = /* @__PURE__ */ C(() => u().oninput), f = /* @__PURE__ */ C(() => u().onchange), p = /* @__PURE__ */ C(() => Dn(u(), ["oninput", "onchange"])), _ = /* @__PURE__ */ C(() => pr(r, l().path));
  var b = {
    get value() {
      return a();
    },
    set value(P) {
      a(P), m();
    },
    get config() {
      return l();
    },
    set config(P) {
      l(P), m();
    },
    get handlers() {
      return u();
    },
    set handlers(P) {
      u(P), m();
    }
  }, g = ZR(), h = he(g), y = () => a() ?? !1, S = (P) => a(P);
  {
    let P = /* @__PURE__ */ C(() => gr(r, l(), "shadcn4Switch", an(d(p))({
      id: d(_),
      name: d(_),
      required: l().required,
      onCheckedChange: () => {
        d(c)?.(), d(f)?.();
      }
    })));
    Q(h, () => d(o), (w, O) => {
      O(w, ce(
        {
          get checked() {
            return y();
          },
          set checked(k) {
            S(k);
          }
        },
        () => d(P)
      ));
    });
  }
  var x = be(h, 2);
  return Q(x, () => d(i), (P, w) => {
    w(P, {
      get for() {
        return d(_);
      },
      children: (O, k) => {
        vt();
        var $ = tt();
        ke(() => Me($, l().title)), A(O, $);
      },
      $$slots: { default: !0 }
    });
  }), de(g), A(t, g), W(b);
}
K(lx, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.switchWidget = lx;
var QR = /* @__PURE__ */ ne("<textarea></textarea>");
function e5(t, e) {
  H(e, !0);
  let r = v(e, "value", 15), n = v(e, "config", 7), s = v(e, "handlers", 7);
  const o = De(), i = /* @__PURE__ */ C(() => rb(o, n(), "textarea", s(), { class: "sjsf-textarea" }));
  var a = {
    get value() {
      return r();
    },
    set value(u) {
      r(u), m();
    },
    get config() {
      return n();
    },
    set config(u) {
      n(u), m();
    },
    get handlers() {
      return s();
    },
    set handlers(u) {
      s(u), m();
    }
  }, l = QR();
  return Cv(l), ve(l, () => ({ ...d(i) })), fo(l, r), A(t, l), W(a);
}
K(e5, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
function ux(t, e) {
  H(e, !0);
  const r = De(), n = ut(), s = /* @__PURE__ */ C(() => n.components), o = /* @__PURE__ */ C(() => d(s).Textarea);
  let i = v(e, "value", 15), a = v(e, "config", 7), l = v(e, "handlers", 7);
  var u = {
    get value() {
      return i();
    },
    set value(p) {
      i(p), m();
    },
    get config() {
      return a();
    },
    set config(p) {
      a(p), m();
    },
    get handlers() {
      return l();
    },
    set handlers(p) {
      l(p), m();
    }
  }, c = I(), f = D(c);
  {
    let p = /* @__PURE__ */ C(() => rb(r, a(), "textarea", l(), {}));
    Q(f, () => d(o), (_, b) => {
      b(_, ce(() => d(p), {
        get value() {
          return i();
        },
        set value(g) {
          i(g);
        }
      }));
    });
  }
  return A(t, c), W(u);
}
K(ux, { value: {}, config: {}, handlers: {} }, [], [], { mode: "open" });
tr.textareaWidget = ux;
function t5() {
  KA({
    components: {
      ButtonGroup: z_,
      Field: lS,
      FieldLabel: hS,
      FieldError: mS,
      FieldDescription: pS,
      FieldGroup: dS,
      FieldLegend: cS,
      FieldTitle: gS,
      FieldSet: uS,
      Button: D1,
      Checkbox: Y1,
      Input: vS,
      Select: jS,
      SelectContent: KS,
      SelectItem: BS,
      SelectTrigger: HS,
      Textarea: YS,
      RadioGroup: SS,
      RadioGroupItem: xS,
      // @ts-expect-error - Can be safely ignored
      Command: ng,
      CommandEmpty: nS,
      CommandGroup: sS,
      CommandInput: iS,
      CommandItem: oS,
      CommandList: aS,
      Calendar: M1,
      ToggleGroup: JS,
      ToggleGroupItem: ZS,
      Slider: WS,
      Switch: GS,
      Popover: yS,
      PopoverContent: _S,
      PopoverTrigger: wS,
      RangeCalendar: PS
    }
  });
}
const r5 = Wy(_E, {
  formataQrWidget: C_
});
function n5(t, e) {
  return ib({
    resolver: jA,
    theme: r5,
    icons: zE,
    idBuilder: z$,
    validator: F$,
    merger: U$,
    translation: W$,
    schema: t.schema,
    uiSchema: t.uiSchema,
    onSubmitError: j$(),
    onSubmit: (r) => {
      e().dispatchEvent(
        new CustomEvent("submit", {
          bubbles: !0,
          composed: !0,
          cancelable: !0,
          detail: Y$.serialize(r)
        })
      );
    }
  });
}
const s5 = "@layer properties{:host{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-x-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-duration:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-x-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-duration:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;--color-slate-50:oklch(98.4% .003 247.858);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-lg:32rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--tracking-widest:.1em;--leading-snug:1.375;--leading-normal:1.5;--radius-xs:.125rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{border-color:var(--border);outline-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){*{outline-color:color-mix(in oklab,var(--ring)50%,transparent)}}body{background-color:var(--background);color:var(--foreground)}}@layer components;@layer utilities{.\\@container\\/field-group{container:field-group/inline-size}.pointer-events-none{pointer-events:none}.sr-only{clip-path:inset(50%);white-space:nowrap;border-width:0;width:1px;height:1px;margin:-1px;padding:0;position:absolute;overflow:hidden}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.inset-0{inset:calc(var(--spacing)*0)}.inset-x-0{inset-inline:calc(var(--spacing)*0)}.start-1\\/2{inset-inline-start:50%}.end-2{inset-inline-end:calc(var(--spacing)*2)}.end-4{inset-inline-end:calc(var(--spacing)*4)}.top-0{top:calc(var(--spacing)*0)}.top-1\\/2{top:50%}.top-4{top:calc(var(--spacing)*4)}.top-\\[50\\%\\]{top:50%}.right-2{right:calc(var(--spacing)*2)}.left-1\\/2,.left-\\[50\\%\\]{left:50%}.z-50{z-index:50}.\\!m-0{margin:calc(var(--spacing)*0)!important}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.mx-auto{margin-inline:auto}.-my-2{margin-block:calc(var(--spacing)*-2)}.my-1{margin-block:calc(var(--spacing)*1)}.ms-4{margin-inline-start:calc(var(--spacing)*4)}.ms-auto{margin-inline-start:auto}.me-2{margin-inline-end:calc(var(--spacing)*2)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-4{margin-top:calc(var(--spacing)*4)}.mr-2{margin-right:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.ml-2{margin-left:calc(var(--spacing)*2)}.ml-4{margin-left:calc(var(--spacing)*4)}.ml-auto{margin-left:auto}.block{display:block}.flex{display:flex}.grid{display:grid}.inline-flex{display:inline-flex}.field-sizing-content{field-sizing:content}.aspect-square{aspect-ratio:1}.size-\\(--cell-size\\){width:var(--cell-size);height:var(--cell-size)}.size-2{width:calc(var(--spacing)*2);height:calc(var(--spacing)*2)}.size-3\\.5{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-9{width:calc(var(--spacing)*9);height:calc(var(--spacing)*9)}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.size-48{width:calc(var(--spacing)*48);height:calc(var(--spacing)*48)}.h-\\(--bits-select-anchor-height\\){height:var(--bits-select-anchor-height)}.h-\\(--cell-size\\){height:var(--cell-size)}.h-5{height:calc(var(--spacing)*5)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-\\[1\\.15rem\\]{height:1.15rem}.h-full{height:100%}.h-px{height:1px}.max-h-\\(--bits-select-content-available-height\\){max-height:var(--bits-select-content-available-height)}.max-h-\\[300px\\]{max-height:300px}.min-h-5{min-height:calc(var(--spacing)*5)}.min-h-16{min-height:calc(var(--spacing)*16)}.w-\\(--cell-size\\){width:var(--cell-size)}.w-8{width:calc(var(--spacing)*8)}.w-72{width:calc(var(--spacing)*72)}.w-\\[200px\\]{width:200px}.w-auto{width:auto}.w-fit{width:fit-content}.w-full{width:100%}.max-w-\\[calc\\(100\\%-2rem\\)\\]{max-width:calc(100% - 2rem)}.min-w-\\(--bits-select-anchor-width\\){min-width:var(--bits-select-anchor-width)}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-8{min-width:calc(var(--spacing)*8)}.min-w-9{min-width:calc(var(--spacing)*9)}.min-w-10{min-width:calc(var(--spacing)*10)}.min-w-\\[8rem\\]{min-width:8rem}.flex-1{flex:1}.shrink-0{flex-shrink:0}.grow{flex-grow:1}.border-collapse{border-collapse:collapse}.origin-\\(--bits-popover-content-transform-origin\\){transform-origin:var(--bits-popover-content-transform-origin)}.origin-\\(--bits-select-content-transform-origin\\){transform-origin:var(--bits-select-content-transform-origin)}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-x-\\[-50\\%\\]{--tw-translate-x:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-\\[-50\\%\\]{--tw-translate-y:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-default{cursor:default}.touch-none{touch-action:none}.scroll-my-1{scroll-margin-block:calc(var(--spacing)*1)}.scroll-py-1{scroll-padding-block:calc(var(--spacing)*1)}.list-disc{list-style-type:disc}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-rows-\\[1fr\\]{grid-template-rows:1fr}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.items-center{align-items:center}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-start{justify-content:flex-start}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-6{gap:calc(var(--spacing)*6)}.gap-7{gap:calc(var(--spacing)*7)}.gap-\\[--spacing\\(var\\(--gap\\)\\)\\]{gap:calc(var(--spacing)*var(--gap))}.gap-x-1\\.5{column-gap:calc(var(--spacing)*1.5)}:where(.space-x-3>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*3)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-x-reverse)))}.self-stretch{align-self:stretch}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.rounded-\\[4px\\]{border-radius:4px}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-none{border-radius:0}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xs{border-radius:var(--radius-xs)}.border{border-style:var(--tw-border-style);border-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-input{border-color:var(--input)}.border-primary{border-color:var(--primary)}.border-transparent{border-color:#0000}.bg-background{background-color:var(--background)}.bg-black\\/50{background-color:#00000080}@supports (color:color-mix(in lab,red,red)){.bg-black\\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-border{background-color:var(--border)}.bg-destructive{background-color:var(--destructive)}.bg-input{background-color:var(--input)}.bg-muted{background-color:var(--muted)}.bg-popover{background-color:var(--popover)}.bg-primary{background-color:var(--primary)}.bg-secondary{background-color:var(--secondary)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.fill-primary{fill:var(--primary)}.object-contain{object-fit:contain}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.px-\\(--cell-size\\){padding-inline:var(--cell-size)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-6{padding-inline:calc(var(--spacing)*6)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-6{padding-block:calc(var(--spacing)*6)}.ps-2{padding-inline-start:calc(var(--spacing)*2)}.ps-3{padding-inline-start:calc(var(--spacing)*3)}.pe-1{padding-inline-end:calc(var(--spacing)*1)}.pe-8{padding-inline-end:calc(var(--spacing)*8)}.pt-1\\.5{padding-top:calc(var(--spacing)*1.5)}.pr-1{padding-right:calc(var(--spacing)*1)}.pr-8{padding-right:calc(var(--spacing)*8)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.text-center{text-align:center}.text-start{text-align:start}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[0\\.8rem\\]{font-size:.8rem}.leading-none{--tw-leading:1;line-height:1}.leading-normal{--tw-leading:var(--leading-normal);line-height:var(--leading-normal)}.leading-snug{--tw-leading:var(--leading-snug);line-height:var(--leading-snug)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-widest{--tw-tracking:var(--tracking-widest);letter-spacing:var(--tracking-widest)}.whitespace-nowrap{white-space:nowrap}.text-current{color:currentColor}.text-destructive{color:var(--destructive)}.text-foreground{color:var(--foreground)}.text-muted-foreground{color:var(--muted-foreground)}.text-popover-foreground{color:var(--popover-foreground)}.text-primary{color:var(--primary)}.text-primary-foreground{color:var(--primary-foreground)}.text-secondary-foreground{color:var(--secondary-foreground)}.text-transparent{color:#0000}.text-white{color:var(--color-white)}.underline-offset-4{text-underline-offset:4px}.opacity-0{opacity:0}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-none{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-0{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(0px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-ring\\/50{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.ring-ring\\/50{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.ring-offset-background{--tw-ring-offset-color:var(--background)}.outline-hidden{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.outline-hidden{outline-offset:2px;outline:2px solid #0000}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.transition-\\[color\\,box-shadow\\]{transition-property:color,box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-shadow{transition-property:box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-none{transition-property:none}.duration-200{--tw-duration:.2s;transition-duration:.2s}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.\\[--cell-size\\:--spacing\\(8\\)\\]{--cell-size:calc(var(--spacing)*8)}.group-has-\\[\\[data-orientation\\=horizontal\\]\\]\\/field\\:text-balance:is(:where(.group\\/field):has([data-orientation=horizontal]) *){text-wrap:balance}.group-data-\\[disabled\\=true\\]\\:pointer-events-none:is(:where(.group)[data-disabled=true] *){pointer-events:none}.group-data-\\[disabled\\=true\\]\\:opacity-50:is(:where(.group)[data-disabled=true] *),.group-data-\\[disabled\\=true\\]\\/field\\:opacity-50:is(:where(.group\\/field)[data-disabled=true] *){opacity:.5}.group-data-\\[variant\\=outline\\]\\/field-group\\:-mb-2:is(:where(.group\\/field-group)[data-variant=outline] *){margin-bottom:calc(var(--spacing)*-2)}.peer-disabled\\:cursor-not-allowed:is(:where(.peer):disabled~*){cursor:not-allowed}.peer-disabled\\:opacity-50:is(:where(.peer):disabled~*){opacity:.5}.selection\\:bg-primary ::selection{background-color:var(--primary)}.selection\\:bg-primary::selection{background-color:var(--primary)}.selection\\:text-primary-foreground ::selection{color:var(--primary-foreground)}.selection\\:text-primary-foreground::selection{color:var(--primary-foreground)}.placeholder\\:text-muted-foreground::placeholder{color:var(--muted-foreground)}.first\\:rounded-l-md:first-child{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.last\\:mt-0:last-child{margin-top:calc(var(--spacing)*0)}.last\\:rounded-r-md:last-child{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.focus-within\\:z-20:focus-within{z-index:20}@media(hover:hover){.hover\\:bg-accent:hover{background-color:var(--accent)}.hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}.hover\\:bg-muted:hover{background-color:var(--muted)}.hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}.hover\\:bg-secondary\\/80:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-secondary\\/80:hover{background-color:color-mix(in oklab,var(--secondary)80%,transparent)}}.hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}.hover\\:text-muted-foreground:hover{color:var(--muted-foreground)}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}.hover\\:ring-4:hover{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}.focus\\:relative:focus{position:relative}.focus\\:z-10:focus{z-index:10}.focus\\:border-ring:focus{border-color:var(--ring)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-ring:focus,.focus\\:ring-ring\\/50:focus{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus\\:ring-ring\\/50:focus{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus\\:ring-offset-2:focus{--tw-ring-offset-width:2px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}.focus\\:outline-hidden:focus{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.focus\\:outline-hidden:focus{outline-offset:2px;outline:2px solid #0000}}.focus-visible\\:z-10:focus-visible{z-index:10}.focus-visible\\:border-ring:focus-visible{border-color:var(--ring)}.focus-visible\\:ring-4:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-\\[3px\\]:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus-visible\\:outline-hidden:focus-visible{--tw-outline-style:none;outline-style:none}@media(forced-colors:active){.focus-visible\\:outline-hidden:focus-visible{outline-offset:2px;outline:2px solid #0000}}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.has-focus\\:border-ring:has(:focus){border-color:var(--ring)}.has-focus\\:ring-\\[3px\\]:has(:focus){--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.has-focus\\:ring-ring\\/50:has(:focus){--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.has-focus\\:ring-ring\\/50:has(:focus){--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.has-data-\\[state\\=checked\\]\\:border-primary:has([data-state=checked]){border-color:var(--primary)}.has-data-\\[state\\=checked\\]\\:bg-primary\\/5:has([data-state=checked]){background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.has-data-\\[state\\=checked\\]\\:bg-primary\\/5:has([data-state=checked]){background-color:color-mix(in oklab,var(--primary)5%,transparent)}}.has-\\[\\>\\[data-slot\\=button-group\\]\\]\\:gap-2:has(>[data-slot=button-group]){gap:calc(var(--spacing)*2)}.has-\\[\\>\\[data-slot\\=checkbox-group\\]\\]\\:gap-3:has(>[data-slot=checkbox-group]){gap:calc(var(--spacing)*3)}.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:items-start:has(>[data-slot=field-content]){align-items:flex-start}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:w-full:has(>[data-slot=field]){width:100%}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:flex-col:has(>[data-slot=field]){flex-direction:column}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:rounded-md:has(>[data-slot=field]){border-radius:calc(var(--radius) - 2px)}.has-\\[\\>\\[data-slot\\=field\\]\\]\\:border:has(>[data-slot=field]){border-style:var(--tw-border-style);border-width:1px}.has-\\[\\>\\[data-slot\\=radio-group\\]\\]\\:gap-3:has(>[data-slot=radio-group]){gap:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-2\\.5:has(>svg){padding-inline:calc(var(--spacing)*2.5)}.has-\\[\\>svg\\]\\:px-3:has(>svg){padding-inline:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-4:has(>svg){padding-inline:calc(var(--spacing)*4)}.aria-disabled\\:pointer-events-none[aria-disabled=true]{pointer-events:none}.aria-disabled\\:opacity-50[aria-disabled=true]{opacity:.5}.aria-invalid\\:border-destructive[aria-invalid=true]{border-color:var(--destructive)}.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.aria-selected\\:bg-accent[aria-selected=true]{background-color:var(--accent)}.aria-selected\\:text-accent-foreground[aria-selected=true]{color:var(--accent-foreground)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:text-muted-foreground[data-disabled]{color:var(--muted-foreground)}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[disabled\\=true\\]\\:pointer-events-none[data-disabled=true]{pointer-events:none}.data-\\[disabled\\=true\\]\\:opacity-50[data-disabled=true]{opacity:.5}.data-\\[highlighted\\]\\:bg-accent[data-highlighted]{background-color:var(--accent)}.data-\\[highlighted\\]\\:text-accent-foreground[data-highlighted]{color:var(--accent-foreground)}.data-\\[invalid\\=true\\]\\:text-destructive[data-invalid=true]{color:var(--destructive)}.data-\\[orientation\\=horizontal\\]\\:h-1\\.5[data-orientation=horizontal]{height:calc(var(--spacing)*1.5)}.data-\\[orientation\\=horizontal\\]\\:h-full[data-orientation=horizontal]{height:100%}.data-\\[orientation\\=horizontal\\]\\:h-px[data-orientation=horizontal]{height:1px}.data-\\[orientation\\=horizontal\\]\\:w-full[data-orientation=horizontal]{width:100%}.data-\\[orientation\\=vertical\\]\\:h-auto[data-orientation=vertical]{height:auto}.data-\\[orientation\\=vertical\\]\\:h-full[data-orientation=vertical]{height:100%}.data-\\[orientation\\=vertical\\]\\:min-h-44[data-orientation=vertical]{min-height:calc(var(--spacing)*44)}.data-\\[orientation\\=vertical\\]\\:min-h-full[data-orientation=vertical]{min-height:100%}.data-\\[orientation\\=vertical\\]\\:w-1\\.5[data-orientation=vertical]{width:calc(var(--spacing)*1.5)}.data-\\[orientation\\=vertical\\]\\:w-auto[data-orientation=vertical]{width:auto}.data-\\[orientation\\=vertical\\]\\:w-full[data-orientation=vertical]{width:100%}.data-\\[orientation\\=vertical\\]\\:w-px[data-orientation=vertical]{width:1px}.data-\\[orientation\\=vertical\\]\\:flex-col[data-orientation=vertical]{flex-direction:column}.data-\\[placeholder\\]\\:text-muted-foreground[data-placeholder]{color:var(--muted-foreground)}.data-\\[range-end\\]\\:bg-primary[data-range-end]{background-color:var(--primary)}.data-\\[range-end\\]\\:text-primary-foreground[data-range-end]{color:var(--primary-foreground)}.data-\\[range-middle\\]\\:rounded-none[data-range-middle]{border-radius:0}.data-\\[range-middle\\]\\:rounded-e-md[data-range-middle]{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.data-\\[range-start\\]\\:bg-primary[data-range-start]{background-color:var(--primary)}.data-\\[range-start\\]\\:text-primary-foreground[data-range-start]{color:var(--primary-foreground)}.data-\\[selected\\]\\:bg-primary[data-selected]{background-color:var(--primary)}.data-\\[selected\\]\\:text-primary-foreground[data-selected]{color:var(--primary-foreground)}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=left\\]\\:slide-in-from-end-2[data-side=left]:where(:dir(ltr),[dir=ltr]){--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=left\\]\\:slide-in-from-end-2[data-side=left]:where(:dir(rtl),[dir=rtl]){--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=right\\]\\:slide-in-from-start-2[data-side=right]:where(:dir(ltr),[dir=ltr]){--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=right\\]\\:slide-in-from-start-2[data-side=right]:where(:dir(rtl),[dir=rtl]){--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y:calc(2*var(--spacing))}.data-\\[size\\=default\\]\\:h-9[data-size=default]{height:calc(var(--spacing)*9)}.data-\\[size\\=sm\\]\\:h-8[data-size=sm]{height:calc(var(--spacing)*8)}.data-\\[slot\\=checkbox-group\\]\\:gap-3[data-slot=checkbox-group]{gap:calc(var(--spacing)*3)}:is(.\\*\\*\\:data-\\[slot\\=command-input-wrapper\\]\\:h-12 *)[data-slot=command-input-wrapper]{height:calc(var(--spacing)*12)}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:line-clamp-1>*)[data-slot=select-value]{-webkit-line-clamp:1;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:flex>*)[data-slot=select-value]{display:flex}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:items-center>*)[data-slot=select-value]{align-items:center}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:gap-2>*)[data-slot=select-value]{gap:calc(var(--spacing)*2)}.data-\\[spacing\\=0\\]\\:rounded-none[data-spacing=\"0\"]{border-radius:0}.data-\\[spacing\\=0\\]\\:shadow-none[data-spacing=\"0\"]{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.data-\\[spacing\\=0\\]\\:first\\:rounded-l-md[data-spacing=\"0\"]:first-child{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.data-\\[spacing\\=0\\]\\:last\\:rounded-r-md[data-spacing=\"0\"]:last-child{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.data-\\[state\\=checked\\]\\:translate-x-\\[calc\\(100\\%-2px\\)\\][data-state=checked]{--tw-translate-x: calc(100% - 2px) ;translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=checked\\]\\:border-primary[data-state=checked]{border-color:var(--primary)}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:var(--primary)}.data-\\[state\\=checked\\]\\:text-primary-foreground[data-state=checked]{color:var(--primary-foreground)}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity:0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale:.95}.data-\\[state\\=on\\]\\:bg-accent[data-state=on]{background-color:var(--accent)}.data-\\[state\\=on\\]\\:text-accent-foreground[data-state=on]{color:var(--accent-foreground)}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity:0}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale:.95}.data-\\[state\\=unchecked\\]\\:translate-x-0[data-state=unchecked]{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=unchecked\\]\\:bg-input[data-state=unchecked]{background-color:var(--input)}.data-\\[unavailable\\]\\:text-muted-foreground[data-unavailable]{color:var(--muted-foreground)}.data-\\[unavailable\\]\\:line-through[data-unavailable]{text-decoration-line:line-through}.data-\\[variant\\=label\\]\\:text-sm[data-variant=label]{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.data-\\[variant\\=legend\\]\\:text-base[data-variant=legend]{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.data-\\[variant\\=outline\\]\\:border-l-0[data-variant=outline]{border-left-style:var(--tw-border-style);border-left-width:0}.data-\\[variant\\=outline\\]\\:shadow-xs[data-variant=outline]{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.data-\\[variant\\=outline\\]\\:first\\:border-l[data-variant=outline]:first-child{border-left-style:var(--tw-border-style);border-left-width:1px}.data-\\[spacing\\=0\\]\\:data-\\[variant\\=outline\\]\\:border-l-0[data-spacing=\"0\"][data-variant=outline]{border-left-style:var(--tw-border-style);border-left-width:0}.data-\\[spacing\\=0\\]\\:data-\\[variant\\=outline\\]\\:first\\:border-l[data-spacing=\"0\"][data-variant=outline]:first-child{border-left-style:var(--tw-border-style);border-left-width:1px}.data-\\[spacing\\=default\\]\\:data-\\[variant\\=outline\\]\\:shadow-xs[data-spacing=default][data-variant=outline]{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.nth-last-2\\:-mt-1:nth-last-child(2){margin-top:calc(var(--spacing)*-1)}@media(min-width:40rem){.sm\\:max-w-lg{max-width:var(--container-lg)}.sm\\:flex-row{flex-direction:row}.sm\\:justify-end{justify-content:flex-end}.sm\\:text-left{text-align:left}.sm\\:text-start{text-align:start}}@media(min-width:48rem){.md\\:flex-row{flex-direction:row}.md\\:text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}}@container field-group (min-width:28rem){.\\@md\\/field-group\\:flex-row{flex-direction:row}.\\@md\\/field-group\\:items-center{align-items:center}.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:items-start:has(>[data-slot=field-content]){align-items:flex-start}}.rtl\\:rotate-180:where(:dir(rtl),[dir=rtl],[dir=rtl] *){rotate:180deg}.dark\\:border-input:is(.dark *){border-color:var(--input)}.dark\\:bg-destructive\\/60:is(.dark *){background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-destructive\\/60:is(.dark *){background-color:color-mix(in oklab,var(--destructive)60%,transparent)}}.dark\\:bg-input\\/30:is(.dark *){background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-input\\/30:is(.dark *){background-color:color-mix(in oklab,var(--input)30%,transparent)}}.dark\\:bg-popover:is(.dark *){background-color:var(--popover)}.dark\\:text-popover-foreground:is(.dark *){color:var(--popover-foreground)}@media(hover:hover){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--input)50%,transparent)}}.dark\\:hover\\:text-accent-foreground:is(.dark *):hover{color:var(--accent-foreground)}}.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:has-data-\\[state\\=checked\\]\\:bg-primary\\/10:is(.dark *):has([data-state=checked]){background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.dark\\:has-data-\\[state\\=checked\\]\\:bg-primary\\/10:is(.dark *):has([data-state=checked]){background-color:color-mix(in oklab,var(--primary)10%,transparent)}}.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}@media(hover:hover){.dark\\:data-\\[range-end\\]\\:hover\\:bg-accent:is(.dark *)[data-range-end]:hover,.dark\\:data-\\[range-middle\\]\\:hover\\:bg-accent\\/0:is(.dark *)[data-range-middle]:hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[range-middle\\]\\:hover\\:bg-accent\\/0:is(.dark *)[data-range-middle]:hover{background-color:color-mix(in oklab,var(--accent)0%,transparent)}}.dark\\:data-\\[range-start\\]\\:hover\\:bg-accent:is(.dark *)[data-range-start]:hover,.dark\\:data-\\[selected\\]\\:hover\\:bg-accent\\/50:is(.dark *)[data-selected]:hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[selected\\]\\:hover\\:bg-accent\\/50:is(.dark *)[data-selected]:hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}}.dark\\:data-\\[state\\=checked\\]\\:bg-primary:is(.dark *)[data-state=checked]{background-color:var(--primary)}.dark\\:data-\\[state\\=checked\\]\\:bg-primary-foreground:is(.dark *)[data-state=checked]{background-color:var(--primary-foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-foreground:is(.dark *)[data-state=unchecked]{background-color:var(--foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:color-mix(in oklab,var(--input)80%,transparent)}}.\\[\\&_\\[data-command-group\\]\\]\\:px-2 [data-command-group]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[data-command-group\\]\\:not\\(\\[hidden\\]\\)_\\~\\[data-command-group\\]\\]\\:pt-0 [data-command-group]:not([hidden])~[data-command-group]{padding-top:calc(var(--spacing)*0)}.\\[\\&_\\[data-command-input-wrapper\\]_svg\\]\\:h-5 [data-command-input-wrapper] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-input-wrapper\\]_svg\\]\\:w-5 [data-command-input-wrapper] svg{width:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-input\\]\\]\\:h-12 [data-command-input]{height:calc(var(--spacing)*12)}.\\[\\&_\\[data-command-item\\]\\]\\:px-2 [data-command-item]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[data-command-item\\]\\]\\:py-3 [data-command-item]{padding-block:calc(var(--spacing)*3)}.\\[\\&_\\[data-command-item\\]_svg\\]\\:h-5 [data-command-item] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[data-command-item\\]_svg\\]\\:w-5 [data-command-item] svg{width:calc(var(--spacing)*5)}.\\[\\&_svg\\]\\:pointer-events-none svg{pointer-events:none}.\\[\\&_svg\\]\\:shrink-0 svg{flex-shrink:0}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\\'size-\\\'\\]\\)\\]\\:size-4 svg:not([class*=size-]){width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\\'text-\\\'\\]\\)\\]\\:text-muted-foreground svg:not([class*=text-]){color:var(--muted-foreground)}.\\[\\&\\:first-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-s-md:first-child[data-selected] [data-bits-day]{border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}.\\[\\&\\:first-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-l-md:first-child[data-selected] [data-bits-day]{border-top-left-radius:calc(var(--radius) - 2px);border-bottom-left-radius:calc(var(--radius) - 2px)}.\\[\\&\\:has\\(\\>\\:nth-child\\(2\\)\\)\\]\\:grid-cols-\\[1fr_1fr_auto\\]:has(>:nth-child(2)){grid-template-columns:1fr 1fr auto}.\\[\\&\\:has\\(\\[data-range-end\\]\\)\\]\\:rounded-e-md:has([data-range-end]){border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-end\\]\\)\\]\\:hover\\:bg-accent:is(.dark *):has([data-range-end]):hover{background-color:var(--accent)}}.\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-none:has([data-range-middle]){border-radius:0}.\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:bg-accent:has([data-range-middle]){background-color:var(--accent)}.first\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-s-md:first-child:has([data-range-middle]){border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}.last\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:rounded-e-md:last-child:has([data-range-middle]){border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:hover\\:bg-accent\\/50:is(.dark *):has([data-range-middle]):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:\\[\\&\\:has\\(\\[data-range-middle\\]\\)\\]\\:hover\\:bg-accent\\/50:is(.dark *):has([data-range-middle]):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}}.\\[\\&\\:has\\(\\[data-range-start\\]\\)\\]\\:rounded-s-md:has([data-range-start]){border-start-start-radius:calc(var(--radius) - 2px);border-end-start-radius:calc(var(--radius) - 2px)}@media(hover:hover){.dark\\:\\[\\&\\:has\\(\\[data-range-start\\]\\)\\]\\:hover\\:bg-accent:is(.dark *):has([data-range-start]):hover{background-color:var(--accent)}}.\\[\\&\\:has\\(\\[data-selected\\]\\)\\]\\:bg-accent:has([data-selected]){background-color:var(--accent)}:is(.\\*\\:\\[span\\]\\:last\\:flex>*):is(span):last-child{display:flex}:is(.\\*\\:\\[span\\]\\:last\\:items-center>*):is(span):last-child{align-items:center}:is(.\\*\\:\\[span\\]\\:last\\:gap-2>*):is(span):last-child{gap:calc(var(--spacing)*2)}.\\[\\&\\:last-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-e-md:last-child[data-selected] [data-bits-day]{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.\\[\\&\\:last-child\\[data-selected\\]_\\[data-bits-day\\]\\]\\:rounded-r-md:last-child[data-selected] [data-bits-day]{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.\\[\\&\\>\\*\\]\\:w-full>*{width:100%}.\\[\\&\\>\\*\\]\\:focus-visible\\:relative>:focus-visible{position:relative}.\\[\\&\\>\\*\\]\\:focus-visible\\:z-10>:focus-visible{z-index:10}.\\[\\&\\>\\*\\]\\:data-\\[slot\\=field\\]\\:p-4>[data-slot=field]{padding:calc(var(--spacing)*4)}@container field-group (min-width:28rem){.\\@md\\/field-group\\:\\[\\&\\>\\*\\]\\:w-auto>*{width:auto}}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-s-none>:not(:first-child){border-start-start-radius:0;border-end-start-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-t-none>:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:rounded-l-none>:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-s-0>:not(:first-child){border-inline-start-style:var(--tw-border-style);border-inline-start-width:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-t-0>:not(:first-child){border-top-style:var(--tw-border-style);border-top-width:0}.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:border-l-0>:not(:first-child){border-left-style:var(--tw-border-style);border-left-width:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-e-none>:not(:last-child){border-start-end-radius:0;border-end-end-radius:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-r-none>:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:rounded-b-none>:not(:last-child){border-bottom-right-radius:0;border-bottom-left-radius:0}.\\[\\&\\>\\.sr-only\\]\\:w-auto>.sr-only{width:auto}.\\[\\&\\>\\[data-slot\\=field-group\\]\\]\\:gap-4>[data-slot=field-group]{gap:calc(var(--spacing)*4)}.\\[\\&\\>\\[data-slot\\=field-label\\]\\]\\:flex-auto>[data-slot=field-label]{flex:auto}@container field-group (min-width:28rem){.\\@md\\/field-group\\:\\[\\&\\>\\[data-slot\\=field-label\\]\\]\\:flex-auto>[data-slot=field-label]{flex:auto}}.has-\\[select\\[aria-hidden\\=true\\]\\:last-child\\]\\:\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:last-of-type\\]\\:rounded-e-md:has(:is(select[aria-hidden=true]:last-child))>[data-slot=select-trigger]:last-of-type{border-start-end-radius:calc(var(--radius) - 2px);border-end-end-radius:calc(var(--radius) - 2px)}.has-\\[select\\[aria-hidden\\=true\\]\\:last-child\\]\\:\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:last-of-type\\]\\:rounded-r-md:has(:is(select[aria-hidden=true]:last-child))>[data-slot=select-trigger]:last-of-type{border-top-right-radius:calc(var(--radius) - 2px);border-bottom-right-radius:calc(var(--radius) - 2px)}.\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:not\\(\\[class\\*\\=\\\'w-\\\'\\]\\)\\]\\:w-fit>[data-slot=select-trigger]:not([class*=w-]){width:fit-content}.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content])>[role=checkbox],.has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content]) [role=radio]{margin-top:1px}@container field-group (min-width:28rem){.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content])>[role=checkbox],.\\@md\\/field-group\\:has-\\[\\>\\[data-slot\\=field-content\\]\\]\\:\\[\\&\\>\\[role\\=checkbox\\]\\,\\[role\\=radio\\]\\]\\:mt-px:has(>[data-slot=field-content]) [role=radio]{margin-top:1px}}.\\[\\&\\>a\\]\\:underline>a{text-decoration-line:underline}.\\[\\&\\>a\\]\\:underline-offset-4>a{text-underline-offset:4px}.\\[\\&\\>a\\:hover\\]\\:text-primary>a:hover{color:var(--primary)}.\\[\\&\\>input\\]\\:flex-1>input{flex:1}.\\[\\&\\>span\\]\\:text-xs>span{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.\\[\\&\\>span\\]\\:opacity-70>span{opacity:.7}.\\[\\&\\>svg\\]\\:size-3\\.5>svg{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.\\[\\&\\>svg\\]\\:text-muted-foreground>svg,.\\[\\&\\[data-outside-month\\]\\:not\\(\\[data-selected\\]\\)\\]\\:text-muted-foreground[data-outside-month]:not([data-selected]){color:var(--muted-foreground)}@media(hover:hover){.\\[\\&\\[data-outside-month\\]\\:not\\(\\[data-selected\\]\\)\\]\\:hover\\:text-accent-foreground[data-outside-month]:not([data-selected]):hover{color:var(--accent-foreground)}}.\\[\\&\\[data-today\\]\\:not\\(\\[data-selected\\]\\)\\]\\:bg-accent[data-today]:not([data-selected]){background-color:var(--accent)}.\\[\\&\\[data-today\\]\\:not\\(\\[data-selected\\]\\)\\]\\:text-accent-foreground[data-today]:not([data-selected]){color:var(--accent-foreground)}.\\[\\&\\[data-today\\]\\[data-disabled\\]\\]\\:text-muted-foreground[data-today][data-disabled]{color:var(--muted-foreground)}[data-slot=card-content] .\\[\\[data-slot\\=card-content\\]_\\&\\]\\:bg-transparent,[data-slot=popover-content] .\\[\\[data-slot\\=popover-content\\]_\\&\\]\\:bg-transparent{background-color:#0000}[data-variant=legend]+.\\[\\[data-variant\\=legend\\]\\+\\&\\]\\:-mt-1\\.5{margin-top:calc(var(--spacing)*-1.5)}}@property --tw-animation-delay{syntax:\"*\";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:\"*\";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:\"*\";inherits:false}@property --tw-animation-fill-mode{syntax:\"*\";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:\"*\";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:\"*\";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:\"*\";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:\"*\";inherits:false;initial-value:0}:root,:host{--radius:.625rem;--background:oklch(100% 0 0);--foreground:oklch(12.9% .042 264.695);--card:oklch(100% 0 0);--card-foreground:oklch(12.9% .042 264.695);--popover:oklch(100% 0 0);--popover-foreground:oklch(12.9% .042 264.695);--primary:oklch(20.8% .042 265.755);--primary-foreground:oklch(98.4% .003 247.858);--secondary:oklch(96.8% .007 247.896);--secondary-foreground:oklch(20.8% .042 265.755);--muted:oklch(96.8% .007 247.896);--muted-foreground:oklch(55.4% .046 257.417);--accent:oklch(96.8% .007 247.896);--accent-foreground:oklch(20.8% .042 265.755);--destructive:oklch(57.7% .245 27.325);--border:oklch(92.9% .013 255.508);--input:oklch(92.9% .013 255.508);--ring:oklch(70.4% .04 256.788);--chart-1:oklch(64.6% .222 41.116);--chart-2:oklch(60% .118 184.704);--chart-3:oklch(39.8% .07 227.392);--chart-4:oklch(82.8% .189 84.429);--chart-5:oklch(76.9% .188 70.08);--sidebar:oklch(98.4% .003 247.858);--sidebar-foreground:oklch(12.9% .042 264.695);--sidebar-primary:oklch(20.8% .042 265.755);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(96.8% .007 247.896);--sidebar-accent-foreground:oklch(20.8% .042 265.755);--sidebar-border:oklch(92.9% .013 255.508);--sidebar-ring:oklch(70.4% .04 256.788)}.dark{--background:oklch(12.9% .042 264.695);--foreground:oklch(98.4% .003 247.858);--card:oklch(20.8% .042 265.755);--card-foreground:oklch(98.4% .003 247.858);--popover:oklch(20.8% .042 265.755);--popover-foreground:oklch(98.4% .003 247.858);--primary:oklch(92.9% .013 255.508);--primary-foreground:oklch(20.8% .042 265.755);--secondary:oklch(27.9% .041 260.031);--secondary-foreground:oklch(98.4% .003 247.858);--muted:oklch(27.9% .041 260.031);--muted-foreground:oklch(70.4% .04 256.788);--accent:oklch(27.9% .041 260.031);--accent-foreground:oklch(98.4% .003 247.858);--destructive:oklch(70.4% .191 22.216);--border:oklch(100% 0 0/.1);--input:oklch(100% 0 0/.15);--ring:oklch(55.1% .027 264.364);--chart-1:oklch(48.8% .243 264.376);--chart-2:oklch(69.6% .17 162.48);--chart-3:oklch(76.9% .188 70.08);--chart-4:oklch(62.7% .265 303.9);--chart-5:oklch(64.5% .246 16.439);--sidebar:oklch(20.8% .042 265.755);--sidebar-foreground:oklch(98.4% .003 247.858);--sidebar-primary:oklch(48.8% .243 264.376);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(27.9% .041 260.031);--sidebar-accent-foreground:oklch(98.4% .003 247.858);--sidebar-border:oklch(100% 0 0/.1);--sidebar-ring:oklch(55.1% .027 264.364)}@property --tw-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-z{syntax:\"*\";inherits:false;initial-value:0}@property --tw-rotate-x{syntax:\"*\";inherits:false}@property --tw-rotate-y{syntax:\"*\";inherits:false}@property --tw-rotate-z{syntax:\"*\";inherits:false}@property --tw-skew-x{syntax:\"*\";inherits:false}@property --tw-skew-y{syntax:\"*\";inherits:false}@property --tw-space-x-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-border-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-leading{syntax:\"*\";inherits:false}@property --tw-font-weight{syntax:\"*\";inherits:false}@property --tw-tracking{syntax:\"*\";inherits:false}@property --tw-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:\"*\";inherits:false}@property --tw-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:\"*\";inherits:false}@property --tw-inset-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:\"*\";inherits:false}@property --tw-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:\"*\";inherits:false}@property --tw-inset-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:\"*\";inherits:false}@property --tw-ring-offset-width{syntax:\"<length>\";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:\"*\";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-duration{syntax:\"*\";inherits:false}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));filter:blur(var(--tw-enter-blur,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));filter:blur(var(--tw-exit-blur,0))}}\n";
function o5(t) {
  if (!t) return;
  const e = new CSSStyleSheet();
  e.replaceSync(s5), t.adoptedStyleSheets = [e];
}
var i5 = /* @__PURE__ */ ne("<!> <!>", 1);
function a5(t, e) {
  H(e, !0);
  let r = /* @__PURE__ */ ie(e, ["$$slots", "$$events", "$$legacy", "$$host"]);
  t5(), ko(() => {
    o5(e.$$host?.shadowRoot);
  });
  const n = n5(r, () => e.$$host);
  fk(n);
  var s = i5(), o = D(s);
  Fd(o, {
    get form() {
      return n;
    }
  });
  var i = be(o, 2);
  ue(i, (a) => {
  }), A(t, s), W();
}
customElements.define("formata-form", K(
  a5,
  {
    schema: { attribute: "schema", reflect: !0, type: "Object" },
    uiSchema: { attribute: "ui-schema", reflect: !0, type: "Object" }
  },
  [],
  [],
  { mode: "open" }
));
export {
  a5 as Form
};
